---
title: "aaaService структуры резервного копирования и восстановления | Документы Microsoft"
description: "Основная документация по резервному копированию и восстановлению платформы Service Fabric"
services: service-fabric
documentationcenter: .net
author: mcoskun
manager: timlt
editor: subramar,jessebenson
ms.assetid: 91ea6ca4-cc2a-4155-9823-dcbd0b996349
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/18/2017
ms.author: mcoskun
ms.openlocfilehash: e502b59c84999c3fe825167383f00a5ebd70c9b5
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="back-up-and-restore-reliable-services-and-reliable-actors"></a><span data-ttu-id="0184a-103">Резервное копирование и восстановление служб Reliable Services и субъектов Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="0184a-103">Back up and restore Reliable Services and Reliable Actors</span></span>
<span data-ttu-id="0184a-104">Azure Service Fabric — это платформа высокого уровня доступности, которое реплицирует состояние hello по несколько узлов toomaintain высокого уровня доступности.</span><span class="sxs-lookup"><span data-stu-id="0184a-104">Azure Service Fabric is a high-availability platform that replicates hello state across multiple nodes toomaintain this high availability.</span></span>  <span data-ttu-id="0184a-105">Таким образом даже в случае сбоя одного узла в кластере hello hello службы по-прежнему доступны toobe.</span><span class="sxs-lookup"><span data-stu-id="0184a-105">Thus, even if one node in hello cluster fails, hello services continue toobe available.</span></span> <span data-ttu-id="0184a-106">Хотя эта избыточность встроенными, предоставляемых платформой hello может быть достаточно для некоторых, в некоторых случаях желательно для hello tooback службы данных (внешнее хранилище tooan).</span><span class="sxs-lookup"><span data-stu-id="0184a-106">While this in-built redundancy provided by hello platform may be sufficient for some, in certain cases it is desirable for hello service tooback up data (tooan external store).</span></span>

> [!NOTE]
> <span data-ttu-id="0184a-107">Он критических toobackup и восстановления данных (и тест, который он работает нужным образом), вы можете получить от потери данных.</span><span class="sxs-lookup"><span data-stu-id="0184a-107">It is critical toobackup and restore your data (and test that it works as expected) so you can recover from data loss scenarios.</span></span>
> 
> 

<span data-ttu-id="0184a-108">Например служба может потребоваться tooback копирование данных в порядке tooprotect из hello следующие сценарии:</span><span class="sxs-lookup"><span data-stu-id="0184a-108">For example, a service may want tooback up data in order tooprotect from hello following scenarios:</span></span>

- <span data-ttu-id="0184a-109">В событии hello hello необратимой потере всего кластера Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="0184a-109">In hello event of hello permanent loss of an entire Service Fabric cluster.</span></span>
- <span data-ttu-id="0184a-110">Безвозвратная потеря большинства реплик hello служебного раздела</span><span class="sxs-lookup"><span data-stu-id="0184a-110">Permanent loss of a majority of hello replicas of a service partition</span></span>
- <span data-ttu-id="0184a-111">Административных ошибок, при котором состояние hello случайно возвращает удален или поврежден.</span><span class="sxs-lookup"><span data-stu-id="0184a-111">Administrative errors whereby hello state accidentally gets deleted or corrupted.</span></span> <span data-ttu-id="0184a-112">Например это может произойти, если администратор с достаточными правами ошибочно удаляет службу hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-112">For example, this may happen if an administrator with sufficient privilege erroneously deletes hello service.</span></span>
- <span data-ttu-id="0184a-113">Ошибок в службе hello, привести к повреждению данных.</span><span class="sxs-lookup"><span data-stu-id="0184a-113">Bugs in hello service that cause data corruption.</span></span> <span data-ttu-id="0184a-114">Например это может происходить при запуске службы обновления кода записи неисправный данных tooa надежного коллекции.</span><span class="sxs-lookup"><span data-stu-id="0184a-114">For example, this may happen when a service code upgrade starts writing faulty data tooa Reliable Collection.</span></span> <span data-ttu-id="0184a-115">В этом случае оба hello кода и данных hello, возможно, toobe отменены tooan ранее состояния.</span><span class="sxs-lookup"><span data-stu-id="0184a-115">In such a case, both hello code and hello data may have toobe reverted tooan earlier state.</span></span>
- <span data-ttu-id="0184a-116">При автономной обработке данных.</span><span class="sxs-lookup"><span data-stu-id="0184a-116">Offline data processing.</span></span> <span data-ttu-id="0184a-117">Может оказаться удобным toohave автономную обработку данных для бизнес-аналитики, в который осуществляется отдельно от службы hello, создает данные hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-117">It might be convenient toohave offline processing of data for business intelligence that happens separately from hello service that generates hello data.</span></span>

<span data-ttu-id="0184a-118">функция резервного копирования и восстановления Hello позволяет службам, созданным на hello надежные API служб toocreate и восстановления резервных копий.</span><span class="sxs-lookup"><span data-stu-id="0184a-118">hello Backup/Restore feature allows services built on hello Reliable Services API toocreate and restore backups.</span></span> <span data-ttu-id="0184a-119">Hello резервного копирования API-интерфейсов, предоставляемых платформой hello разрешить архивы состояния раздела службы, без блокировки чтения и записи операций.</span><span class="sxs-lookup"><span data-stu-id="0184a-119">hello backup APIs provided by hello platform allow backup(s) of a service partition's state, without blocking read or write operations.</span></span> <span data-ttu-id="0184a-120">Восстановление Hello интерфейсы API позволяют toobe состояние раздела службы, восстановить из выбранной резервной копии.</span><span class="sxs-lookup"><span data-stu-id="0184a-120">hello restore APIs allow a service partition's state toobe restored from a chosen backup.</span></span>

## <a name="types-of-backup"></a><span data-ttu-id="0184a-121">Типы архивации</span><span class="sxs-lookup"><span data-stu-id="0184a-121">Types of Backup</span></span>
<span data-ttu-id="0184a-122">Существует два варианта архивации: полная и добавочная.</span><span class="sxs-lookup"><span data-stu-id="0184a-122">There are two backup options: Full and Incremental.</span></span>
<span data-ttu-id="0184a-123">Резервная копия, содержащая все hello данные, необходимые toorecreate hello состояние hello реплики является полной резервной копии: контрольные точки и все записи журнала.</span><span class="sxs-lookup"><span data-stu-id="0184a-123">A full backup is a backup that contains all hello data required toorecreate hello state of hello replica: checkpoints and all log records.</span></span>
<span data-ttu-id="0184a-124">Так как он содержит hello контрольных точек и журналов hello, сам по себе может быть восстановлена полной резервной копии.</span><span class="sxs-lookup"><span data-stu-id="0184a-124">Since it has hello checkpoints and hello log, a full backup can be restored by itself.</span></span>

<span data-ttu-id="0184a-125">Hello проблема с полные резервные копии возникает, когда hello контрольные точки имеют большой размер.</span><span class="sxs-lookup"><span data-stu-id="0184a-125">hello problem with full backups arises when hello checkpoints are large.</span></span>
<span data-ttu-id="0184a-126">Например реплика, которая 16 ГБ состояния будет иметь контрольные точки, из которых состоит примерно too16 ГБ.</span><span class="sxs-lookup"><span data-stu-id="0184a-126">For example, a replica that has 16 GB of state will have checkpoints that add up approximately too16 GB.</span></span>
<span data-ttu-id="0184a-127">Если у нас есть пять минут цели точки восстановления, реплики hello должен toobe резервное копирование каждые пять минут.</span><span class="sxs-lookup"><span data-stu-id="0184a-127">If we have a Recovery Point Objective of five minutes, hello replica needs toobe backed up every five minutes.</span></span>
<span data-ttu-id="0184a-128">Каждый раз, он создает резервную копию, он должен toocopy 16 ГБ контрольных точек в дополнение к этому too50 МБ (можно настроить с помощью `CheckpointThresholdInMB`), за которые журналы.</span><span class="sxs-lookup"><span data-stu-id="0184a-128">Each time it backs up it needs toocopy 16 GB of checkpoints in addition too50 MB (configurable using `CheckpointThresholdInMB`) worth of logs.</span></span>

![Пример полной архивации.](media/service-fabric-reliable-services-backup-restore/FullBackupExample.PNG)

<span data-ttu-id="0184a-130">проблема toothis Hello решение — добавочное резервное копирование, где резервной копии содержит только записи журнала hello изменен с момента последнего резервного копирования hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-130">hello solution toothis problem is incremental backups, where backup only contains hello changed log records since hello last backup.</span></span>

![Пример добавочной архивации.](media/service-fabric-reliable-services-backup-restore/IncrementalBackupExample.PNG)

<span data-ttu-id="0184a-132">Поскольку добавочное резервное копирование только изменения, сделанные с момента последнего резервного копирования hello (не включает hello контрольных точек), они, как правило, toobe быстрее, но их можно восстанавливать по отдельности.</span><span class="sxs-lookup"><span data-stu-id="0184a-132">Since incremental backups are only changes since hello last backup (does not include hello checkpoints), they tend toobe faster but they cannot be restored on their own.</span></span>
<span data-ttu-id="0184a-133">toorestore добавочное резервное копирование всей цепочки резервных копий hello является обязательным.</span><span class="sxs-lookup"><span data-stu-id="0184a-133">toorestore an incremental backup, hello entire backup chain is required.</span></span>
<span data-ttu-id="0184a-134">Цепочка резервных копий — это ряд резервных копий, начинающийся с полной резервной копии, за которой следует несколько добавочных резервных копий, которые создавались непрерывно.</span><span class="sxs-lookup"><span data-stu-id="0184a-134">A backup chain is a chain of backups starting with a full backup and followed by a number of contiguous incremental backups.</span></span>

## <a name="backup-reliable-services"></a><span data-ttu-id="0184a-135">Резервное копирование служб Reliable Services</span><span class="sxs-lookup"><span data-stu-id="0184a-135">Backup Reliable Services</span></span>
<span data-ttu-id="0184a-136">Hello автор службы имеет полный доступ, когда toomake резервного копирования и хранения резервных копий.</span><span class="sxs-lookup"><span data-stu-id="0184a-136">hello service author has full control of when toomake backups and where backups will be stored.</span></span>

<span data-ttu-id="0184a-137">toostart резервной копии hello служба должна функция-член наследуется hello tooinvoke `BackupAsync`.</span><span class="sxs-lookup"><span data-stu-id="0184a-137">toostart a backup, hello service needs tooinvoke hello inherited member function `BackupAsync`.</span></span>  
<span data-ttu-id="0184a-138">Резервные копии могут быть созданы только из основной реплики и требуют предоставлены toobe состояние записи.</span><span class="sxs-lookup"><span data-stu-id="0184a-138">Backups can be made only from primary replicas, and they require write status toobe granted.</span></span>

<span data-ttu-id="0184a-139">Как показано ниже, `BackupAsync` принимает `BackupDescription` объекта, где один можно указать полное или добавочное резервное копирование, а также функцию обратного вызова, `Func<< BackupInfo, CancellationToken, Task<bool>>>` , вызывается, когда hello папка резервного копирования будет создана локально и готов toobe перемещается out toosome Внешнее хранилище.</span><span class="sxs-lookup"><span data-stu-id="0184a-139">As shown below, `BackupAsync` takes in a `BackupDescription` object, where one can specify a full or incremental backup, as well as a callback function, `Func<< BackupInfo, CancellationToken, Task<bool>>>` that is invoked when hello backup folder has been created locally and is ready toobe moved out toosome external storage.</span></span>

```csharp

BackupDescription myBackupDescription = new BackupDescription(backupOption.Incremental,this.BackupCallbackAsync);

await this.BackupAsync(myBackupDescription);

```

<span data-ttu-id="0184a-140">Запрос tootake добавочного резервного копирования может завершиться `FabricMissingFullBackupException`.</span><span class="sxs-lookup"><span data-stu-id="0184a-140">Request tootake an incremental backup can fail with `FabricMissingFullBackupException`.</span></span> <span data-ttu-id="0184a-141">Это исключение указывает, что один из следующих вещей hello происходит:</span><span class="sxs-lookup"><span data-stu-id="0184a-141">This exception indicates that one of hello following things is happening:</span></span>

- <span data-ttu-id="0184a-142">реплика Hello не переводится полной резервной копии, поскольку она теперь стала первичной,</span><span class="sxs-lookup"><span data-stu-id="0184a-142">hello replica has never taken a full backup since it has become primary,</span></span>
- <span data-ttu-id="0184a-143">Некоторые hello записи журнала, с момента последнего резервного копирования hello был усечен или</span><span class="sxs-lookup"><span data-stu-id="0184a-143">some of hello log records since hello last backup has been truncated or</span></span>
- <span data-ttu-id="0184a-144">реплика, переданный hello `MaxAccumulatedBackupLogSizeInMB` ограничение.</span><span class="sxs-lookup"><span data-stu-id="0184a-144">replica passed hello `MaxAccumulatedBackupLogSizeInMB` limit.</span></span>

<span data-ttu-id="0184a-145">Пользователи могут увеличивать hello вероятность может toodo добавочное резервное копирование, настроив `MinLogSizeInMB` или `TruncationThresholdFactor`.</span><span class="sxs-lookup"><span data-stu-id="0184a-145">Users can increase hello likelihood of being able toodo incremental backups by configuring `MinLogSizeInMB` or `TruncationThresholdFactor`.</span></span>
<span data-ttu-id="0184a-146">Обратите внимание, что увеличение этих значений увеличивает hello в реплику на диске.</span><span class="sxs-lookup"><span data-stu-id="0184a-146">Note that increasing these values increases hello per replica disk usage.</span></span>
<span data-ttu-id="0184a-147">Чтобы узнать больше, ознакомьтесь с [конфигурацией Reliable Services](service-fabric-reliable-services-configuration.md).</span><span class="sxs-lookup"><span data-stu-id="0184a-147">For more information, see [Reliable Services Configuration](service-fabric-reliable-services-configuration.md)</span></span>

<span data-ttu-id="0184a-148">`BackupInfo`Предоставляет сведения, касающиеся hello резервной копии, включая расположение hello hello папку для сохранения резервной копии hello в hello среды выполнения (`BackupInfo.Directory`).</span><span class="sxs-lookup"><span data-stu-id="0184a-148">`BackupInfo` provides information regarding hello backup, including hello location of hello folder where hello runtime saved hello backup (`BackupInfo.Directory`).</span></span> <span data-ttu-id="0184a-149">функция обратного вызова Hello можно переместить hello `BackupInfo.Directory` tooan внешнем хранилище или в другом месте.</span><span class="sxs-lookup"><span data-stu-id="0184a-149">hello callback function can move hello `BackupInfo.Directory` tooan external store or another location.</span></span>  <span data-ttu-id="0184a-150">Эта функция также возвращает логическое значение, указывающее, была ли может toosuccessfully перемещения hello tooits целевой папке архивации.</span><span class="sxs-lookup"><span data-stu-id="0184a-150">This function also returns a bool that indicates whether it was able toosuccessfully move hello backup folder tooits target location.</span></span>

<span data-ttu-id="0184a-151">Hello следующий код демонстрирует, как hello `BackupCallbackAsync` метод может быть используется tooupload hello резервного копирования tooAzure хранилища:</span><span class="sxs-lookup"><span data-stu-id="0184a-151">hello following code demonstrates how hello `BackupCallbackAsync` method can be used tooupload hello backup tooAzure Storage:</span></span>

```csharp
private async Task<bool> BackupCallbackAsync(BackupInfo backupInfo, CancellationToken cancellationToken)
{
    var backupId = Guid.NewGuid();

    await externalBackupStore.UploadBackupFolderAsync(backupInfo.Directory, backupId, cancellationToken);

    return true;
}
```

<span data-ttu-id="0184a-152">В предыдущем примере hello `ExternalBackupStore` — класс образец hello, используемые toointerface с хранилищем больших двоичных объектов Azure и `UploadBackupFolderAsync` — метод hello, сжимает папку hello и помещает его в хранилище больших двоичных объектов Azure hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-152">In hello preceeding example, `ExternalBackupStore` is hello sample class that is used toointerface with Azure Blob storage, and `UploadBackupFolderAsync` is hello method that compresses hello folder and places it in hello Azure Blob store.</span></span>

<span data-ttu-id="0184a-153">Обратите внимание на следующее.</span><span class="sxs-lookup"><span data-stu-id="0184a-153">Note that:</span></span>

  - <span data-ttu-id="0184a-154">В любой момент времени в реплике можно выполнить только одну операцию резервного копирования.</span><span class="sxs-lookup"><span data-stu-id="0184a-154">There can be only one backup operation in-flight per replica at any given time.</span></span> <span data-ttu-id="0184a-155">Более одного `BackupAsync` вызовов одновременно вызовет `FabricBackupInProgressException` toolimit порядковых резервные копии tooone.</span><span class="sxs-lookup"><span data-stu-id="0184a-155">More than one `BackupAsync` call at a time will throw `FabricBackupInProgressException` toolimit inflight backups tooone.</span></span>
  - <span data-ttu-id="0184a-156">Если реплики при сбое во время резервного копирования, резервное копирование hello возможно не завершена.</span><span class="sxs-lookup"><span data-stu-id="0184a-156">If a replica fails over while a backup is in progress, hello backup may not have been completed.</span></span> <span data-ttu-id="0184a-157">Таким образом, после завершения выполнения hello отработки отказа, это hello службы ответственность toorestart hello резервная копия путем вызова `BackupAsync` при необходимости.</span><span class="sxs-lookup"><span data-stu-id="0184a-157">Thus, once hello failover finishes, it is hello service's responsibility toorestart hello backup by invoking `BackupAsync` as necessary.</span></span>

## <a name="restore-reliable-services"></a><span data-ttu-id="0184a-158">Восстановление служб Reliable Services</span><span class="sxs-lookup"><span data-stu-id="0184a-158">Restore Reliable Services</span></span>
<span data-ttu-id="0184a-159">В общем случае hello случаях, когда может потребоваться tooperform операции восстановления относятся к одной из этих категорий:</span><span class="sxs-lookup"><span data-stu-id="0184a-159">In general, hello cases when you might need tooperform a restore operation fall into one of these categories:</span></span>

  - <span data-ttu-id="0184a-160">Служба Hello секционировать данные потеряны.</span><span class="sxs-lookup"><span data-stu-id="0184a-160">hello service partition lost data.</span></span> <span data-ttu-id="0184a-161">Например диск hello для двух из трех реплик для секции (включая первичную реплику hello) возвращает поврежден или очищено.</span><span class="sxs-lookup"><span data-stu-id="0184a-161">For example, hello disk for two out of three replicas for a partition (including hello primary replica) gets corrupted or wiped.</span></span> <span data-ttu-id="0184a-162">Hello новой первичной реплике может понадобиться toorestore данных из резервной копии.</span><span class="sxs-lookup"><span data-stu-id="0184a-162">hello new primary may need toorestore data from a backup.</span></span>
  - <span data-ttu-id="0184a-163">Hello всей службы теряется.</span><span class="sxs-lookup"><span data-stu-id="0184a-163">hello entire service is lost.</span></span> <span data-ttu-id="0184a-164">Например администратор удаляет hello всей службе и таким образом, служба hello и hello данных должен восстановить toobe.</span><span class="sxs-lookup"><span data-stu-id="0184a-164">For example, an administrator removes hello entire service and thus hello service and hello data need toobe restored.</span></span>
  - <span data-ttu-id="0184a-165">Служба Hello реплицированные данные повреждены приложения (например, из-за ошибку приложения).</span><span class="sxs-lookup"><span data-stu-id="0184a-165">hello service replicated corrupt application data (e.g., because of an application bug).</span></span> <span data-ttu-id="0184a-166">В этом случае служба hello имеет toobe обновления или возвращенной tooremove hello причину повреждения hello и не были повреждены данные имеет toobe восстановлена.</span><span class="sxs-lookup"><span data-stu-id="0184a-166">In this case, hello service has toobe upgraded or reverted tooremove hello cause of hello corruption, and non-corrupt data has toobe restored.</span></span>

<span data-ttu-id="0184a-167">Хотя многими способами, возможно, мы предлагаем некоторые примеры использования `RestoreAsync` toorecover из hello выше сценариев.</span><span class="sxs-lookup"><span data-stu-id="0184a-167">While many approaches are possible, we offer some examples on using `RestoreAsync` toorecover from hello above scenarios.</span></span>

## <a name="partition-data-loss-in-reliable-services"></a><span data-ttu-id="0184a-168">Потеря данных раздела в службах Reliable Services</span><span class="sxs-lookup"><span data-stu-id="0184a-168">Partition data loss in Reliable Services</span></span>
<span data-ttu-id="0184a-169">В этом случае среда выполнения hello автоматически обнаруживает hello потери данных и вызова неуправляемого кода hello `OnDataLossAsync` API.</span><span class="sxs-lookup"><span data-stu-id="0184a-169">In this case, hello runtime would automatically detect hello data loss and invoke hello `OnDataLossAsync` API.</span></span>

<span data-ttu-id="0184a-170">автор службы Hello должен hello tooperform toorecover следующие:</span><span class="sxs-lookup"><span data-stu-id="0184a-170">hello service author needs tooperform hello following toorecover:</span></span>

  - <span data-ttu-id="0184a-171">Переопределите метод hello виртуального базового класса `OnDataLossAsync`.</span><span class="sxs-lookup"><span data-stu-id="0184a-171">Override hello virtual base class method `OnDataLossAsync`.</span></span>
  - <span data-ttu-id="0184a-172">Найти hello в последней резервной копии hello внешний носитель, содержащий резервные копии службы hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-172">Find hello latest backup in hello external location that contains hello service's backups.</span></span>
  - <span data-ttu-id="0184a-173">Загрузка hello последнюю резервную копию (и распаковать в папку резервного копирования hello hello резервного копирования, если она была сжата).</span><span class="sxs-lookup"><span data-stu-id="0184a-173">Download hello latest backup (and uncompress hello backup into hello backup folder if it was compressed).</span></span>
  - <span data-ttu-id="0184a-174">Hello `OnDataLossAsync` предоставляет метод `RestoreContext`.</span><span class="sxs-lookup"><span data-stu-id="0184a-174">hello `OnDataLossAsync` method provides a `RestoreContext`.</span></span> <span data-ttu-id="0184a-175">Вызовите hello `RestoreAsync` API на предоставленный hello `RestoreContext`.</span><span class="sxs-lookup"><span data-stu-id="0184a-175">Call hello `RestoreAsync` API on hello provided `RestoreContext`.</span></span>
  - <span data-ttu-id="0184a-176">Возвращает значение true, если hello восстановления завершается успешно.</span><span class="sxs-lookup"><span data-stu-id="0184a-176">Return true if hello restoration was a success.</span></span>

<span data-ttu-id="0184a-177">Ниже приведен пример реализации hello `OnDataLossAsync` метод:</span><span class="sxs-lookup"><span data-stu-id="0184a-177">Following is an example implementation of hello `OnDataLossAsync` method:</span></span>

```csharp
protected override async Task<bool> OnDataLossAsync(RestoreContext restoreCtx, CancellationToken cancellationToken)
{
    var backupFolder = await this.externalBackupStore.DownloadLastBackupAsync(cancellationToken);

    var restoreDescription = new RestoreDescription(backupFolder);

    await restoreCtx.RestoreAsync(restoreDescription);

    return true;
}
```

<span data-ttu-id="0184a-178">`RestoreDescription`Переданный toohello `RestoreContext.RestoreAsync` вызов содержит член с именем `BackupFolderPath`.</span><span class="sxs-lookup"><span data-stu-id="0184a-178">`RestoreDescription` passed in toohello `RestoreContext.RestoreAsync` call contains a member called `BackupFolderPath`.</span></span>
<span data-ttu-id="0184a-179">При восстановлении одной полной резервной копии, это `BackupFolderPath` следует задать локальный путь toohello hello папке, содержащей к полной резервной копии.</span><span class="sxs-lookup"><span data-stu-id="0184a-179">When restoring a single full backup, this `BackupFolderPath` should be set toohello local path of hello folder that contains your full backup.</span></span>
<span data-ttu-id="0184a-180">При восстановлении полной резервной копии и количество добавочное резервное копирование, `BackupFolderPath` должно быть установлено toohello локальный путь к папке hello, содержит не только hello полной резервной копии, но также все hello добавочных резервных копий.</span><span class="sxs-lookup"><span data-stu-id="0184a-180">When restoring a full backup and a number of incremental backups, `BackupFolderPath` should be set toohello local path of hello folder that not only contains hello full backup, but also all hello incremental backups.</span></span>
<span data-ttu-id="0184a-181">`RestoreAsync`вызов может вызывать `FabricMissingFullBackupException` Если hello `BackupFolderPath` указано не содержит полной резервной копии.</span><span class="sxs-lookup"><span data-stu-id="0184a-181">`RestoreAsync` call can throw `FabricMissingFullBackupException` if hello `BackupFolderPath` provided does not contain a full backup.</span></span>
<span data-ttu-id="0184a-182">Он также может породить `ArgumentException`, если `BackupFolderPath` указывает на папку с нарушенной цепочкой добавочных резервных копий.</span><span class="sxs-lookup"><span data-stu-id="0184a-182">It can also throw `ArgumentException` if `BackupFolderPath` has a broken chain of incremental backups.</span></span>
<span data-ttu-id="0184a-183">Например если она содержит hello полного резервного копирования, сначала hello добавочных и hello третий добавочное резервное копирование, но не hello второй добавочного резервного копирования.</span><span class="sxs-lookup"><span data-stu-id="0184a-183">For example, if it contains hello full backup, hello first incremental and hello third incremental backup but no hello second incremental backup.</span></span>

> [!NOTE]
> <span data-ttu-id="0184a-184">по умолчанию Hello RestorePolicy имеет значение tooSafe.</span><span class="sxs-lookup"><span data-stu-id="0184a-184">hello RestorePolicy is set tooSafe by default.</span></span>  <span data-ttu-id="0184a-185">Это означает, что hello `RestoreAsync` API, будут завершаться ArgumentException при обнаружении эта папка резервного копирования hello содержит состояние, которое является более ранней, чем или равно toohello состоянием, содержащимся в этой реплике.</span><span class="sxs-lookup"><span data-stu-id="0184a-185">This means that hello `RestoreAsync` API will fail with ArgumentException if it detects that hello backup folder contains a state that is older than or equal toohello state contained in this replica.</span></span>  <span data-ttu-id="0184a-186">`RestorePolicy.Force`можно использовать tooskip такую проверку.</span><span class="sxs-lookup"><span data-stu-id="0184a-186">`RestorePolicy.Force` can be used tooskip this safety check.</span></span> <span data-ttu-id="0184a-187">Этот параметр указывается как часть `RestoreDescription`.</span><span class="sxs-lookup"><span data-stu-id="0184a-187">This is specified as part of `RestoreDescription`.</span></span>
> 

## <a name="deleted-or-lost-service"></a><span data-ttu-id="0184a-188">Удаленная или утерянная служба</span><span class="sxs-lookup"><span data-stu-id="0184a-188">Deleted or lost service</span></span>
<span data-ttu-id="0184a-189">При удалении службы необходимо сначала создать службу hello перед восстановлением данных hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-189">If a service is removed, you must first re-create hello service before hello data can be restored.</span></span>  <span data-ttu-id="0184a-190">Это важные toocreate службу hello с приветствия новую конфигурацию, например, схему, секционирования, которая hello данных может быть восстановлена без проблем.</span><span class="sxs-lookup"><span data-stu-id="0184a-190">It is important toocreate hello service with hello same configuration, e.g., partitioning scheme, so that hello data can be restored seamlessly.</span></span>  <span data-ttu-id="0184a-191">После обновления hello hello данных toorestore API (`OnDataLossAsync` выше) имеет toobe вызывается в каждом разделе этой службы.</span><span class="sxs-lookup"><span data-stu-id="0184a-191">Once hello service is up, hello API toorestore data (`OnDataLossAsync` above) has toobe invoked on every partition of this service.</span></span> <span data-ttu-id="0184a-192">Один из способов сделать это — использовать `[FabricClient.TestManagementClient.StartPartitionDataLossAsync](https://msdn.microsoft.com/library/mt693569.aspx)` в каждой секции.</span><span class="sxs-lookup"><span data-stu-id="0184a-192">One way of achieving this is by using `[FabricClient.TestManagementClient.StartPartitionDataLossAsync](https://msdn.microsoft.com/library/mt693569.aspx)` on every partition.</span></span>  

<span data-ttu-id="0184a-193">С этого момента реализации является hello аналогично hello выше сценария.</span><span class="sxs-lookup"><span data-stu-id="0184a-193">From this point, implementation is hello same as hello above scenario.</span></span> <span data-ttu-id="0184a-194">Каждая секция должна toorestore hello последние соответствующего резервного копирования из внешнего хранилища hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-194">Each partition needs toorestore hello latest relevant backup from hello external store.</span></span> <span data-ttu-id="0184a-195">Один оговорка заключается в этой секции hello, возможно, идентификатор теперь изменился, поскольку среда выполнения hello динамически создает идентификаторы секций.</span><span class="sxs-lookup"><span data-stu-id="0184a-195">One caveat is that hello partition ID may have now changed, since hello runtime creates partition IDs dynamically.</span></span> <span data-ttu-id="0184a-196">Таким образом служба hello должна toostore hello подходящий метод секционирования сведения и службы имя tooidentify hello правильный последней резервной копии toorestore из для каждой секции.</span><span class="sxs-lookup"><span data-stu-id="0184a-196">Thus, hello service needs toostore hello appropriate partition information and service name tooidentify hello correct latest backup toorestore from for each partition.</span></span>

> [!NOTE]
> <span data-ttu-id="0184a-197">Не рекомендуется toouse `FabricClient.ServiceManager.InvokeDataLossAsync` для каждой секции toorestore hello всей службы, так как, может привести к повреждению состояния кластера.</span><span class="sxs-lookup"><span data-stu-id="0184a-197">It is not recommended toouse `FabricClient.ServiceManager.InvokeDataLossAsync` on each partition toorestore hello entire service, since that may corrupt your cluster state.</span></span>
> 

## <a name="replication-of-corrupt-application-data"></a><span data-ttu-id="0184a-198">Репликация поврежденных данных приложения</span><span class="sxs-lookup"><span data-stu-id="0184a-198">Replication of corrupt application data</span></span>
<span data-ttu-id="0184a-199">Обновление приложения hello вновь развернуть обнаруживается ошибка, может привести к повреждению данных.</span><span class="sxs-lookup"><span data-stu-id="0184a-199">If hello newly deployed application upgrade has a bug, that may cause corruption of data.</span></span> <span data-ttu-id="0184a-200">Например обновление приложения может запускаться tooupdate каждой записи номера телефона в надежные словаря с недопустимый код города.</span><span class="sxs-lookup"><span data-stu-id="0184a-200">For example, an application upgrade may start tooupdate every phone number record in a Reliable Dictionary with an invalid area code.</span></span>  <span data-ttu-id="0184a-201">В этом случае hello недопустимыми номерами телефонов будут реплицированы, поскольку Service Fabric не учитывать характер hello hello данных, которая хранится.</span><span class="sxs-lookup"><span data-stu-id="0184a-201">In this case, hello invalid phone numbers will be replicated since Service Fabric is not aware of hello nature of hello data that is being stored.</span></span>

<span data-ttu-id="0184a-202">Hello первое, что toodo после обнаружения таких egregious ошибку, приводят к повреждению данных является toofreeze hello службы на уровне приложения hello и, если это возможно, обновление версии toohello кода приложения hello, у которого нет ошибки hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-202">hello first thing toodo after you detect such an egregious bug that causes data corruption is toofreeze hello service at hello application level and, if possible, upgrade toohello version of hello application code that does not have hello bug.</span></span>  <span data-ttu-id="0184a-203">Даже после устранения код службы hello hello данных по-прежнему может быть поврежден и таким образом данных может потребоваться восстановить toobe.</span><span class="sxs-lookup"><span data-stu-id="0184a-203">However, even after hello service code is fixed, hello data may still be corrupt and thus data may need toobe restored.</span></span>  <span data-ttu-id="0184a-204">В таких случаях его может оказаться достаточно toorestore hello последнюю резервную копию, так как hello последние резервные копии могут быть повреждены.</span><span class="sxs-lookup"><span data-stu-id="0184a-204">In such cases, it may not be sufficient toorestore hello latest backup, since hello latest backups may also be corrupt.</span></span>  <span data-ttu-id="0184a-205">Таким образом у вас есть toofind hello последней резервной копии, сделанной до повреждения данных hello получен.</span><span class="sxs-lookup"><span data-stu-id="0184a-205">Thus, you have toofind hello last backup that was made before hello data got corrupted.</span></span>

<span data-ttu-id="0184a-206">Если вы не уверены, какие резервные копии, повреждены, можно развернуть в новый кластер Service Fabric и восстановите резервные копии затронутые секции, так же, как hello выше «Deleted или потеряны службы» hello сценария.</span><span class="sxs-lookup"><span data-stu-id="0184a-206">If you are not sure which backups are corrupt, you could deploy a new Service Fabric cluster and restore hello backups of affected partitions just like hello above "Deleted or lost service" scenario.</span></span>  <span data-ttu-id="0184a-207">Для каждой из секций запустите восстановление резервных копий hello из самой последней toohello hello бы.</span><span class="sxs-lookup"><span data-stu-id="0184a-207">For each partition, start restoring hello backups from hello most recent toohello least.</span></span> <span data-ttu-id="0184a-208">Найдя резервную копию, которая не повреждение hello, переместить или удалить все резервные копии этого раздела, были новее (этой резервной копии).</span><span class="sxs-lookup"><span data-stu-id="0184a-208">Once you find a backup that does not have hello corruption, move/delete all backups of this partition that were more recent (than that backup).</span></span> <span data-ttu-id="0184a-209">Повторите эту процедуру для каждой секции.</span><span class="sxs-lookup"><span data-stu-id="0184a-209">Repeat this process for each partition.</span></span> <span data-ttu-id="0184a-210">Теперь, когда `OnDataLossAsync` вызывается в hello производственного кластера раздела hello, hello последней резервной копии найден в hello внешнего хранилища будут hello выбрать одно, hello выше процесса.</span><span class="sxs-lookup"><span data-stu-id="0184a-210">Now, when `OnDataLossAsync` is called on hello partition in hello production cluster, hello last backup found in hello external store will be hello one picked by hello above process.</span></span>

<span data-ttu-id="0184a-211">Теперь hello шагов в hello, «Deleted или потеряны службы» раздела могут быть используется toorestore hello состояние hello службы toohello до дефектный код hello повреждения состояния hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-211">Now, hello steps in hello "Deleted or lost service" section can be used toorestore hello state of hello service toohello state before hello buggy code corrupted hello state.</span></span>

<span data-ttu-id="0184a-212">Обратите внимание на следующее.</span><span class="sxs-lookup"><span data-stu-id="0184a-212">Note that:</span></span>

  - <span data-ttu-id="0184a-213">При восстановлении, существует вероятность того, что hello резервного копирования, восстановления старее, чем состояние hello hello секции перед hello данных было потеряно.</span><span class="sxs-lookup"><span data-stu-id="0184a-213">When you restore, there is a chance that hello backup being restored is older than hello state of hello partition before hello data was lost.</span></span> <span data-ttu-id="0184a-214">По этой причине следует восстановить только как последнее средство спасения toorecover объема данных, насколько это возможно.</span><span class="sxs-lookup"><span data-stu-id="0184a-214">Because of this, you should restore only as a last resort toorecover as much data as possible.</span></span>
  - <span data-ttu-id="0184a-215">Строка, представляющая путь к папке резервного копирования hello Hello и hello пути к файлам в папке резервного копирования hello может превышать 255 символов, в зависимости от пути FabricDataRoot hello и длина имени типа приложения.</span><span class="sxs-lookup"><span data-stu-id="0184a-215">hello string that represents hello backup folder path and hello paths of files inside hello backup folder can be greater than 255 characters, depending on hello FabricDataRoot path and Application Type name's length.</span></span> <span data-ttu-id="0184a-216">Это может вызвать некоторые методы .NET, таких как `Directory.Move`, toothrow hello `PathTooLongException` исключение.</span><span class="sxs-lookup"><span data-stu-id="0184a-216">This can cause some .NET methods, like `Directory.Move`, toothrow hello `PathTooLongException` exception.</span></span> <span data-ttu-id="0184a-217">Одно решение — toodirectly вызывает kernel32 API-интерфейсы, такие как `CopyFile`.</span><span class="sxs-lookup"><span data-stu-id="0184a-217">One workaround is toodirectly call kernel32 APIs, like `CopyFile`.</span></span>

## <a name="backup-and-restore-reliable-actors"></a><span data-ttu-id="0184a-218">Резервное копирование и восстановление субъектов Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="0184a-218">Backup and restore Reliable Actors</span></span>


<span data-ttu-id="0184a-219">Платформа Reliable Actors создана на основе Reliable Services.</span><span class="sxs-lookup"><span data-stu-id="0184a-219">Reliable Actors Framework is built on top of Reliable Services.</span></span> <span data-ttu-id="0184a-220">Hello ActorService, на котором размещается hello actor(s) является надежных служб с отслеживанием состояния.</span><span class="sxs-lookup"><span data-stu-id="0184a-220">hello ActorService which hosts hello actor(s) is a stateful reliable service.</span></span> <span data-ttu-id="0184a-221">Таким образом все hello резервного копирования и восстановления функциональных возможностей, доступных в надежные службы также доступны tooReliable субъекты (кроме поведений, которые поставщик состояний конкретного).</span><span class="sxs-lookup"><span data-stu-id="0184a-221">Hence, all hello backup and restore functionality available in Reliable Services is also available tooReliable Actors (except behaviors that are state provider specific).</span></span> <span data-ttu-id="0184a-222">Так как резервные копии будут создаваться для каждого раздела, состояния всех субъектов в этом разделе будут архивированы (восстановление будет происходить для каждого раздела).</span><span class="sxs-lookup"><span data-stu-id="0184a-222">Since backups will be taken on a per-partition basis, states for all actors in that partition will be backed up (and restoration is similar and will happen on a per-partition basis).</span></span> <span data-ttu-id="0184a-223">tooperform резервного копирования и восстановления, владелец службы hello следует создавать пользовательские субъекта службы класс, производный от класса ActorService и затем резервного копирования и восстановления tooReliable аналогичные службы, как описано выше в предыдущих разделах.</span><span class="sxs-lookup"><span data-stu-id="0184a-223">tooperform backup/restore, hello service owner should create a custom actor service class that derives from ActorService class and then do backup/restore similar tooReliable Services as described above in previous sections.</span></span>

```csharp
class MyCustomActorService : ActorService
{
     public MyCustomActorService(StatefulServiceContext context, ActorTypeInformation actorTypeInfo)
            : base(context, actorTypeInfo)
     {                  
     }
    
    //
   // Method overrides and other code.
    //
}
```

<span data-ttu-id="0184a-224">При создании пользовательских субъекта классом службы, потребуется tooregister, а также при регистрации hello субъекта.</span><span class="sxs-lookup"><span data-stu-id="0184a-224">When you create a custom actor service class, you need tooregister that as well when registering hello actor.</span></span>

```csharp
ActorRuntime.RegisterActorAsync<MyActor>(
   (context, typeInfo) => new MyCustomActorService(context, typeInfo)).GetAwaiter().GetResult();
```

<span data-ttu-id="0184a-225">поставщик состояния по умолчанию Hello для службы Reliable Actor `KvsActorStateProvider`.</span><span class="sxs-lookup"><span data-stu-id="0184a-225">hello default state provider for Reliable Actors is `KvsActorStateProvider`.</span></span> <span data-ttu-id="0184a-226">Добавочная архивация для `KvsActorStateProvider` не включена по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0184a-226">Incremental backup is not enabled by default for `KvsActorStateProvider`.</span></span> <span data-ttu-id="0184a-227">Добавочное резервное копирование можно включить, создав `KvsActorStateProvider` с hello соответствующий параметр в конструкторе и передачи его конструктору tooActorService, как показано в следующем фрагменте кода:</span><span class="sxs-lookup"><span data-stu-id="0184a-227">You can enable incremental backup by creating `KvsActorStateProvider` with hello appropriate setting in its constructor and then passing it tooActorService constructor as shown in following code snippet:</span></span>

```csharp
class MyCustomActorService : ActorService
{
     public MyCustomActorService(StatefulServiceContext context, ActorTypeInformation actorTypeInfo)
            : base(context, actorTypeInfo, null, null, new KvsActorStateProvider(true)) // Enable incremental backup
     {                  
     }
    
    //
   // Method overrides and other code.
    //
}
```

<span data-ttu-id="0184a-228">После включения добавочного резервного копирования добавочного резервного копирования может завершиться FabricMissingFullBackupException по одной из следующих причин и вам потребуется tootake полной резервной копии перед выполнением добавочного архивы:</span><span class="sxs-lookup"><span data-stu-id="0184a-228">After incremental backup has been enabled, taking an incremental backup can fail with FabricMissingFullBackupException for one of following reasons and you will need tootake a full backup before taking incremental backup(s):</span></span>

  - <span data-ttu-id="0184a-229">Hello реплики никогда не было полной резервной копии, так как он стал основным.</span><span class="sxs-lookup"><span data-stu-id="0184a-229">hello replica has never taken a full backup since it became primary.</span></span>
  - <span data-ttu-id="0184a-230">Некоторые записи журнала hello было усечено, поскольку последняя резервная копия была сделана.</span><span class="sxs-lookup"><span data-stu-id="0184a-230">Some of hello log records were truncated since last backup was taken.</span></span>

<span data-ttu-id="0184a-231">Если добавочное резервное копирование включено, `KvsActorStateProvider` не использует toomanage циклического буфера журнала записывает и периодически производит усечение.</span><span class="sxs-lookup"><span data-stu-id="0184a-231">When incremental backup is enabled, `KvsActorStateProvider` does not use circular buffer toomanage its log records and periodically truncates it.</span></span> <span data-ttu-id="0184a-232">Если нет резервной копии пользователем в течение 45 минут hello системы автоматически усекает hello записей журнала.</span><span class="sxs-lookup"><span data-stu-id="0184a-232">If no backup is taken by user for a period of 45 minutes, hello system automatically truncates hello log records.</span></span> <span data-ttu-id="0184a-233">Этот интервал можно настроить, указав `logTrunctationIntervalInMinutes` в `KvsActorStateProvider` конструктор (аналогично toowhen включения добавочного резервного копирования).</span><span class="sxs-lookup"><span data-stu-id="0184a-233">This interval can be configured by specifying `logTrunctationIntervalInMinutes` in `KvsActorStateProvider` constructor (similar toowhen enabling incremental backup).</span></span> <span data-ttu-id="0184a-234">записи журнала Hello также может получить усечена, если первичная реплика должны toobuild другой реплике, отправляя свои данные.</span><span class="sxs-lookup"><span data-stu-id="0184a-234">hello log records may also get truncated if primary replica need toobuild another replica by sending all its data.</span></span>

<span data-ttu-id="0184a-235">При выполнении восстановления из резервной копии цепочки, аналогичные службы tooReliable, hello BackupFolderPath должен содержать подкаталогов по один вложенный каталог, содержащий полное резервное копирование и другие подкаталогов, содержащих добавочное архивы.</span><span class="sxs-lookup"><span data-stu-id="0184a-235">When doing restore from a backup chain, similar tooReliable Services, hello BackupFolderPath should contain subdirectories with one subdirectory containing full backup and others subdirectories containing incremental backup(s).</span></span> <span data-ttu-id="0184a-236">API восстановления Hello вызовет FabricException с соответствующим сообщением об ошибке при сбое проверки hello цепочку резервных копий.</span><span class="sxs-lookup"><span data-stu-id="0184a-236">hello restore API will throw FabricException with appropriate error message if hello backup chain validation fails.</span></span> 

> [!NOTE]
> <span data-ttu-id="0184a-237">`KvsActorStateProvider`в настоящее время пропускает параметр hello RestorePolicy.Safe.</span><span class="sxs-lookup"><span data-stu-id="0184a-237">`KvsActorStateProvider` currently ignores hello option RestorePolicy.Safe.</span></span> <span data-ttu-id="0184a-238">В следующих выпусках планируется поддержка этой функции.</span><span class="sxs-lookup"><span data-stu-id="0184a-238">Support for this feature is planned in an upcoming release.</span></span>
> 

## <a name="testing-backup-and-restore"></a><span data-ttu-id="0184a-239">Проверка резервного копирования и восстановления</span><span class="sxs-lookup"><span data-stu-id="0184a-239">Testing Backup and Restore</span></span>
<span data-ttu-id="0184a-240">Это важные tooensure, который выполняется резервное копирование важных данных и могут быть восстановлены из.</span><span class="sxs-lookup"><span data-stu-id="0184a-240">It is important tooensure that critical data is being backed up, and can be restored from.</span></span> <span data-ttu-id="0184a-241">Это можно сделать путем вызова hello `Start-ServiceFabricPartitionDataLoss` в PowerShell, который может вызвать потерю данных в заданной секции tootest ли hello данных резервного копирования и восстановления для правильной работы службы.</span><span class="sxs-lookup"><span data-stu-id="0184a-241">This can be done by invoking hello `Start-ServiceFabricPartitionDataLoss` cmdlet in PowerShell that can induce data loss in a particular partition tootest whether hello data backup and restore functionality for your service is working as expected.</span></span>  <span data-ttu-id="0184a-242">Это также возможно tooprogrammatically вызывать потерю данных и восстановление из этого события, а также.</span><span class="sxs-lookup"><span data-stu-id="0184a-242">It is also possible tooprogrammatically invoke data loss and restore from that event as well.</span></span>

> [!NOTE]
> <span data-ttu-id="0184a-243">Можно найти образец реализации резервного копирования и восстановления функциональности в hello веб-ссылку приложения на GitHub.</span><span class="sxs-lookup"><span data-stu-id="0184a-243">You can find a sample implementation of backup and restore functionality in hello Web Reference App on GitHub.</span></span> <span data-ttu-id="0184a-244">См. в hello `Inventory.Service` службы для получения дополнительных сведений.</span><span class="sxs-lookup"><span data-stu-id="0184a-244">Please look at hello `Inventory.Service` service for more details.</span></span>
> 
> 

## <a name="under-hello-hood-more-details-on-backup-and-restore"></a><span data-ttu-id="0184a-245">Hello механизме: Дополнительные сведения о резервном копировании и восстановлении</span><span class="sxs-lookup"><span data-stu-id="0184a-245">Under hello hood: more details on backup and restore</span></span>
<span data-ttu-id="0184a-246">Далее представлены дополнительные сведения о резервном копировании и восстановлении.</span><span class="sxs-lookup"><span data-stu-id="0184a-246">Here's some more details on backup and restore.</span></span>

### <a name="backup"></a><span data-ttu-id="0184a-247">Резервное копирование</span><span class="sxs-lookup"><span data-stu-id="0184a-247">Backup</span></span>
<span data-ttu-id="0184a-248">Hello надежного диспетчер состояний предоставляет hello возможность toocreate согласованных копий без блокировки любых операций чтения или записи.</span><span class="sxs-lookup"><span data-stu-id="0184a-248">hello Reliable State Manager provides hello ability toocreate consistent backups without blocking any read or write operations.</span></span> <span data-ttu-id="0184a-249">toodo таким образом, он использует механизм сохраняемости контрольной точки или журнала.</span><span class="sxs-lookup"><span data-stu-id="0184a-249">toodo so, it utilizes a checkpoint and log persistence mechanism.</span></span>  <span data-ttu-id="0184a-250">Hello надежного диспетчер состояния принимает нечеткого (упрощенный) контрольные точки в определенных давление toorelieve точек из журнала транзакций hello и сократить время восстановления.</span><span class="sxs-lookup"><span data-stu-id="0184a-250">hello Reliable State Manager takes fuzzy (lightweight) checkpoints at certain points toorelieve pressure from hello transactional log and improve recovery times.</span></span>  <span data-ttu-id="0184a-251">При `BackupAsync` вызове hello надежного диспетчер состояния указывает, что все объекты надежного toocopy их последней контрольной точки файлы tooa локальной папки резервных копий.</span><span class="sxs-lookup"><span data-stu-id="0184a-251">When `BackupAsync` is called, hello Reliable State Manager instructs all Reliable objects toocopy their latest checkpoint files tooa local backup folder.</span></span>  <span data-ttu-id="0184a-252">Затем hello надежного диспетчер состояния копирует все записи журнала, начиная с hello «start указатель» toohello последней записи в журнале в папке резервных копий hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-252">Then, hello Reliable State Manager copies all log records, starting from hello "start pointer" toohello latest log record into hello backup folder.</span></span>  <span data-ttu-id="0184a-253">Так как все записи журнала hello вверх toohello последней записи в журнале включаются в резервную копию hello и hello надежного диспетчер состояния сохраняет упреждающее ведение журнала, hello надежного диспетчер состояния гарантирует, что все транзакции, фиксируются (`CommitAsync` вернул успешно), включаются в резервную копию hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-253">Since all hello log records up toohello latest log record are included in hello backup and hello Reliable State Manager preserves write-ahead logging, hello Reliable State Manager guarantees that all transactions that are committed (`CommitAsync` has returned successfully) are included in hello backup.</span></span>

<span data-ttu-id="0184a-254">Любая транзакция, которая фиксируется после `BackupAsync` был вызван может или не может быть в резервной копии hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-254">Any transaction that commits after `BackupAsync` has been called may or may not be in hello backup.</span></span>  <span data-ttu-id="0184a-255">После заполнения платформой hello hello локальной папки резервных копий (т. е. локальный архивирования средой выполнения hello) hello службы резервного копирования обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="0184a-255">Once hello local backup folder has been populated by hello platform (i.e., local backup is completed by hello runtime), hello service's backup callback is invoked.</span></span>  <span data-ttu-id="0184a-256">Этот обратный вызов отвечает за перемещение hello папка резервного копирования tooan внешнее расположение таких как хранилище Azure.</span><span class="sxs-lookup"><span data-stu-id="0184a-256">This callback is responsible for moving hello backup folder tooan external location such as Azure Storage.</span></span>

### <a name="restore"></a><span data-ttu-id="0184a-257">восстановление;</span><span class="sxs-lookup"><span data-stu-id="0184a-257">Restore</span></span>
<span data-ttu-id="0184a-258">Hello надежного диспетчер состояния обеспечивает возможность toorestore hello из резервной копии с помощью hello `RestoreAsync` API.</span><span class="sxs-lookup"><span data-stu-id="0184a-258">hello Reliable State Manager provides hello ability toorestore from a backup by using hello `RestoreAsync` API.</span></span>  
<span data-ttu-id="0184a-259">Hello `RestoreAsync` метод `RestoreContext` может вызываться только внутри hello `OnDataLossAsync` метод.</span><span class="sxs-lookup"><span data-stu-id="0184a-259">hello `RestoreAsync` method on `RestoreContext` can be called only inside hello `OnDataLossAsync` method.</span></span>
<span data-ttu-id="0184a-260">Здравствуйте, bool, возвращенных `OnDataLossAsync` указывает ли служба hello восстановить свое состояние из внешнего источника.</span><span class="sxs-lookup"><span data-stu-id="0184a-260">hello bool returned by `OnDataLossAsync` indicates whether hello service restored its state from an external source.</span></span>
<span data-ttu-id="0184a-261">Если hello `OnDataLossAsync` возвращает значение true, заново всех остальных реплик из этому Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="0184a-261">If hello `OnDataLossAsync` returns true, Service Fabric will rebuild all other replicas from this primary.</span></span> <span data-ttu-id="0184a-262">Гарантирует, что Service Fabric реплик, которые будут получать `OnDataLossAsync` вызывать первый переход toohello первичной роли, но не предоставляется чтение состояния или состояние записи.</span><span class="sxs-lookup"><span data-stu-id="0184a-262">Service Fabric ensures that replicas that will receive `OnDataLossAsync` call first transition toohello primary role but are not granted read status or write status.</span></span>
<span data-ttu-id="0184a-263">Это означает, что для исполнителей StatefulService метод `RunAsync` будет вызван только после успешного завершения метода `OnDataLossAsync`.</span><span class="sxs-lookup"><span data-stu-id="0184a-263">This implies that for StatefulService implementers, `RunAsync` will not be called until `OnDataLossAsync` finishes successfully.</span></span>
<span data-ttu-id="0184a-264">Затем `OnDataLossAsync` будет вызван на новом сервере-источнике hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-264">Then, `OnDataLossAsync` will be invoked on hello new primary.</span></span>
<span data-ttu-id="0184a-265">Пока служба завершается успешно (возвращая true или false) этот API и завершает соответствующий перенастройки hello, hello API будет хранить вызывается по одному.</span><span class="sxs-lookup"><span data-stu-id="0184a-265">Until a service completes this API successfully (by returning true or false) and finishes hello relevant reconfiguration, hello API will keep being called one at a time.</span></span>

<span data-ttu-id="0184a-266">`RestoreAsync`сначала удаляет все существующие состояния в hello первичной реплики, он вызывался.</span><span class="sxs-lookup"><span data-stu-id="0184a-266">`RestoreAsync` first drops all existing state in hello primary replica that it was called on.</span></span>  
<span data-ttu-id="0184a-267">Затем hello надежного диспетчер состояний создает все hello надежного объекты, существующие в папке резервных копий hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-267">Then hello Reliable State Manager creates all hello Reliable objects that exist in hello backup folder.</span></span>  
<span data-ttu-id="0184a-268">Затем объекты надежного hello, toorestore соответствии с их контрольных точек в папке резервных копий hello.</span><span class="sxs-lookup"><span data-stu-id="0184a-268">Next, hello Reliable objects are instructed toorestore from their checkpoints in hello backup folder.</span></span>  
<span data-ttu-id="0184a-269">Наконец hello надежного диспетчер состояния восстанавливает собственное состояние из hello записей журнала в папке резервных копий hello и выполняет восстановление.</span><span class="sxs-lookup"><span data-stu-id="0184a-269">Finally, hello Reliable State Manager recovers its own state from hello log records in hello backup folder and performs recovery.</span></span>  
<span data-ttu-id="0184a-270">Как часть процесса восстановления hello начиная с hello «основы» операции, которые имеют фиксации записи журнала в папке резервных копий hello являются объектами надежного воспроизводимой toohello.</span><span class="sxs-lookup"><span data-stu-id="0184a-270">As part of hello recovery process, operations starting from hello "starting point" that have commit log records in hello backup folder are replayed toohello Reliable objects.</span></span>  
<span data-ttu-id="0184a-271">Это действие гарантирует, что hello восстановленные состояние.</span><span class="sxs-lookup"><span data-stu-id="0184a-271">This step ensures that hello recovered state is consistent.</span></span>

## <a name="next-steps"></a><span data-ttu-id="0184a-272">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="0184a-272">Next steps</span></span>
  - [<span data-ttu-id="0184a-273">Reliable Collections</span><span class="sxs-lookup"><span data-stu-id="0184a-273">Reliable Collections</span></span>](service-fabric-work-with-reliable-collections.md)
  - [<span data-ttu-id="0184a-274">Краткое руководство по надежным службам Reliable Services</span><span class="sxs-lookup"><span data-stu-id="0184a-274">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
  - [<span data-ttu-id="0184a-275">Уведомления Reliable Services</span><span class="sxs-lookup"><span data-stu-id="0184a-275">Reliable Services notifications</span></span>](service-fabric-reliable-services-notifications.md)
  - [<span data-ttu-id="0184a-276">Конфигурация Reliable Services</span><span class="sxs-lookup"><span data-stu-id="0184a-276">Reliable Services configuration</span></span>](service-fabric-reliable-services-configuration.md)
  - [<span data-ttu-id="0184a-277">Справочник разработчика по надежным коллекциям</span><span class="sxs-lookup"><span data-stu-id="0184a-277">Developer reference for Reliable Collections</span></span>](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)

