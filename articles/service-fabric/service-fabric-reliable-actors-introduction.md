---
title: "aaaService структуры надежного субъекты Обзор | Документы Microsoft"
description: "Введение toohello Service Fabric службы Reliable Actor модель программирования."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a>Введение tooService структуры службы Reliable Actor
Службы Reliable Actor — это платформа приложения Service Fabric, основании hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) шаблон. Hello надежного субъекты API предоставляет модель для программирования с одним потоком лежит hello масштабируемость и надежность гарантий, предоставляемых Service Fabric.

## <a name="what-are-actors"></a>Что представляют собой субъекты?
Субъект — это изолированная, независимая единица вычислений и состояния с однопоточным выполнением. Hello [шаблон субъекта](https://en.wikipedia.org/wiki/Actor_model) модель вычислений для параллельной или распределенных систем, в которой большое количество эти субъекты могут выполнять одновременно и независимо друг от друга. Субъекты могут взаимодействовать друг с другом и создавать новые субъекты.

### <a name="when-toouse-reliable-actors"></a>Когда toouse службы Reliable Actor
Служба структуры службы Reliable Actor представляет собой реализацию hello субъекта конструктивного шаблона. Как и любой шаблон разработки программного обеспечения, решение hello ли toouse шаблону выполняется с учетом ли программного обеспечения проектирования проблема помещается шаблон hello.

Несмотря на то, что шаблон разработки hello субъекта может быть хорошим соответствия tooa количество проблем распределенных систем и сценариев, тщательного рассмотрения этого ограничения hello шаблон hello и реализации framework hello, его необходимо сделать. Как общие рекомендации рекомендуется использовать шаблон toomodel hello субъекта вашей проблемы или сценарии если.

* Проблемное пространство включает множество (тысячи и больше) небольших независимых и изолированных единиц состояния и логики.
* Вы хотите toowork с одним потоком объектами, не требующие значительных взаимодействия с внешними компонентами, включая запросы состояния между несколькими субъектами.
* Экземпляры субъекта не должны блокировать вызывающие объекты с непредсказуемыми задержками, выполняя операции ввода-вывода.

## <a name="actors-in-service-fabric"></a>Субъекты в Service Fabric
В Service Fabric субъекты реализуются в framework службы Reliable Actor hello: построены на основе субъекта шаблон на основе исполняющую среду [надежного служб Service Fabric](service-fabric-reliable-services-introduction.md). Каждая написанный вами субъект Reliable Actor фактически представляет собой секционированную надежную службу Reliable Service с отслеживанием состояния.

Каждый субъект определяется как экземпляр типа субъекта, идентичные toohello как объект .NET является экземпляром типа .NET. Например может быть тип субъекта, который реализует функциональность hello калькулятора, и может быть много агентам этого типа, распределенных в различных узлах в кластере. У каждого такого субъекта есть уникальный идентификатор.

### <a name="actor-lifetime"></a>Срок действия субъекта
Субъекты Service Fabric являются виртуальными, это означает, что их время жизни не равноценных tootheir в памяти представление. В результате они не обязательно toobe явно создается или уничтожается. Среда выполнения службы Reliable Actor Hello автоматически активирует hello субъекта первый раз, он получает запрос для этого идентификатора субъекта. Если субъект не используется в течение заданного времени, среда выполнения службы Reliable Actor hello мусора собирает hello объекта в памяти. Он будет также поддерживать знаний существования hello субъекта реально toobe повторно активировать. Дополнительные сведения см. в статье [Жизненный цикл субъектов и сбор мусора](service-fabric-reliable-actors-lifecycle.md).

Эта абстракция времени существования виртуальной субъекта несет некоторыми оговорками в результате hello виртуального субъекта модели, и на самом деле hello реализацию службы Reliable Actor иногда отличается от этой модели.

* Субъект активируется автоматически (в результате чего субъект toobe объект создан) hello первый раз, сообщение отправляется ИД tooits субъекта. Через некоторое время hello объекта субъекта является сбора мусора. В hello будущее, еще раз, с помощью идентификатора субъекта hello вызывает новый субъект toobe объект создан. Состояния субъекта превышает время существования hello объекта, сохраненное в диспетчер состояния hello.
* Вызов любого метода субъекта с идентификатором субъекта активирует этот субъект. По этой причине типы субъект имеет их конструктора, неявно вызывается средой выполнения hello. Таким образом клиентскому коду невозможно передать конструктор типа для параметров toohello субъекта, несмотря на то, что параметры могут передаваться конструктор toohello субъекта по самой службы hello. Hello получается, что субъекты можно составить в состоянии частично инициализирована hello момент времени, когда другие методы вызываются, если субъект hello требует инициализации параметров из клиента hello. Нет точки одну запись для активации hello субъект из клиента hello.
* Несмотря на то, что службы Reliable Actor неявно создают объекты субъектов. у вас есть tooexplicitly возможность hello удалить субъект и его состояние.

### <a name="distribution-and-failover"></a>Распространение и отработка отказа
распределяет tooprovide масштабируемость и надежность, Service Fabric субъекты везде hello кластера и автоматически переносит их с toohealthy Неисправные узлы из них при необходимости. Это абстрактное представление [секционированной службы Reliable Service с отслеживанием состояния](service-fabric-concepts-partitioning.md). Распространения, масштабируемость, надежность и автоматической отработки отказа предоставляются посредством hello факт субъекты выполняются внутри надежных служб с отслеживанием состояния вызывается hello *службу субъектов*.

Субъекты распределяются по секциям hello hello службу субъектов и секциями распределяются между узлами кластера Service Fabric hello. Каждая секция службы содержит набор субъектов. Service Fabric управляет распределение и отработка отказа hello службы секций.

Например службу субъектов девять разделов развернуто toothree узлов с помощью размещения секции субъекта по умолчанию hello будет распространена таким:

![Распространение субъектов Reliable Actors][2]

Hello субъекта Framework управляет секции схему и ключ параметров диапазона для вас. Это упрощает работу, но требует внимания к следующим моментам:

* Надежные службы позволяет toochoose схему секционирования диапазона ключей (при использовании схему секционирования диапазона) и число секций. Службы Reliable Actor схему секционирования диапазона ограниченных toohello (hello универсальный Int64 схемы) и требует использовать полный набор ключей hello Int64.
* По умолчанию субъекты равномерно распределяются между секциями в случайном порядке.
* Поскольку субъекты размещаются случайным образом, для выполняемых ими операций, включая сериализацию и десериализацию данных по вызовам методов, задержкам и нагрузке, всегда будет требоваться подключение к сети.
* В сложных сценариях это возможных toocontrol субъекта секции размещения с помощью субъекта Int64 идентификаторы, сопоставление секций toospecific. однако это может привести к неравномерному распределению субъектов между секциями.

Дополнительные сведения о как секционируются служб субъекта ссылаться слишком[секционирование основные понятия для субъектов](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).

### <a name="actor-communication"></a>Обмен данными с субъектами
Взаимодействия субъекта определяются в интерфейсе, который совместно используется hello субъект, который реализует интерфейс hello и hello клиента, который получает учетную запись-посредник субъекта tooan через hello тот же интерфейс. Поскольку этот интерфейс используется tooinvoke субъекта методы асинхронно, каждый метод в интерфейсе hello должен быть возвращающих задачи.

Вызовы методов и их ответы в конечном счете приводят сетевые запросы через hello кластера, поэтому hello аргументы и типы результата hello hello задач, что возвращают должен быть сериализуем методом hello платформы. В частности, они должны быть [сериализуемыми по контракту данных](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

#### <a name="hello-actor-proxy"></a>Hello субъекта прокси-сервера
API клиента службы Reliable Actor Hello обеспечивает обмен данными между экземпляром субъекта и клиент субъекта. toocommunicate с субъектом, клиент создает субъект прокси-объект, реализующий интерфейс субъекта hello. Hello клиент взаимодействует с субъекта hello путем вызова методов применительно к hello прокси-объект. Hello субъекта прокси-сервер может использоваться для связи клиента для субъекта и субъекта для субъекта.

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


Обратите внимание, что hello два блока данных используется toocreate hello субъекта прокси-объект: hello идентификатор субъекта и имя приложения hello. Идентификатор субъекта Hello однозначно определяет субъект hello, хотя имя приложения hello идентифицирует hello [приложения Service Fabric](service-fabric-reliable-actors-platform.md#application-model) развертывания hello субъекта.

Hello `ActorProxy`(C#) или `ActorProxyBase`класс (Java) на стороне клиента hello выполняет hello необходимые разрешения toolocate hello субъекта по Идентификатору и откройте канал связи с ним. Она также повторяет toolocate hello субъекта в случаях hello сбоев связи и переход на другой ресурс. В результате доставки сообщений имеет следующие характеристики hello.

* Доставка сообщений не гарантируется.
* Субъекты может получить дублирующие сообщения из hello того же клиента.

### <a name="concurrency"></a>Параллелизм
Среда выполнения службы Reliable Actor Hello предоставляет модели простого доступа на основе включить доступ к методам субъекта. Это означает, что в конкретный момент времени в коде объекта субъекта может быть активен только один поток. Поочередный доступ значительно упрощает параллельные системы, поскольку снимает необходимость в механизмах синхронизации для доступа к данным. Это также означает, что системы должно быть рассчитано на специальные рассуждения о природе однопоточного доступа hello каждого экземпляра субъекта.

* Экземпляр одного субъекта не может обрабатывать больше одного запроса за раз. Экземпляр субъекта может привести к узким местом пропускной способности, если ожидаемый toohandle параллельных запросов.
* Субъекты может произойти взаимоблокировка друг от друга, если между двумя субъектами при внешний запрос tooone субъектов hello одновременно циклические запрос. Hello субъекта среда выполнения будет автоматически времени ожидания на субъекта вызывает и вызывать исключение toohello вызывающего объекта toointerrupt взаимоблокировке.

![Обмен данными между субъектами Reliable Actors][3]

#### <a name="turn-based-access"></a>Поочередный доступ
Полный цикл состоит из hello завершится выполнение метода субъекта в запросе tooa ответа от других сторон или клиентов или hello завершить выполнение [таймера и напоминание](service-fabric-reliable-actors-timers-reminders.md) обратного вызова. Даже если эти методы и обратные вызовы являются асинхронными, среда выполнения субъекты hello не чередовать их. Для смены очереди предыдущее действие должно быть завершено полностью. Другими словами субъект метод или таймера и напоминание обратный вызов, который в данный момент должен быть полностью завершена до нового вызова метода tooa или обратный вызов может. Метод или обратный вызов считается toohave по завершении выполнения hello вернул из метода hello или завершения обратного вызова и hello задачи, возвращаемой методом hello или обратный вызов. Следует подчеркнуть, что пошаговый параллелизм касается разных методов, таймеров и обратных вызовов.

Среда выполнения субъекты Hello обеспечивает основанных параллелизма, получение блокировки субъекта в начале оборота hello и освобождении блокировки hello в конце hello hello отключить. Таким образом, поочередный параллелизм обеспечивается на уровне отдельного субъекта, а не для всех субъектов сразу. Разные субъекты могут одновременно и независимо выполнять методы субъектов и обратные вызовы по таймеру или напоминанию.

Привет, следующий пример иллюстрирует hello выше основные понятия. Рассмотрим тип субъекта, который реализует два асинхронных метода (назовем их *Method1* и *Method2*), таймер и напоминание. Hello приведенной ниже схеме показан пример временной шкалы для выполнения hello этих методов и обратные вызовы от имени с двух сторон (*ActorId1* и *ActorId2*), принадлежат toothis типа субъекта.

![Доступ и пошаговый параллелизм в среде выполнения Reliable Actors][1]

В схеме используются следующие обозначения:

* Каждой вертикальной линии показан hello логический поток выполнения метода или обратный вызов от имени определенного субъекта.
* Hello на каждой вертикальной линии событиями в хронологическом порядке с новой событиями, происходящими ниже старые.
* Различные цвета используются для соответствующих субъектов toodifferent временных шкал.
* Выделение — интервал используется tooindicate hello, для которых hello блокировки субъекта удерживается от имени метода или обратный вызов.

Некоторые важные моменты tooconsider:

* Хотя *метод1* выполняется от имени *ActorId2* в запросе ответа tooclient *xyz789*, другой запрос клиента (*abc123*) поступает, также требуется *метод1* toobe исполнен *ActorId2*. Однако hello второго исполнения *метод1* не начинается до завершения выполнения предыдущего hello. Аналогичным образом, зарегистрированных напоминание *ActorId2* активируется при *метод1* выполняется в запросе ответа tooclient *xyz789*. Hello напоминание обратный вызов выполняется только после выполнения обоих *метод1* являются полными. — Все это из-за параллелизма на основе tooturn применяется принудительно для *ActorId2*.
* Аналогичным образом, основанных параллелизма также применяется для *ActorId1*, как показано выполнение hello *метод1*, *метод2*, и hello таймер обратного вызова от имени *ActorId1* происходит последовательно.
* Выполнение метода *Method1* от имени субъекта *ActorId1* перекрывается с выполнением того же метода от имени субъекта *ActorId2*. Это связано с тем, что пошаговый параллелизм применяется только для одного субъекта, а не для всех субъектов сразу.
* В некоторых выполнений метод/обратного вызова hello hello `Task`(C#) или `CompletableFuture`(Java) возвращенных hello метод или обратный вызов завершения после возврата метода hello. В некоторых других hello асинхронной операции уже завершено моменту hello hello метод или функция обратного вызова. В обоих случаях блокировки субъекта hello освобождается только после того, метод или функция обратного вызова обоих hello и завершения асинхронной операции hello.

#### <a name="reentrancy"></a>Повторный вход
Среда выполнения субъекты Hello позволяет повторного входа по умолчанию. Это означает, что если метод субъекта *субъекта A* вызывает метод *B субъекта*, который в свою очередь вызывает другой метод в *субъекта A*, допустимость toorun метод. Это, поскольку он является частью hello того же контекста логические цепочки вызовов. Все вызовы таймера и напоминание начинаются с Привет нового логического контекста вызова. В разделе hello [повторный вход службы Reliable Actor](service-fabric-reliable-actors-reentrancy.md) для получения дополнительных сведений.

#### <a name="scope-of-concurrency-guarantees"></a>Область гарантий параллелизма
Среда выполнения субъекты Hello предоставляет следующие гарантии параллелизма в ситуациях, где он управляет hello вызова этих методов. Например для hello вызовов методов, выполненные в запросе клиента tooa ответа, а также для обратные вызовы таймера и напоминание предоставляет следующие гарантии. Тем не менее если код субъекта hello напрямую вызывает эти методы за пределами hello механизмы, предоставляемые средой выполнения субъекты hello, hello среды выполнения не предоставляет никаких гарантий параллелизма. Например если вызывается метод hello в контексте какой-либо задачи, который не связан с задачей hello, возвращаемые методами субъекта hello hello, hello среды выполнения не может предоставить гарантии параллелизма. Если hello метод вызывается из потока, этот субъект hello создает сам по себе, а затем hello среда выполнения также не может предоставить гарантии параллелизма. Таким образом, tooperform фоновых операций, субъектами следует использовать [таймеров субъекта и субъект напоминания](service-fabric-reliable-actors-timers-reminders.md) , учитывают основанных параллелизма.

## <a name="next-steps"></a>Дальнейшие действия
* Приступите к работе, создав свою первую службу Reliable Actors:
   * [Приступая к работе с Reliable Actors с помощью .NET](service-fabric-reliable-actors-get-started.md)
   * [Приступая к работе с Reliable Actors с помощью Java](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
