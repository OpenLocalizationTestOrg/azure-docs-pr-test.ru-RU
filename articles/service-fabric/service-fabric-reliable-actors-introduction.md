---
title: "aaaService структуры надежного субъекты Обзор | Документы Microsoft"
description: "Введение toohello Service Fabric службы Reliable Actor модель программирования."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="ae148-103">Введение tooService структуры службы Reliable Actor</span><span class="sxs-lookup"><span data-stu-id="ae148-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="ae148-104">Службы Reliable Actor — это платформа приложения Service Fabric, основании hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) шаблон.</span><span class="sxs-lookup"><span data-stu-id="ae148-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="ae148-105">Hello надежного субъекты API предоставляет модель для программирования с одним потоком лежит hello масштабируемость и надежность гарантий, предоставляемых Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="ae148-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="ae148-106">Что представляют собой субъекты?</span><span class="sxs-lookup"><span data-stu-id="ae148-106">What are Actors?</span></span>
<span data-ttu-id="ae148-107">Субъект — это изолированная, независимая единица вычислений и состояния с однопоточным выполнением.</span><span class="sxs-lookup"><span data-stu-id="ae148-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="ae148-108">Hello [шаблон субъекта](https://en.wikipedia.org/wiki/Actor_model) модель вычислений для параллельной или распределенных систем, в которой большое количество эти субъекты могут выполнять одновременно и независимо друг от друга.</span><span class="sxs-lookup"><span data-stu-id="ae148-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="ae148-109">Субъекты могут взаимодействовать друг с другом и создавать новые субъекты.</span><span class="sxs-lookup"><span data-stu-id="ae148-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="ae148-110">Когда toouse службы Reliable Actor</span><span class="sxs-lookup"><span data-stu-id="ae148-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="ae148-111">Служба структуры службы Reliable Actor представляет собой реализацию hello субъекта конструктивного шаблона.</span><span class="sxs-lookup"><span data-stu-id="ae148-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="ae148-112">Как и любой шаблон разработки программного обеспечения, решение hello ли toouse шаблону выполняется с учетом ли программного обеспечения проектирования проблема помещается шаблон hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="ae148-113">Несмотря на то, что шаблон разработки hello субъекта может быть хорошим соответствия tooa количество проблем распределенных систем и сценариев, тщательного рассмотрения этого ограничения hello шаблон hello и реализации framework hello, его необходимо сделать.</span><span class="sxs-lookup"><span data-stu-id="ae148-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="ae148-114">Как общие рекомендации рекомендуется использовать шаблон toomodel hello субъекта вашей проблемы или сценарии если.</span><span class="sxs-lookup"><span data-stu-id="ae148-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="ae148-115">Проблемное пространство включает множество (тысячи и больше) небольших независимых и изолированных единиц состояния и логики.</span><span class="sxs-lookup"><span data-stu-id="ae148-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="ae148-116">Вы хотите toowork с одним потоком объектами, не требующие значительных взаимодействия с внешними компонентами, включая запросы состояния между несколькими субъектами.</span><span class="sxs-lookup"><span data-stu-id="ae148-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="ae148-117">Экземпляры субъекта не должны блокировать вызывающие объекты с непредсказуемыми задержками, выполняя операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="ae148-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="ae148-118">Субъекты в Service Fabric</span><span class="sxs-lookup"><span data-stu-id="ae148-118">Actors in Service Fabric</span></span>
<span data-ttu-id="ae148-119">В Service Fabric субъекты реализуются в framework службы Reliable Actor hello: построены на основе субъекта шаблон на основе исполняющую среду [надежного служб Service Fabric](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="ae148-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="ae148-120">Каждая написанный вами субъект Reliable Actor фактически представляет собой секционированную надежную службу Reliable Service с отслеживанием состояния.</span><span class="sxs-lookup"><span data-stu-id="ae148-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="ae148-121">Каждый субъект определяется как экземпляр типа субъекта, идентичные toohello как объект .NET является экземпляром типа .NET.</span><span class="sxs-lookup"><span data-stu-id="ae148-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="ae148-122">Например может быть тип субъекта, который реализует функциональность hello калькулятора, и может быть много агентам этого типа, распределенных в различных узлах в кластере.</span><span class="sxs-lookup"><span data-stu-id="ae148-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="ae148-123">У каждого такого субъекта есть уникальный идентификатор.</span><span class="sxs-lookup"><span data-stu-id="ae148-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="ae148-124">Срок действия субъекта</span><span class="sxs-lookup"><span data-stu-id="ae148-124">Actor Lifetime</span></span>
<span data-ttu-id="ae148-125">Субъекты Service Fabric являются виртуальными, это означает, что их время жизни не равноценных tootheir в памяти представление.</span><span class="sxs-lookup"><span data-stu-id="ae148-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="ae148-126">В результате они не обязательно toobe явно создается или уничтожается.</span><span class="sxs-lookup"><span data-stu-id="ae148-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="ae148-127">Среда выполнения службы Reliable Actor Hello автоматически активирует hello субъекта первый раз, он получает запрос для этого идентификатора субъекта.</span><span class="sxs-lookup"><span data-stu-id="ae148-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="ae148-128">Если субъект не используется в течение заданного времени, среда выполнения службы Reliable Actor hello мусора собирает hello объекта в памяти.</span><span class="sxs-lookup"><span data-stu-id="ae148-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="ae148-129">Он будет также поддерживать знаний существования hello субъекта реально toobe повторно активировать.</span><span class="sxs-lookup"><span data-stu-id="ae148-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="ae148-130">Дополнительные сведения см. в статье [Жизненный цикл субъектов и сбор мусора](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="ae148-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="ae148-131">Эта абстракция времени существования виртуальной субъекта несет некоторыми оговорками в результате hello виртуального субъекта модели, и на самом деле hello реализацию службы Reliable Actor иногда отличается от этой модели.</span><span class="sxs-lookup"><span data-stu-id="ae148-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="ae148-132">Субъект активируется автоматически (в результате чего субъект toobe объект создан) hello первый раз, сообщение отправляется ИД tooits субъекта.</span><span class="sxs-lookup"><span data-stu-id="ae148-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="ae148-133">Через некоторое время hello объекта субъекта является сбора мусора.</span><span class="sxs-lookup"><span data-stu-id="ae148-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="ae148-134">В hello будущее, еще раз, с помощью идентификатора субъекта hello вызывает новый субъект toobe объект создан.</span><span class="sxs-lookup"><span data-stu-id="ae148-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="ae148-135">Состояния субъекта превышает время существования hello объекта, сохраненное в диспетчер состояния hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="ae148-136">Вызов любого метода субъекта с идентификатором субъекта активирует этот субъект.</span><span class="sxs-lookup"><span data-stu-id="ae148-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="ae148-137">По этой причине типы субъект имеет их конструктора, неявно вызывается средой выполнения hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="ae148-138">Таким образом клиентскому коду невозможно передать конструктор типа для параметров toohello субъекта, несмотря на то, что параметры могут передаваться конструктор toohello субъекта по самой службы hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="ae148-139">Hello получается, что субъекты можно составить в состоянии частично инициализирована hello момент времени, когда другие методы вызываются, если субъект hello требует инициализации параметров из клиента hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="ae148-140">Нет точки одну запись для активации hello субъект из клиента hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="ae148-141">Несмотря на то, что службы Reliable Actor неявно создают объекты субъектов. у вас есть tooexplicitly возможность hello удалить субъект и его состояние.</span><span class="sxs-lookup"><span data-stu-id="ae148-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="ae148-142">Распространение и отработка отказа</span><span class="sxs-lookup"><span data-stu-id="ae148-142">Distribution and failover</span></span>
<span data-ttu-id="ae148-143">распределяет tooprovide масштабируемость и надежность, Service Fabric субъекты везде hello кластера и автоматически переносит их с toohealthy Неисправные узлы из них при необходимости.</span><span class="sxs-lookup"><span data-stu-id="ae148-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="ae148-144">Это абстрактное представление [секционированной службы Reliable Service с отслеживанием состояния](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="ae148-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="ae148-145">Распространения, масштабируемость, надежность и автоматической отработки отказа предоставляются посредством hello факт субъекты выполняются внутри надежных служб с отслеживанием состояния вызывается hello *службу субъектов*.</span><span class="sxs-lookup"><span data-stu-id="ae148-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="ae148-146">Субъекты распределяются по секциям hello hello службу субъектов и секциями распределяются между узлами кластера Service Fabric hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="ae148-147">Каждая секция службы содержит набор субъектов.</span><span class="sxs-lookup"><span data-stu-id="ae148-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="ae148-148">Service Fabric управляет распределение и отработка отказа hello службы секций.</span><span class="sxs-lookup"><span data-stu-id="ae148-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="ae148-149">Например службу субъектов девять разделов развернуто toothree узлов с помощью размещения секции субъекта по умолчанию hello будет распространена таким:</span><span class="sxs-lookup"><span data-stu-id="ae148-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Распространение субъектов Reliable Actors][2]

<span data-ttu-id="ae148-151">Hello субъекта Framework управляет секции схему и ключ параметров диапазона для вас.</span><span class="sxs-lookup"><span data-stu-id="ae148-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="ae148-152">Это упрощает работу, но требует внимания к следующим моментам:</span><span class="sxs-lookup"><span data-stu-id="ae148-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="ae148-153">Надежные службы позволяет toochoose схему секционирования диапазона ключей (при использовании схему секционирования диапазона) и число секций.</span><span class="sxs-lookup"><span data-stu-id="ae148-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="ae148-154">Службы Reliable Actor схему секционирования диапазона ограниченных toohello (hello универсальный Int64 схемы) и требует использовать полный набор ключей hello Int64.</span><span class="sxs-lookup"><span data-stu-id="ae148-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="ae148-155">По умолчанию субъекты равномерно распределяются между секциями в случайном порядке.</span><span class="sxs-lookup"><span data-stu-id="ae148-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="ae148-156">Поскольку субъекты размещаются случайным образом, для выполняемых ими операций, включая сериализацию и десериализацию данных по вызовам методов, задержкам и нагрузке, всегда будет требоваться подключение к сети.</span><span class="sxs-lookup"><span data-stu-id="ae148-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="ae148-157">В сложных сценариях это возможных toocontrol субъекта секции размещения с помощью субъекта Int64 идентификаторы, сопоставление секций toospecific.</span><span class="sxs-lookup"><span data-stu-id="ae148-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="ae148-158">однако это может привести к неравномерному распределению субъектов между секциями.</span><span class="sxs-lookup"><span data-stu-id="ae148-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="ae148-159">Дополнительные сведения о как секционируются служб субъекта ссылаться слишком[секционирование основные понятия для субъектов](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="ae148-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="ae148-160">Обмен данными с субъектами</span><span class="sxs-lookup"><span data-stu-id="ae148-160">Actor communication</span></span>
<span data-ttu-id="ae148-161">Взаимодействия субъекта определяются в интерфейсе, который совместно используется hello субъект, который реализует интерфейс hello и hello клиента, который получает учетную запись-посредник субъекта tooan через hello тот же интерфейс.</span><span class="sxs-lookup"><span data-stu-id="ae148-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="ae148-162">Поскольку этот интерфейс используется tooinvoke субъекта методы асинхронно, каждый метод в интерфейсе hello должен быть возвращающих задачи.</span><span class="sxs-lookup"><span data-stu-id="ae148-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="ae148-163">Вызовы методов и их ответы в конечном счете приводят сетевые запросы через hello кластера, поэтому hello аргументы и типы результата hello hello задач, что возвращают должен быть сериализуем методом hello платформы.</span><span class="sxs-lookup"><span data-stu-id="ae148-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="ae148-164">В частности, они должны быть [сериализуемыми по контракту данных](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="ae148-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="ae148-165">Hello субъекта прокси-сервера</span><span class="sxs-lookup"><span data-stu-id="ae148-165">hello actor proxy</span></span>
<span data-ttu-id="ae148-166">API клиента службы Reliable Actor Hello обеспечивает обмен данными между экземпляром субъекта и клиент субъекта.</span><span class="sxs-lookup"><span data-stu-id="ae148-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="ae148-167">toocommunicate с субъектом, клиент создает субъект прокси-объект, реализующий интерфейс субъекта hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="ae148-168">Hello клиент взаимодействует с субъекта hello путем вызова методов применительно к hello прокси-объект.</span><span class="sxs-lookup"><span data-stu-id="ae148-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="ae148-169">Hello субъекта прокси-сервер может использоваться для связи клиента для субъекта и субъекта для субъекта.</span><span class="sxs-lookup"><span data-stu-id="ae148-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="ae148-170">Обратите внимание, что hello два блока данных используется toocreate hello субъекта прокси-объект: hello идентификатор субъекта и имя приложения hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="ae148-171">Идентификатор субъекта Hello однозначно определяет субъект hello, хотя имя приложения hello идентифицирует hello [приложения Service Fabric](service-fabric-reliable-actors-platform.md#application-model) развертывания hello субъекта.</span><span class="sxs-lookup"><span data-stu-id="ae148-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="ae148-172">Hello `ActorProxy`(C#) или `ActorProxyBase`класс (Java) на стороне клиента hello выполняет hello необходимые разрешения toolocate hello субъекта по Идентификатору и откройте канал связи с ним.</span><span class="sxs-lookup"><span data-stu-id="ae148-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="ae148-173">Она также повторяет toolocate hello субъекта в случаях hello сбоев связи и переход на другой ресурс.</span><span class="sxs-lookup"><span data-stu-id="ae148-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="ae148-174">В результате доставки сообщений имеет следующие характеристики hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="ae148-175">Доставка сообщений не гарантируется.</span><span class="sxs-lookup"><span data-stu-id="ae148-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="ae148-176">Субъекты может получить дублирующие сообщения из hello того же клиента.</span><span class="sxs-lookup"><span data-stu-id="ae148-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="ae148-177">Параллелизм</span><span class="sxs-lookup"><span data-stu-id="ae148-177">Concurrency</span></span>
<span data-ttu-id="ae148-178">Среда выполнения службы Reliable Actor Hello предоставляет модели простого доступа на основе включить доступ к методам субъекта.</span><span class="sxs-lookup"><span data-stu-id="ae148-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="ae148-179">Это означает, что в конкретный момент времени в коде объекта субъекта может быть активен только один поток.</span><span class="sxs-lookup"><span data-stu-id="ae148-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="ae148-180">Поочередный доступ значительно упрощает параллельные системы, поскольку снимает необходимость в механизмах синхронизации для доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="ae148-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="ae148-181">Это также означает, что системы должно быть рассчитано на специальные рассуждения о природе однопоточного доступа hello каждого экземпляра субъекта.</span><span class="sxs-lookup"><span data-stu-id="ae148-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="ae148-182">Экземпляр одного субъекта не может обрабатывать больше одного запроса за раз.</span><span class="sxs-lookup"><span data-stu-id="ae148-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="ae148-183">Экземпляр субъекта может привести к узким местом пропускной способности, если ожидаемый toohandle параллельных запросов.</span><span class="sxs-lookup"><span data-stu-id="ae148-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="ae148-184">Субъекты может произойти взаимоблокировка друг от друга, если между двумя субъектами при внешний запрос tooone субъектов hello одновременно циклические запрос.</span><span class="sxs-lookup"><span data-stu-id="ae148-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="ae148-185">Hello субъекта среда выполнения будет автоматически времени ожидания на субъекта вызывает и вызывать исключение toohello вызывающего объекта toointerrupt взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="ae148-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Обмен данными между субъектами Reliable Actors][3]

#### <a name="turn-based-access"></a><span data-ttu-id="ae148-187">Поочередный доступ</span><span class="sxs-lookup"><span data-stu-id="ae148-187">Turn-based access</span></span>
<span data-ttu-id="ae148-188">Полный цикл состоит из hello завершится выполнение метода субъекта в запросе tooa ответа от других сторон или клиентов или hello завершить выполнение [таймера и напоминание](service-fabric-reliable-actors-timers-reminders.md) обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="ae148-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="ae148-189">Даже если эти методы и обратные вызовы являются асинхронными, среда выполнения субъекты hello не чередовать их.</span><span class="sxs-lookup"><span data-stu-id="ae148-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="ae148-190">Для смены очереди предыдущее действие должно быть завершено полностью.</span><span class="sxs-lookup"><span data-stu-id="ae148-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="ae148-191">Другими словами субъект метод или таймера и напоминание обратный вызов, который в данный момент должен быть полностью завершена до нового вызова метода tooa или обратный вызов может.</span><span class="sxs-lookup"><span data-stu-id="ae148-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="ae148-192">Метод или обратный вызов считается toohave по завершении выполнения hello вернул из метода hello или завершения обратного вызова и hello задачи, возвращаемой методом hello или обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="ae148-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="ae148-193">Следует подчеркнуть, что пошаговый параллелизм касается разных методов, таймеров и обратных вызовов.</span><span class="sxs-lookup"><span data-stu-id="ae148-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="ae148-194">Среда выполнения субъекты Hello обеспечивает основанных параллелизма, получение блокировки субъекта в начале оборота hello и освобождении блокировки hello в конце hello hello отключить.</span><span class="sxs-lookup"><span data-stu-id="ae148-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="ae148-195">Таким образом, поочередный параллелизм обеспечивается на уровне отдельного субъекта, а не для всех субъектов сразу.</span><span class="sxs-lookup"><span data-stu-id="ae148-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="ae148-196">Разные субъекты могут одновременно и независимо выполнять методы субъектов и обратные вызовы по таймеру или напоминанию.</span><span class="sxs-lookup"><span data-stu-id="ae148-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="ae148-197">Привет, следующий пример иллюстрирует hello выше основные понятия.</span><span class="sxs-lookup"><span data-stu-id="ae148-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="ae148-198">Рассмотрим тип субъекта, который реализует два асинхронных метода (назовем их *Method1* и *Method2*), таймер и напоминание.</span><span class="sxs-lookup"><span data-stu-id="ae148-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="ae148-199">Hello приведенной ниже схеме показан пример временной шкалы для выполнения hello этих методов и обратные вызовы от имени с двух сторон (*ActorId1* и *ActorId2*), принадлежат toothis типа субъекта.</span><span class="sxs-lookup"><span data-stu-id="ae148-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Доступ и пошаговый параллелизм в среде выполнения Reliable Actors][1]

<span data-ttu-id="ae148-201">В схеме используются следующие обозначения:</span><span class="sxs-lookup"><span data-stu-id="ae148-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="ae148-202">Каждой вертикальной линии показан hello логический поток выполнения метода или обратный вызов от имени определенного субъекта.</span><span class="sxs-lookup"><span data-stu-id="ae148-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="ae148-203">Hello на каждой вертикальной линии событиями в хронологическом порядке с новой событиями, происходящими ниже старые.</span><span class="sxs-lookup"><span data-stu-id="ae148-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="ae148-204">Различные цвета используются для соответствующих субъектов toodifferent временных шкал.</span><span class="sxs-lookup"><span data-stu-id="ae148-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="ae148-205">Выделение — интервал используется tooindicate hello, для которых hello блокировки субъекта удерживается от имени метода или обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="ae148-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="ae148-206">Некоторые важные моменты tooconsider:</span><span class="sxs-lookup"><span data-stu-id="ae148-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="ae148-207">Хотя *метод1* выполняется от имени *ActorId2* в запросе ответа tooclient *xyz789*, другой запрос клиента (*abc123*) поступает, также требуется *метод1* toobe исполнен *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="ae148-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="ae148-208">Однако hello второго исполнения *метод1* не начинается до завершения выполнения предыдущего hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="ae148-209">Аналогичным образом, зарегистрированных напоминание *ActorId2* активируется при *метод1* выполняется в запросе ответа tooclient *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="ae148-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="ae148-210">Hello напоминание обратный вызов выполняется только после выполнения обоих *метод1* являются полными.</span><span class="sxs-lookup"><span data-stu-id="ae148-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="ae148-211">— Все это из-за параллелизма на основе tooturn применяется принудительно для *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="ae148-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="ae148-212">Аналогичным образом, основанных параллелизма также применяется для *ActorId1*, как показано выполнение hello *метод1*, *метод2*, и hello таймер обратного вызова от имени *ActorId1* происходит последовательно.</span><span class="sxs-lookup"><span data-stu-id="ae148-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="ae148-213">Выполнение метода *Method1* от имени субъекта *ActorId1* перекрывается с выполнением того же метода от имени субъекта *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="ae148-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="ae148-214">Это связано с тем, что пошаговый параллелизм применяется только для одного субъекта, а не для всех субъектов сразу.</span><span class="sxs-lookup"><span data-stu-id="ae148-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="ae148-215">В некоторых выполнений метод/обратного вызова hello hello `Task`(C#) или `CompletableFuture`(Java) возвращенных hello метод или обратный вызов завершения после возврата метода hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="ae148-216">В некоторых других hello асинхронной операции уже завершено моменту hello hello метод или функция обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="ae148-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="ae148-217">В обоих случаях блокировки субъекта hello освобождается только после того, метод или функция обратного вызова обоих hello и завершения асинхронной операции hello.</span><span class="sxs-lookup"><span data-stu-id="ae148-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="ae148-218">Повторный вход</span><span class="sxs-lookup"><span data-stu-id="ae148-218">Reentrancy</span></span>
<span data-ttu-id="ae148-219">Среда выполнения субъекты Hello позволяет повторного входа по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="ae148-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="ae148-220">Это означает, что если метод субъекта *субъекта A* вызывает метод *B субъекта*, который в свою очередь вызывает другой метод в *субъекта A*, допустимость toorun метод.</span><span class="sxs-lookup"><span data-stu-id="ae148-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="ae148-221">Это, поскольку он является частью hello того же контекста логические цепочки вызовов.</span><span class="sxs-lookup"><span data-stu-id="ae148-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="ae148-222">Все вызовы таймера и напоминание начинаются с Привет нового логического контекста вызова.</span><span class="sxs-lookup"><span data-stu-id="ae148-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="ae148-223">В разделе hello [повторный вход службы Reliable Actor](service-fabric-reliable-actors-reentrancy.md) для получения дополнительных сведений.</span><span class="sxs-lookup"><span data-stu-id="ae148-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="ae148-224">Область гарантий параллелизма</span><span class="sxs-lookup"><span data-stu-id="ae148-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="ae148-225">Среда выполнения субъекты Hello предоставляет следующие гарантии параллелизма в ситуациях, где он управляет hello вызова этих методов.</span><span class="sxs-lookup"><span data-stu-id="ae148-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="ae148-226">Например для hello вызовов методов, выполненные в запросе клиента tooa ответа, а также для обратные вызовы таймера и напоминание предоставляет следующие гарантии.</span><span class="sxs-lookup"><span data-stu-id="ae148-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="ae148-227">Тем не менее если код субъекта hello напрямую вызывает эти методы за пределами hello механизмы, предоставляемые средой выполнения субъекты hello, hello среды выполнения не предоставляет никаких гарантий параллелизма.</span><span class="sxs-lookup"><span data-stu-id="ae148-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="ae148-228">Например если вызывается метод hello в контексте какой-либо задачи, который не связан с задачей hello, возвращаемые методами субъекта hello hello, hello среды выполнения не может предоставить гарантии параллелизма.</span><span class="sxs-lookup"><span data-stu-id="ae148-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="ae148-229">Если hello метод вызывается из потока, этот субъект hello создает сам по себе, а затем hello среда выполнения также не может предоставить гарантии параллелизма.</span><span class="sxs-lookup"><span data-stu-id="ae148-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="ae148-230">Таким образом, tooperform фоновых операций, субъектами следует использовать [таймеров субъекта и субъект напоминания](service-fabric-reliable-actors-timers-reminders.md) , учитывают основанных параллелизма.</span><span class="sxs-lookup"><span data-stu-id="ae148-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="ae148-231">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="ae148-231">Next steps</span></span>
* <span data-ttu-id="ae148-232">Приступите к работе, создав свою первую службу Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="ae148-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="ae148-233">Приступая к работе с Reliable Actors с помощью .NET</span><span class="sxs-lookup"><span data-stu-id="ae148-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="ae148-234">Приступая к работе с Reliable Actors с помощью Java</span><span class="sxs-lookup"><span data-stu-id="ae148-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
