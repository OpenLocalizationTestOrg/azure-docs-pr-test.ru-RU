---
title: "aaaOverview жизненного цикла hello служб Azure Service Fabric надежного | Документы Microsoft"
description: "Дополнительные сведения о событиях жизненного цикла различных hello в Service Fabric надежного обмена"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 0d75ed5ee7cda85ac9af6a02e160727277804a2b
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a>Жизненный цикл Reliable Services
> [!div class="op_single_selector"]
> * [C# в Windows](service-fabric-reliable-services-lifecycle.md)
> * [Java в Linux](service-fabric-reliable-services-lifecycle-java.md)
>
>

Если говорить о жизненном цикле hello надежных служб основы hello hello жизненного цикла являются наиболее важных hello. а именно:

- во время запуска:
  - создаются службы;
  - Они имеют возможность tooconstruct и возвращают ноль или несколько прослушивателей
  - Любые возвращенные прослушиватели должны быть открыты соединение со службой hello
  - Hello службы RunAsync, вызывается метод, позволяя hello служба toodo долго выполняющиеся или фоновых рабочих
- во время завершения работы:
  - Hello отмены маркера переданный tooRunAsync отменяется и закрываются прослушиватели hello
  - После ее завершения, уничтожении сам объект службы hello

Подробно о вокруг hello точный порядок этих событий. В частности hello порядок событий может немного измениться в зависимости от того, является ли hello надежной службы Stateless или с отслеживанием состояния. Кроме того для служб с отслеживанием состояния, у нас есть toodeal со сценарием основной swap hello. Во время этой последовательности hello роль первичной репликой переносятся tooanother (или возобновляет) без отключения службы hello. Наконец у нас есть toothink об условиях ошибок и сбоев.

## <a name="stateless-service-startup"></a>Запуск службы без отслеживания состояния
жизненный цикл службы без отслеживания состояния Hello выполняется очень просто. Ниже приведен порядок событий hello.

1. Hello службы создается
2. Затем одновременно происходят две вещи:
    - Вызывается метод `StatelessService.CreateServiceInstanceListeners()` и открываются все возвращаемые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.
    - Здравствуйте, службы `StatelessService.RunAsync()` вызывается метод
3. Если он имеется, hello службы `StatelessService.OnOpenAsync()` вызывается метод. Это редко используемое переопределение, но оно доступно.

Это важные toonote, это не порядок toocreate вызовы hello и откройте hello прослушивателей и RunAsync. Перед запуском RunAsync, может открыть Hello прослушиватели. Аналогичным образом RunAsync может оказаться вызывается перед прослушивания связи hello открыты или даже были построены. Если необходима синхронизация, она останется при реализации toohello упражнении. Ниже приведены распространенные решения.

  - Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи. Для служб без отслеживания состояния, работа которых обычно может быть выполнена в других расположениях, например: 
    - в конструкторе службы hello
    - во время hello `CreateServiceInstanceListeners()` вызова
    - в составе конструкции hello сам прослушиватель hello
  - Иногда hello кода в RunAsync не требуется toostart пока открыты hello прослушиватели. В этом случае необходима дополнительная координация. Общие решением проблемы является некоторые флаг за hello прослушивателей, указывающее, когда они будут завершены. Затем этот флаг установлен в RunAsync перед продолжением работы tooactual.

## <a name="stateless-service-shutdown"></a>Завершение работы службы без отслеживания состояния
При выключении службы без отслеживания состояния, Привет одному шаблону, просто в обратном направлении:

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.
    - токен отмены Hello передано слишком`RunAsync()` отменяется. Проверка hello токен отмены `IsCancellationRequested` свойство возвращает значение true и при вызове hello токен `ThrowIfCancellationRequested` вызывает исключение `OperationCanceledException`.
2. Один раз `CloseAsync()` завершения на каждый прослушиватель и `RunAsync()` также завершается hello службы `StatelessService.OnCloseAsync()` метод вызывается, если он имеется. Это часто toooverride `StatelessService.OnCloseAsync()`.
3. После `StatelessService.OnCloseAsync()` завершения уничтожении hello объекта службы

## <a name="stateful-service-startup"></a>Запуск службы с отслеживанием состояния
С отслеживанием состояния службы имеют аналогичные службы toostateless шаблон, с несколькими изменениями. При запуске службы с отслеживанием состояния, hello порядок событий выглядит следующим образом:

1. Hello службы создается
2. Вызывается метод `StatefulServiceBase.OnOpenAsync()`. Uncommonly переопределяется в службе hello.
3. Hello выполняются следующие действия параллельно
    - Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()`. 
      - Если служба hello основной открываются все возвращенные прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.
      - Если служба hello получателя, только эти прослушиватели помечен как `ListenOnSecondary = true` открыты. Открытые прослушиватели для вторичных реплик используются реже.
    - Здравствуйте, hello службы в настоящее время является основной, hello службы `StatefulServiceBase.RunAsync()` вызывается метод
4. Как только все hello прослушиватель реплики `OpenAsync()` вызывает завершение и `RunAsync()` вызове `StatefulServiceBase.OnChangeRoleAsync()` вызывается. Uncommonly переопределяется в службе hello.

Аналогично службы toostateless имеется не координацию между hello порядок, в какие hello прослушиватели создается и открывается и при вызове RunAsync. Если требуется координация hello решений являются гораздо hello же. Есть один дополнительный случай: предположим, что вызовы hello, поступающих в прослушивания связи hello требуют сведения сохраняются внутри некоторых [надежного коллекции](service-fabric-reliable-services-reliable-collections.md). Поскольку hello прослушивания связи может открыть перед hello надежного коллекции — для чтения или для чтения, и перед RunAsync удалось запустить, некоторые дополнительные координации не требуется. решение простейшим и наиболее распространенным Hello предназначен для hello связи прослушиватели tooreturn код ошибки, hello запрос клиента использует tooknow tooretry hello.

## <a name="stateful-service-shutdown"></a>Завершение работы службы с отслеживанием состояния
Аналогичным образом tooStateless службы, событий жизненного цикла hello во время завершения работы hello же во время запуска, но отменены. При завершении работы службы с отслеживанием состояния hello происходят следующие события.

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.
    - токен отмены Hello передано слишком`RunAsync()` отменяется. Проверка hello токен отмены `IsCancellationRequested` свойство возвращает значение true и при вызове hello токен `ThrowIfCancellationRequested` вызывает исключение `OperationCanceledException`.
2. Один раз `CloseAsync()` завершения на каждый прослушиватель и `RunAsync()` также завершается hello службы `StatefulServiceBase.OnChangeRoleAsync()` вызывается. (Это uncommonly переопределяется в службе hello.)
    - Ожидание RunAsync toocomplete необходим только в случае основной этой реплики службы.
3. Здравствуйте, один раз `StatefulServiceBase.OnChangeRoleAsync()` метод завершения hello `StatefulServiceBase.OnCloseAsync()` вызывается метод. Это редко используемое переопределение, но оно доступно.
3. После `StatefulServiceBase.OnCloseAsync()` завершения уничтожении hello объекта службы.

## <a name="stateful-service-primary-swaps"></a>Переключения первичной реплики службы с отслеживанием состояния
Во время выполнения службы с отслеживанием состояния, hello первичные реплики, с отслеживанием состояния службы достаточно их открытии прослушивания связи и их RunAsync метод с именем. Вторичные реплики создаются, но не видят последующие вызовы. Однако под управлением службы с отслеживанием состояния реплику, которая в настоящее время является основной hello можно изменить. Что это означает точки зрения hello события жизненного цикла, которые могут видеть реплики? Hello поведение hello реплики с отслеживанием состояния видит зависит от реплики hello пониженных или повышается во время замены hello.

### <a name="for-hello-primary-being-demoted"></a>Для первичной пониженных hello
Service Fabric требуется toostop этой реплики, обработки сообщений и выйти из любой фоновой работы выполняемых действий. В результате этого шага выглядит примерно toowhen hello службы завершает работу. Единственным отличием является, hello службы не уничтожены или закрыты, так как он остается в качестве получателя. следующие API-интерфейсы Hello называются:

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.
    - токен отмены Hello передано слишком`RunAsync()` отменяется. Проверка hello токен отмены `IsCancellationRequested` свойство возвращает значение true и при вызове hello токен `ThrowIfCancellationRequested` вызывает исключение `OperationCanceledException`.
2. Один раз `CloseAsync()` завершения на каждый прослушиватель и `RunAsync()` также завершается hello службы `StatefulServiceBase.OnChangeRoleAsync()` вызывается. Uncommonly переопределяется в службе hello.

### <a name="for-hello-secondary-being-promoted"></a>Для получателей, роль которого повышается hello
Аналогичным образом Service Fabric должен toostart этой реплики, ожидающую сообщений hello сети и запустить все фоновой задачи, которые его интересуют. Таким образом, оно выглядит процесс создания аналогичную службу hello toowhen, за исключением того, эта реплика hello сам уже существует. следующие API-интерфейсы Hello называются:

1. В параллельном режиме:
    - Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()` и открываются все возвращаемые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.
    - Здравствуйте, службы `StatefulServiceBase.RunAsync()` вызывается метод
2. Как только все hello прослушиватель реплики `OpenAsync()` вызывает завершение и `RunAsync()` был вызван, `StatefulServiceBase.OnChangeRoleAsync()` вызывается. Uncommonly переопределяется в службе hello.

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a>Распространенные проблемы во время завершения работы службы с отслеживанием состояния и понижения уровня первичной реплики
Изменения Service Fabric hello основным для службы с отслеживанием состояния по ряду причин. Hello чаще всего являются [кластера Балансировка](service-fabric-cluster-resource-manager-balancing.md) и [обновление приложения](service-fabric-application-upgrade.md). Во время таких операций (а также во время завершения работы нормальную работу службы, как вы увидите, если служба hello была удалена), очень важно, что hello относительно службы hello `CancellationToken`. Службы, которые не обрабатывают отмену аккуратно, могут вызывать несколько проблем. В частности эти операции будут работать медленно, поскольку Service Fabric ожидает toostop служб hello надлежащим образом. В конечном счете, это может привести toofailed обновления, время ожидания и отката. Токен отмены hello toohonor сбоя могут возникать несбалансированных кластеров так, как получить горячей узлов, но hello службы не может быть балансируется повторное присоединение с момента занимает слишком много времени toomove их в другом месте. 

Поскольку hello служб с отслеживанием состояния, это скорее всего, что они используют hello [надежного коллекции](service-fabric-reliable-services-reliable-collections.md). В Service Fabric после понижения роли основного, одним из hello первое, что происходит является отменяется, состояние базового toohello доступ для записи. Это порождает tooa второй набор проблем, которые могут повлиять на жизненный цикл службы hello. Возвращаемое исключения на основе времени hello и перемещается ли реплика hello коллекций Hello или завершение работы. Эти исключения должны обрабатываться правильно. Исключения, порождаемые Service Fabric, делятся на постоянные [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) и временные [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet). Постоянное исключения следует войти и исключение во время hello временные исключения может быть повторена основании определенную логику повторных попыток.

Обработка исключений hello, полученные от использования hello `ReliableCollections` в сочетании с события жизненного цикла службы является важной частью тестировании и проверке надежной службы. Здравствуйте, рекомендация — всегда toorun службы под нагрузкой во время выполнения обновлений и [хаоса тестирование](service-fabric-controlled-chaos.md) перед развертыванием tooproduction когда-либо. Эти простые действия помогут обеспечить правильную реализацию службы и обработку событий жизненного цикла.


## <a name="notes-on-service-lifecycle"></a>Примечания о жизненном цикле службы
  - Оба hello `RunAsync()` метод и hello `CreateServiceReplicaListeners/CreateServiceInstanceListeners` вызовы являются необязательными. В службе может использоваться один из их, оба или ни одного. Например, если служба hello выполняет свою работу в вызовах toouser ответа, нет необходимости для него tooimplement `RunAsync()`. Необходимы только hello прослушивания связи и их кода. Аналогичным образом Создание и возвращение прослушивания связи является необязательной, поскольку служба hello может иметь только фоновой работы toodo и поэтому достаточно tooimplement`RunAsync()`
  - Он является допустимым для toocomplete службы `RunAsync()` успешно и вернуть из нее. Завершение не является состоянием сбоя. Завершение работы `RunAsync()` указывает на завершение hello фоновой работы службы hello. Для надежных служб с отслеживанием состояния `RunAsync()` вызывается снова, если реплика hello были понижены из первичного tooSecondary и затем повышается tooPrimary назад.
  - Если служба выполняет выход из `RunAsync()`, порождая какое-либо непредвиденное исключение, это означает сбой. Hello объекта службы завершает работу, а ошибка работоспособности.
  - Пока нет ограничения времени после возвращения из этих методов, вы сразу же потеряют hello возможности toowrite tooReliable коллекций и поэтому не может завершить какой-либо реальной работы. Рекомендуется восстановить как можно быстрее при получении запроса отмены hello. Если служба не отвечает toothese API-вызовов за приемлемое время Service Fabric может принудительно прекратить использование службы. Обычно это происходит только во время обновления приложения или при удалении службы. По умолчанию время ожидания составляет 15 минут.
  - Сбои в hello `OnCloseAsync()` результирующий путь в `OnAbort()` называемый, это возможность последнего вероятность усилия для hello службы tooclean вверх и освободить все ресурсы, которые они уже запросили.

## <a name="next-steps"></a>Дальнейшие действия
- [Введение tooReliable служб](service-fabric-reliable-services-introduction.md)
- [Краткое руководство по надежным службам Reliable Services](service-fabric-reliable-services-quick-start.md)
- [Продвинутое использование надежных служб](service-fabric-reliable-services-advanced-usage.md)
