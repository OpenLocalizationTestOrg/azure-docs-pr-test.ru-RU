---
title: "Общие сведения о жизненном цикле Reliable Services в Azure Service Fabric | Документация Майкрософт"
description: "Сведения о различных событиях жизненного цикла служб Reliable Services в Service Fabric"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 16021ca72a2f10070b6409417ff0d88009591331
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="3483b-103">Жизненный цикл Reliable Services</span><span class="sxs-lookup"><span data-stu-id="3483b-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="3483b-104">C# в Windows</span><span class="sxs-lookup"><span data-stu-id="3483b-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="3483b-105">Java в Linux</span><span class="sxs-lookup"><span data-stu-id="3483b-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="3483b-106">Если речь идет о жизненных циклах служб Reliable Services, наиболее важны основные аспекты,</span><span class="sxs-lookup"><span data-stu-id="3483b-106">When thinking about the lifecycles of Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="3483b-107">а именно:</span><span class="sxs-lookup"><span data-stu-id="3483b-107">In general:</span></span>

- <span data-ttu-id="3483b-108">во время запуска:</span><span class="sxs-lookup"><span data-stu-id="3483b-108">During Startup</span></span>
  - <span data-ttu-id="3483b-109">создаются службы;</span><span class="sxs-lookup"><span data-stu-id="3483b-109">Services are constructed</span></span>
  - <span data-ttu-id="3483b-110">они могут создавать и возвращать ни одного или несколько прослушивателей;</span><span class="sxs-lookup"><span data-stu-id="3483b-110">They have an opportunity to construct and return zero or more listeners</span></span>
  - <span data-ttu-id="3483b-111">все возвращаемые прослушиватели открываются, что разрешает взаимодействие со службой;</span><span class="sxs-lookup"><span data-stu-id="3483b-111">Any returned listeners are opened, allowing communication with the service</span></span>
  - <span data-ttu-id="3483b-112">вызывается метод RunAsync службы, позволяя службе выполнять длительную или фоновую работу;</span><span class="sxs-lookup"><span data-stu-id="3483b-112">The Service's RunAsync method is called, allowing the service to do long running or background work</span></span>
- <span data-ttu-id="3483b-113">во время завершения работы:</span><span class="sxs-lookup"><span data-stu-id="3483b-113">During shutdown</span></span>
  - <span data-ttu-id="3483b-114">маркер отмены, переданный в RunAsync, отменяется, и прослушиватели закрываются;</span><span class="sxs-lookup"><span data-stu-id="3483b-114">The cancellation token passed to RunAsync is canceled, and the listeners are closed</span></span>
  - <span data-ttu-id="3483b-115">после этого уничтожается сам объект службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-115">Once that is complete, the service object itself is destructed</span></span>

<span data-ttu-id="3483b-116">Следует отметить некоторые моменты, связанные с точным порядком этих событий.</span><span class="sxs-lookup"><span data-stu-id="3483b-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="3483b-117">В частности, порядок событий может немного изменяться в зависимости от того, предусматривают ли Reliable Services отслеживание состояния.</span><span class="sxs-lookup"><span data-stu-id="3483b-117">In particular, the order of events may change slightly depending on whether the Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="3483b-118">В случае со службами с отслеживанием состояния приходится иметь дело со сценарием переключения первичной реплики.</span><span class="sxs-lookup"><span data-stu-id="3483b-118">In addition, for stateful services, we have to deal with the Primary swap scenario.</span></span> <span data-ttu-id="3483b-119">Во время этой процедуры первичная роль передается другой реплике (или возвращается) без завершения работы службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="3483b-120">И, наконец, следует учитывать условия ошибок и сбоев.</span><span class="sxs-lookup"><span data-stu-id="3483b-120">Finally, we have to think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="3483b-121">Запуск службы без отслеживания состояния</span><span class="sxs-lookup"><span data-stu-id="3483b-121">Stateless service startup</span></span>
<span data-ttu-id="3483b-122">Жизненный цикл службы без отслеживания состояния достаточно прост.</span><span class="sxs-lookup"><span data-stu-id="3483b-122">The lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="3483b-123">Ниже приведен порядок событий.</span><span class="sxs-lookup"><span data-stu-id="3483b-123">Here's the order of events:</span></span>

1. <span data-ttu-id="3483b-124">Создается служба.</span><span class="sxs-lookup"><span data-stu-id="3483b-124">The Service is constructed</span></span>
2. <span data-ttu-id="3483b-125">Затем одновременно происходят две вещи:</span><span class="sxs-lookup"><span data-stu-id="3483b-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="3483b-126">Вызывается метод `StatelessService.CreateServiceInstanceListeners()` и открываются все возвращаемые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="3483b-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="3483b-127">Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="3483b-128">Вызывается метод `StatelessService.RunAsync()` службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-128">The service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="3483b-129">Вызывается метод `StatelessService.OnOpenAsync()` службы, если он присутствует.</span><span class="sxs-lookup"><span data-stu-id="3483b-129">If present, the service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="3483b-130">Это редко используемое переопределение, но оно доступно.</span><span class="sxs-lookup"><span data-stu-id="3483b-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="3483b-131">Важно отметить, что между вызовами методов для создания и открытия прослушивателей и RunAsync нет упорядоченности.</span><span class="sxs-lookup"><span data-stu-id="3483b-131">It is important to note that there is no ordering between the calls to create and open the listeners and RunAsync.</span></span> <span data-ttu-id="3483b-132">Прослушиватели могут быть открыты перед запуском RunAsync.</span><span class="sxs-lookup"><span data-stu-id="3483b-132">The listeners may open before RunAsync is started.</span></span> <span data-ttu-id="3483b-133">Аналогичным образом метод RunAsync может быть вызван перед открытием или созданием прослушивателей связи.</span><span class="sxs-lookup"><span data-stu-id="3483b-133">Similarly, RunAsync may end up invoked before the communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="3483b-134">Если синхронизация не требуется, она остается в качестве упражнения для разработчика.</span><span class="sxs-lookup"><span data-stu-id="3483b-134">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="3483b-135">Ниже приведены распространенные решения.</span><span class="sxs-lookup"><span data-stu-id="3483b-135">Common solutions:</span></span>

  - <span data-ttu-id="3483b-136">Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи.</span><span class="sxs-lookup"><span data-stu-id="3483b-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="3483b-137">Для служб без отслеживания состояния, работа которых обычно может быть выполнена в других расположениях, например:</span><span class="sxs-lookup"><span data-stu-id="3483b-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="3483b-138">в конструкторе службы;</span><span class="sxs-lookup"><span data-stu-id="3483b-138">in the service's constructor</span></span>
    - <span data-ttu-id="3483b-139">во время вызова `CreateServiceInstanceListeners()`;</span><span class="sxs-lookup"><span data-stu-id="3483b-139">during the `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="3483b-140">при создании самого прослушивателя.</span><span class="sxs-lookup"><span data-stu-id="3483b-140">as a part of the construction of the listener itself</span></span>
  - <span data-ttu-id="3483b-141">Иногда код в RunAsync не запускается, пока прослушиватели открыты.</span><span class="sxs-lookup"><span data-stu-id="3483b-141">Sometimes the code in RunAsync does not want to start until the listeners are open.</span></span> <span data-ttu-id="3483b-142">В этом случае необходима дополнительная координация.</span><span class="sxs-lookup"><span data-stu-id="3483b-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="3483b-143">Общим решением проблемы является использование некоторого флага в прослушивателях, указывающего, когда их работа завершена.</span><span class="sxs-lookup"><span data-stu-id="3483b-143">One common solution is some flag within the listeners indicating when they have completed.</span></span> <span data-ttu-id="3483b-144">Затем этот флаг проверяется в RunAsync, прежде чем будет продолжена фактическая работа.</span><span class="sxs-lookup"><span data-stu-id="3483b-144">This flag is then checked in RunAsync before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="3483b-145">Завершение работы службы без отслеживания состояния</span><span class="sxs-lookup"><span data-stu-id="3483b-145">Stateless service shutdown</span></span>
<span data-ttu-id="3483b-146">При завершении работы службы без отслеживания состояния те же операции выполняются в обратном порядке.</span><span class="sxs-lookup"><span data-stu-id="3483b-146">When shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="3483b-147">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="3483b-147">In parallel</span></span>
    - <span data-ttu-id="3483b-148">Закрываются все открытые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="3483b-148">Any open listeners are Closed.</span></span> <span data-ttu-id="3483b-149">Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="3483b-150">Токен отмены, переданный в `RunAsync()`, отменяется.</span><span class="sxs-lookup"><span data-stu-id="3483b-150">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="3483b-151">В результате проверки свойства `IsCancellationRequested` токена отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="3483b-151">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="3483b-152">Как только `CloseAsync()` завершается для каждого прослушивателя, а также завершается `RunAsync()`, вызывается метод `StatelessService.OnCloseAsync()` службы, если он присутствует.</span><span class="sxs-lookup"><span data-stu-id="3483b-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="3483b-153">Обычно `StatelessService.OnCloseAsync()` не переопределяется.</span><span class="sxs-lookup"><span data-stu-id="3483b-153">It is uncommon to override `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="3483b-154">После выполнения метода `StatelessService.OnCloseAsync()` объект службы уничтожается.</span><span class="sxs-lookup"><span data-stu-id="3483b-154">After `StatelessService.OnCloseAsync()` completes, the service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="3483b-155">Запуск службы с отслеживанием состояния</span><span class="sxs-lookup"><span data-stu-id="3483b-155">Stateful service Startup</span></span>
<span data-ttu-id="3483b-156">Запуск службы с отслеживанием состояния имеет лишь несколько отличий по сравнению со службой без отслеживания состояния.</span><span class="sxs-lookup"><span data-stu-id="3483b-156">Stateful services have a similar pattern to stateless services, with a few changes.</span></span> <span data-ttu-id="3483b-157">При запуске службы с отслеживанием состояния порядок событий выглядит следующим образом.</span><span class="sxs-lookup"><span data-stu-id="3483b-157">When starting up a stateful service, the order of events is as follows:</span></span>

1. <span data-ttu-id="3483b-158">Создается служба.</span><span class="sxs-lookup"><span data-stu-id="3483b-158">The Service is constructed</span></span>
2. <span data-ttu-id="3483b-159">Вызывается метод `StatefulServiceBase.OnOpenAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="3483b-160">Он редко переопределяется в службе.</span><span class="sxs-lookup"><span data-stu-id="3483b-160">This is uncommonly overridden in the service.</span></span>
3. <span data-ttu-id="3483b-161">Ниже приведены действия, которые выполняются параллельно:</span><span class="sxs-lookup"><span data-stu-id="3483b-161">The following things happen in parallel</span></span>
    - <span data-ttu-id="3483b-162">Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="3483b-163">Если служба является первичной репликой, открываются все возвращенные прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="3483b-163">If the service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="3483b-164">Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="3483b-165">Если служба является вторичной репликой, то открываются только прослушиватели, помеченные как `ListenOnSecondary = true`.</span><span class="sxs-lookup"><span data-stu-id="3483b-165">If the service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="3483b-166">Открытые прослушиватели для вторичных реплик используются реже.</span><span class="sxs-lookup"><span data-stu-id="3483b-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="3483b-167">Если служба в настоящий момент является первичной репликой, то вызывается метод `StatefulServiceBase.RunAsync()` службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-167">The if the Service is currently a Primary, the service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="3483b-168">После завершения всех вызовов `OpenAsync()` прослушивателя реплик и вызова `RunAsync()` вызывается метод `StatefulServiceBase.OnChangeRoleAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-168">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="3483b-169">Он редко переопределяется в службе.</span><span class="sxs-lookup"><span data-stu-id="3483b-169">This is uncommonly overridden in the service.</span></span>

<span data-ttu-id="3483b-170">Как и в случае со службами без отслеживания состояния, между порядком, в котором прослушиватели создаются и открываются, а также вызовом RunAsync отсутствует координация.</span><span class="sxs-lookup"><span data-stu-id="3483b-170">Similarly to stateless services, there's no coordination between the order in which the listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="3483b-171">Если требуется координация, то решение будет во многом схожим.</span><span class="sxs-lookup"><span data-stu-id="3483b-171">If you need coordination, the solutions are much the same.</span></span> <span data-ttu-id="3483b-172">Есть лишь одно дополнение. Предположим, что для вызовов, поступающих в прослушиватели связи, требуется наличие сведений в некоторых [надежных коллекциях](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="3483b-172">THere is one additional case: say that the calls arriving at the communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="3483b-173">Так как прослушиватели связи могут быть открыты до того, как надежные коллекции станут доступны для чтения или записи, а также до запуска RunAsync, потребуется дополнительная координация.</span><span class="sxs-lookup"><span data-stu-id="3483b-173">Because the communication listeners could open before the reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="3483b-174">Простейшее и самое распространенное решение для прослушивателей связи — вернуть код ошибки, который клиент использует для повторного запроса.</span><span class="sxs-lookup"><span data-stu-id="3483b-174">The simplest and most common solution is for the communication listeners to return some error code that the client uses to know to retry the request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="3483b-175">Завершение работы службы с отслеживанием состояния</span><span class="sxs-lookup"><span data-stu-id="3483b-175">Stateful service Shutdown</span></span>
<span data-ttu-id="3483b-176">Как и в случае со службами без отслеживания состояния, события жизненного цикла во время завершения работы совпадают с событиями во время запуска, но происходят в обратном порядке.</span><span class="sxs-lookup"><span data-stu-id="3483b-176">Similarly to Stateless services, the lifecycle events during shutdown are the same as during startup, but reversed.</span></span> <span data-ttu-id="3483b-177">При завершении работы службы с отслеживанием состояния происходят следующие события.</span><span class="sxs-lookup"><span data-stu-id="3483b-177">When a stateful service is being shut down, the following events occur:</span></span>

1. <span data-ttu-id="3483b-178">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="3483b-178">In parallel</span></span>
    - <span data-ttu-id="3483b-179">Закрываются все открытые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="3483b-179">Any open listeners are Closed.</span></span> <span data-ttu-id="3483b-180">Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="3483b-181">Токен отмены, переданный в `RunAsync()`, отменяется.</span><span class="sxs-lookup"><span data-stu-id="3483b-181">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="3483b-182">В результате проверки свойства `IsCancellationRequested` токена отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="3483b-182">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="3483b-183">Как только `CloseAsync()` завершается для каждого прослушивателя, а также завершается `RunAsync()`, вызывается `StatefulServiceBase.OnChangeRoleAsync()` службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="3483b-184">(Это редко переопределяется в службе.)</span><span class="sxs-lookup"><span data-stu-id="3483b-184">(This is uncommonly overridden in the service.)</span></span>
    - <span data-ttu-id="3483b-185">Ожидание завершения вызова RunAsync необходимо только в том случае, если реплика службы была первичной.</span><span class="sxs-lookup"><span data-stu-id="3483b-185">Waiting for RunAsync to complete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="3483b-186">После завершения метода `StatefulServiceBase.OnChangeRoleAsync()` вызывается метод `StatefulServiceBase.OnCloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-186">Once the `StatefulServiceBase.OnChangeRoleAsync()` method completes, the `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="3483b-187">Это редко используемое переопределение, но оно доступно.</span><span class="sxs-lookup"><span data-stu-id="3483b-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="3483b-188">После завершения `StatefulServiceBase.OnCloseAsync()` объект службы уничтожается.</span><span class="sxs-lookup"><span data-stu-id="3483b-188">After `StatefulServiceBase.OnCloseAsync()` completes, the service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="3483b-189">Переключения первичной реплики службы с отслеживанием состояния</span><span class="sxs-lookup"><span data-stu-id="3483b-189">Stateful service primary swaps</span></span>
<span data-ttu-id="3483b-190">Во время выполнения службы с отслеживанием состояния только первичные реплики этих служб открывают прослушиватели связи и вызывают метод RunAsync.</span><span class="sxs-lookup"><span data-stu-id="3483b-190">While a stateful service is running, only the Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="3483b-191">Вторичные реплики создаются, но не видят последующие вызовы.</span><span class="sxs-lookup"><span data-stu-id="3483b-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="3483b-192">Пока выполняется служба с отслеживанием состояния, первичная реплика может измениться.</span><span class="sxs-lookup"><span data-stu-id="3483b-192">While a stateful service is running however, which replica is currently the Primary can change.</span></span> <span data-ttu-id="3483b-193">Что это означает с точки зрения событий жизненного цикла, которые может видеть реплика?</span><span class="sxs-lookup"><span data-stu-id="3483b-193">What does this mean in terms of the lifecycle events that a replica can see?</span></span> <span data-ttu-id="3483b-194">Поведение, которое видит реплика с отслеживанием состояния, зависит от того, что происходит во время переключения: понижение или повышение реплики.</span><span class="sxs-lookup"><span data-stu-id="3483b-194">The behavior the stateful replica sees depends on whether it is the replica being demoted or promoted during the swap.</span></span>

### <a name="for-the-primary-being-demoted"></a><span data-ttu-id="3483b-195">При понижении первичной реплики</span><span class="sxs-lookup"><span data-stu-id="3483b-195">For the primary being demoted</span></span>
<span data-ttu-id="3483b-196">Service Fabric требуется, чтобы эта реплика остановила обработку сообщений и выполнение любой фоновой работы.</span><span class="sxs-lookup"><span data-stu-id="3483b-196">Service Fabric needs this replica to stop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="3483b-197">Это выглядит аналогично завершению работы службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-197">As a result, this step looks similar to when the service is being shut down.</span></span> <span data-ttu-id="3483b-198">Отличие в том, что служба не уничтожается или закрывается, так как остается вторичной.</span><span class="sxs-lookup"><span data-stu-id="3483b-198">One difference is that the Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="3483b-199">Вызываются следующие API.</span><span class="sxs-lookup"><span data-stu-id="3483b-199">The following APIs are called:</span></span>

1. <span data-ttu-id="3483b-200">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="3483b-200">In parallel</span></span>
    - <span data-ttu-id="3483b-201">Закрываются все открытые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="3483b-201">Any open listeners are Closed.</span></span> <span data-ttu-id="3483b-202">Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-202">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="3483b-203">Токен отмены, переданный в `RunAsync()`, отменяется.</span><span class="sxs-lookup"><span data-stu-id="3483b-203">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="3483b-204">В результате проверки свойства `IsCancellationRequested` токена отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="3483b-204">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="3483b-205">Как только `CloseAsync()` завершается для каждого прослушивателя, а также завершается `RunAsync()`, вызывается `StatefulServiceBase.OnChangeRoleAsync()` службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-205">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="3483b-206">Он редко переопределяется в службе.</span><span class="sxs-lookup"><span data-stu-id="3483b-206">This is uncommonly overridden in the service.</span></span>

### <a name="for-the-secondary-being-promoted"></a><span data-ttu-id="3483b-207">При повышении вторичной реплики</span><span class="sxs-lookup"><span data-stu-id="3483b-207">For the secondary being promoted</span></span>
<span data-ttu-id="3483b-208">Аналогичным образом Service Fabric необходимо, чтобы эта реплика начала ожидать передачи сообщений и запустила все необходимые фоновые задачи.</span><span class="sxs-lookup"><span data-stu-id="3483b-208">Similarly, Service Fabric needs this replica to start listening for messages on the wire and start any background tasks it cares about.</span></span> <span data-ttu-id="3483b-209">Эта процедура соответствует процессу создании службы за исключением того, что сама реплика уже существует.</span><span class="sxs-lookup"><span data-stu-id="3483b-209">As a result, this process looks similar to when the service is created, except that the replica itself already exists.</span></span> <span data-ttu-id="3483b-210">Вызываются следующие API.</span><span class="sxs-lookup"><span data-stu-id="3483b-210">The following APIs are called:</span></span>

1. <span data-ttu-id="3483b-211">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="3483b-211">In parallel</span></span>
    - <span data-ttu-id="3483b-212">Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()` и открываются все возвращаемые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="3483b-212">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="3483b-213">Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-213">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="3483b-214">Вызывается метод `StatefulServiceBase.RunAsync()` службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-214">The service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="3483b-215">После завершения всех вызовов `OpenAsync()` прослушивателя реплик и вызова `RunAsync()` вызывается метод `StatefulServiceBase.OnChangeRoleAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-215">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="3483b-216">Он редко переопределяется в службе.</span><span class="sxs-lookup"><span data-stu-id="3483b-216">This is uncommonly overridden in the service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="3483b-217">Распространенные проблемы во время завершения работы службы с отслеживанием состояния и понижения уровня первичной реплики</span><span class="sxs-lookup"><span data-stu-id="3483b-217">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="3483b-218">Service Fabric изменяет первичную реплику службы с отслеживанием состояния по ряду причин.</span><span class="sxs-lookup"><span data-stu-id="3483b-218">Service Fabric changes the Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="3483b-219">Наиболее распространенными являются [балансировка кластера](service-fabric-cluster-resource-manager-balancing.md) и [обновление приложения](service-fabric-application-upgrade.md).</span><span class="sxs-lookup"><span data-stu-id="3483b-219">The most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="3483b-220">Во время этих операций (а также во время штатного завершения работы службы, т. е. как при ее удалении) очень важно, чтобы служба учитывала `CancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="3483b-220">During these operations (as well as during normal service shutdown, like you'd see if the service was deleted), it is important that the service respect the `CancellationToken`.</span></span> <span data-ttu-id="3483b-221">Службы, которые не обрабатывают отмену аккуратно, могут вызывать несколько проблем.</span><span class="sxs-lookup"><span data-stu-id="3483b-221">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="3483b-222">В частности, эти операции будут выполняться медленно, так как Service Fabric ожидает корректную остановку служб.</span><span class="sxs-lookup"><span data-stu-id="3483b-222">In particular, these operations will be slow since Service Fabric waits for the services to stop gracefully.</span></span> <span data-ttu-id="3483b-223">В конечном счете это может привести к сбоям обновлений из-за истечения времени ожидания и откату.</span><span class="sxs-lookup"><span data-stu-id="3483b-223">This can ultimately lead to failed upgrades that time out and roll back.</span></span> <span data-ttu-id="3483b-224">Если не использовать токен отмены, это может также нарушить балансировку кластеров, так как узлы нагружаются, но реорганизация служб невозможна, так как их перемещение занимает слишком много времени.</span><span class="sxs-lookup"><span data-stu-id="3483b-224">Failure to honor the cancellation token can also cause imbalanced clusters because nodes get hot but the services can't be rebalanced since it takes too long to move them elsewhere.</span></span> 

<span data-ttu-id="3483b-225">Так как это службы с отслеживанием состояния, то, скорее всего, они используют [надежные коллекции](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="3483b-225">Since the services are stateful, it is also likely that they are using the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="3483b-226">Когда в Service Fabric понижается уровень первичной реплики, то в первую очередь отменяется доступ на запись к базовому состоянию.</span><span class="sxs-lookup"><span data-stu-id="3483b-226">In Service Fabric, when a Primary is demoted, one of the first things that happens is that write access to the underlying state is revoked.</span></span> <span data-ttu-id="3483b-227">Это приводит ко второму ряду проблем, которые могут повлиять на жизненный цикл службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-227">This leads to a second set of issues that can impact the service lifecycle.</span></span> <span data-ttu-id="3483b-228">Коллекции возвращают исключения на основании времени и операции с репликой (перемещение или завершение работы).</span><span class="sxs-lookup"><span data-stu-id="3483b-228">The collections return Exceptions based on the timing and whether the replica is being moved or shut down.</span></span> <span data-ttu-id="3483b-229">Эти исключения должны обрабатываться правильно.</span><span class="sxs-lookup"><span data-stu-id="3483b-229">These exceptions should be handled correctly.</span></span> <span data-ttu-id="3483b-230">Исключения, порождаемые Service Fabric, делятся на постоянные [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) и временные [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet).</span><span class="sxs-lookup"><span data-stu-id="3483b-230">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="3483b-231">Постоянные исключения должны быть зарегистрированы в журнале и порождены, тогда как для временных исключений возможен повтор породившей их операции в соответствии с логикой повтора.</span><span class="sxs-lookup"><span data-stu-id="3483b-231">Permanent exceptions should be logged and thrown, while the transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="3483b-232">Обработка исключений, которые поступают от `ReliableCollections`, в сочетании с событиями жизненного цикла службы является важной частью тестирования и проверки надежной службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-232">Handling the exceptions that come from use of the `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="3483b-233">Перед развертыванием в рабочей среде рекомендуется запустить службу под нагрузкой во время выполнения обновлений и [хаотического тестирования](service-fabric-controlled-chaos.md).</span><span class="sxs-lookup"><span data-stu-id="3483b-233">The recommendation is always to run your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying to production.</span></span> <span data-ttu-id="3483b-234">Эти простые действия помогут обеспечить правильную реализацию службы и обработку событий жизненного цикла.</span><span class="sxs-lookup"><span data-stu-id="3483b-234">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="3483b-235">Примечания о жизненном цикле службы</span><span class="sxs-lookup"><span data-stu-id="3483b-235">Notes on service lifecycle</span></span>
  - <span data-ttu-id="3483b-236">Метод `RunAsync()` и вызовы `CreateServiceReplicaListeners/CreateServiceInstanceListeners` являются необязательны.</span><span class="sxs-lookup"><span data-stu-id="3483b-236">Both the `RunAsync()` method and the `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="3483b-237">В службе может использоваться один из их, оба или ни одного.</span><span class="sxs-lookup"><span data-stu-id="3483b-237">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="3483b-238">Например, если служба выполняет всю работу в ответ на вызовы пользователя, реализовывать метод `RunAsync()` не нужно.</span><span class="sxs-lookup"><span data-stu-id="3483b-238">For example, if the service does all its work in response to user calls, there is no need for it to implement `RunAsync()`.</span></span> <span data-ttu-id="3483b-239">Необходимы только прослушиватели связи и соответствующий код.</span><span class="sxs-lookup"><span data-stu-id="3483b-239">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="3483b-240">Создание и возвращение прослушивателей связи является необязательным, так как у службы может быть только фоновая работа, поэтому достаточно реализовать `RunAsync()`.</span><span class="sxs-lookup"><span data-stu-id="3483b-240">Similarly, creating and returning communication listeners is optional, as the service may have only background work to do, and so only needs to implement `RunAsync()`</span></span>
  - <span data-ttu-id="3483b-241">Служба может успешно завершить `RunAsync()` и вернуться из него.</span><span class="sxs-lookup"><span data-stu-id="3483b-241">It is valid for a service to complete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="3483b-242">Завершение не является состоянием сбоя.</span><span class="sxs-lookup"><span data-stu-id="3483b-242">Completing is not a failure condition.</span></span> <span data-ttu-id="3483b-243">Завершение `RunAsync()` указывает на то, что фоновая работа службы выполнена.</span><span class="sxs-lookup"><span data-stu-id="3483b-243">Completing `RunAsync()` indicates that the background work of the service has completed.</span></span> <span data-ttu-id="3483b-244">Для надежных служб с отслеживанием состояния `RunAsync()` вызывается снова, если уровень реплики был понижен с первичной до вторичной, а затем обратно повышен до первичной.</span><span class="sxs-lookup"><span data-stu-id="3483b-244">For stateful reliable services, `RunAsync()` is called again if the replica were demoted from Primary to Secondary and then promoted back to Primary.</span></span>
  - <span data-ttu-id="3483b-245">Если служба выполняет выход из `RunAsync()`, порождая какое-либо непредвиденное исключение, это означает сбой.</span><span class="sxs-lookup"><span data-stu-id="3483b-245">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="3483b-246">Объект службы завершает работу, и сообщается об ошибке работоспособности.</span><span class="sxs-lookup"><span data-stu-id="3483b-246">The service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="3483b-247">Несмотря на то, что возвращение этих методов не ограничивается по времени, вы не сможете записать никакие надежные коллекции, а значит, и выполнить какую-либо действительную задачу.</span><span class="sxs-lookup"><span data-stu-id="3483b-247">While there is no time limit on returning from these methods, you immediately lose the ability to write to Reliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="3483b-248">После получения запроса на отмену рекомендуется возвращать методы как можно быстрее.</span><span class="sxs-lookup"><span data-stu-id="3483b-248">It is recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="3483b-249">Если служба не отвечает на такие вызовы API в течение приемлемого промежутка времени, Service Fabric может принудительно завершить работу службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-249">If your service does not respond to these API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="3483b-250">Обычно это происходит только во время обновления приложения или при удалении службы.</span><span class="sxs-lookup"><span data-stu-id="3483b-250">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="3483b-251">По умолчанию время ожидания составляет 15 минут.</span><span class="sxs-lookup"><span data-stu-id="3483b-251">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="3483b-252">Сбои в пути `OnCloseAsync()` приводят к вызову `OnAbort()`, что является последней наилучшей возможностью для службы очистить и освободить все запрошенные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="3483b-252">Failures in the `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="3483b-253">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="3483b-253">Next steps</span></span>
- [<span data-ttu-id="3483b-254">Обзор надежных служб</span><span class="sxs-lookup"><span data-stu-id="3483b-254">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="3483b-255">Краткое руководство по надежным службам Reliable Services</span><span class="sxs-lookup"><span data-stu-id="3483b-255">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="3483b-256">Продвинутое использование надежных служб</span><span class="sxs-lookup"><span data-stu-id="3483b-256">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
