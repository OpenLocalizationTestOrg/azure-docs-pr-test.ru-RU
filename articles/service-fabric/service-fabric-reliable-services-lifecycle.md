---
title: "aaaOverview жизненного цикла hello служб Azure Service Fabric надежного | Документы Microsoft"
description: "Дополнительные сведения о событиях жизненного цикла различных hello в Service Fabric надежного обмена"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 0d75ed5ee7cda85ac9af6a02e160727277804a2b
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="88b2e-103">Жизненный цикл Reliable Services</span><span class="sxs-lookup"><span data-stu-id="88b2e-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="88b2e-104">C# в Windows</span><span class="sxs-lookup"><span data-stu-id="88b2e-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="88b2e-105">Java в Linux</span><span class="sxs-lookup"><span data-stu-id="88b2e-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="88b2e-106">Если говорить о жизненном цикле hello надежных служб основы hello hello жизненного цикла являются наиболее важных hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-106">When thinking about hello lifecycles of Reliable Services, hello basics of hello lifecycle are hello most important.</span></span> <span data-ttu-id="88b2e-107">а именно:</span><span class="sxs-lookup"><span data-stu-id="88b2e-107">In general:</span></span>

- <span data-ttu-id="88b2e-108">во время запуска:</span><span class="sxs-lookup"><span data-stu-id="88b2e-108">During Startup</span></span>
  - <span data-ttu-id="88b2e-109">создаются службы;</span><span class="sxs-lookup"><span data-stu-id="88b2e-109">Services are constructed</span></span>
  - <span data-ttu-id="88b2e-110">Они имеют возможность tooconstruct и возвращают ноль или несколько прослушивателей</span><span class="sxs-lookup"><span data-stu-id="88b2e-110">They have an opportunity tooconstruct and return zero or more listeners</span></span>
  - <span data-ttu-id="88b2e-111">Любые возвращенные прослушиватели должны быть открыты соединение со службой hello</span><span class="sxs-lookup"><span data-stu-id="88b2e-111">Any returned listeners are opened, allowing communication with hello service</span></span>
  - <span data-ttu-id="88b2e-112">Hello службы RunAsync, вызывается метод, позволяя hello служба toodo долго выполняющиеся или фоновых рабочих</span><span class="sxs-lookup"><span data-stu-id="88b2e-112">hello Service's RunAsync method is called, allowing hello service toodo long running or background work</span></span>
- <span data-ttu-id="88b2e-113">во время завершения работы:</span><span class="sxs-lookup"><span data-stu-id="88b2e-113">During shutdown</span></span>
  - <span data-ttu-id="88b2e-114">Hello отмены маркера переданный tooRunAsync отменяется и закрываются прослушиватели hello</span><span class="sxs-lookup"><span data-stu-id="88b2e-114">hello cancellation token passed tooRunAsync is canceled, and hello listeners are closed</span></span>
  - <span data-ttu-id="88b2e-115">После ее завершения, уничтожении сам объект службы hello</span><span class="sxs-lookup"><span data-stu-id="88b2e-115">Once that is complete, hello service object itself is destructed</span></span>

<span data-ttu-id="88b2e-116">Подробно о вокруг hello точный порядок этих событий.</span><span class="sxs-lookup"><span data-stu-id="88b2e-116">There are details around hello exact ordering of these events.</span></span> <span data-ttu-id="88b2e-117">В частности hello порядок событий может немного измениться в зависимости от того, является ли hello надежной службы Stateless или с отслеживанием состояния.</span><span class="sxs-lookup"><span data-stu-id="88b2e-117">In particular, hello order of events may change slightly depending on whether hello Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="88b2e-118">Кроме того для служб с отслеживанием состояния, у нас есть toodeal со сценарием основной swap hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-118">In addition, for stateful services, we have toodeal with hello Primary swap scenario.</span></span> <span data-ttu-id="88b2e-119">Во время этой последовательности hello роль первичной репликой переносятся tooanother (или возобновляет) без отключения службы hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-119">During this sequence, hello role of Primary is transferred tooanother replica (or comes back) without hello service shutting down.</span></span> <span data-ttu-id="88b2e-120">Наконец у нас есть toothink об условиях ошибок и сбоев.</span><span class="sxs-lookup"><span data-stu-id="88b2e-120">Finally, we have toothink about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="88b2e-121">Запуск службы без отслеживания состояния</span><span class="sxs-lookup"><span data-stu-id="88b2e-121">Stateless service startup</span></span>
<span data-ttu-id="88b2e-122">жизненный цикл службы без отслеживания состояния Hello выполняется очень просто.</span><span class="sxs-lookup"><span data-stu-id="88b2e-122">hello lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="88b2e-123">Ниже приведен порядок событий hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-123">Here's hello order of events:</span></span>

1. <span data-ttu-id="88b2e-124">Hello службы создается</span><span class="sxs-lookup"><span data-stu-id="88b2e-124">hello Service is constructed</span></span>
2. <span data-ttu-id="88b2e-125">Затем одновременно происходят две вещи:</span><span class="sxs-lookup"><span data-stu-id="88b2e-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="88b2e-126">Вызывается метод `StatelessService.CreateServiceInstanceListeners()` и открываются все возвращаемые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="88b2e-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="88b2e-127">Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="88b2e-128">Здравствуйте, службы `StatelessService.RunAsync()` вызывается метод</span><span class="sxs-lookup"><span data-stu-id="88b2e-128">hello service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="88b2e-129">Если он имеется, hello службы `StatelessService.OnOpenAsync()` вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="88b2e-129">If present, hello service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="88b2e-130">Это редко используемое переопределение, но оно доступно.</span><span class="sxs-lookup"><span data-stu-id="88b2e-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="88b2e-131">Это важные toonote, это не порядок toocreate вызовы hello и откройте hello прослушивателей и RunAsync.</span><span class="sxs-lookup"><span data-stu-id="88b2e-131">It is important toonote that there is no ordering between hello calls toocreate and open hello listeners and RunAsync.</span></span> <span data-ttu-id="88b2e-132">Перед запуском RunAsync, может открыть Hello прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="88b2e-132">hello listeners may open before RunAsync is started.</span></span> <span data-ttu-id="88b2e-133">Аналогичным образом RunAsync может оказаться вызывается перед прослушивания связи hello открыты или даже были построены.</span><span class="sxs-lookup"><span data-stu-id="88b2e-133">Similarly, RunAsync may end up invoked before hello communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="88b2e-134">Если необходима синхронизация, она останется при реализации toohello упражнении.</span><span class="sxs-lookup"><span data-stu-id="88b2e-134">If any synchronization is required, it is left as an exercise toohello implementer.</span></span> <span data-ttu-id="88b2e-135">Ниже приведены распространенные решения.</span><span class="sxs-lookup"><span data-stu-id="88b2e-135">Common solutions:</span></span>

  - <span data-ttu-id="88b2e-136">Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи.</span><span class="sxs-lookup"><span data-stu-id="88b2e-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="88b2e-137">Для служб без отслеживания состояния, работа которых обычно может быть выполнена в других расположениях, например:</span><span class="sxs-lookup"><span data-stu-id="88b2e-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="88b2e-138">в конструкторе службы hello</span><span class="sxs-lookup"><span data-stu-id="88b2e-138">in hello service's constructor</span></span>
    - <span data-ttu-id="88b2e-139">во время hello `CreateServiceInstanceListeners()` вызова</span><span class="sxs-lookup"><span data-stu-id="88b2e-139">during hello `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="88b2e-140">в составе конструкции hello сам прослушиватель hello</span><span class="sxs-lookup"><span data-stu-id="88b2e-140">as a part of hello construction of hello listener itself</span></span>
  - <span data-ttu-id="88b2e-141">Иногда hello кода в RunAsync не требуется toostart пока открыты hello прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="88b2e-141">Sometimes hello code in RunAsync does not want toostart until hello listeners are open.</span></span> <span data-ttu-id="88b2e-142">В этом случае необходима дополнительная координация.</span><span class="sxs-lookup"><span data-stu-id="88b2e-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="88b2e-143">Общие решением проблемы является некоторые флаг за hello прослушивателей, указывающее, когда они будут завершены.</span><span class="sxs-lookup"><span data-stu-id="88b2e-143">One common solution is some flag within hello listeners indicating when they have completed.</span></span> <span data-ttu-id="88b2e-144">Затем этот флаг установлен в RunAsync перед продолжением работы tooactual.</span><span class="sxs-lookup"><span data-stu-id="88b2e-144">This flag is then checked in RunAsync before continuing tooactual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="88b2e-145">Завершение работы службы без отслеживания состояния</span><span class="sxs-lookup"><span data-stu-id="88b2e-145">Stateless service shutdown</span></span>
<span data-ttu-id="88b2e-146">При выключении службы без отслеживания состояния, Привет одному шаблону, просто в обратном направлении:</span><span class="sxs-lookup"><span data-stu-id="88b2e-146">When shutting down a stateless service, hello same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="88b2e-147">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="88b2e-147">In parallel</span></span>
    - <span data-ttu-id="88b2e-148">Закрываются все открытые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="88b2e-148">Any open listeners are Closed.</span></span> <span data-ttu-id="88b2e-149">Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="88b2e-150">токен отмены Hello передано слишком`RunAsync()` отменяется.</span><span class="sxs-lookup"><span data-stu-id="88b2e-150">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="88b2e-151">Проверка hello токен отмены `IsCancellationRequested` свойство возвращает значение true и при вызове hello токен `ThrowIfCancellationRequested` вызывает исключение `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-151">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="88b2e-152">Один раз `CloseAsync()` завершения на каждый прослушиватель и `RunAsync()` также завершается hello службы `StatelessService.OnCloseAsync()` метод вызывается, если он имеется.</span><span class="sxs-lookup"><span data-stu-id="88b2e-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="88b2e-153">Это часто toooverride `StatelessService.OnCloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-153">It is uncommon toooverride `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="88b2e-154">После `StatelessService.OnCloseAsync()` завершения уничтожении hello объекта службы</span><span class="sxs-lookup"><span data-stu-id="88b2e-154">After `StatelessService.OnCloseAsync()` completes, hello service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="88b2e-155">Запуск службы с отслеживанием состояния</span><span class="sxs-lookup"><span data-stu-id="88b2e-155">Stateful service Startup</span></span>
<span data-ttu-id="88b2e-156">С отслеживанием состояния службы имеют аналогичные службы toostateless шаблон, с несколькими изменениями.</span><span class="sxs-lookup"><span data-stu-id="88b2e-156">Stateful services have a similar pattern toostateless services, with a few changes.</span></span> <span data-ttu-id="88b2e-157">При запуске службы с отслеживанием состояния, hello порядок событий выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="88b2e-157">When starting up a stateful service, hello order of events is as follows:</span></span>

1. <span data-ttu-id="88b2e-158">Hello службы создается</span><span class="sxs-lookup"><span data-stu-id="88b2e-158">hello Service is constructed</span></span>
2. <span data-ttu-id="88b2e-159">Вызывается метод `StatefulServiceBase.OnOpenAsync()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="88b2e-160">Uncommonly переопределяется в службе hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-160">This is uncommonly overridden in hello service.</span></span>
3. <span data-ttu-id="88b2e-161">Hello выполняются следующие действия параллельно</span><span class="sxs-lookup"><span data-stu-id="88b2e-161">hello following things happen in parallel</span></span>
    - <span data-ttu-id="88b2e-162">Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="88b2e-163">Если служба hello основной открываются все возвращенные прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="88b2e-163">If hello service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="88b2e-164">Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="88b2e-165">Если служба hello получателя, только эти прослушиватели помечен как `ListenOnSecondary = true` открыты.</span><span class="sxs-lookup"><span data-stu-id="88b2e-165">If hello service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="88b2e-166">Открытые прослушиватели для вторичных реплик используются реже.</span><span class="sxs-lookup"><span data-stu-id="88b2e-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="88b2e-167">Здравствуйте, hello службы в настоящее время является основной, hello службы `StatefulServiceBase.RunAsync()` вызывается метод</span><span class="sxs-lookup"><span data-stu-id="88b2e-167">hello if hello Service is currently a Primary, hello service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="88b2e-168">Как только все hello прослушиватель реплики `OpenAsync()` вызывает завершение и `RunAsync()` вызове `StatefulServiceBase.OnChangeRoleAsync()` вызывается.</span><span class="sxs-lookup"><span data-stu-id="88b2e-168">Once all hello replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="88b2e-169">Uncommonly переопределяется в службе hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-169">This is uncommonly overridden in hello service.</span></span>

<span data-ttu-id="88b2e-170">Аналогично службы toostateless имеется не координацию между hello порядок, в какие hello прослушиватели создается и открывается и при вызове RunAsync.</span><span class="sxs-lookup"><span data-stu-id="88b2e-170">Similarly toostateless services, there's no coordination between hello order in which hello listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="88b2e-171">Если требуется координация hello решений являются гораздо hello же.</span><span class="sxs-lookup"><span data-stu-id="88b2e-171">If you need coordination, hello solutions are much hello same.</span></span> <span data-ttu-id="88b2e-172">Есть один дополнительный случай: предположим, что вызовы hello, поступающих в прослушивания связи hello требуют сведения сохраняются внутри некоторых [надежного коллекции](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="88b2e-172">THere is one additional case: say that hello calls arriving at hello communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="88b2e-173">Поскольку hello прослушивания связи может открыть перед hello надежного коллекции — для чтения или для чтения, и перед RunAsync удалось запустить, некоторые дополнительные координации не требуется.</span><span class="sxs-lookup"><span data-stu-id="88b2e-173">Because hello communication listeners could open before hello reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="88b2e-174">решение простейшим и наиболее распространенным Hello предназначен для hello связи прослушиватели tooreturn код ошибки, hello запрос клиента использует tooknow tooretry hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-174">hello simplest and most common solution is for hello communication listeners tooreturn some error code that hello client uses tooknow tooretry hello request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="88b2e-175">Завершение работы службы с отслеживанием состояния</span><span class="sxs-lookup"><span data-stu-id="88b2e-175">Stateful service Shutdown</span></span>
<span data-ttu-id="88b2e-176">Аналогичным образом tooStateless службы, событий жизненного цикла hello во время завершения работы hello же во время запуска, но отменены.</span><span class="sxs-lookup"><span data-stu-id="88b2e-176">Similarly tooStateless services, hello lifecycle events during shutdown are hello same as during startup, but reversed.</span></span> <span data-ttu-id="88b2e-177">При завершении работы службы с отслеживанием состояния hello происходят следующие события.</span><span class="sxs-lookup"><span data-stu-id="88b2e-177">When a stateful service is being shut down, hello following events occur:</span></span>

1. <span data-ttu-id="88b2e-178">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="88b2e-178">In parallel</span></span>
    - <span data-ttu-id="88b2e-179">Закрываются все открытые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="88b2e-179">Any open listeners are Closed.</span></span> <span data-ttu-id="88b2e-180">Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="88b2e-181">токен отмены Hello передано слишком`RunAsync()` отменяется.</span><span class="sxs-lookup"><span data-stu-id="88b2e-181">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="88b2e-182">Проверка hello токен отмены `IsCancellationRequested` свойство возвращает значение true и при вызове hello токен `ThrowIfCancellationRequested` вызывает исключение `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-182">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="88b2e-183">Один раз `CloseAsync()` завершения на каждый прослушиватель и `RunAsync()` также завершается hello службы `StatefulServiceBase.OnChangeRoleAsync()` вызывается.</span><span class="sxs-lookup"><span data-stu-id="88b2e-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="88b2e-184">(Это uncommonly переопределяется в службе hello.)</span><span class="sxs-lookup"><span data-stu-id="88b2e-184">(This is uncommonly overridden in hello service.)</span></span>
    - <span data-ttu-id="88b2e-185">Ожидание RunAsync toocomplete необходим только в случае основной этой реплики службы.</span><span class="sxs-lookup"><span data-stu-id="88b2e-185">Waiting for RunAsync toocomplete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="88b2e-186">Здравствуйте, один раз `StatefulServiceBase.OnChangeRoleAsync()` метод завершения hello `StatefulServiceBase.OnCloseAsync()` вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="88b2e-186">Once hello `StatefulServiceBase.OnChangeRoleAsync()` method completes, hello `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="88b2e-187">Это редко используемое переопределение, но оно доступно.</span><span class="sxs-lookup"><span data-stu-id="88b2e-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="88b2e-188">После `StatefulServiceBase.OnCloseAsync()` завершения уничтожении hello объекта службы.</span><span class="sxs-lookup"><span data-stu-id="88b2e-188">After `StatefulServiceBase.OnCloseAsync()` completes, hello service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="88b2e-189">Переключения первичной реплики службы с отслеживанием состояния</span><span class="sxs-lookup"><span data-stu-id="88b2e-189">Stateful service primary swaps</span></span>
<span data-ttu-id="88b2e-190">Во время выполнения службы с отслеживанием состояния, hello первичные реплики, с отслеживанием состояния службы достаточно их открытии прослушивания связи и их RunAsync метод с именем.</span><span class="sxs-lookup"><span data-stu-id="88b2e-190">While a stateful service is running, only hello Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="88b2e-191">Вторичные реплики создаются, но не видят последующие вызовы.</span><span class="sxs-lookup"><span data-stu-id="88b2e-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="88b2e-192">Однако под управлением службы с отслеживанием состояния реплику, которая в настоящее время является основной hello можно изменить.</span><span class="sxs-lookup"><span data-stu-id="88b2e-192">While a stateful service is running however, which replica is currently hello Primary can change.</span></span> <span data-ttu-id="88b2e-193">Что это означает точки зрения hello события жизненного цикла, которые могут видеть реплики? Hello поведение hello реплики с отслеживанием состояния видит зависит от реплики hello пониженных или повышается во время замены hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-193">What does this mean in terms of hello lifecycle events that a replica can see? hello behavior hello stateful replica sees depends on whether it is hello replica being demoted or promoted during hello swap.</span></span>

### <a name="for-hello-primary-being-demoted"></a><span data-ttu-id="88b2e-194">Для первичной пониженных hello</span><span class="sxs-lookup"><span data-stu-id="88b2e-194">For hello primary being demoted</span></span>
<span data-ttu-id="88b2e-195">Service Fabric требуется toostop этой реплики, обработки сообщений и выйти из любой фоновой работы выполняемых действий.</span><span class="sxs-lookup"><span data-stu-id="88b2e-195">Service Fabric needs this replica toostop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="88b2e-196">В результате этого шага выглядит примерно toowhen hello службы завершает работу.</span><span class="sxs-lookup"><span data-stu-id="88b2e-196">As a result, this step looks similar toowhen hello service is being shut down.</span></span> <span data-ttu-id="88b2e-197">Единственным отличием является, hello службы не уничтожены или закрыты, так как он остается в качестве получателя.</span><span class="sxs-lookup"><span data-stu-id="88b2e-197">One difference is that hello Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="88b2e-198">следующие API-интерфейсы Hello называются:</span><span class="sxs-lookup"><span data-stu-id="88b2e-198">hello following APIs are called:</span></span>

1. <span data-ttu-id="88b2e-199">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="88b2e-199">In parallel</span></span>
    - <span data-ttu-id="88b2e-200">Закрываются все открытые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="88b2e-200">Any open listeners are Closed.</span></span> <span data-ttu-id="88b2e-201">Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-201">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="88b2e-202">токен отмены Hello передано слишком`RunAsync()` отменяется.</span><span class="sxs-lookup"><span data-stu-id="88b2e-202">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="88b2e-203">Проверка hello токен отмены `IsCancellationRequested` свойство возвращает значение true и при вызове hello токен `ThrowIfCancellationRequested` вызывает исключение `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-203">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="88b2e-204">Один раз `CloseAsync()` завершения на каждый прослушиватель и `RunAsync()` также завершается hello службы `StatefulServiceBase.OnChangeRoleAsync()` вызывается.</span><span class="sxs-lookup"><span data-stu-id="88b2e-204">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="88b2e-205">Uncommonly переопределяется в службе hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-205">This is uncommonly overridden in hello service.</span></span>

### <a name="for-hello-secondary-being-promoted"></a><span data-ttu-id="88b2e-206">Для получателей, роль которого повышается hello</span><span class="sxs-lookup"><span data-stu-id="88b2e-206">For hello secondary being promoted</span></span>
<span data-ttu-id="88b2e-207">Аналогичным образом Service Fabric должен toostart этой реплики, ожидающую сообщений hello сети и запустить все фоновой задачи, которые его интересуют.</span><span class="sxs-lookup"><span data-stu-id="88b2e-207">Similarly, Service Fabric needs this replica toostart listening for messages on hello wire and start any background tasks it cares about.</span></span> <span data-ttu-id="88b2e-208">Таким образом, оно выглядит процесс создания аналогичную службу hello toowhen, за исключением того, эта реплика hello сам уже существует.</span><span class="sxs-lookup"><span data-stu-id="88b2e-208">As a result, this process looks similar toowhen hello service is created, except that hello replica itself already exists.</span></span> <span data-ttu-id="88b2e-209">следующие API-интерфейсы Hello называются:</span><span class="sxs-lookup"><span data-stu-id="88b2e-209">hello following APIs are called:</span></span>

1. <span data-ttu-id="88b2e-210">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="88b2e-210">In parallel</span></span>
    - <span data-ttu-id="88b2e-211">Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()` и открываются все возвращаемые прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="88b2e-211">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="88b2e-212">Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-212">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="88b2e-213">Здравствуйте, службы `StatefulServiceBase.RunAsync()` вызывается метод</span><span class="sxs-lookup"><span data-stu-id="88b2e-213">hello service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="88b2e-214">Как только все hello прослушиватель реплики `OpenAsync()` вызывает завершение и `RunAsync()` был вызван, `StatefulServiceBase.OnChangeRoleAsync()` вызывается.</span><span class="sxs-lookup"><span data-stu-id="88b2e-214">Once all hello replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="88b2e-215">Uncommonly переопределяется в службе hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-215">This is uncommonly overridden in hello service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="88b2e-216">Распространенные проблемы во время завершения работы службы с отслеживанием состояния и понижения уровня первичной реплики</span><span class="sxs-lookup"><span data-stu-id="88b2e-216">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="88b2e-217">Изменения Service Fabric hello основным для службы с отслеживанием состояния по ряду причин.</span><span class="sxs-lookup"><span data-stu-id="88b2e-217">Service Fabric changes hello Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="88b2e-218">Hello чаще всего являются [кластера Балансировка](service-fabric-cluster-resource-manager-balancing.md) и [обновление приложения](service-fabric-application-upgrade.md).</span><span class="sxs-lookup"><span data-stu-id="88b2e-218">hello most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="88b2e-219">Во время таких операций (а также во время завершения работы нормальную работу службы, как вы увидите, если служба hello была удалена), очень важно, что hello относительно службы hello `CancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-219">During these operations (as well as during normal service shutdown, like you'd see if hello service was deleted), it is important that hello service respect hello `CancellationToken`.</span></span> <span data-ttu-id="88b2e-220">Службы, которые не обрабатывают отмену аккуратно, могут вызывать несколько проблем.</span><span class="sxs-lookup"><span data-stu-id="88b2e-220">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="88b2e-221">В частности эти операции будут работать медленно, поскольку Service Fabric ожидает toostop служб hello надлежащим образом.</span><span class="sxs-lookup"><span data-stu-id="88b2e-221">In particular, these operations will be slow since Service Fabric waits for hello services toostop gracefully.</span></span> <span data-ttu-id="88b2e-222">В конечном счете, это может привести toofailed обновления, время ожидания и отката.</span><span class="sxs-lookup"><span data-stu-id="88b2e-222">This can ultimately lead toofailed upgrades that time out and roll back.</span></span> <span data-ttu-id="88b2e-223">Токен отмены hello toohonor сбоя могут возникать несбалансированных кластеров так, как получить горячей узлов, но hello службы не может быть балансируется повторное присоединение с момента занимает слишком много времени toomove их в другом месте.</span><span class="sxs-lookup"><span data-stu-id="88b2e-223">Failure toohonor hello cancellation token can also cause imbalanced clusters because nodes get hot but hello services can't be rebalanced since it takes too long toomove them elsewhere.</span></span> 

<span data-ttu-id="88b2e-224">Поскольку hello служб с отслеживанием состояния, это скорее всего, что они используют hello [надежного коллекции](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="88b2e-224">Since hello services are stateful, it is also likely that they are using hello [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="88b2e-225">В Service Fabric после понижения роли основного, одним из hello первое, что происходит является отменяется, состояние базового toohello доступ для записи.</span><span class="sxs-lookup"><span data-stu-id="88b2e-225">In Service Fabric, when a Primary is demoted, one of hello first things that happens is that write access toohello underlying state is revoked.</span></span> <span data-ttu-id="88b2e-226">Это порождает tooa второй набор проблем, которые могут повлиять на жизненный цикл службы hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-226">This leads tooa second set of issues that can impact hello service lifecycle.</span></span> <span data-ttu-id="88b2e-227">Возвращаемое исключения на основе времени hello и перемещается ли реплика hello коллекций Hello или завершение работы.</span><span class="sxs-lookup"><span data-stu-id="88b2e-227">hello collections return Exceptions based on hello timing and whether hello replica is being moved or shut down.</span></span> <span data-ttu-id="88b2e-228">Эти исключения должны обрабатываться правильно.</span><span class="sxs-lookup"><span data-stu-id="88b2e-228">These exceptions should be handled correctly.</span></span> <span data-ttu-id="88b2e-229">Исключения, порождаемые Service Fabric, делятся на постоянные [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) и временные [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet).</span><span class="sxs-lookup"><span data-stu-id="88b2e-229">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="88b2e-230">Постоянное исключения следует войти и исключение во время hello временные исключения может быть повторена основании определенную логику повторных попыток.</span><span class="sxs-lookup"><span data-stu-id="88b2e-230">Permanent exceptions should be logged and thrown, while hello transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="88b2e-231">Обработка исключений hello, полученные от использования hello `ReliableCollections` в сочетании с события жизненного цикла службы является важной частью тестировании и проверке надежной службы.</span><span class="sxs-lookup"><span data-stu-id="88b2e-231">Handling hello exceptions that come from use of hello `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="88b2e-232">Здравствуйте, рекомендация — всегда toorun службы под нагрузкой во время выполнения обновлений и [хаоса тестирование](service-fabric-controlled-chaos.md) перед развертыванием tooproduction когда-либо.</span><span class="sxs-lookup"><span data-stu-id="88b2e-232">hello recommendation is always toorun your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying tooproduction.</span></span> <span data-ttu-id="88b2e-233">Эти простые действия помогут обеспечить правильную реализацию службы и обработку событий жизненного цикла.</span><span class="sxs-lookup"><span data-stu-id="88b2e-233">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="88b2e-234">Примечания о жизненном цикле службы</span><span class="sxs-lookup"><span data-stu-id="88b2e-234">Notes on service lifecycle</span></span>
  - <span data-ttu-id="88b2e-235">Оба hello `RunAsync()` метод и hello `CreateServiceReplicaListeners/CreateServiceInstanceListeners` вызовы являются необязательными.</span><span class="sxs-lookup"><span data-stu-id="88b2e-235">Both hello `RunAsync()` method and hello `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="88b2e-236">В службе может использоваться один из их, оба или ни одного.</span><span class="sxs-lookup"><span data-stu-id="88b2e-236">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="88b2e-237">Например, если служба hello выполняет свою работу в вызовах toouser ответа, нет необходимости для него tooimplement `RunAsync()`.</span><span class="sxs-lookup"><span data-stu-id="88b2e-237">For example, if hello service does all its work in response toouser calls, there is no need for it tooimplement `RunAsync()`.</span></span> <span data-ttu-id="88b2e-238">Необходимы только hello прослушивания связи и их кода.</span><span class="sxs-lookup"><span data-stu-id="88b2e-238">Only hello communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="88b2e-239">Аналогичным образом Создание и возвращение прослушивания связи является необязательной, поскольку служба hello может иметь только фоновой работы toodo и поэтому достаточно tooimplement`RunAsync()`</span><span class="sxs-lookup"><span data-stu-id="88b2e-239">Similarly, creating and returning communication listeners is optional, as hello service may have only background work toodo, and so only needs tooimplement `RunAsync()`</span></span>
  - <span data-ttu-id="88b2e-240">Он является допустимым для toocomplete службы `RunAsync()` успешно и вернуть из нее.</span><span class="sxs-lookup"><span data-stu-id="88b2e-240">It is valid for a service toocomplete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="88b2e-241">Завершение не является состоянием сбоя.</span><span class="sxs-lookup"><span data-stu-id="88b2e-241">Completing is not a failure condition.</span></span> <span data-ttu-id="88b2e-242">Завершение работы `RunAsync()` указывает на завершение hello фоновой работы службы hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-242">Completing `RunAsync()` indicates that hello background work of hello service has completed.</span></span> <span data-ttu-id="88b2e-243">Для надежных служб с отслеживанием состояния `RunAsync()` вызывается снова, если реплика hello были понижены из первичного tooSecondary и затем повышается tooPrimary назад.</span><span class="sxs-lookup"><span data-stu-id="88b2e-243">For stateful reliable services, `RunAsync()` is called again if hello replica were demoted from Primary tooSecondary and then promoted back tooPrimary.</span></span>
  - <span data-ttu-id="88b2e-244">Если служба выполняет выход из `RunAsync()`, порождая какое-либо непредвиденное исключение, это означает сбой.</span><span class="sxs-lookup"><span data-stu-id="88b2e-244">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="88b2e-245">Hello объекта службы завершает работу, а ошибка работоспособности.</span><span class="sxs-lookup"><span data-stu-id="88b2e-245">hello service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="88b2e-246">Пока нет ограничения времени после возвращения из этих методов, вы сразу же потеряют hello возможности toowrite tooReliable коллекций и поэтому не может завершить какой-либо реальной работы.</span><span class="sxs-lookup"><span data-stu-id="88b2e-246">While there is no time limit on returning from these methods, you immediately lose hello ability toowrite tooReliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="88b2e-247">Рекомендуется восстановить как можно быстрее при получении запроса отмены hello.</span><span class="sxs-lookup"><span data-stu-id="88b2e-247">It is recommended that you return as quickly as possible upon receiving hello cancellation request.</span></span> <span data-ttu-id="88b2e-248">Если служба не отвечает toothese API-вызовов за приемлемое время Service Fabric может принудительно прекратить использование службы.</span><span class="sxs-lookup"><span data-stu-id="88b2e-248">If your service does not respond toothese API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="88b2e-249">Обычно это происходит только во время обновления приложения или при удалении службы.</span><span class="sxs-lookup"><span data-stu-id="88b2e-249">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="88b2e-250">По умолчанию время ожидания составляет 15 минут.</span><span class="sxs-lookup"><span data-stu-id="88b2e-250">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="88b2e-251">Сбои в hello `OnCloseAsync()` результирующий путь в `OnAbort()` называемый, это возможность последнего вероятность усилия для hello службы tooclean вверх и освободить все ресурсы, которые они уже запросили.</span><span class="sxs-lookup"><span data-stu-id="88b2e-251">Failures in hello `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for hello service tooclean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="88b2e-252">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="88b2e-252">Next steps</span></span>
- [<span data-ttu-id="88b2e-253">Введение tooReliable служб</span><span class="sxs-lookup"><span data-stu-id="88b2e-253">Introduction tooReliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="88b2e-254">Краткое руководство по надежным службам Reliable Services</span><span class="sxs-lookup"><span data-stu-id="88b2e-254">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="88b2e-255">Продвинутое использование надежных служб</span><span class="sxs-lookup"><span data-stu-id="88b2e-255">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
