---
title: "aaaOverview жизненного цикла hello служб Azure Service Fabric надежного | Документы Microsoft"
description: "Дополнительные сведения о событиях жизненного цикла различных hello в Service Fabric надежного обмена"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 6d48c217d12bc5248c2da57b544aac747cecd872
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a>Жизненный цикл Reliable Services
> [!div class="op_single_selector"]
> * [C# в Windows](service-fabric-reliable-services-lifecycle.md)
> * [Java в Linux](service-fabric-reliable-services-lifecycle-java.md)
>
>

Если говорить о жизненном цикле hello надежных служб основы hello hello жизненного цикла являются наиболее важных hello. а именно:

* во время запуска:
  * создаются службы;
  * Они имеют возможность tooconstruct и возвращают ноль или несколько прослушивателей
  * Любые возвращенные прослушиватели должны быть открыты соединение со службой hello
  * вызывается метод runAsync Hello службы, позволяя hello toodo службы долго выполняющиеся или фон рабочего
* во время завершения работы:
  * Hello отмены маркера переданный toorunAsync отменяется и закрываются прослушиватели hello
  * После ее завершения, уничтожении сам объект службы hello

Подробно о вокруг hello точный порядок этих событий. В частности hello порядок событий может немного измениться в зависимости от того, является ли hello надежной службы Stateless или с отслеживанием состояния. Кроме того для служб с отслеживанием состояния, у нас есть toodeal со сценарием основной swap hello. Во время этой последовательности hello роль первичной репликой переносятся tooanother (или возобновляет) без отключения службы hello. Наконец у нас есть toothink об условиях ошибок и сбоев.

## <a name="stateless-service-startup"></a>Запуск службы без отслеживания состояния
жизненный цикл службы без отслеживания состояния Hello выполняется очень просто. Ниже приведен порядок событий hello.

1. Hello службы создается
2. Затем одновременно происходят две вещи:
    - вызывается метод `StatelessService.createServiceInstanceListeners()` и открываются все возвращаемые прослушиватели (для каждого прослушивателя вызывается `CommunicationListener.openAsync()`);
    - Здравствуйте, метод runAsync службы (`StatelessService.runAsync()`) называется
3. Если присутствует, вызывается метод onOpenAsync hello службы (в частности, `StatelessService.onOpenAsync()` вызывается. Это редко используемое переопределение, но оно доступно.

Это важные toonote, это не порядок toocreate вызовы hello и откройте hello прослушивателей и runAsync. Перед запуском runAsync, может открыть Hello прослушиватели. Аналогичным образом runAsync может оказаться вызывается перед прослушивания связи hello открыты или даже были построены. Если необходима синхронизация, она останется при реализации toohello упражнении. Ниже приведены распространенные решения.

* Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи. Для службы без сохранения состояния, которые работы обычно выполняются в конструкторе hello службы во время hello `createServiceInstanceListeners()` вызвать, либо в качестве части конструкции "hello" сам прослушиватель hello.
* Иногда hello кода в runAsync не требуется toostart пока открыты hello прослушиватели. В этом случае необходима дополнительная координация. Общие решением проблемы является некоторые флаг за hello прослушивателей, указывающее, когда они завершили, который runAsync проверяется перед продолжением работы tooactual.

## <a name="stateless-service-shutdown"></a>Завершение работы службы без отслеживания состояния
При выключении службы без отслеживания состояния, Привет одному шаблону, просто в обратном направлении:

1. В параллельном режиме:
    - все открытые прослушиватели закрываются (для каждого прослушивателя вызывается `CommunicationListener.closeAsync()`);
    - токен отмены Hello передано слишком`runAsync()` отменяется (проверка токена отмены hello `isCancelled` свойство возвращает значение true и при вызове hello токен `throwIfCancellationRequested` вызывает исключение `CancellationException`)
2. Один раз `closeAsync()` завершения на каждый прослушиватель и `runAsync()` также завершается hello службы `StatelessService.onCloseAsync()` метод вызывается, если он имеется (снова это переопределение редко).
3. После `StatelessService.onCloseAsync()` завершения уничтожении hello объекта службы

## <a name="notes-on-service-lifecycle"></a>Примечания о жизненном цикле службы
* Оба hello `runAsync()` метод и hello `createServiceInstanceListeners` вызовы являются необязательными. В службе может использоваться один из их, оба или ни одного. Например, если служба hello выполняет свою работу в вызовах toouser ответа, нет необходимости для него tooimplement `runAsync()`. Необходимы только hello прослушивания связи и их кода. Аналогичным образом Создание и возвращение прослушивания связи является необязательной, поскольку служба hello может иметь только фоновой работы toodo и поэтому достаточно tooimplement`runAsync()`
* Он является допустимым для toocomplete службы `runAsync()` успешно и вернуть из нее. Это рассматривается как условие сбоя и представляют собой hello фоновой работы после завершения обновления hello. Для надежных служб с отслеживанием состояния `runAsync()` будет вызываться снова, если служба hello были понижены от основного и затем повышается задней tooprimary.
* Если служба выполняет выход из `runAsync()` путем создания исключения некоторые непредвиденное исключение, это сбой и выключить hello объекта службы, и ошибка работоспособности.
* Пока нет ограничения времени после возвращения из этих методов, вы сразу же потеряют возможность toowrite hello и поэтому не может завершить какой-либо реальной работы. Рекомендуется восстановить как можно быстрее при получении запроса отмены hello. Если служба не отвечает toothese API-вызовов за приемлемое время Service Fabric может принудительно прекратить использование службы. Обычно это происходит только во время обновления приложения или при удалении службы. По умолчанию время ожидания составляет 15 минут.
* Сбои в hello `onCloseAsync()` результирующий путь в `onAbort()` называемый, это возможность последнего вероятность усилия для hello службы tooclean вверх и освободить все ресурсы, которые они уже запросили.

> [!NOTE]
> Сейчас Java не поддерживает службы Reliable Services с отслеживанием состояния.
>
>

## <a name="next-steps"></a>Дальнейшие действия
* [Введение tooReliable служб](service-fabric-reliable-services-introduction.md)
* [Краткое руководство по надежным службам Reliable Services](service-fabric-reliable-services-quick-start.md)
* [Продвинутое использование надежных служб](service-fabric-reliable-services-advanced-usage.md)
