---
title: "Общие сведения о жизненном цикле Reliable Services в Azure Service Fabric | Документация Майкрософт"
description: "Сведения о различных событиях жизненного цикла служб Reliable Services в Service Fabric"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 80eb68346dd05c256c60725eb082aa0651fe7cbd
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="4c5c9-103">Жизненный цикл Reliable Services</span><span class="sxs-lookup"><span data-stu-id="4c5c9-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="4c5c9-104">C# в Windows</span><span class="sxs-lookup"><span data-stu-id="4c5c9-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="4c5c9-105">Java в Linux</span><span class="sxs-lookup"><span data-stu-id="4c5c9-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="4c5c9-106">Если речь идет о жизненных циклах служб Reliable Services, наиболее важны основные аспекты,</span><span class="sxs-lookup"><span data-stu-id="4c5c9-106">When thinking about the lifecycles of Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="4c5c9-107">а именно:</span><span class="sxs-lookup"><span data-stu-id="4c5c9-107">In general:</span></span>

* <span data-ttu-id="4c5c9-108">во время запуска:</span><span class="sxs-lookup"><span data-stu-id="4c5c9-108">During Startup</span></span>
  * <span data-ttu-id="4c5c9-109">создаются службы;</span><span class="sxs-lookup"><span data-stu-id="4c5c9-109">Services are constructed</span></span>
  * <span data-ttu-id="4c5c9-110">они могут создавать и возвращать ни одного или несколько прослушивателей;</span><span class="sxs-lookup"><span data-stu-id="4c5c9-110">They have an opportunity to construct and return zero or more listeners</span></span>
  * <span data-ttu-id="4c5c9-111">все возвращаемые прослушиватели открываются, что разрешает взаимодействие со службой;</span><span class="sxs-lookup"><span data-stu-id="4c5c9-111">Any returned listeners are opened, allowing communication with the service</span></span>
  * <span data-ttu-id="4c5c9-112">вызывается метод RunAsync службы, позволяя службе выполнять длительную или фоновую работу;</span><span class="sxs-lookup"><span data-stu-id="4c5c9-112">The Service's runAsync method is called, allowing the service to do long running or background work</span></span>
* <span data-ttu-id="4c5c9-113">во время завершения работы:</span><span class="sxs-lookup"><span data-stu-id="4c5c9-113">During shutdown</span></span>
  * <span data-ttu-id="4c5c9-114">токен отмены, переданный в RunAsync, отменяется, и прослушиватели закрываются;</span><span class="sxs-lookup"><span data-stu-id="4c5c9-114">The cancellation token passed to runAsync is canceled, and the listeners are closed</span></span>
  * <span data-ttu-id="4c5c9-115">после этого уничтожается сам объект службы.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-115">Once that is complete, the service object itself is destructed</span></span>

<span data-ttu-id="4c5c9-116">Следует отметить некоторые моменты, связанные с точным порядком этих событий.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="4c5c9-117">В частности, порядок событий может немного изменяться в зависимости от того, предусматривают ли Reliable Services отслеживание состояния.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-117">In particular, the order of events may change slightly depending on whether the Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="4c5c9-118">В случае со службами с отслеживанием состояния приходится иметь дело со сценарием переключения первичной реплики.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-118">In addition, for stateful services, we have to deal with the Primary swap scenario.</span></span> <span data-ttu-id="4c5c9-119">Во время этой процедуры первичная роль передается другой реплике (или возвращается) без завершения работы службы.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="4c5c9-120">И, наконец, следует учитывать условия ошибок и сбоев.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-120">Finally, we have to think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="4c5c9-121">Запуск службы без отслеживания состояния</span><span class="sxs-lookup"><span data-stu-id="4c5c9-121">Stateless service startup</span></span>
<span data-ttu-id="4c5c9-122">Жизненный цикл службы без отслеживания состояния достаточно прост.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-122">The lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="4c5c9-123">Ниже приведен порядок событий.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-123">Here's the order of events:</span></span>

1. <span data-ttu-id="4c5c9-124">Создается служба.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-124">The Service is constructed</span></span>
2. <span data-ttu-id="4c5c9-125">Затем одновременно происходят две вещи:</span><span class="sxs-lookup"><span data-stu-id="4c5c9-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="4c5c9-126">вызывается метод `StatelessService.createServiceInstanceListeners()` и открываются все возвращаемые прослушиватели (для каждого прослушивателя вызывается `CommunicationListener.openAsync()`);</span><span class="sxs-lookup"><span data-stu-id="4c5c9-126">`StatelessService.createServiceInstanceListeners()` is invoked and any returned listeners are Opened (`CommunicationListener.openAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="4c5c9-127">вызывается метод RunAsync службы (`StatelessService.runAsync()`).</span><span class="sxs-lookup"><span data-stu-id="4c5c9-127">The service's runAsync method (`StatelessService.runAsync()`) is called</span></span>
3. <span data-ttu-id="4c5c9-128">При наличии вызывается собственный метод службы OnOpenAsync (в частности, вызывается `StatelessService.onOpenAsync()`).</span><span class="sxs-lookup"><span data-stu-id="4c5c9-128">If present, the service's own onOpenAsync method is called (Specifically, `StatelessService.onOpenAsync()` is called.</span></span> <span data-ttu-id="4c5c9-129">Это редко используемое переопределение, но оно доступно.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-129">This is an uncommon override but it is available).</span></span>

<span data-ttu-id="4c5c9-130">Важно отметить, что между вызовами методов для создания и открытия прослушивателей и RunAsync нет упорядоченности.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-130">It is important to note that there is no ordering between the calls to create and open the listeners and runAsync.</span></span> <span data-ttu-id="4c5c9-131">Прослушиватели могут быть открыты перед запуском RunAsync.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-131">The listeners may open before runAsync is started.</span></span> <span data-ttu-id="4c5c9-132">Аналогичным образом метод RunAsync может быть вызван перед открытием или созданием прослушивателей связи.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-132">Similarly, runAsync may end up invoked before the communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="4c5c9-133">Если синхронизация не требуется, она остается в качестве упражнения для разработчика.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-133">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="4c5c9-134">Ниже приведены распространенные решения.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-134">Common solutions:</span></span>

* <span data-ttu-id="4c5c9-135">Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-135">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="4c5c9-136">Для служб без отслеживания состояния такие задачи обычно могут выполняться в конструкторе службы во время вызова `createServiceInstanceListeners()` или в рамках создания самого прослушивателя.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-136">For stateless services that work can usually be done in the service's constructor, during the `createServiceInstanceListeners()` call, or as a part of the construction of the listener itself.</span></span>
* <span data-ttu-id="4c5c9-137">Иногда код в RunAsync не запускается, пока прослушиватели открыты.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-137">Sometimes the code in runAsync does not want to start until the listeners are open.</span></span> <span data-ttu-id="4c5c9-138">В этом случае необходима дополнительная координация.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-138">In this case additional coordination is necessary.</span></span> <span data-ttu-id="4c5c9-139">Распространенным решением является использование в прослушивателях флагов, указывающих, что прослушиватели завершили работу. Их необходимо установить в RunAsync, прежде чем приступать к фактической работе.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-139">One common solution is some flag within the listeners indicating when they have completed, which is checked in runAsync before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="4c5c9-140">Завершение работы службы без отслеживания состояния</span><span class="sxs-lookup"><span data-stu-id="4c5c9-140">Stateless service shutdown</span></span>
<span data-ttu-id="4c5c9-141">При завершении работы службы без отслеживания состояния те же операции выполняются в обратном порядке.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-141">When shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="4c5c9-142">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="4c5c9-142">In parallel</span></span>
    - <span data-ttu-id="4c5c9-143">все открытые прослушиватели закрываются (для каждого прослушивателя вызывается `CommunicationListener.closeAsync()`);</span><span class="sxs-lookup"><span data-stu-id="4c5c9-143">Any open listeners are Closed (`CommunicationListener.closeAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="4c5c9-144">маркер отмены, переданный в `runAsync()`, отменяется (в результате проверки свойства `isCancelled` маркера отмены возвращается значение true, а при вызове метода `throwIfCancellationRequested` маркера возвращается `CancellationException`).</span><span class="sxs-lookup"><span data-stu-id="4c5c9-144">The cancellation token passed to `runAsync()` is canceled (checking the cancellation token's `isCancelled` property returns true, and if called the token's `throwIfCancellationRequested` method throws a `CancellationException`)</span></span>
2. <span data-ttu-id="4c5c9-145">После выполнения метода `closeAsync()` для каждого прослушивателя и завершения выполнения `runAsync()` при наличии вызывается метод `StatelessService.onCloseAsync()` службы (это редкое переопределение).</span><span class="sxs-lookup"><span data-stu-id="4c5c9-145">Once `closeAsync()` completes on each listener and `runAsync()` also completes, the service's `StatelessService.onCloseAsync()` method is called, if present (again this is an uncommon override).</span></span>
3. <span data-ttu-id="4c5c9-146">После выполнения метода `StatelessService.onCloseAsync()` объект службы уничтожается.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-146">After `StatelessService.onCloseAsync()` completes, the service object is destructed</span></span>

## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="4c5c9-147">Примечания о жизненном цикле службы</span><span class="sxs-lookup"><span data-stu-id="4c5c9-147">Notes on service lifecycle</span></span>
* <span data-ttu-id="4c5c9-148">Метод `runAsync()` и вызовы `createServiceInstanceListeners` являются необязательны.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-148">Both the `runAsync()` method and the `createServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="4c5c9-149">В службе может использоваться один из их, оба или ни одного.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-149">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="4c5c9-150">Например, если служба выполняет всю работу в ответ на вызовы пользователя, реализовывать метод `runAsync()` не нужно.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-150">For example, if the service does all its work in response to user calls, there is no need for it to implement `runAsync()`.</span></span> <span data-ttu-id="4c5c9-151">Необходимы только прослушиватели связи и соответствующий код.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-151">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="4c5c9-152">Создание и возвращение прослушивателей связи является необязательным, так как у службы может быть только фоновая работа, поэтому достаточно реализовать `runAsync()`.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-152">Similarly, creating and returning communication listeners is optional, as the service may have only background work to do, and so only needs to implement `runAsync()`</span></span>
* <span data-ttu-id="4c5c9-153">Служба может успешно завершить `runAsync()` и вернуться из него.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-153">It is valid for a service to complete `runAsync()` successfully and return from it.</span></span> <span data-ttu-id="4c5c9-154">Это не считается сбоем и представляет фоновую работу завершения службы.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-154">This is not considered a failure condition and would represent the background work of the service completing.</span></span> <span data-ttu-id="4c5c9-155">Для надежных служб с отслеживанием состояния `runAsync()` будет вызываться снова, если служба была понижена с первичной, а затем обратно повышена.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-155">For stateful reliable services `runAsync()` would be called again if the service were demoted from primary and then promoted back to primary.</span></span>
* <span data-ttu-id="4c5c9-156">Если служба выходит при выполнении `runAsync()`, выдавая непредвиденные исключения, — это сбой. Объект службы завершает работу, и возникает ошибка работоспособности.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-156">If a service exits from `runAsync()` by throwing some unexpected exception, this is a failure and the service object is shut down and a health error reported.</span></span>
* <span data-ttu-id="4c5c9-157">Несмотря на то, что возвращение этих методов не ограничивается по времени, вы не сможете выполнять запись, а значит, и выполнить какую-либо действительную задачу.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-157">While there is no time limit on returning from these methods, you immediately lose the ability to write and therefore cannot complete any real work.</span></span> <span data-ttu-id="4c5c9-158">После получения запроса на отмену рекомендуется возвращать методы как можно быстрее.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-158">It is recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="4c5c9-159">Если служба не отвечает на такие вызовы API в течение приемлемого промежутка времени, Service Fabric может принудительно завершить работу службы.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-159">If your service does not respond to these API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="4c5c9-160">Обычно это происходит только во время обновления приложения или при удалении службы.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-160">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="4c5c9-161">По умолчанию время ожидания составляет 15 минут.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-161">This timeout is 15 minutes by default.</span></span>
* <span data-ttu-id="4c5c9-162">Сбои в пути `onCloseAsync()` приводят к вызову `onAbort()`, что является последней наилучшей возможностью для службы очистить и освободить все запрошенные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-162">Failures in the `onCloseAsync()` path result in `onAbort()` being called which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span>

> [!NOTE]
> <span data-ttu-id="4c5c9-163">Сейчас Java не поддерживает службы Reliable Services с отслеживанием состояния.</span><span class="sxs-lookup"><span data-stu-id="4c5c9-163">Stateful reliable services are not supported in java yet.</span></span>
>
>

## <a name="next-steps"></a><span data-ttu-id="4c5c9-164">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="4c5c9-164">Next steps</span></span>
* [<span data-ttu-id="4c5c9-165">Обзор надежных служб</span><span class="sxs-lookup"><span data-stu-id="4c5c9-165">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
* [<span data-ttu-id="4c5c9-166">Краткое руководство по надежным службам Reliable Services</span><span class="sxs-lookup"><span data-stu-id="4c5c9-166">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="4c5c9-167">Продвинутое использование надежных служб</span><span class="sxs-lookup"><span data-stu-id="4c5c9-167">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
