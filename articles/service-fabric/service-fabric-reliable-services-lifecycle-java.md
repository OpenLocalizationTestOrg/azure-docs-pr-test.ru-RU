---
title: "Общие сведения о жизненном цикле Reliable Services в Azure Service Fabric | Документация Майкрософт"
description: "Сведения о различных событиях жизненного цикла служб Reliable Services в Service Fabric"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 80eb68346dd05c256c60725eb082aa0651fe7cbd
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a>Жизненный цикл Reliable Services
> [!div class="op_single_selector"]
> * [C# в Windows](service-fabric-reliable-services-lifecycle.md)
> * [Java в Linux](service-fabric-reliable-services-lifecycle-java.md)
>
>

Если речь идет о жизненных циклах служб Reliable Services, наиболее важны основные аспекты, а именно:

* во время запуска:
  * создаются службы;
  * они могут создавать и возвращать ни одного или несколько прослушивателей;
  * все возвращаемые прослушиватели открываются, что разрешает взаимодействие со службой;
  * вызывается метод RunAsync службы, позволяя службе выполнять длительную или фоновую работу;
* во время завершения работы:
  * токен отмены, переданный в RunAsync, отменяется, и прослушиватели закрываются;
  * после этого уничтожается сам объект службы.

Следует отметить некоторые моменты, связанные с точным порядком этих событий. В частности, порядок событий может немного изменяться в зависимости от того, предусматривают ли Reliable Services отслеживание состояния. В случае со службами с отслеживанием состояния приходится иметь дело со сценарием переключения первичной реплики. Во время этой процедуры первичная роль передается другой реплике (или возвращается) без завершения работы службы. И, наконец, следует учитывать условия ошибок и сбоев.

## <a name="stateless-service-startup"></a>Запуск службы без отслеживания состояния
Жизненный цикл службы без отслеживания состояния достаточно прост. Ниже приведен порядок событий.

1. Создается служба.
2. Затем одновременно происходят две вещи:
    - вызывается метод `StatelessService.createServiceInstanceListeners()` и открываются все возвращаемые прослушиватели (для каждого прослушивателя вызывается `CommunicationListener.openAsync()`);
    - вызывается метод RunAsync службы (`StatelessService.runAsync()`).
3. При наличии вызывается собственный метод службы OnOpenAsync (в частности, вызывается `StatelessService.onOpenAsync()`). Это редко используемое переопределение, но оно доступно.

Важно отметить, что между вызовами методов для создания и открытия прослушивателей и RunAsync нет упорядоченности. Прослушиватели могут быть открыты перед запуском RunAsync. Аналогичным образом метод RunAsync может быть вызван перед открытием или созданием прослушивателей связи. Если синхронизация не требуется, она остается в качестве упражнения для разработчика. Ниже приведены распространенные решения.

* Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи. Для служб без отслеживания состояния такие задачи обычно могут выполняться в конструкторе службы во время вызова `createServiceInstanceListeners()` или в рамках создания самого прослушивателя.
* Иногда код в RunAsync не запускается, пока прослушиватели открыты. В этом случае необходима дополнительная координация. Распространенным решением является использование в прослушивателях флагов, указывающих, что прослушиватели завершили работу. Их необходимо установить в RunAsync, прежде чем приступать к фактической работе.

## <a name="stateless-service-shutdown"></a>Завершение работы службы без отслеживания состояния
При завершении работы службы без отслеживания состояния те же операции выполняются в обратном порядке.

1. В параллельном режиме:
    - все открытые прослушиватели закрываются (для каждого прослушивателя вызывается `CommunicationListener.closeAsync()`);
    - маркер отмены, переданный в `runAsync()`, отменяется (в результате проверки свойства `isCancelled` маркера отмены возвращается значение true, а при вызове метода `throwIfCancellationRequested` маркера возвращается `CancellationException`).
2. После выполнения метода `closeAsync()` для каждого прослушивателя и завершения выполнения `runAsync()` при наличии вызывается метод `StatelessService.onCloseAsync()` службы (это редкое переопределение).
3. После выполнения метода `StatelessService.onCloseAsync()` объект службы уничтожается.

## <a name="notes-on-service-lifecycle"></a>Примечания о жизненном цикле службы
* Метод `runAsync()` и вызовы `createServiceInstanceListeners` являются необязательны. В службе может использоваться один из их, оба или ни одного. Например, если служба выполняет всю работу в ответ на вызовы пользователя, реализовывать метод `runAsync()` не нужно. Необходимы только прослушиватели связи и соответствующий код. Создание и возвращение прослушивателей связи является необязательным, так как у службы может быть только фоновая работа, поэтому достаточно реализовать `runAsync()`.
* Служба может успешно завершить `runAsync()` и вернуться из него. Это не считается сбоем и представляет фоновую работу завершения службы. Для надежных служб с отслеживанием состояния `runAsync()` будет вызываться снова, если служба была понижена с первичной, а затем обратно повышена.
* Если служба выходит при выполнении `runAsync()`, выдавая непредвиденные исключения, — это сбой. Объект службы завершает работу, и возникает ошибка работоспособности.
* Несмотря на то, что возвращение этих методов не ограничивается по времени, вы не сможете выполнять запись, а значит, и выполнить какую-либо действительную задачу. После получения запроса на отмену рекомендуется возвращать методы как можно быстрее. Если служба не отвечает на такие вызовы API в течение приемлемого промежутка времени, Service Fabric может принудительно завершить работу службы. Обычно это происходит только во время обновления приложения или при удалении службы. По умолчанию время ожидания составляет 15 минут.
* Сбои в пути `onCloseAsync()` приводят к вызову `onAbort()`, что является последней наилучшей возможностью для службы очистить и освободить все запрошенные ресурсы.

> [!NOTE]
> Сейчас Java не поддерживает службы Reliable Services с отслеживанием состояния.
>
>

## <a name="next-steps"></a>Дальнейшие действия
* [Обзор надежных служб](service-fabric-reliable-services-introduction.md)
* [Краткое руководство по надежным службам Reliable Services](service-fabric-reliable-services-quick-start.md)
* [Продвинутое использование надежных служб](service-fabric-reliable-services-advanced-usage.md)
