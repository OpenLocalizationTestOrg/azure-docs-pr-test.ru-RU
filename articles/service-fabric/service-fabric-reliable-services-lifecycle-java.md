---
title: "aaaOverview жизненного цикла hello служб Azure Service Fabric надежного | Документы Microsoft"
description: "Дополнительные сведения о событиях жизненного цикла различных hello в Service Fabric надежного обмена"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 6d48c217d12bc5248c2da57b544aac747cecd872
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="7e437-103">Жизненный цикл Reliable Services</span><span class="sxs-lookup"><span data-stu-id="7e437-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="7e437-104">C# в Windows</span><span class="sxs-lookup"><span data-stu-id="7e437-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="7e437-105">Java в Linux</span><span class="sxs-lookup"><span data-stu-id="7e437-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="7e437-106">Если говорить о жизненном цикле hello надежных служб основы hello hello жизненного цикла являются наиболее важных hello.</span><span class="sxs-lookup"><span data-stu-id="7e437-106">When thinking about hello lifecycles of Reliable Services, hello basics of hello lifecycle are hello most important.</span></span> <span data-ttu-id="7e437-107">а именно:</span><span class="sxs-lookup"><span data-stu-id="7e437-107">In general:</span></span>

* <span data-ttu-id="7e437-108">во время запуска:</span><span class="sxs-lookup"><span data-stu-id="7e437-108">During Startup</span></span>
  * <span data-ttu-id="7e437-109">создаются службы;</span><span class="sxs-lookup"><span data-stu-id="7e437-109">Services are constructed</span></span>
  * <span data-ttu-id="7e437-110">Они имеют возможность tooconstruct и возвращают ноль или несколько прослушивателей</span><span class="sxs-lookup"><span data-stu-id="7e437-110">They have an opportunity tooconstruct and return zero or more listeners</span></span>
  * <span data-ttu-id="7e437-111">Любые возвращенные прослушиватели должны быть открыты соединение со службой hello</span><span class="sxs-lookup"><span data-stu-id="7e437-111">Any returned listeners are opened, allowing communication with hello service</span></span>
  * <span data-ttu-id="7e437-112">вызывается метод runAsync Hello службы, позволяя hello toodo службы долго выполняющиеся или фон рабочего</span><span class="sxs-lookup"><span data-stu-id="7e437-112">hello Service's runAsync method is called, allowing hello service toodo long running or background work</span></span>
* <span data-ttu-id="7e437-113">во время завершения работы:</span><span class="sxs-lookup"><span data-stu-id="7e437-113">During shutdown</span></span>
  * <span data-ttu-id="7e437-114">Hello отмены маркера переданный toorunAsync отменяется и закрываются прослушиватели hello</span><span class="sxs-lookup"><span data-stu-id="7e437-114">hello cancellation token passed toorunAsync is canceled, and hello listeners are closed</span></span>
  * <span data-ttu-id="7e437-115">После ее завершения, уничтожении сам объект службы hello</span><span class="sxs-lookup"><span data-stu-id="7e437-115">Once that is complete, hello service object itself is destructed</span></span>

<span data-ttu-id="7e437-116">Подробно о вокруг hello точный порядок этих событий.</span><span class="sxs-lookup"><span data-stu-id="7e437-116">There are details around hello exact ordering of these events.</span></span> <span data-ttu-id="7e437-117">В частности hello порядок событий может немного измениться в зависимости от того, является ли hello надежной службы Stateless или с отслеживанием состояния.</span><span class="sxs-lookup"><span data-stu-id="7e437-117">In particular, hello order of events may change slightly depending on whether hello Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="7e437-118">Кроме того для служб с отслеживанием состояния, у нас есть toodeal со сценарием основной swap hello.</span><span class="sxs-lookup"><span data-stu-id="7e437-118">In addition, for stateful services, we have toodeal with hello Primary swap scenario.</span></span> <span data-ttu-id="7e437-119">Во время этой последовательности hello роль первичной репликой переносятся tooanother (или возобновляет) без отключения службы hello.</span><span class="sxs-lookup"><span data-stu-id="7e437-119">During this sequence, hello role of Primary is transferred tooanother replica (or comes back) without hello service shutting down.</span></span> <span data-ttu-id="7e437-120">Наконец у нас есть toothink об условиях ошибок и сбоев.</span><span class="sxs-lookup"><span data-stu-id="7e437-120">Finally, we have toothink about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="7e437-121">Запуск службы без отслеживания состояния</span><span class="sxs-lookup"><span data-stu-id="7e437-121">Stateless service startup</span></span>
<span data-ttu-id="7e437-122">жизненный цикл службы без отслеживания состояния Hello выполняется очень просто.</span><span class="sxs-lookup"><span data-stu-id="7e437-122">hello lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="7e437-123">Ниже приведен порядок событий hello.</span><span class="sxs-lookup"><span data-stu-id="7e437-123">Here's hello order of events:</span></span>

1. <span data-ttu-id="7e437-124">Hello службы создается</span><span class="sxs-lookup"><span data-stu-id="7e437-124">hello Service is constructed</span></span>
2. <span data-ttu-id="7e437-125">Затем одновременно происходят две вещи:</span><span class="sxs-lookup"><span data-stu-id="7e437-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="7e437-126">вызывается метод `StatelessService.createServiceInstanceListeners()` и открываются все возвращаемые прослушиватели (для каждого прослушивателя вызывается `CommunicationListener.openAsync()`);</span><span class="sxs-lookup"><span data-stu-id="7e437-126">`StatelessService.createServiceInstanceListeners()` is invoked and any returned listeners are Opened (`CommunicationListener.openAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="7e437-127">Здравствуйте, метод runAsync службы (`StatelessService.runAsync()`) называется</span><span class="sxs-lookup"><span data-stu-id="7e437-127">hello service's runAsync method (`StatelessService.runAsync()`) is called</span></span>
3. <span data-ttu-id="7e437-128">Если присутствует, вызывается метод onOpenAsync hello службы (в частности, `StatelessService.onOpenAsync()` вызывается.</span><span class="sxs-lookup"><span data-stu-id="7e437-128">If present, hello service's own onOpenAsync method is called (Specifically, `StatelessService.onOpenAsync()` is called.</span></span> <span data-ttu-id="7e437-129">Это редко используемое переопределение, но оно доступно.</span><span class="sxs-lookup"><span data-stu-id="7e437-129">This is an uncommon override but it is available).</span></span>

<span data-ttu-id="7e437-130">Это важные toonote, это не порядок toocreate вызовы hello и откройте hello прослушивателей и runAsync.</span><span class="sxs-lookup"><span data-stu-id="7e437-130">It is important toonote that there is no ordering between hello calls toocreate and open hello listeners and runAsync.</span></span> <span data-ttu-id="7e437-131">Перед запуском runAsync, может открыть Hello прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="7e437-131">hello listeners may open before runAsync is started.</span></span> <span data-ttu-id="7e437-132">Аналогичным образом runAsync может оказаться вызывается перед прослушивания связи hello открыты или даже были построены.</span><span class="sxs-lookup"><span data-stu-id="7e437-132">Similarly, runAsync may end up invoked before hello communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="7e437-133">Если необходима синхронизация, она останется при реализации toohello упражнении.</span><span class="sxs-lookup"><span data-stu-id="7e437-133">If any synchronization is required, it is left as an exercise toohello implementer.</span></span> <span data-ttu-id="7e437-134">Ниже приведены распространенные решения.</span><span class="sxs-lookup"><span data-stu-id="7e437-134">Common solutions:</span></span>

* <span data-ttu-id="7e437-135">Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи.</span><span class="sxs-lookup"><span data-stu-id="7e437-135">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="7e437-136">Для службы без сохранения состояния, которые работы обычно выполняются в конструкторе hello службы во время hello `createServiceInstanceListeners()` вызвать, либо в качестве части конструкции "hello" сам прослушиватель hello.</span><span class="sxs-lookup"><span data-stu-id="7e437-136">For stateless services that work can usually be done in hello service's constructor, during hello `createServiceInstanceListeners()` call, or as a part of hello construction of hello listener itself.</span></span>
* <span data-ttu-id="7e437-137">Иногда hello кода в runAsync не требуется toostart пока открыты hello прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="7e437-137">Sometimes hello code in runAsync does not want toostart until hello listeners are open.</span></span> <span data-ttu-id="7e437-138">В этом случае необходима дополнительная координация.</span><span class="sxs-lookup"><span data-stu-id="7e437-138">In this case additional coordination is necessary.</span></span> <span data-ttu-id="7e437-139">Общие решением проблемы является некоторые флаг за hello прослушивателей, указывающее, когда они завершили, который runAsync проверяется перед продолжением работы tooactual.</span><span class="sxs-lookup"><span data-stu-id="7e437-139">One common solution is some flag within hello listeners indicating when they have completed, which is checked in runAsync before continuing tooactual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="7e437-140">Завершение работы службы без отслеживания состояния</span><span class="sxs-lookup"><span data-stu-id="7e437-140">Stateless service shutdown</span></span>
<span data-ttu-id="7e437-141">При выключении службы без отслеживания состояния, Привет одному шаблону, просто в обратном направлении:</span><span class="sxs-lookup"><span data-stu-id="7e437-141">When shutting down a stateless service, hello same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="7e437-142">В параллельном режиме:</span><span class="sxs-lookup"><span data-stu-id="7e437-142">In parallel</span></span>
    - <span data-ttu-id="7e437-143">все открытые прослушиватели закрываются (для каждого прослушивателя вызывается `CommunicationListener.closeAsync()`);</span><span class="sxs-lookup"><span data-stu-id="7e437-143">Any open listeners are Closed (`CommunicationListener.closeAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="7e437-144">токен отмены Hello передано слишком`runAsync()` отменяется (проверка токена отмены hello `isCancelled` свойство возвращает значение true и при вызове hello токен `throwIfCancellationRequested` вызывает исключение `CancellationException`)</span><span class="sxs-lookup"><span data-stu-id="7e437-144">hello cancellation token passed too`runAsync()` is canceled (checking hello cancellation token's `isCancelled` property returns true, and if called hello token's `throwIfCancellationRequested` method throws a `CancellationException`)</span></span>
2. <span data-ttu-id="7e437-145">Один раз `closeAsync()` завершения на каждый прослушиватель и `runAsync()` также завершается hello службы `StatelessService.onCloseAsync()` метод вызывается, если он имеется (снова это переопределение редко).</span><span class="sxs-lookup"><span data-stu-id="7e437-145">Once `closeAsync()` completes on each listener and `runAsync()` also completes, hello service's `StatelessService.onCloseAsync()` method is called, if present (again this is an uncommon override).</span></span>
3. <span data-ttu-id="7e437-146">После `StatelessService.onCloseAsync()` завершения уничтожении hello объекта службы</span><span class="sxs-lookup"><span data-stu-id="7e437-146">After `StatelessService.onCloseAsync()` completes, hello service object is destructed</span></span>

## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="7e437-147">Примечания о жизненном цикле службы</span><span class="sxs-lookup"><span data-stu-id="7e437-147">Notes on service lifecycle</span></span>
* <span data-ttu-id="7e437-148">Оба hello `runAsync()` метод и hello `createServiceInstanceListeners` вызовы являются необязательными.</span><span class="sxs-lookup"><span data-stu-id="7e437-148">Both hello `runAsync()` method and hello `createServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="7e437-149">В службе может использоваться один из их, оба или ни одного.</span><span class="sxs-lookup"><span data-stu-id="7e437-149">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="7e437-150">Например, если служба hello выполняет свою работу в вызовах toouser ответа, нет необходимости для него tooimplement `runAsync()`.</span><span class="sxs-lookup"><span data-stu-id="7e437-150">For example, if hello service does all its work in response toouser calls, there is no need for it tooimplement `runAsync()`.</span></span> <span data-ttu-id="7e437-151">Необходимы только hello прослушивания связи и их кода.</span><span class="sxs-lookup"><span data-stu-id="7e437-151">Only hello communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="7e437-152">Аналогичным образом Создание и возвращение прослушивания связи является необязательной, поскольку служба hello может иметь только фоновой работы toodo и поэтому достаточно tooimplement`runAsync()`</span><span class="sxs-lookup"><span data-stu-id="7e437-152">Similarly, creating and returning communication listeners is optional, as hello service may have only background work toodo, and so only needs tooimplement `runAsync()`</span></span>
* <span data-ttu-id="7e437-153">Он является допустимым для toocomplete службы `runAsync()` успешно и вернуть из нее.</span><span class="sxs-lookup"><span data-stu-id="7e437-153">It is valid for a service toocomplete `runAsync()` successfully and return from it.</span></span> <span data-ttu-id="7e437-154">Это рассматривается как условие сбоя и представляют собой hello фоновой работы после завершения обновления hello.</span><span class="sxs-lookup"><span data-stu-id="7e437-154">This is not considered a failure condition and would represent hello background work of hello service completing.</span></span> <span data-ttu-id="7e437-155">Для надежных служб с отслеживанием состояния `runAsync()` будет вызываться снова, если служба hello были понижены от основного и затем повышается задней tooprimary.</span><span class="sxs-lookup"><span data-stu-id="7e437-155">For stateful reliable services `runAsync()` would be called again if hello service were demoted from primary and then promoted back tooprimary.</span></span>
* <span data-ttu-id="7e437-156">Если служба выполняет выход из `runAsync()` путем создания исключения некоторые непредвиденное исключение, это сбой и выключить hello объекта службы, и ошибка работоспособности.</span><span class="sxs-lookup"><span data-stu-id="7e437-156">If a service exits from `runAsync()` by throwing some unexpected exception, this is a failure and hello service object is shut down and a health error reported.</span></span>
* <span data-ttu-id="7e437-157">Пока нет ограничения времени после возвращения из этих методов, вы сразу же потеряют возможность toowrite hello и поэтому не может завершить какой-либо реальной работы.</span><span class="sxs-lookup"><span data-stu-id="7e437-157">While there is no time limit on returning from these methods, you immediately lose hello ability toowrite and therefore cannot complete any real work.</span></span> <span data-ttu-id="7e437-158">Рекомендуется восстановить как можно быстрее при получении запроса отмены hello.</span><span class="sxs-lookup"><span data-stu-id="7e437-158">It is recommended that you return as quickly as possible upon receiving hello cancellation request.</span></span> <span data-ttu-id="7e437-159">Если служба не отвечает toothese API-вызовов за приемлемое время Service Fabric может принудительно прекратить использование службы.</span><span class="sxs-lookup"><span data-stu-id="7e437-159">If your service does not respond toothese API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="7e437-160">Обычно это происходит только во время обновления приложения или при удалении службы.</span><span class="sxs-lookup"><span data-stu-id="7e437-160">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="7e437-161">По умолчанию время ожидания составляет 15 минут.</span><span class="sxs-lookup"><span data-stu-id="7e437-161">This timeout is 15 minutes by default.</span></span>
* <span data-ttu-id="7e437-162">Сбои в hello `onCloseAsync()` результирующий путь в `onAbort()` называемый, это возможность последнего вероятность усилия для hello службы tooclean вверх и освободить все ресурсы, которые они уже запросили.</span><span class="sxs-lookup"><span data-stu-id="7e437-162">Failures in hello `onCloseAsync()` path result in `onAbort()` being called which is a last-chance best-effort opportunity for hello service tooclean up and release any resources that they have claimed.</span></span>

> [!NOTE]
> <span data-ttu-id="7e437-163">Сейчас Java не поддерживает службы Reliable Services с отслеживанием состояния.</span><span class="sxs-lookup"><span data-stu-id="7e437-163">Stateful reliable services are not supported in java yet.</span></span>
>
>

## <a name="next-steps"></a><span data-ttu-id="7e437-164">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="7e437-164">Next steps</span></span>
* [<span data-ttu-id="7e437-165">Введение tooReliable служб</span><span class="sxs-lookup"><span data-stu-id="7e437-165">Introduction tooReliable Services</span></span>](service-fabric-reliable-services-introduction.md)
* [<span data-ttu-id="7e437-166">Краткое руководство по надежным службам Reliable Services</span><span class="sxs-lookup"><span data-stu-id="7e437-166">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="7e437-167">Продвинутое использование надежных служб</span><span class="sxs-lookup"><span data-stu-id="7e437-167">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
