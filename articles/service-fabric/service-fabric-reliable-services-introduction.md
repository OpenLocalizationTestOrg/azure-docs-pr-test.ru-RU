---
title: "Общие сведения о модели программирования Service Fabric Reliable Services | Документация Майкрософт"
description: "Сведения о модели программирования надежных служб Service Fabric, позволяющие приступить к написанию собственных служб."
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek; mani-ramaswamy
ms.assetid: 0c88a533-73f8-4ae1-a939-67d17456ac06
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 8/9/2017
ms.author: masnider;
ms.openlocfilehash: 601b1c7713c9785d949c1c72000ec7f3f63dd682
ms.sourcegitcommit: 6699c77dcbd5f8a1a2f21fba3d0a0005ac9ed6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2017
---
# <a name="reliable-services-overview"></a>Обзор надежных служб
Платформа Azure Service Fabric упрощает написание надежных служб с отслеживанием и без отслеживания состояния и управление такими службами. В этой статье рассматриваются следующие вопросы.

* Модель программирования надежных служб для служб с отслеживанием состояния и без него.
* Варианты выбора при написании надежной службы.
* Некоторые сценарии и примеры использования надежных служб, а также способ их написания.

Надежные службы являются одной из моделей программирования, доступных в Service Fabric. Другая модель программирования — модель Reliable Actors, которая в дополнение к модели Reliable Services предоставляет модель программирования на основе виртуальных субъектов. Дополнительные сведения о модели программирования Reliable Actors см. в статье [Общие сведения о надежных субъектах Service Fabric](service-fabric-reliable-actors-introduction.md).

Service Fabric управляет временем существования служб от подготовки и развертывания до обновления и удаления посредством [управления приложениями Service Fabric](service-fabric-deploy-remove-applications.md).

## <a name="what-are-reliable-services"></a>Что такое надежные службы?
Надежные службы — это простая, мощная, верхнеуровневая модель программирования, открывающая широкие и гибкие возможности для разработки приложений. С помощью модели программирования надежных служб вы получаете такие возможности:

* Доступ к остальным программным интерфейсам API платформы Service Fabric. В отличие от служб Service Fabric, смоделированных в виде [гостевых исполняемых файлов](service-fabric-deploy-existing-app.md), Reliable Services напрямую использует остальные API-интерфейсы платформы Service Fabric. Это дает службам такие возможности:
  * выполнение запросов к системе;
  * создание отчетов о работоспособности сущностей в кластере;
  * получение уведомлений об изменениях конфигурации и кода;
  * поиск других служб и обмен данными с ними;
  * (необязательно) использование коллекций [Reliable Collections](service-fabric-reliable-services-reliable-collections.md);
  * доступ ко многим другим возможностям высококлассной модели программирования на нескольких языках программирования.
* Простая модель для выполнения собственного кода, которая похожа на привычные модели программирования: у создаваемого кода четко определенная точка входа и простой в управлении жизненный цикл.
* Модель взаимодействия со службами Транспорт может быть любым, включая HTTP с [веб-API](service-fabric-reliable-services-communication-webapi.md), протоколы WebSocket, пользовательские протоколы TCP и т. п. Надежные службы позволяют использовать ряд отличных готовых вариантов или задействовать собственный.
* Для служб с отслеживанием состояния модель программирования Reliable Services позволяет согласованно и надежно хранить состояние прямо в службе с помощью коллекций [Reliable Collections](service-fabric-reliable-services-reliable-collections.md). Reliable Collections — это простой набор классов коллекций с высокой доступностью и надежностью, которые будут знакомы всем, кто использовал коллекции C#. Обычно для надежного управления состоянием службам требовались внешние системы. Коллекции Reliable Collections обеспечивают хранение состояния вместе с вычислениями при таком же уровне доступности и надежности, как и в высокодоступных внешних хранилищах. Такая модель также сокращает задержку, потому что необходимые для работы данные состояния и вычисления хранятся рядом.

Посмотрите этот видеоролик от Microsoft Virtual Academy, который содержит обзор служб Reliable Services: <center>
<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=HhD9566yC_4106218965">
<img src="./media/service-fabric-reliable-services-introduction/ReliableServicesVid.png" WIDTH="360" HEIGHT="244" />
</a>
</center>

## <a name="what-makes-reliable-services-different"></a>Чем отличаются надежные службы
Надежные службы в Service Fabric отличаются от служб, которые вы могли создавать ранее. Service Fabric обеспечивает надежность, доступность, согласованность и масштабируемость.

* **Надежность** — служба остается активной даже в ненадежных средах, в которых компьютеры дают сбой или сталкиваются с ошибками сети, либо когда ошибки возникают в самих службах и происходит сбой. В службах с отслеживанием состояния состояние сохраняется даже при наличии ошибок сети или других сбоев.
* **Доступность** — служба доступна и отвечает на запросы. Платформа Service Fabric поддерживает нужное число запущенных копий.
* **Масштабируемость** — службы отвязываются от конкретного оборудования и могут увеличиваться или уменьшаться в масштабе (насколько нужно) путем добавления или удаления оборудования или других ресурсов. Службы легко секционируются (особенно в случае с отслеживанием состояния). Это дает возможность масштабировать службу и обрабатывать частичные сбои. Службы можно динамически создавать и удалять с помощью кода, развертывая по мере необходимости дополнительные экземпляры, например по запросу клиента. И наконец, платформа Service Fabric способствует тому, что службы имеют небольшой размер. Service Fabric позволяет подготавливать тысячи служб в рамках одного процесса. То есть нет необходимости выделять целые экземпляры ОС или процессы для одного экземпляра службы.
* **Согласованность** — гарантия согласованности любых данных, которые хранятся в этой службе. Это касается и согласованности между несколькими коллекциями Reliable Collections в пределах одной службы. Изменения в нескольких коллекциях в пределах службы можно выполнять путем атомарных транзакций.

## <a name="service-lifecycle"></a>Жизненный цикл службы
Независимо от того, какую службу вы используете (с отслеживанием или без отслеживания состояния), надежные службы обеспечивают простой жизненный цикл, позволяющий быстро подключить код и приступить к работе.  Для запуска службы необходимо реализовать всего лишь один или два метода.

* **CreateServiceReplicaListeners/CreateServiceInstanceListeners** — в этом методе служба определяет стеки связи, которые собирается использовать. Стек связи, например [веб-API](service-fabric-reliable-services-communication-webapi.md), определяет одну или несколько конечных точек прослушивания для службы (способ доступа к ней клиентов), а также определяет взаимодействие поступающих сообщений с остальным кодом службы.
* **RunAsync** — в этом методе выполняется бизнес-логика службы, а также запускаются все фоновые задачи, которые должны выполняться в течение всего времени существования службы. Предоставляемый токен отмены сигнализирует о моменте, когда работу следует остановить. Например, если служба должна извлекать сообщения из очереди Reliable Queue и обрабатывать их, это и будет местом выполнения соответствующей работы.

Если вы впервые узнали о Reliable Services, читайте статью дальше. Если вам необходимо подробное пошаговое руководство о жизненном цикле Reliable Services, можно перейти [к этой статье](service-fabric-reliable-services-lifecycle.md).

## <a name="example-services"></a>Примеры служб
Зная эту модель программирования, давайте кратко рассмотрим две разные службы, чтобы увидеть, как взаимодействуют все описанные элементы.

### <a name="stateless-reliable-services"></a>Надежные службы без отслеживания состояния
Служба без отслеживания состояния — это служба, в которой не поддерживается состояние в службе в пределах нескольких вызовов. Любое имеющееся состояние является одноразовым и не требует синхронизации, репликации, постоянного сохранения или высокой доступности.

Например, рассмотрим калькулятор — службу, которая не пользуется памятью и которая принимает все условия и операции для одновременного выполнения.

В этом случае метод `RunAsync()` (C#) или `runAsync()` (Java) службы может быть пустым, так как у службы нет необходимости в фоновой обработке задач. Когда создается служба калькулятора, она возвращает интерфейс `ICommunicationListener` (C#) или `CommunicationListener` (Java) (например, [веб-API](service-fabric-reliable-services-communication-webapi.md)), который открывает конечную точку прослушивания на том или ином порту. Эта конечная точка подключается к различным вычислительным методам (например, Add(n1, n2)), которые определяют общедоступный API калькулятора.

При клиентском вызове вызывается соответствующий метод, а калькулятор выполняет операции над предоставленными данными и возвращает результат. Никакого состояния она не хранит.

Это простой пример, так как в службе калькулятора внутреннее состояние не сохраняется. Большинство служб без отслеживания состояния не являются таковыми в полной мере, так как они записывают свои состояния в какое-либо внешнее хранилище (например, веб-приложение, хранящее состояние сеанса в резервном хранилище или кэше, не является службой без отслеживания состояния).

Распространенным примером использования служб без отслеживания состояния в Service Fabric является внешний интерфейс, который позволяет пользоваться общедоступным интерфейсом API для веб-приложения. Затем внешняя служба обменивается данными со службами с отслеживанием состояния для выполнения запроса пользователя. В этом случае вызовы от клиентов направляются на известный порт, например с номером 80, который прослушивает служба без отслеживания состояния. Такая служба получает вызов и определяет, поступил ли он из надежного источника, а также устанавливает, для какой службы он предназначен.  Затем служба без отслеживания состояния перенаправляет вызов на нужную секцию службы с отслеживанием состояния и ожидает ответа. При получении ответа служба без отслеживания состояния отвечает исходному клиенту. Пример такой службы можно найти в образцах [C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) / [Java](https://github.com/Azure-Samples/service-fabric-java-getting-started/tree/master/Actors/VisualObjectActor/VisualObjectWebService). Это только один из примеров данного шаблона. Существуют и другие.

### <a name="stateful-reliable-services"></a>Надежные службы с отслеживанием состояния
Служба с отслеживанием состояния — это служба, которой для надлежащего функционирования необходимо часть состояния поддерживать в согласованном виде. Рассмотрим службу, которая постоянно вычисляет скользящее среднее некоторых значений на основе получаемых обновлений. Для этого службе необходимо располагать текущим набором входящих запросов, которые требуется обработать, а также текущим средним значением. Любая служба, которая получает, обрабатывает и сохраняет информацию во внешнем хранилище (как это сегодня делается в хранилище BLOB-объектов или табличном хранилище Azure), является службой с отслеживанием состояния — она просто хранит свое состояние во внешнем хранилище состояний.

Большинство служб сегодня хранят свое состояние во внешних хранилищах, что обеспечивает надежность, доступность, масштабируемость и согласованность состояния. В Service Fabric необязательно, чтобы службы хранили состояние во внешних хранилищах. Service Fabric соответствует таким требованиям к коду и состоянию службы.

> [!NOTE]
> Поддержка надежных служб с отслеживанием состояния пока недоступна в Linux (для C# и Java).
>

Допустим, нам нужно создать службу, которая обрабатывает изображения. Для этого служба принимает изображение и ряд преобразований, которые необходимо с ним выполнить. Эта служба возвращает прослушиватель связи (допустим, веб-API), который предоставляет такой API, как `ConvertImage(Image i, IList<Conversion> conversions)`. Получив запрос, служба сохраняет его в `IReliableQueue` и возвращает клиенту идентификатор для отслеживания запроса.

В этой службе метод `RunAsync()` может быть более сложным. В методе `RunAsync()` этой службы существует цикл, который извлекает запросы из очереди `IReliableQueue` и выполняет запрошенные преобразования. Результаты сохраняются в `IReliableDictionary`. Когда клиент обращается к службе снова, он получает преобразованные изображения. Чтобы гарантировать, что даже в случае отказа изображение не будет утеряно, такая служба Reliable Service выполняет извлечение из очереди, преобразование и сохранение результата в одной транзакции. В таком случае сообщение удаляется из очереди и результаты сохраняются в словаре результатов только после завершения преобразований. Кроме того, служба может извлечь изображение из очереди и сразу же сохранить его в удаленном хранилище. Это уменьшает объем состояния, которым должна управлять служба, но увеличивает сложность, так как служба должна хранить необходимые метаданные для управления удаленным хранилищем. В обоих подходах при возникновении сбоя в процессе выполнения запрос остается в очереди, ожидая обработки.

Следует также отметить, что эта служба выглядит почти как обычная служба .NET. Единственная разница в том, что используемые структуры данных (`IReliableQueue` и `IReliableDictionary`) предоставляются платформой Service Fabric и для них обеспечивается высокая надежность, доступность и согласованность.

## <a name="when-to-use-reliable-services-apis"></a>Когда следует использовать API надежных служб
Если службе приложения требуется любая из приведенных ниже характеристик, следует рассмотреть возможность использования интерфейсов API надежных служб.

* Необходима высокая доступность и надежность кода службы (и при необходимости состояния).
* Необходимы гарантии выполнения транзакций между несколькими единицами состояния (например, заказами и позициями строки заказа).
* Состояние приложения можно естественным образом моделировать в виде надежных словарей и очередей.
* Код или состояние приложения должны иметь высокую доступность с низкой задержкой операций чтения и записи.
* Приложению требуется контролировать параллелизм или степень детализации транзакционных операций по одной или нескольким надежным коллекциям.
* Необходимо управлять обменом данными или контролировать схему секционирования службы.
* Коду требуется среда выполнения, работающая в режиме свободного потока.
* Приложению требуется динамически создавать или уничтожать словари Reliable Dictionary, очереди Reliable Queue или целые службы во время выполнения.
* Вам нужно программным способом управлять функциями резервного копирования и восстановления, которые предоставляет платформа Service Fabric и которые относятся к вашей службе.
* Приложению необходимо поддерживать историю изменений своих единиц состояния.
* Вам нужно разработать свои настраиваемые поставщики состояний или использовать сторонние.

## <a name="next-steps"></a>Дальнейшие действия
* [Краткое руководство по надежным службам Reliable Services](service-fabric-reliable-services-quick-start.md)
* [Продвинутое использование надежных служб](service-fabric-reliable-services-advanced-usage.md)
* [Модель программирования надежных субъектов](service-fabric-reliable-actors-introduction.md)
