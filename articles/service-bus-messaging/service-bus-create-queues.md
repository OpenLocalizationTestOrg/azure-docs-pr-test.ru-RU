---
title: "Создание приложений, использующих очереди служебной шины Azure | Документация Майкрософт"
description: "Как написать простое приложение на основе очереди, которое использует служебную шину Azure."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 419caff7e8ceeb419c89a2ef9a6614c1accf3e52
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="26dde-103">Создание приложений, использующих очереди служебной шины</span><span class="sxs-lookup"><span data-stu-id="26dde-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="26dde-104">В этом разделе описаны очереди служебной шины и показаны способы написания простого приложения на основе очереди, которое использует служебную шину.</span><span class="sxs-lookup"><span data-stu-id="26dde-104">This topic describes Service Bus queues and shows how to write a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="26dde-105">Рассмотрим сценарий из мира розничной продажи, в котором данные о продажах из отдельных точек продаж (POS) должны направляться в систему управления запасами, которая использует эти данные, чтобы определять необходимость пополнения запасов.</span><span class="sxs-lookup"><span data-stu-id="26dde-105">Consider a scenario from the world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed to an inventory management system that uses the data to determine when stock has to be replenished.</span></span> <span data-ttu-id="26dde-106">В этом решении используется обмен сообщениями служебной шины для обмена данными между терминалами и системой управления запасами, как показано на следующем рисунке:</span><span class="sxs-lookup"><span data-stu-id="26dde-106">This solution uses Service Bus messaging for the communication between the terminals and the inventory management system, as illustrated in the following figure:</span></span>

![Очереди служебной шины, рисунок 1](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="26dde-108">Каждый терминал POS передает данные о продажах путем отправки сообщений в очередь **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="26dde-108">Each POS terminal reports its sales data by sending messages to the **DataCollectionQueue**.</span></span> <span data-ttu-id="26dde-109">Эти сообщения остаются в этой очереди до тех пор, пока не извлекаются системой управления запасами.</span><span class="sxs-lookup"><span data-stu-id="26dde-109">These messages remain in this queue until they are retrieved by the inventory management system.</span></span> <span data-ttu-id="26dde-110">Эта схема часто называется *асинхронным обменом сообщениями*, так терминал POS не должен ждать ответа от системы управления запасами для продолжения обработки.</span><span class="sxs-lookup"><span data-stu-id="26dde-110">This pattern is often termed *asynchronous messaging*, because the POS terminal does not have to wait for a reply from the inventory management system to continue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="26dde-111">Зачем использовать очередь?</span><span class="sxs-lookup"><span data-stu-id="26dde-111">Why queuing?</span></span>
<span data-ttu-id="26dde-112">Прежде чем обратиться к коду данного приложения рассмотрим преимущества использования очереди по сравнению с прямым (синхронным) взаимодействием терминалов POS с системой управления запасами.</span><span class="sxs-lookup"><span data-stu-id="26dde-112">Before we look at the code that is required to set up this application, consider the advantages of using a queue in this scenario instead of having the POS terminals talk directly (synchronously) to the inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="26dde-113">Временное разделение</span><span class="sxs-lookup"><span data-stu-id="26dde-113">Temporal decoupling</span></span>
<span data-ttu-id="26dde-114">В асинхронной модели обмена отправители и получатели сообщений не обязательно должны находиться в сети одновременно.</span><span class="sxs-lookup"><span data-stu-id="26dde-114">With the asynchronous messaging pattern, producers and consumers do not have to be online at the same time.</span></span> <span data-ttu-id="26dde-115">Инфраструктура обмена сообщениями надежно хранит сообщения до тех пор, пока принимающая сторона не будет готова к их приему.</span><span class="sxs-lookup"><span data-stu-id="26dde-115">The messaging infrastructure reliably stores messages until the consuming party is ready to receive them.</span></span> <span data-ttu-id="26dde-116">Это означает, что возможно отключение компонентов распределенного приложения как в плановых ситуациях, например для обслуживания, так и в экстренных случаях, чтобы исключить влияние сбоя одного компонента на систему в целом.</span><span class="sxs-lookup"><span data-stu-id="26dde-116">This means the components of the distributed application can be disconnected, either voluntarily; for example, for maintenance, or due to a component crash, without affecting the whole system.</span></span> <span data-ttu-id="26dde-117">Более того, потребляющему приложению достаточно находиться в сети несколько раз в день в определенное время.</span><span class="sxs-lookup"><span data-stu-id="26dde-117">Furthermore, the consuming application may only have to be online during certain times of the day.</span></span> <span data-ttu-id="26dde-118">Например в данном сценарии розничной торговли, система управления запасами может подключиться к сети только после окончания рабочего дня.</span><span class="sxs-lookup"><span data-stu-id="26dde-118">For example, in this retail scenario, the inventory management system may only have to come online after the end of the business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="26dde-119">Выравнивание нагрузки</span><span class="sxs-lookup"><span data-stu-id="26dde-119">Load leveling</span></span>
<span data-ttu-id="26dde-120">Во многих приложениях уровень нагрузки на систему меняется с течением времени, тогда как время, затрачиваемое на обработку каждой рабочей единицы, как правило, постоянно.</span><span class="sxs-lookup"><span data-stu-id="26dde-120">In many applications system load varies over time, whereas the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="26dde-121">Благодаря обмену сообщениями между поставщиками и потребителями через посредника с использованием очереди потребляющее приложение (рабочую роль) достаточно подготовить для обработки средней, а не пиковой нагрузки.</span><span class="sxs-lookup"><span data-stu-id="26dde-121">Intermediating message producers and consumers with a queue means that the consuming application (the worker) only has to be provisioned to service an average load rather than a peak load.</span></span> <span data-ttu-id="26dde-122">В таких случаях при колебаниях входящей нагрузки просто изменяется глубина очереди.</span><span class="sxs-lookup"><span data-stu-id="26dde-122">The depth of the queue will grow and contract as the incoming load varies.</span></span> <span data-ttu-id="26dde-123">Это позволяет существенно сократить расходы на инфраструктуру, необходимую для обработки нагрузки приложения.</span><span class="sxs-lookup"><span data-stu-id="26dde-123">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span>

![Очереди служебной шины, рисунок 2](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="26dde-125">Балансировка нагрузки.</span><span class="sxs-lookup"><span data-stu-id="26dde-125">Load balancing</span></span>
<span data-ttu-id="26dde-126">По мере возрастания нагрузки могут потребоваться дополнительные рабочие роли для чтения из очереди рабочих ролей.</span><span class="sxs-lookup"><span data-stu-id="26dde-126">As the load increases, more worker processes can be added to read from the worker queue.</span></span> <span data-ttu-id="26dde-127">Каждое сообщение обрабатывается одним рабочим процессом.</span><span class="sxs-lookup"><span data-stu-id="26dde-127">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="26dde-128">Кроме того, балансировка нагрузки по запросу обеспечивает оптимальное использование компьютеров рабочих ролей с разной вычислительной мощностью, позволяя извлекать сообщения с максимально доступной скоростью.</span><span class="sxs-lookup"><span data-stu-id="26dde-128">Furthermore, this pull-based load balancing allows for optimum usage of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="26dde-129">Такая концепция часто называется моделью конкурирующих потребителей.</span><span class="sxs-lookup"><span data-stu-id="26dde-129">This pattern is often termed the competing consumer pattern.</span></span>

![Очереди служебной шины, рисунок 3](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="26dde-131">Слабые связи</span><span class="sxs-lookup"><span data-stu-id="26dde-131">Loose coupling</span></span>
<span data-ttu-id="26dde-132">Использование очередей сообщений в качестве посредника между производителями и потребителями сообщений уменьшает внутреннюю зависимость между компонентами.</span><span class="sxs-lookup"><span data-stu-id="26dde-132">Using message queuing to intermediate between message producers and consumers provides an intrinsic loose coupling between the components.</span></span> <span data-ttu-id="26dde-133">Так как производители и потребители не зависят друг от друга, обновление потребителя не оказывает влияния на производителя.</span><span class="sxs-lookup"><span data-stu-id="26dde-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span> <span data-ttu-id="26dde-134">Кроме того, топология обмена сообщениями может развиваться, не влияя на существующие конечные точки.</span><span class="sxs-lookup"><span data-stu-id="26dde-134">Furthermore, the messaging topology can evolve without affecting the existing endpoints.</span></span> <span data-ttu-id="26dde-135">Мы обсудим это подробнее, когда будем говорить о публикациях и подписках.</span><span class="sxs-lookup"><span data-stu-id="26dde-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-the-code"></a><span data-ttu-id="26dde-136">Покажите мне код</span><span class="sxs-lookup"><span data-stu-id="26dde-136">Show me the code</span></span>
<span data-ttu-id="26dde-137">Ниже показано, как использовать служебную шину для построения этого приложения.</span><span class="sxs-lookup"><span data-stu-id="26dde-137">The following section shows how to use Service Bus to build this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="26dde-138">Регистрация учетной записи Azure</span><span class="sxs-lookup"><span data-stu-id="26dde-138">Sign up for an Azure account</span></span>
<span data-ttu-id="26dde-139">Чтобы начать работу со служебной шиной, вам потребуется учетная запись Azure.</span><span class="sxs-lookup"><span data-stu-id="26dde-139">You’ll need an Azure account in order to start working with Service Bus.</span></span> <span data-ttu-id="26dde-140">Если у вас ее нет, вы можете зарегистрироваться для получения бесплатной учетной записи [здесь](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span><span class="sxs-lookup"><span data-stu-id="26dde-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="26dde-141">Создание пространства имен</span><span class="sxs-lookup"><span data-stu-id="26dde-141">Create a namespace</span></span>
<span data-ttu-id="26dde-142">После получения подписки можно [создать пространство имен службы](service-bus-create-namespace-portal.md).</span><span class="sxs-lookup"><span data-stu-id="26dde-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="26dde-143">Каждое пространство имен выступает в качестве определяющего область действия контейнера для набора сущностей служебной шины.</span><span class="sxs-lookup"><span data-stu-id="26dde-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="26dde-144">Присвойте пространству имен имя, которое будет уникальным среди всех учетных записей служебной шины.</span><span class="sxs-lookup"><span data-stu-id="26dde-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-the-nuget-package"></a><span data-ttu-id="26dde-145">Установка пакета NuGet</span><span class="sxs-lookup"><span data-stu-id="26dde-145">Install the NuGet package</span></span>
<span data-ttu-id="26dde-146">Чтобы использовать пространство имен служебной шины, приложение должно ссылаться на сборку служебной шины, а именно Microsoft.ServiceBus.dll.</span><span class="sxs-lookup"><span data-stu-id="26dde-146">To use the Service Bus namespace, an application must reference the Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="26dde-147">Эта сборка является частью пакета SDK Microsoft Azure, который можно загрузить на [странице загрузки пакета SDK Azure](https://azure.microsoft.com/downloads/).</span><span class="sxs-lookup"><span data-stu-id="26dde-147">You can find this assembly as part of the Microsoft Azure SDK, and the download is available at the [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="26dde-148">Однако проще всего получить API служебной шины и настроить свое приложение с учетом всех зависимостей служебной шины с помощью [пакета NuGet для служебной шины](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span><span class="sxs-lookup"><span data-stu-id="26dde-148">However, the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is the easiest way to get the Service Bus API and to configure your application with all of the Service Bus dependencies.</span></span>

### <a name="create-the-queue"></a><span data-ttu-id="26dde-149">Создание очереди</span><span class="sxs-lookup"><span data-stu-id="26dde-149">Create the queue</span></span>
<span data-ttu-id="26dde-150">Операции управления для сущностей обмена сообщениями служебной шины (очередей и разделов публикации и подписки) выполняются с помощью класса [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager).</span><span class="sxs-lookup"><span data-stu-id="26dde-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="26dde-151">Служебная шина использует модель безопасности на основе [подписанного URL-адреса](service-bus-sas.md) (SAS).</span><span class="sxs-lookup"><span data-stu-id="26dde-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="26dde-152">Класс [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) представляет поставщика маркеров безопасности со встроенными методами фабрики, которые возвращают несколько хорошо известных поставщиков маркеров.</span><span class="sxs-lookup"><span data-stu-id="26dde-152">The [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="26dde-153">Для хранения учетных данных SAS мы будем использовать метод [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_).</span><span class="sxs-lookup"><span data-stu-id="26dde-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method to hold the SAS credentials.</span></span> <span data-ttu-id="26dde-154">Затем экземпляр [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) объединяется с базовым адресом пространства имен служебной шины и поставщиком маркеров.</span><span class="sxs-lookup"><span data-stu-id="26dde-154">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with the base address of the Service Bus namespace and the token provider.</span></span>

<span data-ttu-id="26dde-155">Класс [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) предоставляет методы для создания, перечисления и удаления сущностей обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="26dde-155">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="26dde-156">Приведенный здесь код иллюстрирует создание и использование экземпляра класса [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) для создания очереди **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="26dde-156">The code that is shown here shows how the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used to create the **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="26dde-157">Обратите внимание, что существуют перегруженные версии метода [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_), которые позволяют задавать свойства очереди.</span><span class="sxs-lookup"><span data-stu-id="26dde-157">Note that there are overloads of the [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of the queue to be tuned.</span></span> <span data-ttu-id="26dde-158">Например, можно указать значение "срока жизни" (TTL) по умолчанию, которое будет применяться к сообщениям, отправляемым в очередь.</span><span class="sxs-lookup"><span data-stu-id="26dde-158">For example, you can set the default time-to-live (TTL) value for messages sent to the queue.</span></span>

### <a name="send-messages-to-the-queue"></a><span data-ttu-id="26dde-159">Отправка сообщений в очередь</span><span class="sxs-lookup"><span data-stu-id="26dde-159">Send messages to the queue</span></span>
<span data-ttu-id="26dde-160">Для выполнения операций над сущностями служебной шины, например для отправки и получения сообщений, приложение сначала должно создать объект [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory).</span><span class="sxs-lookup"><span data-stu-id="26dde-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="26dde-161">По аналогии с классом [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) экземпляр [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) создается на основе базового адреса пространства имен службы и поставщика маркеров.</span><span class="sxs-lookup"><span data-stu-id="26dde-161">Similar to the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from the base address of the service namespace and the token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="26dde-162">Сообщения, отправляемые в очереди служебной шины и получаемые из них, представляют собой экземпляры класса [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage).</span><span class="sxs-lookup"><span data-stu-id="26dde-162">Messages sent to, and received from Service Bus queues are instances of the [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="26dde-163">Этот класс состоит из набора стандартных свойств (таких как [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) и [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), словаря, в котором хранятся свойства приложения, и набора произвольных данных приложения.</span><span class="sxs-lookup"><span data-stu-id="26dde-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used to hold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="26dde-164">Приложение может задать набор произвольных данных, передав любой сериализуемый объект, который будет использовать [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) для сериализации объекта. (В следующем примере передается объект **SalesData**, представляющий данные о продажах от терминала POS.)</span><span class="sxs-lookup"><span data-stu-id="26dde-164">An application can set the body by passing in any serializable object (the following example passes in a **SalesData** object that represents the sales data from the POS terminal), which will use the [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) to serialize the object.</span></span> <span data-ttu-id="26dde-165">Также можно предоставить объект [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx).</span><span class="sxs-lookup"><span data-stu-id="26dde-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="26dde-166">Самый простой способ отправки сообщений в очередь, в данном случае **DataCollectionQueue**, — воспользоваться методом [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) для создания объекта [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) прямо из экземпляра класса [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory).</span><span class="sxs-lookup"><span data-stu-id="26dde-166">The easiest way to send messages to a given queue, in our case the **DataCollectionQueue**, is to use [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) to create a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-the-queue"></a><span data-ttu-id="26dde-167">Получение сообщений из очереди</span><span class="sxs-lookup"><span data-stu-id="26dde-167">Receiving messages from the queue</span></span>
<span data-ttu-id="26dde-168">Для получения сообщений из очереди можно воспользоваться объектом [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver), который создается непосредственно в [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) с помощью [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span><span class="sxs-lookup"><span data-stu-id="26dde-168">To receive messages from the queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="26dde-169">Получатели сообщений могут работать в двух различных режимах: **ReceiveAndDelete** и **PeekLock**.</span><span class="sxs-lookup"><span data-stu-id="26dde-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="26dde-170">Режим приема [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) устанавливается при создании получателя сообщения и задается в качестве параметра вызова [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_).</span><span class="sxs-lookup"><span data-stu-id="26dde-170">The [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when the message receiver is created, as a parameter to the [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="26dde-171">В режиме **ReceiveAndDelete** получение является одиночной операцией. Это значит, что, когда служебная шина получает запрос, сообщение помечается как использованное и возвращается в приложение.</span><span class="sxs-lookup"><span data-stu-id="26dde-171">When using the **ReceiveAndDelete** mode, the receive is a single-shot operation; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="26dde-172">Режим **ReceiveAndDelete** представляет собой самую простую модель. Он наиболее эффективен в сценариях, когда приложение допускает отсутствие обработки сообщения в случае сбоя.</span><span class="sxs-lookup"><span data-stu-id="26dde-172">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message if a failure were to occur.</span></span> <span data-ttu-id="26dde-173">Чтобы это понять, рассмотрим сценарий, в котором объект-получатель выдает запрос на получение и выходит из строя до его обработки.</span><span class="sxs-lookup"><span data-stu-id="26dde-173">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="26dde-174">Так как служебная шина помечает сообщение как использованное, то после перезапуска и начала приема сообщений приложение пропустит сообщение, полученной перед возникновением сбоя.</span><span class="sxs-lookup"><span data-stu-id="26dde-174">Since Service Bus marked the message as being consumed, when the application restarts and starts consuming messages again, it will have missed the message that was consumed before the crash.</span></span>

<span data-ttu-id="26dde-175">В режиме **PeekLock** процесс получения становится двухэтапной операцией, что позволяет поддерживать приложения, неустойчивые к потере сообщений.</span><span class="sxs-lookup"><span data-stu-id="26dde-175">In **PeekLock** mode, the receive becomes a two-stage operation, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="26dde-176">Получив запрос, служебная шина находит следующее сообщение, которое должно быть получено, блокирует его, чтобы предотвратить его получение другими получателями, и возвращает его приложению.</span><span class="sxs-lookup"><span data-stu-id="26dde-176">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers receiving it, and then returns it to the application.</span></span> <span data-ttu-id="26dde-177">Когда приложение завершает обработку сообщения (или надежно сохраняет его для последующей обработки), оно завершает второй этап процесса получения, вызывая метод [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) для полученного сообщения.</span><span class="sxs-lookup"><span data-stu-id="26dde-177">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="26dde-178">Когда служебная шина фиксирует вызов [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), сообщение помечается как использованное.</span><span class="sxs-lookup"><span data-stu-id="26dde-178">When Service Bus sees the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks the message as being consumed.</span></span>

<span data-ttu-id="26dde-179">Также возможны два других результата.</span><span class="sxs-lookup"><span data-stu-id="26dde-179">Two other outcomes are possible.</span></span> <span data-ttu-id="26dde-180">Во-первых, если приложение по каким-либо причинам не может обработать сообщение, оно может вызвать для полученного сообщения метод [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) (вместо метода [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="26dde-180">First, if the application is unable to process the message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="26dde-181">После этого служебная шина разблокирует сообщение в очереди, сделав его доступным для приема тому же потребителю или другому конкурирующему потребителю.</span><span class="sxs-lookup"><span data-stu-id="26dde-181">This causes Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another completing consumer.</span></span> <span data-ttu-id="26dde-182">Во-вторых, с блокировкой связано определенное время ожидания. Если приложение не сможет обработать сообщение до истечения времени ожидания (например, при сбое приложения), служебная шина автоматически разблокирует сообщение, сделав его снова доступным для получения (фактически выполняя операцию [прерывания](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) по умолчанию).</span><span class="sxs-lookup"><span data-stu-id="26dde-182">Second, there is a time-out associated with the lock and if the application cannot process the message before the lock time-out expires (for example, if the application crashes), then Service Bus will unlock the message and make it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="26dde-183">Обратите внимание, что, если сбой приложения происходит после обработки сообщения, но до отправки запроса [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), это сообщение будет повторно доставлено в приложение после его перезапуска.</span><span class="sxs-lookup"><span data-stu-id="26dde-183">Note that if the application crashes after it processes the message but before the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, the message will be redelivered to the application when it restarts.</span></span> <span data-ttu-id="26dde-184">Оно часто называется * хотя бы один раз * обработки.</span><span class="sxs-lookup"><span data-stu-id="26dde-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="26dde-185">Это означает, что каждое приложение будет обработано по крайней мере один раз, но в некоторых случаях одно и то же сообщение может быть доставлено повторно.</span><span class="sxs-lookup"><span data-stu-id="26dde-185">This means that each message will be processed at least once but in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="26dde-186">Если сценарий не допускает обработки дубликатов сообщений, в приложении необходимо реализовать дополнительную логику для обнаружения дубликатов.</span><span class="sxs-lookup"><span data-stu-id="26dde-186">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates.</span></span> <span data-ttu-id="26dde-187">Обнаружить дубликаты можно с помощью свойства [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) сообщения.</span><span class="sxs-lookup"><span data-stu-id="26dde-187">This can be achieved based on the [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of the message.</span></span> <span data-ttu-id="26dde-188">Значение данного свойства остается неизменным при всех попытках доставки.</span><span class="sxs-lookup"><span data-stu-id="26dde-188">The value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="26dde-189">Это называется обработкой *только один раз*.</span><span class="sxs-lookup"><span data-stu-id="26dde-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="26dde-190">Приведенный здесь код получает и обрабатывает сообщения в режиме **PeekLock**, который используется по умолчанию, если значение параметра [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) не указано явно.</span><span class="sxs-lookup"><span data-stu-id="26dde-190">The code that is shown here receives and processes a message using the **PeekLock** mode, which is the default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-the-queue-client"></a><span data-ttu-id="26dde-191">Использование клиента очереди</span><span class="sxs-lookup"><span data-stu-id="26dde-191">Use the queue client</span></span>
<span data-ttu-id="26dde-192">В примерах, приведенных ранее в этом разделе, создаются объекты [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) и [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) непосредственно из экземпляра класса [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory). Эти методы используются для отправки и получения сообщений из очереди соответственно.</span><span class="sxs-lookup"><span data-stu-id="26dde-192">The examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) to send and receive messages from the queue, respectively.</span></span> <span data-ttu-id="26dde-193">Альтернативным подходом является использование объекта [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient), который поддерживает операции отправки и получения сообщений, а также более сложные функции, такие как сеансы.</span><span class="sxs-lookup"><span data-stu-id="26dde-193">An alternative approach is to use a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition to more advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="26dde-194">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="26dde-194">Next steps</span></span>
<span data-ttu-id="26dde-195">Теперь, когда вы ознакомились с основами использования очередей, обратитесь к статье [Создание приложений, использующих разделы и подписки служебной шины](service-bus-create-topics-subscriptions.md). В этой статье объясняется, как использовать возможности публикации и подписки разделов и подписок служебной шины.</span><span class="sxs-lookup"><span data-stu-id="26dde-195">Now that you've learned the basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) to continue this discussion using the publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>

