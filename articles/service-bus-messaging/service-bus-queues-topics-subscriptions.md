---
title: "Обзор очередей сообщений, разделов и подписок служебной шины Azure | Документация Майкрософт"
description: "Общие сведения о сущностях обмена сообщениями в служебной шине."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: a306ced4-74e9-47c6-990a-d9c47efa31d5
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 06/28/2017
ms.author: sethm
ms.openlocfilehash: 00f9f38fbae028486270053dedb4df580a3f1a44
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2017
---
# <a name="service-bus-queues-topics-and-subscriptions"></a><span data-ttu-id="0a6ee-103">Очереди, разделы и подписки служебной шины</span><span class="sxs-lookup"><span data-stu-id="0a6ee-103">Service Bus queues, topics, and subscriptions</span></span>

<span data-ttu-id="0a6ee-104">Служебная шина Microsoft Azure поддерживает набор облачных технологий промежуточного уровня, ориентированных на обработку сообщений. Эти технологии представлены надежными очередями сообщений, а также возможностями публикации и подписки в рамках обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-104">Microsoft Azure Service Bus supports a set of cloud-based, message-oriented middleware technologies including reliable message queuing and durable publish/subscribe messaging.</span></span> <span data-ttu-id="0a6ee-105">Эти возможности обмена сообщениями через посредника могут рассматриваться как разделенные функции обмена сообщениями, поддерживающие публикацию и подписку, временное разделение, а также сценарии балансировки нагрузки с использованием фабрики обмена сообщениями служебной шины.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-105">These "brokered" messaging capabilities can be thought of as decoupled messaging features that support publish-subscribe, temporal decoupling, and load balancing scenarios using the Service Bus messaging fabric.</span></span> <span data-ttu-id="0a6ee-106">Разделенный обмен данными имеет множество преимуществ. Например, клиенты и серверы могут подключаться по необходимости, выполняя свои операции в асинхронном режиме.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-106">Decoupled communication has many advantages; for example, clients and servers can connect as needed and perform their operations in an asynchronous fashion.</span></span>

<span data-ttu-id="0a6ee-107">Сущности обмена сообщениями, образующие основные возможности обмена сообщениями в служебной шине, представлены очередями, разделами и подписками, а также правилами и действиями.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-107">The messaging entities that form the core of the messaging capabilities in Service Bus are queues, topics and subscriptions, and rules/actions.</span></span>

## <a name="queues"></a><span data-ttu-id="0a6ee-108">Очереди</span><span class="sxs-lookup"><span data-stu-id="0a6ee-108">Queues</span></span>

<span data-ttu-id="0a6ee-109">Очереди предлагают доставку сообщений конкурирующим потребителям по типу *FIFO* (первым пришел, первым вышел).</span><span class="sxs-lookup"><span data-stu-id="0a6ee-109">Queues offer *First In, First Out* (FIFO) message delivery to one or more competing consumers.</span></span> <span data-ttu-id="0a6ee-110">То есть обычно получатели принимают и обрабатывают сообщения в том порядке, в котором они были добавлены в очередь. При этом каждое сообщение принимается и обрабатывается только одним потребителем сообщений.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-110">That is, messages are typically expected to be received and processed by the receivers in the order in which they were added to the queue, and each message is received and processed by only one message consumer.</span></span> <span data-ttu-id="0a6ee-111">Основное преимущество использования очередей — временное разделение компонентов приложений.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-111">A key benefit of using queues is to achieve "temporal decoupling" of application components.</span></span> <span data-ttu-id="0a6ee-112">Другими словами, производителям (отправителям) и потребителям (получателям) не приходится отправлять и получать сообщения в одно и то же время, поскольку сообщения надежно хранятся в очереди.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-112">In other words, the producers (senders) and consumers (receivers) do not have to be sending and receiving messages at the same time, because messages are stored durably in the queue.</span></span> <span data-ttu-id="0a6ee-113">Более того, производителю не нужно ждать ответ от потребителя, чтобы продолжить обработку и отправку дальнейших сообщений.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-113">Furthermore, the producer does not have to wait for a reply from the consumer in order to continue to process and send messages.</span></span>

<span data-ttu-id="0a6ee-114">Сопутствующее преимущество заключается в выравнивании нагрузки — оно позволяет производителям и потребителям отправлять и получать сообщения с разной скоростью.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-114">A related benefit is "load leveling," which enables producers and consumers to send and receive messages at different rates.</span></span> <span data-ttu-id="0a6ee-115">Во многих приложениях уровень системной нагрузки со временем меняется, однако длительность обработки каждой единицы работы, как правило, остается постоянной.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-115">In many applications, the system load varies over time; however, the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="0a6ee-116">Обмен сообщениями между производителем и потребителем с использованием очереди предусматривает подготовку потребляющего приложения к обработке средней, а не пиковой нагрузки.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-116">Intermediating message producers and consumers with a queue means that the consuming application only has to be provisioned to be able to handle average load instead of peak load.</span></span> <span data-ttu-id="0a6ee-117">При колебаниях входящей нагрузки просто изменяется глубина очереди.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-117">The depth of the queue grows and contracts as the incoming load varies.</span></span> <span data-ttu-id="0a6ee-118">Это позволяет существенно сократить расходы на инфраструктуру, необходимую для обработки нагрузки приложения.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-118">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span> <span data-ttu-id="0a6ee-119">По мере возрастания нагрузки могут потребоваться дополнительные рабочие процессы для чтения из очереди.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-119">As the load increases, more worker processes can be added to read from the queue.</span></span> <span data-ttu-id="0a6ee-120">Каждое сообщение обрабатывается одним рабочим процессом.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-120">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="0a6ee-121">Кроме того, балансировка нагрузки по запросу обеспечивает оптимальное использование рабочих компьютеров с разной вычислительной мощностью, позволяя извлекать сообщения с максимально доступной скоростью.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-121">Furthermore, this pull-based load balancing allows for optimum use of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="0a6ee-122">Такой подход часто называют моделью "конкурирующих потребителей".</span><span class="sxs-lookup"><span data-stu-id="0a6ee-122">This pattern is often termed the "competing consumer" pattern.</span></span>

<span data-ttu-id="0a6ee-123">Использование очередей в качестве посредника между производителями и потребителями сообщений уменьшает зависимость между компонентами.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-123">Using queues to intermediate between message producers and consumers provides an inherent loose coupling between the components.</span></span> <span data-ttu-id="0a6ee-124">Так как производители и потребители не зависят друг от друга, обновление потребителя не оказывает влияния на производителя.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-124">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span>

<span data-ttu-id="0a6ee-125">Создание очереди является многоэтапным процессом.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-125">Creating a queue is a multi-step process.</span></span> <span data-ttu-id="0a6ee-126">Выполнять операции управления для сущностей обмена сообщениями служебной шины (очередей и разделов) можно с использованием класса [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager). Этот класс создается путем предоставления базового адреса пространства имен служебной шины и учетных данных пользователя.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-126">You perform management operations for Service Bus messaging entities (both queues and topics) via the [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) class, which is constructed by supplying the base address of the Service Bus namespace and the user credentials.</span></span> <span data-ttu-id="0a6ee-127">Класс [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) предоставляет методы для создания, перечисления и удаления сущностей обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="0a6ee-128">Создав объект [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) на основе имени и ключа SAS, а также объект управления пространством имен службы, можно создать очередь, используя метод [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_).</span><span class="sxs-lookup"><span data-stu-id="0a6ee-128">After creating a [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) object from the SAS name and key, and a service namespace management object, you can use the [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method to create the queue.</span></span> <span data-ttu-id="0a6ee-129">Например:</span><span class="sxs-lookup"><span data-stu-id="0a6ee-129">For example:</span></span>

```csharp
// Create management credentials
TokenProvider credentials = TokenProvider.CreateSharedAccessSignatureTokenProvider(sasKeyName,sasKeyValue);
// Create namespace client
NamespaceManager namespaceClient = new NamespaceManager(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials);
```

<span data-ttu-id="0a6ee-130">Затем можно создать объект очереди и фабрику обмена сообщениями с помощью URI служебной шины в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-130">You can then create a queue object and a messaging factory with the Service Bus URI as an argument.</span></span> <span data-ttu-id="0a6ee-131">Например:</span><span class="sxs-lookup"><span data-stu-id="0a6ee-131">For example:</span></span>

```csharp
QueueDescription myQueue;
myQueue = namespaceClient.CreateQueue("TestQueue");
MessagingFactory factory = MessagingFactory.Create(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials); 
QueueClient myQueueClient = factory.CreateQueueClient("TestQueue");
```

<span data-ttu-id="0a6ee-132">После этого можно отправлять сообщения в очередь.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-132">You can then send messages to the queue.</span></span> <span data-ttu-id="0a6ee-133">Например, если имеется список сообщений, передаваемых через посредника, с именем `MessageList`, код будет выглядеть приблизительно так:</span><span class="sxs-lookup"><span data-stu-id="0a6ee-133">For example, if you have a list of brokered messages called `MessageList`, the code appears similar to the following:</span></span>

```csharp
for (int count = 0; count < 6; count++)
{
    var issue = MessageList[count];
    issue.Label = issue.Properties["IssueTitle"].ToString();
    myQueueClient.Send(issue);
}
```

<span data-ttu-id="0a6ee-134">Затем можно получить сообщения из очереди, как показано ниже:</span><span class="sxs-lookup"><span data-stu-id="0a6ee-134">You then receive messages from the queue as follows:</span></span>

```csharp
while ((message = myQueueClient.Receive(new TimeSpan(hours: 0, minutes: 0, seconds: 5))) != null)
    {
        Console.WriteLine(string.Format("Message received: {0}, {1}, {2}", message.SequenceNumber, message.Label, message.MessageId));
        message.Complete();

        Console.WriteLine("Processing message (sleeping...)");
        Thread.Sleep(1000);
    }
```

<span data-ttu-id="0a6ee-135">В режиме [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) получение является одиночной операцией. Это значит, что, когда служебная шина получает запрос, сообщение помечается как использованное и возвращается в приложение.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-135">In the [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation is single-shot; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="0a6ee-136">Режим **ReceiveAndDelete** представляет собой самую простую модель. Наиболее эффективен он в сценариях, когда приложение допускает отсутствие обработки сообщения в случае сбоя.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-136">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message in the event of a failure.</span></span> <span data-ttu-id="0a6ee-137">Чтобы это понять, рассмотрим сценарий, в котором объект-получатель выдает запрос на получение и выходит из строя до его обработки.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-137">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="0a6ee-138">Служебная шина помечает сообщение как использованное. Следовательно, когда после перезапуска приложение снова начнет обрабатывать сообщения, оно пропустит сообщение, использованное до сбоя.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-138">Because Service Bus marks the message as being consumed, when the application restarts and begins consuming messages again, it will have missed the message that was consumed prior to the crash.</span></span>

<span data-ttu-id="0a6ee-139">В режиме [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) процесс получения становится двухэтапной операцией. Это позволяет поддерживать приложения, которые не допускают пропуск сообщений.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-139">In [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation becomes two-stage, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="0a6ee-140">Получив запрос, служебная шина находит следующее сообщение, блокирует его, чтобы другие потребители не могли его принять, а затем возвращает его приложению.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-140">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers from receiving it, and then returns it to the application.</span></span> <span data-ttu-id="0a6ee-141">Когда приложение завершает обработку сообщения (или надежно сохраняет его для последующей обработки), оно завершает второй этап процесса получения, вызывая метод [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) для полученного сообщения.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-141">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="0a6ee-142">Когда служебная шина фиксирует вызов **Complete**, сообщение помечается как использованное.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-142">When Service Bus sees the **Complete** call, it marks the message as being consumed.</span></span>

<span data-ttu-id="0a6ee-143">Если приложение по каким-либо причинам не может обработать сообщение, оно может вызвать для полученного сообщения метод [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) (вместо метода [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="0a6ee-143">If the application is unable to process the message for some reason, it can call the [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) method on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="0a6ee-144">После этого служебная шина разблокирует сообщение в очереди, сделав его доступным для приема тем же или другим конкурирующим потребителем.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-144">This enables Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another competing consumer.</span></span> <span data-ttu-id="0a6ee-145">Кроме того, блокирование связано с определенным временем ожидания. Если приложение не сможет обработать сообщение до истечения времени ожидания (например, при сбое приложения), служебная шина автоматически разблокирует сообщение, сделав его снова доступным для получения (фактически выполняя операцию [прерывания](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) по умолчанию).</span><span class="sxs-lookup"><span data-stu-id="0a6ee-145">Secondly, there is a timeout associated with the lock and if the application fails to process the message before the lock timeout expires (for example, if the application crashes), then Service Bus unlocks the message and makes it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="0a6ee-146">Если сбой приложения происходит после обработки сообщения, но перед отправкой запроса **Complete**, такое сообщение будет повторно доставлено в приложение после перезапуска.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-146">Note that in the event that the application crashes after processing the message, but before the **Complete** request is issued, the message is redelivered to the application when it restarts.</span></span> <span data-ttu-id="0a6ee-147">Такой подход предполагает принцип обработки сообщения *хотя бы один раз*.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-147">This is often called *At Least Once* processing; that is, each message is processed at least once.</span></span> <span data-ttu-id="0a6ee-148">Тем не менее в некоторых случаях это же сообщение может быть доставлено повторно.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-148">However, in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="0a6ee-149">Если сценарий не допускает повторную обработку, для обнаружения дубликатов требуется дополнительная логика в приложении. Это реализуется с помощью свойства сообщения **MessageId**, которое остается постоянным в ходе разных попыток доставки.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-149">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates which can be achieved based upon the **MessageId** property of the message, which remains constant across delivery attempts.</span></span> <span data-ttu-id="0a6ee-150">Такой подход предполагает концепцию обработки *только один раз*.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-150">This is known as *Exactly Once* processing.</span></span>

## <a name="topics-and-subscriptions"></a><span data-ttu-id="0a6ee-151">Разделы и подписки</span><span class="sxs-lookup"><span data-stu-id="0a6ee-151">Topics and subscriptions</span></span>
<span data-ttu-id="0a6ee-152">В отличие от очередей, в которых каждое сообщение обрабатывается одним потребителем, *разделы* и *подписки* предоставляют возможность взаимодействия типа "один ко многим" в рамках шаблона *публикации или подписки*.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-152">In contrast to queues, in which each message is processed by a single consumer, *topics* and *subscriptions* provide a one-to-many form of communication, in a *publish/subscribe* pattern.</span></span> <span data-ttu-id="0a6ee-153">Каждое опубликованное сообщение становится доступным в рамках каждой подписки, зарегистрированной в разделе. Это особенно удобно при масштабировании с учетом большого количества получателей.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-153">Useful for scaling to very large numbers of recipients, each published message is made available to each subscription registered with the topic.</span></span> <span data-ttu-id="0a6ee-154">Сообщения отправляются в раздел и доставляются в одну или несколько связанных подписок в зависимости от правил фильтрации, которые могут быть заданы для каждой подписки.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-154">Messages are sent to a topic and delivered to one or more associated subscriptions, depending on filter rules that can be set on a per-subscription basis.</span></span> <span data-ttu-id="0a6ee-155">Подписки могут использовать дополнительные фильтры для ограничения получаемых сообщений.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-155">The subscriptions can use additional filters to restrict the messages that they want to receive.</span></span> <span data-ttu-id="0a6ee-156">Сообщения отправляются в раздел так же, как и в очередь; при этом непосредственно из раздела получить их нельзя.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-156">Messages are sent to a topic in the same way they are sent to a queue, but messages are not received from the topic directly.</span></span> <span data-ttu-id="0a6ee-157">Зато их можно получить из подписок.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-157">Instead, they are received from subscriptions.</span></span> <span data-ttu-id="0a6ee-158">Подписка раздела напоминает виртуальную очередь, которая получает копии сообщений, отправленных в раздел.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-158">A topic subscription resembles a virtual queue that receives copies of the messages that are sent to the topic.</span></span> <span data-ttu-id="0a6ee-159">Сообщения передаются из подписки так же, как и из очереди.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-159">Messages are received from a subscription identically to the way they are received from a queue.</span></span>

<span data-ttu-id="0a6ee-160">Продолжая сравнение, следует отметить, что при отправке из очереди сообщения распределяются непосредственно в раздел, а при извлечении — в подписку.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-160">By way of comparison, the message-sending functionality of a queue maps directly to a topic and its message-receiving functionality maps to a subscription.</span></span> <span data-ttu-id="0a6ee-161">Помимо прочего, это означает, что подписки также поддерживают схемы для очередей, описанные ранее в этом разделе, в том числе конкуренцию потребителей, временное разделение, а также выравнивание и балансировку нагрузки.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-161">Among other things, this means that subscriptions support the same patterns described earlier in this section with regard to queues: competing consumer, temporal decoupling, load leveling, and load balancing.</span></span>

<span data-ttu-id="0a6ee-162">Создание раздела аналогично созданию очереди, как показано в примере, приведенном в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-162">Creating a topic is similar to creating a queue, as shown in the example in the previous section.</span></span> <span data-ttu-id="0a6ee-163">Создайте URI службы, а затем с помощью класса [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) создайте клиент пространства имен.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-163">Create the service URI, and then use the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class to create the namespace client.</span></span> <span data-ttu-id="0a6ee-164">Затем с помощью метода [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) можно создать раздел.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-164">You can then create a topic using the [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) method.</span></span> <span data-ttu-id="0a6ee-165">Например:</span><span class="sxs-lookup"><span data-stu-id="0a6ee-165">For example:</span></span>

```csharp
TopicDescription dataCollectionTopic = namespaceClient.CreateTopic("DataCollectionTopic");
```

<span data-ttu-id="0a6ee-166">Затем добавьте необходимые подписки:</span><span class="sxs-lookup"><span data-stu-id="0a6ee-166">Next, add subscriptions as desired:</span></span>

```csharp
SubscriptionDescription myAgentSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Inventory");
SubscriptionDescription myAuditSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Dashboard");
```

<span data-ttu-id="0a6ee-167">После этого можно создать клиент раздела.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-167">You can then create a topic client.</span></span> <span data-ttu-id="0a6ee-168">Например:</span><span class="sxs-lookup"><span data-stu-id="0a6ee-168">For example:</span></span>

```csharp
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider);
TopicClient myTopicClient = factory.CreateTopicClient(myTopic.Path)
```

<span data-ttu-id="0a6ee-169">С помощью отправителя сообщений можно отправлять сообщения в раздел и извлекать их из раздела, как описано выше.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-169">Using the message sender, you can send and receive messages to and from the topic, as shown in the previous section.</span></span> <span data-ttu-id="0a6ee-170">Например:</span><span class="sxs-lookup"><span data-stu-id="0a6ee-170">For example:</span></span>

```csharp
foreach (BrokeredMessage message in messageList)
{
    myTopicClient.Send(message);
    Console.WriteLine(
    string.Format("Message sent: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

<span data-ttu-id="0a6ee-171">Как и в случае с очередью, сообщения извлекаются из подписки с помощью объекта [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient), используемого вместо объекта [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient).</span><span class="sxs-lookup"><span data-stu-id="0a6ee-171">Similar to queues, messages are received from a subscription using a [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) object instead of a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object.</span></span> <span data-ttu-id="0a6ee-172">Создайте клиент подписки, передав в качестве параметров имя раздела, имя подписки и (необязательно) режим получения.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-172">Create the subscription client, passing the name of the topic, the name of the subscription, and (optionally) the receive mode as parameters.</span></span> <span data-ttu-id="0a6ee-173">Пример с подпиской **Inventory**:</span><span class="sxs-lookup"><span data-stu-id="0a6ee-173">For example, with the **Inventory** subscription:</span></span>

```csharp
// Create the subscription client
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider); 

SubscriptionClient agentSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Inventory", ReceiveMode.PeekLock);
SubscriptionClient auditSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Dashboard", ReceiveMode.ReceiveAndDelete); 

while ((message = agentSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Inventory...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
    message.Complete();
}          

// Create a receiver using ReceiveAndDelete mode
while ((message = auditSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Dashboard...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

### <a name="rules-and-actions"></a><span data-ttu-id="0a6ee-174">Правила и действия</span><span class="sxs-lookup"><span data-stu-id="0a6ee-174">Rules and actions</span></span>
<span data-ttu-id="0a6ee-175">Во многих ситуациях сообщения с определенными характеристиками должны обрабатываться разными способами.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-175">In many scenarios, messages that have specific characteristics must be processed in different ways.</span></span> <span data-ttu-id="0a6ee-176">Для этого можно настроить подписки, обеспечивающие поиск сообщений с нужными свойствами, после чего можно определенным образом изменить эти свойства.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-176">To enable this, you can configure subscriptions to find messages that have desired properties and then perform certain modifications to those properties.</span></span> <span data-ttu-id="0a6ee-177">Подписки служебной шины регистрируют все сообщения, отправленные в раздел, однако в виртуальную очередь подписки можно скопировать только подмножество этих сообщений.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-177">While Service Bus subscriptions see all messages sent to the topic, you can only copy a subset of those messages to the virtual subscription queue.</span></span> <span data-ttu-id="0a6ee-178">Это возможно благодаря использованию фильтров подписок.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-178">This is accomplished using subscription filters.</span></span> <span data-ttu-id="0a6ee-179">Такие изменения называются *действиями фильтров*.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-179">Such modifications are called *filter actions*.</span></span> <span data-ttu-id="0a6ee-180">При создании подписки можно указать выражение фильтра, которое работает со свойствами сообщения, включая системные свойства (например, **Label**) и свойства пользовательского приложения (например, **StoreName**). В этом случае SQL-выражение фильтра является необязательным. Без него все определенные в подписке действия фильтра будут выполняться по отношению ко всем сообщениям в рамках этой подписки.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-180">When a subscription is created, you can supply a filter expression that operates on the properties of the message, both the system properties (for example, **Label**) and custom application properties (for example, **StoreName**.) The SQL filter expression is optional in this case; without a SQL filter expression, any filter action defined on a subscription will be performed on all the messages for that subscription.</span></span>

<span data-ttu-id="0a6ee-181">Используя предыдущий пример, вы можете создать подписку Dashboard для фильтрации сообщений, приходящих только из хранилища **Store1**, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-181">Using the previous example, to filter messages coming only from **Store1**, you would create the Dashboard subscription as follows:</span></span>

```csharp
namespaceManager.CreateSubscription("IssueTrackingTopic", "Dashboard", new SqlFilter("StoreName = 'Store1'"));
```

<span data-ttu-id="0a6ee-182">Благодаря этому фильтру подписки в виртуальную очередь для подписки `Dashboard` копируются только сообщения со свойством `StoreName`, которому задано значение `Store1`.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-182">With this subscription filter in place, only messages that have the `StoreName` property set to `Store1` are copied to the virtual queue for the `Dashboard` subscription.</span></span>

<span data-ttu-id="0a6ee-183">Дополнительные сведения о возможных значениях фильтров см. в документации по классам [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) и [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction).</span><span class="sxs-lookup"><span data-stu-id="0a6ee-183">For more information about possible filter values, see the documentation for the [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) and [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction) classes.</span></span> <span data-ttu-id="0a6ee-184">Ознакомьтесь также с примерами [Brokered Messaging: Advanced Filters](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) (Обмен сообщениями через брокер: расширенные фильтры) и [Topic Filters](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) (Фильтры разделов).</span><span class="sxs-lookup"><span data-stu-id="0a6ee-184">Also, see the [Brokered Messaging: Advanced Filters](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) and [Topic Filters](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) samples.</span></span>

## <a name="next-steps"></a><span data-ttu-id="0a6ee-185">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="0a6ee-185">Next steps</span></span>
<span data-ttu-id="0a6ee-186">Дополнительные сведения и примеры использования обмена сообщениями в служебной шине см. в следующих дополнительных статьях.</span><span class="sxs-lookup"><span data-stu-id="0a6ee-186">See the following advanced topics for more information and examples of using Service Bus messaging.</span></span>

* [<span data-ttu-id="0a6ee-187">Основные сведения об обмене сообщениями через служебную шину</span><span class="sxs-lookup"><span data-stu-id="0a6ee-187">Service Bus messaging overview</span></span>](service-bus-messaging-overview.md)
* [<span data-ttu-id="0a6ee-188">Учебное пособие по обмену сообщениями .NET через посредника в служебной шине</span><span class="sxs-lookup"><span data-stu-id="0a6ee-188">Service Bus brokered messaging .NET tutorial</span></span>](service-bus-brokered-tutorial-dotnet.md)
* [<span data-ttu-id="0a6ee-189">Руководство по обмену сообщениями через посредника служебной шины на основе REST</span><span class="sxs-lookup"><span data-stu-id="0a6ee-189">Service Bus brokered messaging REST tutorial</span></span>](service-bus-brokered-tutorial-rest.md)
* [<span data-ttu-id="0a6ee-190">Пример фильтров разделов</span><span class="sxs-lookup"><span data-stu-id="0a6ee-190">Topic Filters sample </span></span>](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/TopicFilters)
* [<span data-ttu-id="0a6ee-191">Brokered Messaging: Advanced Filters (Обмен сообщениями через брокер: расширенные фильтры)</span><span class="sxs-lookup"><span data-stu-id="0a6ee-191">Brokered Messaging: Advanced Filters sample</span></span>](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749)

