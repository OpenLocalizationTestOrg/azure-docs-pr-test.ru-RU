---
title: "Сеансы обмена сообщениями служебной шины Azure | Документация Майкрософт"
description: "Обработка последовательностей сообщений служебной шины Azure с помощью сеансов."
services: service-bus-messaging
documentationcenter: 
author: clemensv
manager: timlt
editor: 
ms.service: service-bus-messaging
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 01/02/2018
ms.author: sethm
ms.openlocfilehash: 16f641c7b6fdd1d6730d2ae229c93ce4a33b9492
ms.sourcegitcommit: 9ea2edae5dbb4a104322135bef957ba6e9aeecde
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/03/2018
---
# <a name="message-sessions-first-in-first-out-fifo"></a>Сообщение сеансов: первым, сначала (FIFO) 

Microsoft Azure Service Bus сеансы позволяют соединения и упорядоченные обработки неограниченных последовательностей связанных сообщений. Для реализации гарантирует FIFO в Service Bus, используйте сеансы. В служебной шине не регламентируется характер связи между сообщениями и не указывается конкретная модель, определяющая, где начинается или заканчивается последовательность сообщений.

Любой отправителя может создать сеанс при, задав отправка сообщений в очереди или разделе [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) свойства, определяемые приложением идентификатору, который является уникальным для сеанса. На уровне протокола AMQP 1.0 это значение соответствует свойству *group-id*.

В очередях или подписках с поддержкой сеансов сеансы создаются при наличии по крайней мере одного сообщения, для которого указан [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) сеанса. Для созданного сеанса нет определенного интервала времени или API, определяющего его срок действия или существования. Теоретически, сообщение для сеанса может быть получено сегодня, а следующее — через год, и если значение **SessionId** совпадает, то с точки зрения служебной шины это тот же самый сеанс.

Тем не менее, как правило, приложение имеет очистить понятие где набор связанных сообщений начинается и заканчивается. Service Bus не устанавливает какие-либо конкретного правила.

Например, чтобы разграничить последовательность для передачи файла, можно задать для свойства **Label** первого сообщения значение **start**, для промежуточных сообщений задать для этого свойства значение **content**, а для последнего сообщения — значение **end**. Относительное положение содержимого сообщения может быть вычислено как текущее сообщение *SequenceNumber* изменений из **запустить** сообщение *SequenceNumber*.

Функция сеансов в служебной шине позволяет выполнить специальную операцию получения посредством [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Для включения этой функции нужно задать свойство [requiresSession](/azure/templates/microsoft.servicebus/namespaces/queues#property-values) для очереди или подписки с помощью Azure Resource Manager или установить соответствующий флаг на портале. Это необходимо сделать прежде, чем пытаться использовать операции связанных API.

На портале установите флаг с следующий флажок:

![][2]

Интерфейсы API для сеансов существуют в клиентах очереди и подписки. Отсутствует императивную модель, элементы управления при получении сеансов и сообщений и обработчика модели на основе аналогично *OnMessage*, что скрывает сложность управления получение цикла.

## <a name="session-features"></a>Функции сеансов

Сеансы обеспечивают параллельных демультиплексирующих потоков сообщений с чередованием сохраняя и что гарантирует упорядоченную доставку.

![][1]

Получатель [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) создается клиентом, принимающим сеанс. Клиент вызывает метод [QueueClient.AcceptMessageSession](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesession#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSession) или [QueueClient.AcceptMessageSessionAsync](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesessionasync#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSessionAsync) в C#. В реактивной модели обратного вызова он регистрирует обработчик сеанса, как описано далее.

Когда [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) объекта принимается и во время удержания клиентом, что клиент содержит монопольной блокировки на все сообщения с этим сеансом [SessionId](/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession.sessionid#Microsoft_ServiceBus_Messaging_MessageSession_SessionId) , существующие в очереди или подписки, и Кроме того, на все сообщения, которое **SessionId** , по-прежнему поступают во время сеанса.

Блокировка снимается при **закрыть** или **CloseAsync** вызываются, или когда срок действия блокировки прекращается в случаях, когда приложение не удалось выполнить операцию закрытия. Блокировка сеанса должна рассматриваться как монопольная блокировка файла. Это означает, что приложение должно закрыть сеанс, как только он стал не нужен и (или) оно не ожидает поступления новых сообщений.

Когда несколько параллельных получателей извлекают сообщения из очереди, сообщения, относящиеся к определенному сеансу, отправляются в конкретный получатель, который в настоящее время наложил блокировку для этого сеанса. Благодаря этой операции поток сообщений с чередованием, находящийся в одной очереди или подписке, четко демультиплексируется для различных получателей. Эти получатели могут находиться на разных клиентских компьютерах, так как управление блокировкой осуществляется на стороне службы, внутри служебной шины.

Однако очередь по-прежнему остается очередью: она не обеспечивает произвольный доступ. Если несколько получателей одновременно ожидают прием определенных сеансов или ожидают сообщения из определенных сеансов, и сообщение вверху очереди относится к сеансу, получатель которого еще не утвержден, то доставка откладывается, пока не будет утвержден получатель этого сеанса.

На предыдущем рисунке показаны три параллельных получателя сеансов, которым необходимо активно принимать сообщения из очереди для работы. В предыдущем сеансе работы с `SessionId` = 4 имеет не активно, владеющего клиента, это означает, что сообщения не будут доставлены в любой пользователь, пока что сообщение было удалено с только что созданный объект, которой принадлежит приемника сеанса.

Хотя может показаться, что это накладывает ограничения, один процесс получателя может легко обрабатывать несколько параллельных сеансов, особенно в том случае, если они написаны с помощью строго асинхронного кода. Оперирование десятками одновременных сеансов эффективно автоматизируется при помощи модели обратного вызова.

Стратегия обработки нескольких параллельных сеансов, при которой каждый сеанс только время от времени получает сообщения, предписывает обработчику удалить сеанс через некоторое время простоя и возобновить обработку после принятия сеанса при поступлении следующего сообщения.

Блокировка сеанса, накладываемая получателем сеанса, — это "зонтик" для блокировки сообщений, используемый для режима согласования *PeekLock*. Получатель не может одновременно обработать два сообщения "на лету", но сообщения должны обрабатываться по порядку. Новое сообщение можно будет получить только после того, как предыдущее сообщение будет обработано или отправлено в очередь недоставленных сообщений. Если сообщение отбрасывается, то это же сообщение обслуживается повторно при следующей операции получения.

## <a name="message-session-state"></a>Состояние сеанса обмена сообщениями

При обработке рабочих процессов в крупномасштабных высокодоступных облачных системах обработчик рабочих процессов, связанный с определенным сеансом, должен обладать механизмами восстановления после непредвиденных сбоев, а также иметь возможность возобновлять частично выполненную работу в другом процессе или на другом компьютере.

Функция состояния сеанса позволяет добавлять определяемые приложением заметки для сеанса обмена сообщениями внутри брокера, чтобы записанное состояние обработки, относящееся к этому сеансу, становилось мгновенно доступным при получении этого сеанса новым обработчиком.

С точки зрения служебной шины состояние сеанса обмена сообщениями — непрозрачный двоичный объект, который может содержать данные, размер которых равен размеру одного сообщения, что составляет 256 КБ для служебной шины категории "Стандартный" и 1 МБ для служебной шины категории "Премиум". Состояние обработки относительно сеанса может сохраняться в состоянии сеанса, или состояние сеанса может указывать на некоторое место хранения либо запись базы данных, где содержатся эти сведения.

Интерфейсы API для управления состоянием сеанса, [SetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_) и [GetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate#Microsoft_ServiceBus_Messaging_MessageSession_GetState), можно найти в объекте [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Сеанс, для которого ранее не было задано состояние сеанса, возвращает в интерфейс API **GetState** **пустую** ссылку. Очистка заданного ранее состояния сеанса выполняется с помощью [SetState(null)](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_).

Все существующие сеансы в очереди или подписке могут быть перечислены с помощью метода **SessionBrowser** в интерфейсе API Java и с помощью метода [GetMessageSessions](/dotnet/api/microsoft.servicebus.messaging.queueclient.getmessagesessions#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessions) в интерфейсах API [QueueClient](/dotnet/api/microsoft.azure.servicebus.queueclient) и [SubscriptionClient](/dotnet/api/microsoft.azure.servicebus.subscriptionclient) в клиенте .NET.

Состояние сеанса, хранящееся в очереди или подписке, учитывается при подсчете квоты хранилища этой сущности. Поэтому, когда приложение завершает работу с сеансом, рекомендуется очищать его сохраненное состояние, чтобы избежать затрат на внешнее управление.

## <a name="next-steps"></a>Дальнейшие действия

- [Полный пример](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/GettingStarted/Microsoft.Azure.ServiceBus/BasicSendReceiveUsingQueueClient) отправки и получения сообщений на основе сеанса через очереди служебной шины с помощью библиотеки .NET Standard.
- [Пример](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/Sessions), использующий клиент .NET Framework для обработки сообщений с поддержкой сеансов. 

Дополнительные сведения об обмене сообщениями через служебную шину см. в следующих статьях:

* [Базовая информация о служебной шине](service-bus-fundamentals-hybrid-solutions.md)
* [Очереди, разделы и подписки служебной шины](service-bus-queues-topics-subscriptions.md)
* [Начало работы с очередями служебной шины](service-bus-dotnet-get-started-with-queues.md)
* [Как использовать разделы и подписки служебной шины](service-bus-dotnet-how-to-use-topics-subscriptions.md)

[1]: ./media/message-sessions/sessions.png
[2]: ./media/message-sessions/queue-sessions.png