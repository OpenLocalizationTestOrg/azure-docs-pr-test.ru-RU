---
title: "Использование расширяемости Python с подготовкой данных в Машинном обучении Azure | Документация Майкрософт"
description: "В этом документе представлен обзор и некоторые подробные примеры использования кода Python для расширения функциональности подготовки данных"
services: machine-learning
author: euangMS
ms.author: euang
manager: lanceo
ms.reviewer: 
ms.service: machine-learning
ms.workload: data-services
ms.custom: 
ms.devlang: 
ms.topic: article
ms.date: 09/07/2017
ms.openlocfilehash: 4e1935a7830b8174796ac12792fbbc0ed110d081
ms.sourcegitcommit: 6699c77dcbd5f8a1a2f21fba3d0a0005ac9ed6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2017
---
# <a name="data-prep-python-extensions"></a>Расширения Python для подготовки данных
В качестве способа заполнения функциональных пробелов между встроенными функциями подготовка данных включает в себя расширяемость на нескольких уровнях. В этом документе описана расширяемость с помощью скрипта Python. 

## <a name="custom-code-steps"></a>Использование пользовательского кода 
Подготовка данных включает в себя следующие настраиваемые действия, когда пользователи могут писать код: 
1. Считывание файлов*.
2. Запись*.
3. Добавление столбца.
4. Применение расширенного фильтра.
5. Преобразование потока данных.
6. Преобразование секции.

* Сейчас эти действия не поддерживаются при выполнении Spark. 

## <a name="code-block-types"></a>Типы блоков кода 
Для каждого из этих действий поддерживаются два типа блоков кода. Во-первых, поддерживаются чистые выражения Python, которые выполняются "как есть". Во-вторых, поддерживается модуль Python, в котором вызываются определенные функции с помощью известных подписей в коде, которые вам нужно предоставить.

Например, можно добавить новый столбец, который вычисляет журнал другого столбца двумя приведенными ниже способами. Выражение: 

```python    
    math.log(row["Score"])
```

Модуль: 
    
```python
def newvalue(row): 
        return math.log(row["Score"])
```


Преобразование добавления столбца в модульном режиме предполагает поиск функции с именем `newvalue`, которая принимает переменную строки и возвращает значение для столбца. Этот модуль может содержать любое количество кода Python, в том числе другие функции, операции импорта и т. д. 

Сведения о каждой точке расширения рассматриваются в следующих разделах. 

## <a name="imports"></a>Импорт 
Если вы используете тип блока Expression (Выражение), вы все равно можете добавлять операторы импорта в свой код, но все они должны быть сгруппированы в верхних строках вашего кода. Верно: 

```python
import math 
import numpy 
math.log(row["Score"])
```
 

Ошибка:  

```python
import math  
math.log(row["Score"])  
import numpy
```
 
 
Если вы используете тип блока Module (Модуль), вы можете следовать всем нормальным правилам Python для использования оператора import. 

## <a name="default-imports"></a>Операции импорта по умолчанию
Следующие операции импорта всегда включены и могут использоваться в коде. Их не требуется повторно импортировать. 

```python
import math  
import numbers  
import datetime  
import re  
import pandas as pd  
import numpy as np  
import scipy as sp
```
  

## <a name="installing-new-packages"></a>Установка новых пакетов
Чтобы использовать пакет, который не устанавливается по умолчанию, необходимо сначала установить его в средах, которые используются для подготовки данных. Эта установку необходимо выполнить как на локальном компьютере, так и на любых объектах вычисления, которые вы будете использовать.

Чтобы установить пакеты на объекте вычисления, необходимо изменить файл conda_dependencies.yml, расположенный в папке aml_config в корневом каталоге проекта.

### <a name="windows"></a>Windows 
Чтобы найти расположение в Windows, найдите установку для конкретного приложения Рython и ее каталог со скриптами, по умолчанию:  

`C:\Users\<user>\AppData\Local\AmlWorkbench\Python\Scripts.` 

Затем выполните одну из следующих команд: 

`conda install <libraryname>` 

или 

`pip install <libraryname> `

### <a name="mac"></a>Mac 
Чтобы найти расположение в Mac, найдите установку для конкретного приложения Рython и ее каталог со скриптами, по умолчанию: 

`/Users/<user>/Library/Caches/AmlWorkbench>/Python/bin` 

Затем выполните одну из следующих команд: 

`./conda install <libraryname>`

или 

`./pip install <libraryname>`

## <a name="column-data"></a>Данные столбцов 
Доступ к данным столбцов можно получить из строки, используя точечную нотацию или нотацию "ключ — значение". Имена столбцов, содержащие пробелы или специальные символы, нельзя получить с помощью точечной нотации. Переменная `row` всегда должна быть определена в обоих режимах расширений Рython (Module и Expression). 

Примеры: 

```python
    row.ColumnA + row.ColumnB  
    row["ColumnA"] + row["ColumnB"]
```

## <a name="file-reader"></a>Считывание файлов 
### <a name="purpose"></a>Назначение 
Эта точка расширения позволяет полностью контролировать процесс считывания файла в потоке данных. Система вызывает код, передавая список файлов, которые необходимо обработать, а ваш код должен создавать и возвращать таблицу данных Pandas. 

>[!NOTE]
>Эта точка расширения не работает в Spark. 


### <a name="how-to-use"></a>Использование 
Доступ к этой точке расширения можно получить с помощью мастера Open Data Source. Выберите файл на первой странице, а затем выберите расположение файла. На странице Choose File Parameters (Выберите параметры файла) откройте раскрывающийся список File Type (Тип файла) и выберите Custom File (Script) (Пользовательский файл (скрипт)). 

Коду будет присвоена таблица данных Pandas с именем "df", содержащая сведения о файлах, которые нужно считать. Если вы решили открыть каталог, содержащий несколько файлов, таблица данных будет содержать более одной строки.  

В этой таблице данных содержатся следующие столбцы: 
- Path — файл, который нужно считать.
- PathHint — указывает, где находится файл. Значения: Local, AzureBlobStorage, AzureDataLakeStorage.
- AuthenticationType — тип проверки подлинности, используемый для доступа к файлу. Значения: None, SasToken, OAuthToken.
- AuthenticationValue — содержит значение None или используемый токен.

### <a name="syntax"></a>Синтаксис 
Выражение: 

```python
    paths = df['Path'].tolist()  
    df = pd.read_csv(paths[0])
```


Модуль:  
```python
PathHint = Local  
def read(df):  
    paths = df['Path'].tolist()  
    filedf = pd.read_csv(paths[0])  
    return filedf  
```
 

## <a name="writer"></a>Модуль записи 
### <a name="purpose"></a>Назначение 
Эта точка расширения модуля записи позволяет полностью контролировать процесс записи данных в потоке данных. Система вызывает код, передавая таблицу данных, а код может использовать таблицу для записи данных любым подходящим способом. 

>[!NOTE]
>Эта точка расширения модуля записи не работает в Spark. 


### <a name="how-to-use"></a>Использование 
Эту точку расширения можно добавить с помощью блока Write Dataflow (Script) (Запись потока данных (скрипт)). Он доступен в меню верхнего уровня Transformations (Преобразования). 

### <a name="syntax"></a>Синтаксис 
Выражение: 

```python
    df.to_csv('c:\\temp\\output.csv')
```

Модуль:

```python
def write(df):  
    df.to_csv('c:\\temp\\output.csv')  
    return df
```
 
 
Этот пользовательский блок записи может существовать в середине списка шагов, поэтому, если вы используете модуль, ваша функция записи должна возвращать таблицу данных, которая является входными данными на следующем шаге. 

## <a name="add-column"></a>Добавление столбца 
### <a name="purpose"></a>Назначение
Эта точка расширения позволяет писать код Python для вычисления нового столбца. Написанный код имеет доступ к целой строке. Он должен возвращать новое значение столбца для каждой строки. 

### <a name="how-to-use"></a>Использование
Эту точку расширения можно добавить с помощью блока Аdd Column (Script) (Добавление столбца (скрипт)). Он доступен как в меню верхнего уровня Transformations (Преобразования), так и в контекстном меню столбца. 

### <a name="syntax"></a>Синтаксис
Выражение: 

```python
    math.log(row["Score"])
```

Модуль: 

```python
def newvalue(row):  
     return math.log(row["Score"])
```
 

## <a name="advanced-filter"></a>Применение расширенного фильтра
### <a name="purpose"></a>Назначение 
Эта точка расширения позволяет создавать настраиваемый фильтр. У вас есть доступ ко всей строке, и код должен возвращать значение True (включить строку) или False (исключить строку). 

### <a name="how-to-use"></a>Использование
Эту точку расширения можно добавить с помощью блока Advanced Filter (Script) (Расширенный фильтр (скрипт)). Он доступен в меню верхнего уровня Transformations (Преобразования). 

### <a name="syntax"></a>Синтаксис

Выражение: 

```python
    row["Score"] > 95
```

Модуль:  

```python
def includerow(row):  
    return row["Score"] > 95
```
 

## <a name="transform-dataflow"></a>Преобразование потока данных
### <a name="purpose"></a>Назначение 
Эта точка расширения позволяет полностью преобразовать поток данных. У вас есть доступ к таблице данных Pandas, содержащей все столбцы и строки, которые вы обрабатываете, а ваш код должен вернуть таблицу данных Pandas с новыми данными. 

>[!NOTE]
>При использовании этого расширения в Python все данные загружаются в память в таблице данных Pandas. 

В Spark все данные собираются на одном рабочем узле. Это может привести к нехватке памяти на рабочем узле, если данных слишком много. Используйте этот способ осторожно.

### <a name="how-to-use"></a>Использование 
Эту точку расширения можно добавить с помощью блока Transform Dataflow (Script) (Преобразование потока данных (скрипт)). Он доступен в меню верхнего уровня Transformations (Преобразования). 
### <a name="syntax"></a>Синтаксис 

Выражение: 

```python
    df['index-column'] = range(1, len(df) + 1)  
    df = df.reset_index()
```
 

Модуль: 

```python
def transform(df):  
    df['index-column'] = range(1, len(df) + 1)  
    df = df.reset_index()  
    return df
```
  

## <a name="transform-partition"></a>Преобразование секции  
### <a name="purpose"></a>Назначение 
Эта точка расширения позволяет преобразовывать секции потока данных. У вас есть доступ к таблице данных Pandas, содержащей все столбцы и строки этой секции, а ваш код должен вернуть таблицу данных Pandas с новыми данными. 

>[!NOTE]
>В Python может формироваться одна или несколько секций в зависимости от размера данных. В Spark вы будете работать с таблицей данных, содержащей данные секции на определенном рабочем узле. В обоих случаях не следует рассчитывать на доступ ко всему набору данных. 


### <a name="how-to-use"></a>Использование
Эту точку расширения можно добавить с помощью блока Transform Partition (Script) (Преобразование секции (скрипт)). Он доступен в меню верхнего уровня Transformations (Преобразования). 

### <a name="syntax"></a>Синтаксис 

Выражение: 

```python
    df['partition-id'] = index  
    df['index-column'] = range(1, len(df) + 1)  
    df = df.reset_index()
```
 

Модуль: 

```python
def transform(df, index):
    df['partition-id'] = index
    df['index-column'] = range(1, len(df) + 1)
    df = df.reset_index()
    return df
```


## <a name="datapreperror"></a>DataPrepError  
### <a name="error-values"></a>Ошибочные значения  
В подготовке данных существует понятие значения ошибки. Их создание и назначение описаны тут <link to error values doc>. 

Вы можете столкнуться со значениями ошибок в пользовательском коде Рython. Они являются экземплярами класса Python с именем `DataPrepError`. Этот класс инкапсулирует исключение Python и имеет несколько свойств, содержащих сведения об ошибке, которая возникла при обработке исходного значения, а также исходное значение. 


### <a name="datapreperror-class-definition"></a>Определение класса DataPrepError
```python 
class DataPrepError(Exception): 
    def __bool__(self): 
        return False 
``` 
Создание DataPrepError на платформе подготовки данных Рython обычно выглядит следующим образом: 
```python 
DataPrepError({ 
   'message':'Cannot convert to numeric value', 
   'originalValue': value, 
   'exceptionMessage': e.args[0], 
   '__errorCode__':'Microsoft.DPrep.ErrorValues.InvalidNumericType' 
}) 
``` 
#### <a name="how-to-use"></a>Использование 
Python можно запустить в точке расширения, чтобы создать класс DataPrepErrors в качестве возвращаемых значений, используя описанный выше метод создания. Более вероятно, что DataPrepErrors будет обнаружен при обработке данных в точке расширения. На этом этапе пользовательский код Python должен обрабатывать DataPrepError как допустимый тип данных. 

#### <a name="syntax"></a>Синтаксис 
Выражение:  
```python 
    if (isinstance(row["Score"], DataPrepError)): 
        row["Score"].originalValue 
    else: 
        row["Score"] 
``` 
```python 
    if (hasattr(row["Score"], "originalValue")): 
        row["Score"].originalValue 
    else: 
        row["Score"] 
``` 
Модуль:  
```python 
def newvalue(row): 
    if (isinstance(row["Score"], DataPrepError)): 
        return row["Score"].originalValue 
    else: 
        return row["Score"] 
``` 
```python 
def newvalue(row): 
    if (hasattr(row["Score"], "originalValue")): 
        return row["Score"].originalValue 
    else: 
        return row["Score"] 
```  
