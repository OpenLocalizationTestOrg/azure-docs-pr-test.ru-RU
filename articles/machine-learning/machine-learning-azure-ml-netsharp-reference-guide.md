---
title: "aaaGuide toohello Net # языку описания нейронных сетей | Документы Microsoft"
description: "Синтаксис для hello Net # нейронной сети спецификацию языка, вместе с примерами как toocreate настраиваемой нейронной сети моделировать в машинного Обучения Microsoft Azure, используя язык Net #"
services: machine-learning
documentationcenter: 
author: jeannt
manager: jhubbard
editor: cgronlun
ms.assetid: cfd1454b-47df-4745-b064-ce5f9b3be303
ms.service: machine-learning
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/31/2017
ms.author: jeannt
ms.openlocfilehash: 3493247ecc39ca3a1382510ad520d7017159ff62
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="guide-toonet-neural-network-specification-language-for-azure-machine-learning"></a><span data-ttu-id="6dfc9-103">Руководство по языку описания нейронных сетей tooNet # для машинного обучения Azure</span><span class="sxs-lookup"><span data-stu-id="6dfc9-103">Guide tooNet# neural network specification language for Azure Machine Learning</span></span>
## <a name="overview"></a><span data-ttu-id="6dfc9-104">Обзор</span><span class="sxs-lookup"><span data-stu-id="6dfc9-104">Overview</span></span>
<span data-ttu-id="6dfc9-105">NET # — это язык, разработанный Майкрософт, используемых toodefine архитектуры нейронной сети.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-105">Net# is a language developed by Microsoft that is used toodefine neural network architectures.</span></span> <span data-ttu-id="6dfc9-106">Его можно использовать в модулях нейронной сети Машинного обучения Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-106">You can use Net# in neural network modules in Microsoft Azure Machine Learning.</span></span>

<!-- This function doesn't currentlyappear in hello MicrosoftML documentation. If it is added in a future update, we can uncomment this text.

, or in hello `rxNeuralNetwork()` function in [MicrosoftML](https://msdn.microsoft.com/microsoft-r/microsoftml/microsoftml). 

-->

<span data-ttu-id="6dfc9-107">В этой статье вы узнаете, что основные понятия требуется toodevelop настраиваемой нейронной сети.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-107">In this article, you will learn basic concepts needed toodevelop a custom neural network:</span></span> 

* <span data-ttu-id="6dfc9-108">Требования к нейронной сети и как toodefine hello основные компоненты</span><span class="sxs-lookup"><span data-stu-id="6dfc9-108">Neural network requirements and how toodefine hello primary components</span></span>
* <span data-ttu-id="6dfc9-109">синтаксис Hello и ключевых слов hello спецификации языка Net #</span><span class="sxs-lookup"><span data-stu-id="6dfc9-109">hello syntax and keywords of hello Net# specification language</span></span>
* <span data-ttu-id="6dfc9-110">Примеры настраиваемых нейронных сетей, созданных с использованием Net#</span><span class="sxs-lookup"><span data-stu-id="6dfc9-110">Examples of custom neural networks created using Net#</span></span> 

[!INCLUDE [machine-learning-free-trial](../../includes/machine-learning-free-trial.md)]

## <a name="neural-network-basics"></a><span data-ttu-id="6dfc9-111">Основы нейронных сетей</span><span class="sxs-lookup"><span data-stu-id="6dfc9-111">Neural network basics</span></span>
<span data-ttu-id="6dfc9-112">Структура нейронной сети состоит из ***узлы*** , которые располагаются в ***слои***и Взвешенное ***подключений*** (или ***краев***) между узлы Hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-112">A neural network structure consists of ***nodes*** that are organized in ***layers***, and weighted ***connections*** (or ***edges***) between hello nodes.</span></span> <span data-ttu-id="6dfc9-113">подключение Hello направления, а каждому соединению соответствует ***источника*** узла и ***назначения*** узла.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-113">hello connections are directional, and each connection has a ***source*** node and a ***destination*** node.</span></span>  

<span data-ttu-id="6dfc9-114">Каждый ***обучаемый слой*** (скрытый или выходной) включает один или несколько ***пакетов подключений***.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-114">Each ***trainable layer*** (a hidden or an output layer) has one or more ***connection bundles***.</span></span> <span data-ttu-id="6dfc9-115">В пакете соединение состоит из исходного слоя и спецификацию hello подключения из этого слоя источника.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-115">A connection bundle consists of a source layer and a specification of hello connections from that source layer.</span></span> <span data-ttu-id="6dfc9-116">Все соединения hello в общей папке данного пакета hello же ***слой источника*** и hello же ***целевой слой***.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-116">All hello connections in a given bundle share hello same ***source layer*** and hello same ***destination layer***.</span></span> <span data-ttu-id="6dfc9-117">В Net # пакета соединения будет рассматриваться как принадлежащий toohello пакета целевой слой.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-117">In Net#, a connection bundle is considered as belonging toohello bundle's destination layer.</span></span>  

<span data-ttu-id="6dfc9-118">NET # поддерживает различные типы подключения пакетов, который позволяет настроить способ hello входными значениями являются сопоставленных toohidden слои и сопоставленные toohello выходов.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-118">Net# supports various kinds of connection bundles, which lets you customize hello way inputs are mapped toohidden layers and mapped toohello outputs.</span></span>   

<span data-ttu-id="6dfc9-119">по умолчанию Hello или стандартный набор является **полного набора**, в которой каждый узел hello слой источника является узлом подключенной tooevery hello целевой слой.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-119">hello default or standard bundle is a **full bundle**, in which each node in hello source layer is connected tooevery node in hello destination layer.</span></span>  

<span data-ttu-id="6dfc9-120">Кроме того Net # поддерживает следующие четыре типа пакетов расширенных подключения hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-120">Additionally, Net# supports hello following four kinds of advanced connection bundles:</span></span>  

* <span data-ttu-id="6dfc9-121">**Фильтрованные пакеты**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-121">**Filtered bundles**.</span></span> <span data-ttu-id="6dfc9-122">Hello пользователь может определять предикат с использованием расположений hello hello исходного слоя и hello конечный уровень узла.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-122">hello user can define a predicate by using hello locations of hello source layer node and hello destination layer node.</span></span> <span data-ttu-id="6dfc9-123">Узлы подключены всякий раз, когда hello предиката равно True.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-123">Nodes are connected whenever hello predicate is True.</span></span>
* <span data-ttu-id="6dfc9-124">**Сверточные пакеты**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-124">**Convolutional bundles**.</span></span> <span data-ttu-id="6dfc9-125">Hello пользователь может определять небольшие близко расположенных домах узлов в слой источника hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-125">hello user can define small neighborhoods of nodes in hello source layer.</span></span> <span data-ttu-id="6dfc9-126">Каждый узел в целевой слой hello является окружение подключенных tooone узлов в слой источника hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-126">Each node in hello destination layer is connected tooone neighborhood of nodes in hello source layer.</span></span>
* <span data-ttu-id="6dfc9-127">**Группирующие пакеты** и **пакеты нормализации ответов**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-127">**Pooling bundles** and **Response normalization bundles**.</span></span> <span data-ttu-id="6dfc9-128">Это аналогично tooconvolutional пакеты в этом hello пользователь определяет небольшой близко расположенных домах узлов в слой источника hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-128">These are similar tooconvolutional bundles in that hello user defines small neighborhoods of nodes in hello source layer.</span></span> <span data-ttu-id="6dfc9-129">Hello различие заключается в весовых коэффициентов hello краев hello в эти пакеты не являются trainable.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-129">hello difference is that hello weights of hello edges in these bundles are not trainable.</span></span> <span data-ttu-id="6dfc9-130">Вместо этого применяется Предопределенная функция toohello исходный узел значений toodetermine hello целевой узел значения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-130">Instead, a predefined function is applied toohello source node values toodetermine hello destination node value.</span></span>  

<span data-ttu-id="6dfc9-131">С помощью Net # toodefine hello структуре нейронной сети упрощает возможных toodefine сложных структур, таких как глубоких нейронных сетей или свертки произвольный измерений, которые известны tooimprove обучение на данных, таких как изображения, аудио или видео.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-131">Using Net# toodefine hello structure of a neural network makes it possible toodefine complex structures such as deep neural networks or convolutions of arbitrary dimensions, which are known tooimprove learning on data such as image, audio, or video.</span></span>  

## <a name="supported-customizations"></a><span data-ttu-id="6dfc9-132">Поддерживаемые настройки</span><span class="sxs-lookup"><span data-stu-id="6dfc9-132">Supported customizations</span></span>
<span data-ttu-id="6dfc9-133">Hello архитектура создаваемых моделей нейронной сети, создаваемые в машинном обучении Azure можно настроить с помощью Net # активно.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-133">hello architecture of neural network models that you create in Azure Machine Learning can be extensively customized by using Net#.</span></span> <span data-ttu-id="6dfc9-134">Вы можете:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-134">You can:</span></span>  

* <span data-ttu-id="6dfc9-135">Создание скрытых слоев и управления hello количество узлов в каждом слое.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-135">Create hidden layers and control hello number of nodes in each layer.</span></span>
* <span data-ttu-id="6dfc9-136">Укажите, как слои tooeach toobe подключены другие.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-136">Specify how layers are toobe connected tooeach other.</span></span>
* <span data-ttu-id="6dfc9-137">Определять специальные структуры подключения, такие как свертки и пакеты с распределением весов.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-137">Define special connectivity structures, such as convolutions and weight sharing bundles.</span></span>
* <span data-ttu-id="6dfc9-138">Задавать различные функции активации.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-138">Specify different activation functions.</span></span>  

<span data-ttu-id="6dfc9-139">Сведения о синтаксисе языка спецификации hello. в разделе [спецификация структуры](#Structure-specifications).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-139">For details of hello specification language syntax, see [Structure Specification](#Structure-specifications).</span></span>  

<span data-ttu-id="6dfc9-140">Примеры определения нейронных сетей для некоторых распространенных машинного обучения задачи из Симплексные toocomplex см [примеры](#Examples-of-Net#-usage).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-140">For examples of defining neural networks for some common machine learning tasks, from simplex toocomplex, see [Examples](#Examples-of-Net#-usage).</span></span>  

## <a name="general-requirements"></a><span data-ttu-id="6dfc9-141">Общие требования</span><span class="sxs-lookup"><span data-stu-id="6dfc9-141">General requirements</span></span>
* <span data-ttu-id="6dfc9-142">Должен быть точно один выходной слой, как минимум один входной слой, а также ноль или более скрытых слоев.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-142">There must be exactly one output layer, at least one input layer, and zero or more hidden layers.</span></span> 
* <span data-ttu-id="6dfc9-143">Каждый слой имеет фиксированное количество узлов, концептуально организованных в прямоугольную матрицу произвольных размеров.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-143">Each layer has a fixed number of nodes, conceptually arranged in a rectangular array of arbitrary dimensions.</span></span> 
* <span data-ttu-id="6dfc9-144">Входной слои, не имеют связанных обученной параметров и представляют hello точку, где данные экземпляра вводит hello сети.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-144">Input layers have no associated trained parameters and represent hello point where instance data enters hello network.</span></span> 
* <span data-ttu-id="6dfc9-145">Trainable слои (hello скрытого и выходного слоев) имеют связанные обученной параметров, известных как весовые коэффициенты и дисбаланса.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-145">Trainable layers (hello hidden and output layers) have associated trained parameters, known as weights and biases.</span></span> 
* <span data-ttu-id="6dfc9-146">Hello исходный и целевой узлы должны находиться в отдельные слои.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-146">hello source and destination nodes must be in separate layers.</span></span> 
* <span data-ttu-id="6dfc9-147">Подключения должны быть ациклического; Другими словами не может быть цепочки подключений начальные задней toohello первоначального исходного узла.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-147">Connections must be acyclic; in other words, there cannot be a chain of connections leading back toohello initial source node.</span></span>
* <span data-ttu-id="6dfc9-148">выходной слой Hello не может быть уровнем источника пакета соединения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-148">hello output layer cannot be a source layer of a connection bundle.</span></span>  

## <a name="structure-specifications"></a><span data-ttu-id="6dfc9-149">Спецификация структуры</span><span class="sxs-lookup"><span data-stu-id="6dfc9-149">Structure specifications</span></span>
<span data-ttu-id="6dfc9-150">Спецификация структуры нейронной сети состоит из трех разделов: hello **объявления константы**, hello **слоя объявление**, hello **объявление подключения**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-150">A neural network structure specification is composed of three sections: hello **constant declaration**, hello **layer declaration**, hello **connection declaration**.</span></span> <span data-ttu-id="6dfc9-151">а также дополнительного раздела **объявления общего доступа**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-151">There is also an optional **share declaration** section.</span></span> <span data-ttu-id="6dfc9-152">Hello разделы можно указать в любом порядке.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-152">hello sections can be specified in any order.</span></span>  

## <a name="constant-declaration"></a><span data-ttu-id="6dfc9-153">Объявление констант</span><span class="sxs-lookup"><span data-stu-id="6dfc9-153">Constant declaration</span></span>
<span data-ttu-id="6dfc9-154">Объявление констант является необязательным.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-154">A constant declaration is optional.</span></span> <span data-ttu-id="6dfc9-155">Он предоставляет toodefine означает значения, используемые в определении hello нейронной сети.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-155">It provides a means toodefine values used elsewhere in hello neural network definition.</span></span> <span data-ttu-id="6dfc9-156">оператор объявления Hello состоит из идентификатора, за которым следует знак равенства и выражение значения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-156">hello declaration statement consists of an identifier followed by an equal sign and a value expression.</span></span>   

<span data-ttu-id="6dfc9-157">Например, следующем за инструкцией hello определяет константу **x**:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-157">For example, hello following statement defines a constant **x**:</span></span>  

    Const X = 28;  

<span data-ttu-id="6dfc9-158">toodefine несколько констант одновременно, заключите имена идентификаторов hello и значения в фигурные скобки и разделяйте их точкой с запятой.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-158">toodefine two or more constants simultaneously, enclose hello identifier names and values in braces, and separate them by using semicolons.</span></span> <span data-ttu-id="6dfc9-159">Например:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-159">For example:</span></span>  

    Const { X = 28; Y = 4; }  

<span data-ttu-id="6dfc9-160">правая часть каждого выражения присваивания Hello может быть целое число, вещественное число, логическое значение (True или False) или математическое выражение.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-160">hello right-hand side of each assignment expression can be an integer, a real number, a Boolean value (True or False), or a mathematical expression.</span></span> <span data-ttu-id="6dfc9-161">Например:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-161">For example:</span></span>  

    Const { X = 17 * 2; Y = true; }  

## <a name="layer-declaration"></a><span data-ttu-id="6dfc9-162">Объявление слоев</span><span class="sxs-lookup"><span data-stu-id="6dfc9-162">Layer declaration</span></span>
<span data-ttu-id="6dfc9-163">требуется объявление Hello слоя.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-163">hello layer declaration is required.</span></span> <span data-ttu-id="6dfc9-164">Он определяет размер hello и источник hello слоя, включая атрибуты и пакеты подключения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-164">It defines hello size and source of hello layer, including its connection bundles and attributes.</span></span> <span data-ttu-id="6dfc9-165">Hello объявление оператора начинается с hello имя слоя hello (входной, скрытым или вывести), а затем по измерениям hello hello слоя (кортеж положительные целые числа).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-165">hello declaration statement starts with hello name of hello layer (input, hidden, or output), followed by hello dimensions of hello layer (a tuple of positive integers).</span></span> <span data-ttu-id="6dfc9-166">Например:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-166">For example:</span></span>  

    input Data auto;
    hidden Hidden[5,20] from Data all;
    output Result[2] from Hidden all;  

* <span data-ttu-id="6dfc9-167">Hello hello измерения является hello количество узлов в слое hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-167">hello product of hello dimensions is hello number of nodes in hello layer.</span></span> <span data-ttu-id="6dfc9-168">В этом примере существует два измерения [5,20], это означает, что существует 100 узлов в слое hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-168">In this example, there are two dimensions [5,20], which means there are  100 nodes in hello layer.</span></span>
* <span data-ttu-id="6dfc9-169">Hello слои, которые могут быть объявлены в любом порядке, за одним исключением: Если определено более одного входного слоя hello порядок, в котором они объявлены должен совпадать с порядком hello возможности hello входных данных.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-169">hello layers can be declared in any order, with one exception: If more than one input layer is defined, hello order in which they are declared must match hello order of features in hello input data.</span></span>  

<span data-ttu-id="6dfc9-170">toospecify ее hello количество узлов в слое определяется автоматически, используйте hello **автоматически** ключевое слово.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-170">toospecify that hello number of nodes in a layer be determined automatically, use hello **auto** keyword.</span></span> <span data-ttu-id="6dfc9-171">Hello **автоматически** ключевые слова имеют другой эффект, в зависимости от слоев hello:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-171">hello **auto** keyword has different effects, depending on hello layer:</span></span>  

* <span data-ttu-id="6dfc9-172">В объявлении входного слоя hello количество узлов равно hello количеством признаков в hello входных данных.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-172">In an input layer declaration, hello number of nodes is hello number of features in hello input data.</span></span>
* <span data-ttu-id="6dfc9-173">В объявлении скрытый слой hello узлов используется номер hello задается значение параметра hello для **число скрытых узлов**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-173">In a hidden layer declaration, hello number of nodes is hello number that is specified by hello parameter value for **Number of hidden nodes**.</span></span> 
* <span data-ttu-id="6dfc9-174">В объявлении выходной слой hello количество узлов равно 2 для классификации, 1 для равно toohello количество выходных узлов для мультиклассовой классификации и регрессии.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-174">In an output layer declaration, hello number of nodes is 2 for two-class classification, 1 for regression, and equal toohello number of output nodes for multiclass classification.</span></span>   

<span data-ttu-id="6dfc9-175">Например hello следующее определение сети позволяет hello размер всех toobe слои определяется автоматически:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-175">For example, hello following network definition allows hello size of all layers toobe automatically determined:</span></span>  

    input Data auto;
    hidden Hidden auto from Data all;
    output Result auto from Hidden all;  


<span data-ttu-id="6dfc9-176">Объявление слой trainable слоя (hello скрытого или выходного слоев) при необходимости можно включить вывод функции hello (также называемый функцией активации), значение по умолчанию — слишком**сигмоидальной** для моделей классификации и **линейной** для моделей регрессии.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-176">A layer declaration for a trainable layer (hello hidden or output layers) can optionally include hello output function (also called an activation function), which defaults too**sigmoid** for classification models, and **linear** for regression models.</span></span> <span data-ttu-id="6dfc9-177">(Даже если используется по умолчанию hello, можно явно указать функции hello активации, при необходимости для ясности.)</span><span class="sxs-lookup"><span data-stu-id="6dfc9-177">(Even if you use hello default, you can explicitly state hello activation function, if desired for clarity.)</span></span>

<span data-ttu-id="6dfc9-178">Hello выходных данных поддерживаются следующие функции:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-178">hello following output functions are supported:</span></span>  

* <span data-ttu-id="6dfc9-179">sigmoid</span><span class="sxs-lookup"><span data-stu-id="6dfc9-179">sigmoid</span></span>
* <span data-ttu-id="6dfc9-180">linear</span><span class="sxs-lookup"><span data-stu-id="6dfc9-180">linear</span></span>
* <span data-ttu-id="6dfc9-181">softmax</span><span class="sxs-lookup"><span data-stu-id="6dfc9-181">softmax</span></span>
* <span data-ttu-id="6dfc9-182">rlinear</span><span class="sxs-lookup"><span data-stu-id="6dfc9-182">rlinear</span></span>
* <span data-ttu-id="6dfc9-183">square</span><span class="sxs-lookup"><span data-stu-id="6dfc9-183">square</span></span>
* <span data-ttu-id="6dfc9-184">sqrt</span><span class="sxs-lookup"><span data-stu-id="6dfc9-184">sqrt</span></span>
* <span data-ttu-id="6dfc9-185">srlinear</span><span class="sxs-lookup"><span data-stu-id="6dfc9-185">srlinear</span></span>
* <span data-ttu-id="6dfc9-186">abs</span><span class="sxs-lookup"><span data-stu-id="6dfc9-186">abs</span></span>
* <span data-ttu-id="6dfc9-187">tanh</span><span class="sxs-lookup"><span data-stu-id="6dfc9-187">tanh</span></span> 
* <span data-ttu-id="6dfc9-188">brlinear</span><span class="sxs-lookup"><span data-stu-id="6dfc9-188">brlinear</span></span>  

<span data-ttu-id="6dfc9-189">Например, следующие объявления hello использует hello **softmax** функции:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-189">For example, hello following declaration uses hello **softmax** function:</span></span>  

    output Result [100] softmax from Hidden all;  

## <a name="connection-declaration"></a><span data-ttu-id="6dfc9-190">Объявление подключений</span><span class="sxs-lookup"><span data-stu-id="6dfc9-190">Connection declaration</span></span>
<span data-ttu-id="6dfc9-191">Сразу после определения hello trainable слоя, необходимо объявить соединений между hello слои, которые вы определили.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-191">Immediately after defining hello trainable layer, you must declare connections among hello layers you have defined.</span></span> <span data-ttu-id="6dfc9-192">Объявление пакета соединения Hello начинается с ключевого слова hello **из**, а затем по имени hello hello пакета источник слоя и hello вида toocreate соединений пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-192">hello connection bundle declaration starts with hello keyword **from**, followed by hello name of hello bundle's source layer and hello kind of connection bundle toocreate.</span></span>   

<span data-ttu-id="6dfc9-193">В настоящее время поддерживается пять видов пакетов подключений:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-193">Currently, five kinds of connection bundles are supported:</span></span>  

* <span data-ttu-id="6dfc9-194">**Полный** пакетов, обозначенном ключевое слово hello **все**</span><span class="sxs-lookup"><span data-stu-id="6dfc9-194">**Full** bundles, indicated by hello keyword **all**</span></span>
* <span data-ttu-id="6dfc9-195">**Отфильтрованные** пакетов, обозначенном ключевое слово hello **где**, а затем выражение предиката</span><span class="sxs-lookup"><span data-stu-id="6dfc9-195">**Filtered** bundles, indicated by hello keyword **where**, followed by a predicate expression</span></span>
* <span data-ttu-id="6dfc9-196">**Convolutional** пакетов, обозначенном ключевое слово hello **convolve**, а затем атрибуты свертки hello</span><span class="sxs-lookup"><span data-stu-id="6dfc9-196">**Convolutional** bundles, indicated by hello keyword **convolve**, followed by hello convolution attributes</span></span>
* <span data-ttu-id="6dfc9-197">**Создание пулов** пакетов, обозначенном ключевые слова hello **max пула** или **означает пула**</span><span class="sxs-lookup"><span data-stu-id="6dfc9-197">**Pooling** bundles, indicated by hello keywords **max pool** or **mean pool**</span></span>
* <span data-ttu-id="6dfc9-198">**Ответ нормализации** пакетов, обозначенном ключевое слово hello **нормы ответа**</span><span class="sxs-lookup"><span data-stu-id="6dfc9-198">**Response normalization** bundles, indicated by hello keyword **response norm**</span></span>      

## <a name="full-bundles"></a><span data-ttu-id="6dfc9-199">Полные пакеты</span><span class="sxs-lookup"><span data-stu-id="6dfc9-199">Full bundles</span></span>
<span data-ttu-id="6dfc9-200">Пакет полного соединения включает соединения из каждого узла в узел tooeach слоя hello источника в целевой слой hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-200">A full connection bundle includes a connection from each node in hello source layer tooeach node in hello destination layer.</span></span> <span data-ttu-id="6dfc9-201">Это тип сетевого подключения по умолчанию hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-201">This is hello default network connection type.</span></span>  

## <a name="filtered-bundles"></a><span data-ttu-id="6dfc9-202">Фильтрованные пакеты</span><span class="sxs-lookup"><span data-stu-id="6dfc9-202">Filtered bundles</span></span>
<span data-ttu-id="6dfc9-203">Спецификация фильтрованного пакета подключений содержит предикат, выраженный синтаксически, практически так же, как лямбда-выражение в C#.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-203">A filtered connection bundle specification includes a predicate, expressed syntactically, much like a C# lambda expression.</span></span> <span data-ttu-id="6dfc9-204">Hello следующий пример определяет два отфильтрованные пакеты:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-204">hello following example defines two filtered bundles:</span></span>  

    input Pixels [10, 20];
    hidden ByRow[10, 12] from Pixels where (s,d) => s[0] == d[0];
    hidden ByCol[5, 20] from Pixels where (s,d) => abs(s[1] - d[1]) <= 1;  

* <span data-ttu-id="6dfc9-205">В предикате hello для *ByRow*, **s** — это параметр, представляющий индекс в прямоугольный массив hello узлы входного слоя hello, *пикселей*, и **d**  — это параметр, представляющий индекс в массиве hello узлов скрытого слоя hello, *ByRow*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-205">In hello predicate for *ByRow*, **s** is a parameter representing an index into hello rectangular array of nodes of hello input layer, *Pixels*, and **d** is a parameter representing an index into hello array of nodes of hello hidden layer, *ByRow*.</span></span> <span data-ttu-id="6dfc9-206">Здравствуйте, оба типа **s** и **d** кортеж длина двумя целыми числами.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-206">hello type of both **s** and **d** is a tuple of integers of length two.</span></span> <span data-ttu-id="6dfc9-207">По сути, параметр **s** находится в диапазоне всех пар целых чисел с условиями *0 <= s[0] < 10* и *0 <= s[1] < 20*, а параметр **d** — в диапазоне всех пар целых чисел с условиями *0 <= d[0] < 10* и *0 <= d[1] < 12*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-207">Conceptually, **s** ranges over all pairs of integers with *0 <= s[0] < 10* and *0 <= s[1] < 20*, and **d** ranges over all pairs of integers, with *0 <= d[0] < 10* and *0 <= d[1] < 12*.</span></span> 
* <span data-ttu-id="6dfc9-208">В правой части выражения предиката hello hello имеется условие.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-208">On hello right-hand side of hello predicate expression, there is a condition.</span></span> <span data-ttu-id="6dfc9-209">В этом примере для каждого значения **s** и **d** таким образом, что hello условие имеет значение True, является ребром из источника hello слоя toohello узел назначения узла слоя.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-209">In this example, for every value of **s** and **d** such that hello condition is True, there is an edge from hello source layer node toohello destination layer node.</span></span> <span data-ttu-id="6dfc9-210">Таким образом, этот критерий фильтра показывает, что этот пакет hello включает подключения из узла "hello" определяется **s** toohello узла определяется **d** во всех случаях, где s [0] — равно tood [0].</span><span class="sxs-lookup"><span data-stu-id="6dfc9-210">Thus, this filter expression indicates that hello bundle includes a connection from hello node defined by **s** toohello node defined by **d** in all cases where s[0] is equal tood[0].</span></span>  

<span data-ttu-id="6dfc9-211">Дополнительно можно указать набор весов фильтрованного пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-211">Optionally, you can specify a set of weights for a filtered bundle.</span></span> <span data-ttu-id="6dfc9-212">Здравствуйте, значение для hello **весов** атрибут должен быть кортеж из числа с плавающей запятой с длиной, совпадающий с номером hello соединений, определенных в пакете hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-212">hello value for hello **Weights** attribute must be a tuple of floating point values with a length that matches hello number of connections defined by hello bundle.</span></span> <span data-ttu-id="6dfc9-213">По умолчанию веса генерируются случайно.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-213">By default, weights are randomly generated.</span></span>  

<span data-ttu-id="6dfc9-214">Взвешенные значения группируются по hello индекс узла назначения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-214">Weight values are grouped by hello destination node index.</span></span> <span data-ttu-id="6dfc9-215">То есть, если подключен hello первый узел назначения заняло исходных узлов hello сначала *K* элементы hello **весов** кортежа, hello весов для hello первый целевой узел, в порядке индексирования источника.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-215">That is, if hello first destination node is connected tooK source nodes, hello first *K* elements of hello **Weights** tuple are hello weights for hello first destination node, in source index order.</span></span> <span data-ttu-id="6dfc9-216">Здравствуйте, тоже относится к hello оставшихся узлов назначения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-216">hello same applies for hello remaining destination nodes.</span></span>  

<span data-ttu-id="6dfc9-217">Это возможно toospecify весовые коэффициенты непосредственно как постоянные значения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-217">It's possible toospecify weights directly as constant values.</span></span> <span data-ttu-id="6dfc9-218">Например если ранее вы узнали hello весовые коэффициенты, можно указать их как константы, используя следующий синтаксис:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-218">For example, if you learned hello weights previously, you can specify them as constants using this syntax:</span></span>

    const Weights_1 = [0.0188045055, 0.130500451, ...]


## <a name="convolutional-bundles"></a><span data-ttu-id="6dfc9-219">Сверточные пакеты</span><span class="sxs-lookup"><span data-stu-id="6dfc9-219">Convolutional bundles</span></span>
<span data-ttu-id="6dfc9-220">Если hello обучающих данных имеют однородную структуру, convolutional подключения являются toolearn часто используемые функции hello данных высокого уровня.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-220">When hello training data has a homogeneous structure, convolutional connections are commonly used toolearn high-level features of hello data.</span></span> <span data-ttu-id="6dfc9-221">Например, изображение, аудио- или видеоданные, пространственная или временная размерность могут быть достаточно однородными.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-221">For example, in image, audio, or video data, spatial or temporal dimensionality can be fairly uniform.</span></span>  

<span data-ttu-id="6dfc9-222">Convolutional пакеты используют прямоугольный **ядер** , являются вбок и фиксируется по измерениям hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-222">Convolutional bundles employ rectangular **kernels** that are slid through hello dimensions.</span></span> <span data-ttu-id="6dfc9-223">По существу, каждая ядра определяет набором весовых коэффициентов, примененных в локальном близко расположенных домах, который ссылается tooas **приложений ядра**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-223">Essentially, each kernel defines a set of weights applied in local neighborhoods, referred tooas **kernel applications**.</span></span> <span data-ttu-id="6dfc9-224">Каждое приложение ядра соответствует tooa узел в hello исходного слоя — hello ссылка tooas **центральный узел**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-224">Each kernel application corresponds tooa node in hello source layer, which is referred tooas hello **central node**.</span></span> <span data-ttu-id="6dfc9-225">Hello весов ядро совместно используемые много подключений.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-225">hello weights of a kernel are shared among many connections.</span></span> <span data-ttu-id="6dfc9-226">В набор convolutional каждого ядра прямоугольная и все ядра приложения hello же размера.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-226">In a convolutional bundle, each kernel is rectangular and all kernel applications are hello same size.</span></span>  

<span data-ttu-id="6dfc9-227">Convolutional пакеты поддерживают hello следующие атрибуты:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-227">Convolutional bundles support hello following attributes:</span></span>

<span data-ttu-id="6dfc9-228">**InputShape** определяет размерность hello слой источника hello целях hello convolutional пакет.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-228">**InputShape** defines hello dimensionality of hello source layer for hello purposes of this convolutional bundle.</span></span> <span data-ttu-id="6dfc9-229">Hello значение должно быть кортеж положительных целых чисел.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-229">hello value must be a tuple of positive integers.</span></span> <span data-ttu-id="6dfc9-230">Hello продукта hello целых чисел должно быть равно числу узлов в слой источника hello hello, но в противном случае она не должна toomatch hello размерность, объявленным для hello слой источника.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-230">hello product of hello integers must equal hello number of nodes in hello source layer, but otherwise, it does not need toomatch hello dimensionality declared for hello source layer.</span></span> <span data-ttu-id="6dfc9-231">Длина этого кортежа Hello становится hello **арность** значение для hello convolutional пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-231">hello length of this tuple becomes hello **arity** value for hello convolutional bundle.</span></span> <span data-ttu-id="6dfc9-232">(Обычно арность ссылается toohello число аргументов или операндов, которые может выполнять функции).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-232">(Typically arity refers toohello number of arguments or operands that a function can take.)</span></span>  

<span data-ttu-id="6dfc9-233">фигуры toodefine hello и расположения ядер hello использовать атрибуты hello **KernelShape**, **Stride**, **заполнение**, **LowerPad**, и **UpperPad**:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-233">toodefine hello shape and locations of hello kernels, use hello attributes **KernelShape**, **Stride**, **Padding**, **LowerPad**, and **UpperPad**:</span></span>   

* <span data-ttu-id="6dfc9-234">**KernelShape**: (обязательный) определяет размерность hello каждого ядра для hello convolutional пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-234">**KernelShape**: (required) Defines hello dimensionality of each kernel for hello convolutional bundle.</span></span> <span data-ttu-id="6dfc9-235">Hello значение должно быть кортеж положительных целых чисел с длиной, равным hello арность hello пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-235">hello value must be a tuple of positive integers with a length that equals hello arity of hello bundle.</span></span> <span data-ttu-id="6dfc9-236">Каждый компонент этот кортеж должен быть не больше, чем hello соответствующего компонента **InputShape**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-236">Each component of this tuple must be no greater than hello corresponding component of **InputShape**.</span></span> 
* <span data-ttu-id="6dfc9-237">**STRIDE**: hello (необязательно) определяет, скользящий шаг размеры hello свертки (один шаг размер каждого измерения), hello расстояния между узлами центра hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-237">**Stride**: (optional) Defines hello sliding step sizes of hello convolution (one step size for each dimension), that is hello distance between hello central nodes.</span></span> <span data-ttu-id="6dfc9-238">Hello значение должно быть кортеж положительных целых чисел с длиной, арность hello hello пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-238">hello value must be a tuple of positive integers with a length that is hello arity of hello bundle.</span></span> <span data-ttu-id="6dfc9-239">Каждый компонент этот кортеж должен быть не больше, чем hello соответствующего компонента **KernelShape**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-239">Each component of this tuple must be no greater than hello corresponding component of **KernelShape**.</span></span> <span data-ttu-id="6dfc9-240">значение по умолчанию Hello — кортеж с все равно tooone компонентов.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-240">hello default value is a tuple with all components equal tooone.</span></span> 
* <span data-ttu-id="6dfc9-241">**Совместное использование**: hello вес (необязательно) определяет, для управления доступом для каждого измерения hello свертки.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-241">**Sharing**: (optional) Defines hello weight sharing for each dimension of hello convolution.</span></span> <span data-ttu-id="6dfc9-242">Hello значение может быть одиночное логическое значение или кортеж логических значений с длиной, арность hello hello пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-242">hello value can be a single Boolean value or a tuple of Boolean values with a length that is hello arity of hello bundle.</span></span> <span data-ttu-id="6dfc9-243">Расширенные toobe кортеж hello правильную длину со всеми компонентами является одиночное логическое значение равно toohello заданное значение.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-243">A single Boolean value is extended toobe a tuple of hello correct length with all components equal toohello specified value.</span></span> <span data-ttu-id="6dfc9-244">значение по умолчанию Hello — кортеж, состоящий из всех значений True.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-244">hello default value is a tuple that consists of all True values.</span></span> 
* <span data-ttu-id="6dfc9-245">**MapCount**: сопоставления (необязательно) определяет hello количество компонентов для hello convolutional пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-245">**MapCount**: (optional) Defines hello number of feature maps for hello convolutional bundle.</span></span> <span data-ttu-id="6dfc9-246">Hello значение может быть положительным целым числом или кортежа положительных целых чисел с длиной, арность hello hello пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-246">hello value can be a single positive integer or a tuple of positive integers with a length that is hello arity of hello bundle.</span></span> <span data-ttu-id="6dfc9-247">Целочисленное значение расширяется toobe кортеж hello правильной длины с первой toohello равно hello компоненты указанное значение и все остальные компоненты равно tooone Здравствуйте.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-247">A single integer value is extended toobe a tuple of hello correct length with hello first components equal toohello specified value and all hello remaining components equal tooone.</span></span> <span data-ttu-id="6dfc9-248">значение по умолчанию Hello — один.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-248">hello default value is one.</span></span> <span data-ttu-id="6dfc9-249">Общее число компонентов схемы Hello — hello совокупность hello компоненты hello кортежа.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-249">hello total number of feature maps is hello product of hello components of hello tuple.</span></span> <span data-ttu-id="6dfc9-250">разбиение Hello это общее число во всех компонентах hello определяет, как значения карты компонента hello группируются в узлы назначения hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-250">hello factoring of this total number across hello components determines how hello feature map values are grouped in hello destination nodes.</span></span> 
* <span data-ttu-id="6dfc9-251">**Весовые коэффициенты**: (необязательно) определяет hello начальной весовые коэффициенты для hello пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-251">**Weights**: (optional) Defines hello initial weights for hello bundle.</span></span> <span data-ttu-id="6dfc9-252">Hello значение должно быть кортеж из числа с плавающей запятой с длиной, hello числа ядер раз hello весовых коэффициентов каждого ядра, описанных далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-252">hello value must be a tuple of floating point values with a length that is hello number of kernels times hello number of weights per kernel, as defined later in this article.</span></span> <span data-ttu-id="6dfc9-253">веса по умолчанию Hello случайным образом.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-253">hello default weights are randomly generated.</span></span>  

<span data-ttu-id="6dfc9-254">Существует два набора свойств, определяющих заполнения, свойства hello, взаимно исключают друг друга.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-254">There are two sets of properties that control padding, hello properties being mutually exclusive:</span></span>

* <span data-ttu-id="6dfc9-255">**Заполнение**: (необязательно) определяет ли hello ввода следует заполнены с помощью **схему заполнения по умолчанию**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-255">**Padding**: (optional) Determines whether hello input should be padded by using a **default padding scheme**.</span></span> <span data-ttu-id="6dfc9-256">Hello значением может быть одиночное логическое значение, или может быть кортеж логических значений с длиной, арность hello hello пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-256">hello value can be a single Boolean value, or it can be a tuple of Boolean values with a length that is hello arity of hello bundle.</span></span> <span data-ttu-id="6dfc9-257">Расширенные toobe кортеж hello правильную длину со всеми компонентами является одиночное логическое значение равно toohello заданное значение.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-257">A single Boolean value is extended toobe a tuple of hello correct length with all components equal toohello specified value.</span></span> <span data-ttu-id="6dfc9-258">Значение hello измерения имеет значение True, источник hello логически недостающие в этом измерении с приложениями дополнительные ядра toosupport ячейки с нулевым значением, таким образом, hello центра узлы hello первый и последний ядер в этом измерении hello первый и последний узлы в этом измерении на уровне источника hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-258">If hello value for a dimension is True, hello source is logically padded in that dimension with zero-valued cells toosupport additional kernel applications, such that hello central nodes of hello first and last kernels in that dimension are hello first and last nodes in that dimension in hello source layer.</span></span> <span data-ttu-id="6dfc9-259">Таким образом, число hello «пустой» узлов в каждом измерении определяется определяется автоматически, toofit точно *(InputShape [d] - 1) / Stride [d] + 1* ядер в слой источника дополняются hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-259">Thus, hello number of "dummy" nodes in each dimension is determined automatically, toofit exactly *(InputShape[d] - 1) / Stride[d] + 1* kernels into hello padded source layer.</span></span> <span data-ttu-id="6dfc9-260">Если значение hello измерения имеет значение False, hello ядер определяются так, чтобы hello количество узлов для каждой стороны, опущены hello же (вверх разницу tooa 1).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-260">If hello value for a dimension is False, hello kernels are defined so that hello number of nodes on each side that are left out is hello same (up tooa difference of 1).</span></span> <span data-ttu-id="6dfc9-261">значение по умолчанию Hello этого атрибута — кортеж с все равно tooFalse компонентов.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-261">hello default value of this attribute is a tuple with all components equal tooFalse.</span></span>
* <span data-ttu-id="6dfc9-262">**UpperPad** и **LowerPad**: (необязательно) укажите больший контроль над hello объем toouse заполнения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-262">**UpperPad** and **LowerPad**: (optional) Provide greater control over hello amount of padding toouse.</span></span> <span data-ttu-id="6dfc9-263">**Важно:** эти атрибуты можно определить, если и только если hello **заполнение** свойство выше ***не*** определен.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-263">**Important:** These attributes can be defined if and only if hello **Padding** property above is ***not*** defined.</span></span> <span data-ttu-id="6dfc9-264">Hello значения должны быть целочисленный кортежей с длиной, арность hello hello пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-264">hello values should be integer-valued tuples with lengths that are hello arity of hello bundle.</span></span> <span data-ttu-id="6dfc9-265">Если эти атрибуты указаны, «пустой» узлы будут добавлены toohello нижнем и верхнем концах каждого измерения hello входного слоя.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-265">When these attributes are specified, "dummy" nodes are added toohello lower and upper ends of each dimension of hello input layer.</span></span> <span data-ttu-id="6dfc9-266">Hello количество узлов добавлен toohello нижнем и верхнем концах в каждом измерении определяется **LowerPad**[i] и **UpperPad**[i] соответственно.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-266">hello number of nodes added toohello lower and upper ends in each dimension is determined by **LowerPad**[i] and **UpperPad**[i] respectively.</span></span> <span data-ttu-id="6dfc9-267">tooensure ядер соответствие только слишком «real» и не слишком «пустой» узлам hello следующие условия должны быть выполнены.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-267">tooensure that kernels correspond only too"real" nodes and not too"dummy" nodes, hello following conditions must be met:</span></span>
  * <span data-ttu-id="6dfc9-268">Каждый компонент атрибута **LowerPad** должен быть строго меньше, чем KernelShape[d]/2.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-268">Each component of **LowerPad** must be strictly less than KernelShape[d]/2.</span></span> 
  * <span data-ttu-id="6dfc9-269">Каждый компонент атрибута **UpperPad** должен быть не больше, чем KernelShape[d]/2.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-269">Each component of **UpperPad** must be no greater than KernelShape[d]/2.</span></span> 
  * <span data-ttu-id="6dfc9-270">значение по умолчанию Hello этих атрибутов — кортеж с все равно too0 компонентов.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-270">hello default value of these attributes is a tuple with all components equal too0.</span></span> 

<span data-ttu-id="6dfc9-271">параметр Hello **заполнение** = true позволяет при необходимости tookeep hello «центр» hello ядра внутри hello «real» введите размер внутреннего отступа как есть.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-271">hello setting **Padding** = true allows as much padding as is needed tookeep hello "center" of hello kernel inside hello "real" input.</span></span> <span data-ttu-id="6dfc9-272">При этом изменяется математические hello немного для вычисления размера выходного hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-272">This changes hello math a bit for computing hello output size.</span></span> <span data-ttu-id="6dfc9-273">Как правило, hello выходной размер *D* вычисляется как *D = (I - K) / S + 1*, где *я* — hello размер входных данных, *K* размер ядра hello, *S* — hello stride и  */*  — целочисленное деление (round к нулю).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-273">Generally, hello output size *D* is computed as *D = (I - K) / S + 1*, where *I* is hello input size, *K* is hello kernel size, *S* is hello stride, and */* is integer division (round toward zero).</span></span> <span data-ttu-id="6dfc9-274">Если значение UpperPad = [1, 1] hello указать размер *я* — 29 и, следовательно, *D = (29-5) / 2 + 1 = 13*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-274">If you set UpperPad = [1, 1], hello input size *I* is effectively 29, and thus *D = (29 - 5) / 2 + 1 = 13*.</span></span> <span data-ttu-id="6dfc9-275">Но если **Padding** = true, тогда и *I* фактически вытесняется *K - 1*; следовательно *D = ((28 + 4) - 5) / 2 + 1 = 27 / 2 + 1 = 13 + 1 = 14*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-275">However, when **Padding** = true, essentially *I* gets bumped up by *K - 1*; hence *D = ((28 + 4) - 5) / 2 + 1 = 27 / 2 + 1 = 13 + 1 = 14*.</span></span> <span data-ttu-id="6dfc9-276">При задании значений для **UpperPad** и **LowerPad** вы получаете гораздо больший контроль над hello заполнение не вы просто набор **заполнение** = true.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-276">By specifying values for **UpperPad** and **LowerPad** you get much more control over hello padding than if you just set **Padding** = true.</span></span>

<span data-ttu-id="6dfc9-277">Дополнительную информацию о сверточных сетях и их приложениях см. в следующих статьях:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-277">For more information about convolutional networks and their applications, see these articles:</span></span>  

* [<span data-ttu-id="6dfc9-278">http://deeplearning.net/tutorial/lenet.html </span><span class="sxs-lookup"><span data-stu-id="6dfc9-278">http://deeplearning.net/tutorial/lenet.html </span></span>](http://deeplearning.net/tutorial/lenet.html)
* [<span data-ttu-id="6dfc9-279">http://research.microsoft.com/pubs/68920/icdar03.pdf</span><span class="sxs-lookup"><span data-stu-id="6dfc9-279">http://research.microsoft.com/pubs/68920/icdar03.pdf</span></span>](http://research.microsoft.com/pubs/68920/icdar03.pdf) 
* [<span data-ttu-id="6dfc9-280">http://people.csail.mit.edu/jvb/papers/cnn_tutorial.pdf</span><span class="sxs-lookup"><span data-stu-id="6dfc9-280">http://people.csail.mit.edu/jvb/papers/cnn_tutorial.pdf</span></span>](http://people.csail.mit.edu/jvb/papers/cnn_tutorial.pdf)  

## <a name="pooling-bundles"></a><span data-ttu-id="6dfc9-281">Группирующие пакеты</span><span class="sxs-lookup"><span data-stu-id="6dfc9-281">Pooling bundles</span></span>
<span data-ttu-id="6dfc9-282">Объект **пулов пакета** применяется geometry аналогичные tooconvolutional возможность подключения, но он использует стандартные функции toosource значения tooderive hello целевой узел значение узла.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-282">A **pooling bundle** applies geometry similar tooconvolutional connectivity, but it uses predefined functions toosource node values tooderive hello destination node value.</span></span> <span data-ttu-id="6dfc9-283">Следовательно, группирующие пакеты не имеют обучаемого состояния (весов или смещений).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-283">Hence, pooling bundles have no trainable state (weights or biases).</span></span> <span data-ttu-id="6dfc9-284">Поддержка пакетов, всех hello convolutional атрибуты за исключением организации пулов **доступ**, **MapCount**, и **весов**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-284">Pooling bundles support all hello convolutional attributes except **Sharing**, **MapCount**, and **Weights**.</span></span>  

<span data-ttu-id="6dfc9-285">Как правило hello ядер, представленные на смежные пулов единицы не перекрываются.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-285">Typically, hello kernels summarized by adjacent pooling units do not overlap.</span></span> <span data-ttu-id="6dfc9-286">Если Stride [d] [d] равно tooKernelShape в каждом измерении, полученный слоя hello — hello традиционные локальные пулов уровня, который обычно используются в convolutional нейронных сетей.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-286">If Stride[d] is equal tooKernelShape[d] in each dimension, hello layer obtained is hello traditional local pooling layer, which is commonly employed in convolutional neural networks.</span></span> <span data-ttu-id="6dfc9-287">Каждый узел назначения вычисляет hello максимальное и среднее hello действий hello объекта его ядра в слой источника hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-287">Each destination node computes hello maximum or hello mean of hello activities of its kernel in hello source layer.</span></span>  

<span data-ttu-id="6dfc9-288">Следующий пример Hello рассмотрены пулов пакета:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-288">hello following example illustrates a pooling bundle:</span></span> 

    hidden P1 [5, 12, 12]
      from C1 max pool {
        InputShape  = [ 5, 24, 24];
        KernelShape = [ 1,  2,  2];
        Stride      = [ 1,  2,  2];
      }  

* <span data-ttu-id="6dfc9-289">арность Hello набора hello равно 3 (hello длины кортежей hello **InputShape**, **KernelShape**, и **Stride**).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-289">hello arity of hello bundle is 3 (hello length of hello tuples **InputShape**, **KernelShape**, and **Stride**).</span></span> 
* <span data-ttu-id="6dfc9-290">Hello количество узлов в слое источника hello *5 * 24 * 24 = 2880*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-290">hello number of nodes in hello source layer is *5 * 24 * 24 = 2880*.</span></span> 
* <span data-ttu-id="6dfc9-291">Это стандартный локальный группирующий слой, так как **KernelShape** = **Stride**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-291">This is a traditional local pooling layer because **KernelShape** and **Stride** are equal.</span></span> 
* <span data-ttu-id="6dfc9-292">Hello количество узлов в слое назначения hello *5 * 12 * 12 = 1440*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-292">hello number of nodes in hello destination layer is *5 * 12 * 12 = 1440*.</span></span>  

<span data-ttu-id="6dfc9-293">Дополнительную информацию о группирующих слоях см. в статьях:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-293">For more information about pooling layers, see these articles:</span></span>  

* <span data-ttu-id="6dfc9-294">[http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf) (Section 3.4)</span><span class="sxs-lookup"><span data-stu-id="6dfc9-294">[http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf) (Section 3.4)</span></span>
* [<span data-ttu-id="6dfc9-295">http://cs.nyu.edu/~koray/publis/lecun-iscas-10.pdf</span><span class="sxs-lookup"><span data-stu-id="6dfc9-295">http://cs.nyu.edu/~koray/publis/lecun-iscas-10.pdf</span></span>](http://cs.nyu.edu/~koray/publis/lecun-iscas-10.pdf) 
* [<span data-ttu-id="6dfc9-296">http://cs.nyu.edu/~koray/publis/jarrett-iccv-09.pdf</span><span class="sxs-lookup"><span data-stu-id="6dfc9-296">http://cs.nyu.edu/~koray/publis/jarrett-iccv-09.pdf</span></span>](http://cs.nyu.edu/~koray/publis/jarrett-iccv-09.pdf)

## <a name="response-normalization-bundles"></a><span data-ttu-id="6dfc9-297">Пакеты нормализации ответов</span><span class="sxs-lookup"><span data-stu-id="6dfc9-297">Response normalization bundles</span></span>
<span data-ttu-id="6dfc9-298">**Ответ нормализации** схема локального нормализации, появившийся Geoffrey Hinton и т. п., в документе hello [ImageNet Classiﬁcation с глубокой Convolutional нейронных сетей](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-298">**Response normalization** is a local normalization scheme that was first introduced by Geoffrey Hinton, et al, in hello paper [ImageNet Classiﬁcation with Deep Convolutional Neural Networks](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf).</span></span> <span data-ttu-id="6dfc9-299">Ответ Нормализацией называют обобщение используется tooaid в Нейронная сеть.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-299">Response normalization is used tooaid generalization in neural nets.</span></span> <span data-ttu-id="6dfc9-300">При один нейрон срабатывания на уровне очень высокий уровень активации, слой нормализации локальной ответа подавляет уровень активации hello hello вокруг нейронов.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-300">When one neuron is firing at a very high activation level, a local response normalization layer suppresses hello activation level of hello surrounding neurons.</span></span> <span data-ttu-id="6dfc9-301">Это выполняется с помощью трех параметров (***α***, ***β*** и ***k***) и сверточной структуры (или формы окрестности).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-301">This is done by using three parameters (***α***, ***β***, and ***k***) and a convolutional structure (or neighborhood shape).</span></span> <span data-ttu-id="6dfc9-302">Каждый нейрон в целевой слой hello ***y*** соответствует нейрон tooa ***x*** в слой источника hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-302">Every neuron in hello destination layer ***y*** corresponds tooa neuron ***x*** in hello source layer.</span></span> <span data-ttu-id="6dfc9-303">Здравствуйте, уровень активации ***y*** определяется hello следующую формулу, где ***f*** уровень активации hello нейрона, и ***Nx*** ядра hello (или hello набор, содержащий hello нейроны в районе hello ***x***), в соответствии с определением hello, следуя convolutional структуры:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-303">hello activation level of ***y*** is given by hello following formula, where ***f*** is hello activation level of a neuron, and ***Nx*** is hello kernel (or hello set that contains hello neurons in hello neighborhood of ***x***), as defined by hello following convolutional structure:</span></span>  

![][1]  

<span data-ttu-id="6dfc9-304">Пакеты нормализации ответа поддерживает все атрибуты convolutional hello, за исключением **доступ**, **MapCount**, и **весов**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-304">Response normalization bundles support all hello convolutional attributes except **Sharing**, **MapCount**, and **Weights**.</span></span>  

* <span data-ttu-id="6dfc9-305">Если ядра hello содержит нейронов hello же карту в качестве ***x***, схема нормализации hello — ссылка tooas **же сопоставить нормализации**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-305">If hello kernel contains neurons in hello same map as ***x***, hello normalization scheme is referred tooas **same map normalization**.</span></span> <span data-ttu-id="6dfc9-306">toodefine же сопоставить нормализации, первая координата hello в **InputShape** должно иметь значение 1, hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-306">toodefine same map normalization, hello first coordinate in **InputShape** must have hello value 1.</span></span>
* <span data-ttu-id="6dfc9-307">Если ядра hello содержит нейронов hello же пространственных позиции ***x***, но нейронов hello в других сопоставлений, hello нормализации схема называется **через сопоставляет нормализации**.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-307">If hello kernel contains neurons in hello same spatial position as ***x***, but hello neurons are in other maps, hello normalization scheme is called **across maps normalization**.</span></span> <span data-ttu-id="6dfc9-308">Этот тип ответа нормализации реализует один из видов боковое inhibition по типа hello, обнаруженные в реальном нейронов Создание конкуренции за большой активации уровни среди нейрон выходов, вычисляемый на разных картах.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-308">This type of response normalization implements a form of lateral inhibition inspired by hello type found in real neurons, creating competition for big activation levels amongst neuron outputs computed on different maps.</span></span> <span data-ttu-id="6dfc9-309">toodefine через сопоставляет нормализации, hello первой оси должно быть целым числом, больше единицы и не должен превышать число hello карты и rest hello координат hello должен иметь значение hello 1.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-309">toodefine across maps normalization, hello first coordinate must be an integer greater than one and no greater than hello number of maps, and hello rest of hello coordinates must have hello value 1.</span></span>  

<span data-ttu-id="6dfc9-310">Поскольку пакеты ответа нормализации применяются Предопределенная функция toosource значения toodetermine hello целевой узел значение узла, они имеют состояние не trainable (веса или отклонения от).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-310">Because response normalization bundles apply a predefined function toosource node values toodetermine hello destination node value, they have no trainable state (weights or biases).</span></span>   

<span data-ttu-id="6dfc9-311">**Предупреждения**: hello узлов в слое назначения hello соответствуют tooneurons, которые являются узлами центра hello hello ядер.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-311">**Alert**: hello nodes in hello destination layer correspond tooneurons that are hello central nodes of hello kernels.</span></span> <span data-ttu-id="6dfc9-312">Например, если KernelShape [d] является нечетным, затем *KernelShape [d] / 2* соответствует toohello ядра центральный узел.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-312">For example, if KernelShape[d] is odd, then *KernelShape[d]/2* corresponds toohello central kernel node.</span></span> <span data-ttu-id="6dfc9-313">Если *KernelShape [d]* является четным, hello центральный узел находится на *KernelShape [d] / 2-1*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-313">If *KernelShape[d]* is even, hello central node is at *KernelShape[d]/2 - 1*.</span></span> <span data-ttu-id="6dfc9-314">Таким образом Если **заполнение**[d] имеет значение False, сначала hello и hello последнего *KernelShape [d] / 2* узлы не имеют соответствующие узлы в целевой слой hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-314">Therefore, if **Padding**[d] is False, hello first and hello last *KernelShape[d]/2* nodes do not have corresponding nodes in hello destination layer.</span></span> <span data-ttu-id="6dfc9-315">tooavoid этой ситуации определить **заполнение** как [true значение равно true, true,...,].</span><span class="sxs-lookup"><span data-stu-id="6dfc9-315">tooavoid this situation, define **Padding** as [true, true, …, true].</span></span>  

<span data-ttu-id="6dfc9-316">В дополнение к этому toohello четыре атрибута как описано выше, пакеты нормализации ответ также hello поддержки следующие атрибуты:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-316">In addition toohello four attributes described earlier, response normalization bundles also support hello following attributes:</span></span>  

* <span data-ttu-id="6dfc9-317">**Альфа-канал**: (обязательный) определяет значение с плавающей запятой, соответствующий слишком***α*** в предыдущей формуле hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-317">**Alpha**: (required) Specifies a floating-point value that corresponds too***α*** in hello previous formula.</span></span> 
* <span data-ttu-id="6dfc9-318">**Бета-версии**: (обязательный) определяет значение с плавающей запятой, соответствующий слишком***β*** в предыдущей формуле hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-318">**Beta**: (required) Specifies a floating-point value that corresponds too***β*** in hello previous formula.</span></span> 
* <span data-ttu-id="6dfc9-319">**Смещение**: (необязательно) задает значение с плавающей запятой, соответствующий слишком***k*** в предыдущей формуле hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-319">**Offset**: (optional) Specifies a floating-point value that corresponds too***k*** in hello previous formula.</span></span> <span data-ttu-id="6dfc9-320">По умолчанию too1.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-320">It defaults too1.</span></span>  

<span data-ttu-id="6dfc9-321">Hello следующий пример определяет пакет ответа нормализации с помощью этих атрибутов:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-321">hello following example defines a response normalization bundle using these attributes:</span></span>  

    hidden RN1 [5, 10, 10]
      from P1 response norm {
        InputShape  = [ 5, 12, 12];
        KernelShape = [ 1,  3,  3];
        Alpha = 0.001;
        Beta = 0.75;
      }  

* <span data-ttu-id="6dfc9-322">слой источника Hello включает пять карты с измерением aof 12 x 12, объединенными в узлы 1440.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-322">hello source layer includes five maps, each with aof dimension of 12x12, totaling in 1440 nodes.</span></span> 
* <span data-ttu-id="6dfc9-323">Здравствуйте, значение **KernelShape** указывает, что один слой карты нормализации, где окружение hello представляет собой прямоугольник 3 x 3.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-323">hello value of **KernelShape** indicates that this is a same map normalization layer, where hello neighborhood is a 3x3 rectangle.</span></span> 
* <span data-ttu-id="6dfc9-324">значение по умолчанию Hello **заполнение** имеет значение False, таким образом hello целевой слой имеет только 10 узлов в каждом измерении.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-324">hello default value of **Padding** is False, thus hello destination layer has only 10 nodes in each dimension.</span></span> <span data-ttu-id="6dfc9-325">tooinclude на одном узле в целевой слой hello, соответствующий узел tooevery в слой источника hello, добавлять заполнение = [true, true, true]; и измените размер hello RN1 слишком [5, 12, 12].</span><span class="sxs-lookup"><span data-stu-id="6dfc9-325">tooinclude one node in hello destination layer that corresponds tooevery node in hello source layer, add Padding = [true, true, true]; and change hello size of RN1 too[5, 12, 12].</span></span>  

## <a name="share-declaration"></a><span data-ttu-id="6dfc9-326">Объявление общего доступа</span><span class="sxs-lookup"><span data-stu-id="6dfc9-326">Share declaration</span></span>
<span data-ttu-id="6dfc9-327">Net# дополнительно поддерживает определение нескольких пакетов с общими весами.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-327">Net# optionally supports defining multiple bundles with shared weights.</span></span> <span data-ttu-id="6dfc9-328">Весовые коэффициенты Hello любой двух пакетов можно использовать совместно, если их структур являются одинаковыми hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-328">hello weights of any two bundles can be shared if their structures are hello same.</span></span> <span data-ttu-id="6dfc9-329">Привет, используя синтаксис определяет пакеты с общего веса:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-329">hello following syntax defines bundles with shared weights:</span></span>  

    share-declaration:
        share    {    layer-list    }
        share    {    bundle-list    }
       share    {    bias-list    }

    layer-list:
        layer-name    ,    layer-name
        layer-list    ,    layer-name

    bundle-list:
       bundle-spec    ,    bundle-spec
        bundle-list    ,    bundle-spec

    bundle-spec:
       layer-name    =>     layer-name

    bias-list:
        bias-spec    ,    bias-spec
        bias-list    ,    bias-spec

    bias-spec:
        1    =>    layer-name

    layer-name:
        identifier  

<span data-ttu-id="6dfc9-330">К примеру hello следующей общей папки объявление указывает имена слоев hello, указывающее, весовые коэффициенты и дисбаланса должны совместно:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-330">For example, hello following share-declaration specifies hello layer names, indicating that both weights and biases should be shared:</span></span>  

    Const {
      InputSize = 37;
      HiddenSize = 50;
    }
    input {
      Data1 [InputSize];
      Data2 [InputSize];
    }
    hidden {
      H1 [HiddenSize] from Data1 all;
      H2 [HiddenSize] from Data2 all;
    }
    output Result [2] {
      from H1 all;
      from H2 all;
    }
    share { H1, H2 } // share both weights and biases  

* <span data-ttu-id="6dfc9-331">Hello входных признаков разделена на два равен по размеру входного слоя.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-331">hello input features are partitioned into two equal sized input layers.</span></span> 
* <span data-ttu-id="6dfc9-332">для вычисления Hello скрытые слои выше уровня компонентов на hello два входного слоя.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-332">hello hidden layers then compute higher level features on hello two input layers.</span></span> 
* <span data-ttu-id="6dfc9-333">Указывает, что общий ресурс объявления Hello *H1* и *H2* должно быть вычислено в hello так же, как их соответствующих входных данных.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-333">hello share-declaration specifies that *H1* and *H2* must be computed in hello same way from their respective inputs.</span></span>  

<span data-ttu-id="6dfc9-334">В качестве альтернативы это можно задать с помощью двух отдельных объявлений общего доступа следующим образом:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-334">Alternatively, this could be specified with two separate share-declarations as follows:</span></span>  

    share { Data1 => H1, Data2 => H2 } // share weights  

<!-- -->

    share { 1 => H1, 1 => H2 } // share biases  

<span data-ttu-id="6dfc9-335">Краткая форма hello можно использовать только в том случае, когда слои hello содержат одного пакета.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-335">You can use hello short form only when hello layers contain a single bundle.</span></span> <span data-ttu-id="6dfc9-336">Как правило для управления доступом возможна только при идентичен hello соответствующие структуры, это означает, что они имеют hello размеры же convolutional геометрии и так далее.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-336">In general, sharing is possible only when hello relevant structure is identical, meaning that they have hello same size, same convolutional geometry, and so forth.</span></span>  

## <a name="examples-of-net-usage"></a><span data-ttu-id="6dfc9-337">Примеры использования Net#</span><span class="sxs-lookup"><span data-stu-id="6dfc9-337">Examples of Net# usage</span></span>
<span data-ttu-id="6dfc9-338">Этот раздел содержит несколько примеров того, как можно использовать язык Net # tooadd скрытые слои, определяют способ hello взаимодействовать с другими слоями скрытые слои и построения convolutional сетей.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-338">This section provides some examples of how you can use Net# tooadd hidden layers, define hello way that hidden layers interact with other layers, and build convolutional networks.</span></span>   

### <a name="define-a-simple-custom-neural-network-hello-world-example"></a><span data-ttu-id="6dfc9-339">Определение простой настраиваемой нейронной сети: пример «Привет, мир!»</span><span class="sxs-lookup"><span data-stu-id="6dfc9-339">Define a simple custom neural network: "Hello World" example</span></span>
<span data-ttu-id="6dfc9-340">Этот простой пример демонстрирует, как toocreate a нейронной сети модель, которая содержит один скрытый слой.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-340">This simple example demonstrates how toocreate a neural network model that has a single hidden layer.</span></span>  

    input Data auto;
    hidden H [200] from Data all;
    output Out [10] sigmoid from H all;  

<span data-ttu-id="6dfc9-341">пример Hello рассмотрены некоторые основные команды следующим образом:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-341">hello example illustrates some basic commands as follows:</span></span>  

* <span data-ttu-id="6dfc9-342">Hello первая строка определяет hello входного слоя (с именем *данные*).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-342">hello first line defines hello input layer (named *Data*).</span></span> <span data-ttu-id="6dfc9-343">При использовании hello **автоматически** ключевое слово hello нейронной сети автоматически включает все столбцы признаков в примерах входной hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-343">When you use hello  **auto** keyword, hello neural network automatically includes all feature columns in hello input examples.</span></span> 
* <span data-ttu-id="6dfc9-344">Вторая строка Hello создает hello скрытого слоя.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-344">hello second line creates hello hidden layer.</span></span> <span data-ttu-id="6dfc9-345">Имя Hello *H* назначается toohello скрытого слоя, имеющего 200 узла.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-345">hello name *H* is assigned toohello hidden layer, which has 200 nodes.</span></span> <span data-ttu-id="6dfc9-346">Этот уровень является полностью соединенными toohello входного слоя.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-346">This layer is fully connected toohello input layer.</span></span>
* <span data-ttu-id="6dfc9-347">Третья строка Hello определяет hello выходной слой (с именем *O*), который содержит 10 узлов на выходе.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-347">hello third line defines hello output layer (named *O*), which contains 10 output nodes.</span></span> <span data-ttu-id="6dfc9-348">Если hello нейронной сети используется для классификации, имеется один выходной узел для каждого класса.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-348">If hello neural network is used for classification, there is one output node per class.</span></span> <span data-ttu-id="6dfc9-349">Ключевое слово Hello **сигмоидальной** указывает, что выходные данные функции hello примененных toohello выходного слоя.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-349">hello keyword **sigmoid** indicates that hello output function is applied toohello output layer.</span></span>   

### <a name="define-multiple-hidden-layers-computer-vision-example"></a><span data-ttu-id="6dfc9-350">Определение нескольких скрытых слоев: пример машинного зрения</span><span class="sxs-lookup"><span data-stu-id="6dfc9-350">Define multiple hidden layers: computer vision example</span></span>
<span data-ttu-id="6dfc9-351">Hello следующем примере показано, как toodefine немного более сложными нейронной сети с помощью нескольких пользовательских скрытых слоев.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-351">hello following example demonstrates how toodefine a slightly more complex neural network, with multiple custom hidden layers.</span></span>  

    // Define hello input layers 
    input Pixels [10, 20];
    input MetaData [7];

    // Define hello first two hidden layers, using data only from hello Pixels input
    hidden ByRow [10, 12] from Pixels where (s,d) => s[0] == d[0];
    hidden ByCol [5, 20] from Pixels where (s,d) => abs(s[1] - d[1]) <= 1;

    // Define hello third hidden layer, which uses as source hello hidden layers ByRow and ByCol
    hidden Gather [100] 
    {
      from ByRow all;
      from ByCol all;
    }

    // Define hello output layer and its sources
    output Result [10]  
    {
      from Gather all;
      from MetaData all;
    }  

<span data-ttu-id="6dfc9-352">В этом примере показано несколько функций hello языку описания нейронных сетей.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-352">This example illustrates several features of hello neural networks specification language:</span></span>  

* <span data-ttu-id="6dfc9-353">Структура Hello имеет два входных слоя, *пикселей* и *метаданные*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-353">hello structure has two input layers, *Pixels* and *MetaData*.</span></span>
* <span data-ttu-id="6dfc9-354">Hello *пикселей* слой является уровнем источника для двух пакетов соединения со слоями назначения *ByRow* и *ByCol*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-354">hello *Pixels* layer is a source layer for two connection bundles, with destination layers, *ByRow* and *ByCol*.</span></span>
* <span data-ttu-id="6dfc9-355">Здравствуйте, слои *сбора* и *результат* назначения уровней в несколько пакетов для соединения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-355">hello layers *Gather* and *Result* are destination layers in multiple connection bundles.</span></span>
* <span data-ttu-id="6dfc9-356">выходной слой Hello, *результат*, представляет собой конечный уровень в двух пакетов соединения, по одной с hello второго уровня скрытый (сбор) как целевой слой и Здравствуйте другая hello входного слоя (метаданные), как конечный уровень.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-356">hello output layer, *Result*, is a destination layer in two connection bundles; one with hello second level hidden (Gather) as a destination layer, and hello other with hello input layer (MetaData) as a destination layer.</span></span>
* <span data-ttu-id="6dfc9-357">Здравствуйте, скрытые слои *ByRow* и *ByCol*, укажите с помощью выражения предиката отфильтрованного подключения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-357">hello hidden layers, *ByRow* and *ByCol*, specify filtered connectivity by using predicate expressions.</span></span> <span data-ttu-id="6dfc9-358">Точнее, узел hello в *ByRow* в [x, y] — подключенных toohello узлов в *пикселей* , имеющие первый координат, x hello первый индекс координат равно toohello узла.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-358">More precisely, hello node in *ByRow* at [x, y] is connected toohello nodes in *Pixels* that have hello first index coordinate equal toohello node's first coordinate, x.</span></span> <span data-ttu-id="6dfc9-359">Аналогичным образом, узел hello в *ByCol в [x, y] — подключенных toohello узлов в _Pixels* , имеющих hello вторые координаты индекса в один узел hello второй оси, y.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-359">Similarly, hello node in *ByCol at [x, y] is connected toohello nodes in _Pixels* that have hello second index coordinate within one of hello node's second coordinate, y.</span></span>  

### <a name="define-a-convolutional-network-for-multiclass-classification-digit-recognition-example"></a><span data-ttu-id="6dfc9-360">Определение сверточной сети для многоклассовой классификации: пример распознавания цифр</span><span class="sxs-lookup"><span data-stu-id="6dfc9-360">Define a convolutional network for multiclass classification: digit recognition example</span></span>
<span data-ttu-id="6dfc9-361">Определение Hello hello, следуя сети состоит из цифр спроектированный toorecognize и он иллюстрирует некоторые дополнительные методы для настройки нейронной сети.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-361">hello definition of hello following network is designed toorecognize numbers, and it illustrates some advanced techniques for customizing a neural network.</span></span>  

    input Image [29, 29];
    hidden Conv1 [5, 13, 13] from Image convolve 
    {
       InputShape  = [29, 29];
       KernelShape = [ 5,  5];
       Stride      = [ 2,  2];
       MapCount    = 5;
    }
    hidden Conv2 [50, 5, 5]
    from Conv1 convolve 
    {
       InputShape  = [ 5, 13, 13];
       KernelShape = [ 1,  5,  5];
       Stride      = [ 1,  2,  2];
       Sharing     = [false, true, true];
       MapCount    = 10;
    }
    hidden Hid3 [100] from Conv2 all;
    output Digit [10] from Hid3 all;  


* <span data-ttu-id="6dfc9-362">Структура Hello имеет один входной слой *изображения*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-362">hello structure has a single input layer, *Image*.</span></span>
* <span data-ttu-id="6dfc9-363">Ключевое слово Hello **convolve** указывает, что hello слои с именем *Conv1* и *Conv2* convolutional уровней.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-363">hello keyword **convolve** indicates that hello layers named *Conv1* and *Conv2* are convolutional layers.</span></span> <span data-ttu-id="6dfc9-364">Каждое из этих объявлений слоев следует список атрибутов свертки hello.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-364">Each of these layer declarations is followed by a list of hello convolution attributes.</span></span>
* <span data-ttu-id="6dfc9-365">Hello net третий скрытых слоев, *Hid3*, который полностью подключен toohello второй скрытого слоя, *Conv2*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-365">hello net has a third hidden layer, *Hid3*, which is fully connected toohello second hidden layer, *Conv2*.</span></span>
* <span data-ttu-id="6dfc9-366">выходной слой Hello, *цифра*, подключенных toohello только третий скрытый слой, *Hid3*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-366">hello output layer, *Digit*, is connected only toohello third hidden layer, *Hid3*.</span></span> <span data-ttu-id="6dfc9-367">Ключевое слово Hello **все** указывает, что hello выходной слой полностью связан слишком*Hid3*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-367">hello keyword **all** indicates that hello output layer is fully connected too*Hid3*.</span></span>
* <span data-ttu-id="6dfc9-368">Hello арность свертки hello равно трем (hello длины кортежей hello **InputShape**, **KernelShape**, **Stride**, и **доступ**).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-368">hello arity of hello convolution is three (hello length of hello tuples **InputShape**, **KernelShape**, **Stride**, and **Sharing**).</span></span> 
* <span data-ttu-id="6dfc9-369">Номер Hello весовых коэффициентов каждого ядра *1 + **KernelShape**\[0] * **KernelShape**\[1] * **KernelShape** \[2] = 1 + 1 * 5 * 5 = 26. Или 26 * 50 = 1300*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-369">hello number of weights per kernel is *1 + **KernelShape**\[0] * **KernelShape**\[1] * **KernelShape**\[2] = 1 + 1 * 5 * 5 = 26. Or 26 * 50 = 1300*.</span></span>
* <span data-ttu-id="6dfc9-370">Узлы hello в каждом скрытом слое можно рассчитать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="6dfc9-370">You can calculate hello nodes in each hidden layer as follows:</span></span>
  * <span data-ttu-id="6dfc9-371">**NodeCount**\[0] = (5 - 1) / 1 + 1 = 5.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-371">**NodeCount**\[0] = (5 - 1) / 1 + 1 = 5.</span></span>
  * <span data-ttu-id="6dfc9-372">**NodeCount**\[1] = (13 - 5) / 2 + 1 = 5.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-372">**NodeCount**\[1] = (13 - 5) / 2 + 1 = 5.</span></span> 
  * <span data-ttu-id="6dfc9-373">**NodeCount**\[2] = (13 - 5) / 2 + 1 = 5.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-373">**NodeCount**\[2] = (13 - 5) / 2 + 1 = 5.</span></span> 
* <span data-ttu-id="6dfc9-374">Hello общее число узлов можно вычислить с помощью hello объявлен размерность hello слоя, [50, 5, 5], следующим образом:  ***MapCount** * **NodeCount** \[ 0] * **NodeCount**\[1] * **NodeCount**\[2] = 10 * 5 * 5 * 5*</span><span class="sxs-lookup"><span data-stu-id="6dfc9-374">hello total number of nodes can be calculated by using hello declared dimensionality of hello layer, [50, 5, 5], as follows: ***MapCount** * **NodeCount**\[0] * **NodeCount**\[1] * **NodeCount**\[2] = 10 * 5 * 5 * 5*</span></span>
* <span data-ttu-id="6dfc9-375">Поскольку **доступ**[d] имеет значение False только для *d == 0*, hello число ядер —  ***MapCount** * **NodeCount** \[0] = 10 * 5 = 50*.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-375">Because **Sharing**[d] is False only for *d == 0*, hello number of kernels is ***MapCount** * **NodeCount**\[0] = 10 * 5 = 50*.</span></span> 

## <a name="acknowledgements"></a><span data-ttu-id="6dfc9-376">Благодарности</span><span class="sxs-lookup"><span data-stu-id="6dfc9-376">Acknowledgements</span></span>
<span data-ttu-id="6dfc9-377">Hello языку Net # для настройки архитектура hello нейронных сетей, был разработан в корпорации Майкрософт Shon Katzenberger (архитектор, машинное обучение) и Алексей Kamenev (разработчик программного обеспечения, Microsoft Research).</span><span class="sxs-lookup"><span data-stu-id="6dfc9-377">hello Net# language for customizing hello architecture of neural networks was developed at Microsoft by Shon Katzenberger (Architect, Machine Learning) and Alexey Kamenev (Software Engineer, Microsoft Research).</span></span> <span data-ttu-id="6dfc9-378">Он используется системой для машинного обучения проектов и приложений в диапазоне от аналитика tootext образа обнаружения.</span><span class="sxs-lookup"><span data-stu-id="6dfc9-378">It is used internally for machine learning projects and applications ranging from image detection tootext analytics.</span></span> <span data-ttu-id="6dfc9-379">Дополнительные сведения см. в разделе [Нейронная сеть в Azure ML - введение tooNet #](http://blogs.technet.com/b/machinelearning/archive/2015/02/16/neural-nets-in-azure-ml-introduction-to-net.aspx)</span><span class="sxs-lookup"><span data-stu-id="6dfc9-379">For more information, see [Neural Nets in Azure ML - Introduction tooNet#](http://blogs.technet.com/b/machinelearning/archive/2015/02/16/neural-nets-in-azure-ml-introduction-to-net.aspx)</span></span>

[1]:./media/machine-learning-azure-ml-netsharp-reference-guide/formula_large.gif

