---
title: "aaaGuide toohello Net # языку описания нейронных сетей | Документы Microsoft"
description: "Синтаксис для hello Net # нейронной сети спецификацию языка, вместе с примерами как toocreate настраиваемой нейронной сети моделировать в машинного Обучения Microsoft Azure, используя язык Net #"
services: machine-learning
documentationcenter: 
author: jeannt
manager: jhubbard
editor: cgronlun
ms.assetid: cfd1454b-47df-4745-b064-ce5f9b3be303
ms.service: machine-learning
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/31/2017
ms.author: jeannt
ms.openlocfilehash: 3493247ecc39ca3a1382510ad520d7017159ff62
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="guide-toonet-neural-network-specification-language-for-azure-machine-learning"></a>Руководство по языку описания нейронных сетей tooNet # для машинного обучения Azure
## <a name="overview"></a>Обзор
NET # — это язык, разработанный Майкрософт, используемых toodefine архитектуры нейронной сети. Его можно использовать в модулях нейронной сети Машинного обучения Microsoft Azure.

<!-- This function doesn't currentlyappear in hello MicrosoftML documentation. If it is added in a future update, we can uncomment this text.

, or in hello `rxNeuralNetwork()` function in [MicrosoftML](https://msdn.microsoft.com/microsoft-r/microsoftml/microsoftml). 

-->

В этой статье вы узнаете, что основные понятия требуется toodevelop настраиваемой нейронной сети. 

* Требования к нейронной сети и как toodefine hello основные компоненты
* синтаксис Hello и ключевых слов hello спецификации языка Net #
* Примеры настраиваемых нейронных сетей, созданных с использованием Net# 

[!INCLUDE [machine-learning-free-trial](../../includes/machine-learning-free-trial.md)]

## <a name="neural-network-basics"></a>Основы нейронных сетей
Структура нейронной сети состоит из ***узлы*** , которые располагаются в ***слои***и Взвешенное ***подключений*** (или ***краев***) между узлы Hello. подключение Hello направления, а каждому соединению соответствует ***источника*** узла и ***назначения*** узла.  

Каждый ***обучаемый слой*** (скрытый или выходной) включает один или несколько ***пакетов подключений***. В пакете соединение состоит из исходного слоя и спецификацию hello подключения из этого слоя источника. Все соединения hello в общей папке данного пакета hello же ***слой источника*** и hello же ***целевой слой***. В Net # пакета соединения будет рассматриваться как принадлежащий toohello пакета целевой слой.  

NET # поддерживает различные типы подключения пакетов, который позволяет настроить способ hello входными значениями являются сопоставленных toohidden слои и сопоставленные toohello выходов.   

по умолчанию Hello или стандартный набор является **полного набора**, в которой каждый узел hello слой источника является узлом подключенной tooevery hello целевой слой.  

Кроме того Net # поддерживает следующие четыре типа пакетов расширенных подключения hello.  

* **Фильтрованные пакеты**. Hello пользователь может определять предикат с использованием расположений hello hello исходного слоя и hello конечный уровень узла. Узлы подключены всякий раз, когда hello предиката равно True.
* **Сверточные пакеты**. Hello пользователь может определять небольшие близко расположенных домах узлов в слой источника hello. Каждый узел в целевой слой hello является окружение подключенных tooone узлов в слой источника hello.
* **Группирующие пакеты** и **пакеты нормализации ответов**. Это аналогично tooconvolutional пакеты в этом hello пользователь определяет небольшой близко расположенных домах узлов в слой источника hello. Hello различие заключается в весовых коэффициентов hello краев hello в эти пакеты не являются trainable. Вместо этого применяется Предопределенная функция toohello исходный узел значений toodetermine hello целевой узел значения.  

С помощью Net # toodefine hello структуре нейронной сети упрощает возможных toodefine сложных структур, таких как глубоких нейронных сетей или свертки произвольный измерений, которые известны tooimprove обучение на данных, таких как изображения, аудио или видео.  

## <a name="supported-customizations"></a>Поддерживаемые настройки
Hello архитектура создаваемых моделей нейронной сети, создаваемые в машинном обучении Azure можно настроить с помощью Net # активно. Вы можете:  

* Создание скрытых слоев и управления hello количество узлов в каждом слое.
* Укажите, как слои tooeach toobe подключены другие.
* Определять специальные структуры подключения, такие как свертки и пакеты с распределением весов.
* Задавать различные функции активации.  

Сведения о синтаксисе языка спецификации hello. в разделе [спецификация структуры](#Structure-specifications).  

Примеры определения нейронных сетей для некоторых распространенных машинного обучения задачи из Симплексные toocomplex см [примеры](#Examples-of-Net#-usage).  

## <a name="general-requirements"></a>Общие требования
* Должен быть точно один выходной слой, как минимум один входной слой, а также ноль или более скрытых слоев. 
* Каждый слой имеет фиксированное количество узлов, концептуально организованных в прямоугольную матрицу произвольных размеров. 
* Входной слои, не имеют связанных обученной параметров и представляют hello точку, где данные экземпляра вводит hello сети. 
* Trainable слои (hello скрытого и выходного слоев) имеют связанные обученной параметров, известных как весовые коэффициенты и дисбаланса. 
* Hello исходный и целевой узлы должны находиться в отдельные слои. 
* Подключения должны быть ациклического; Другими словами не может быть цепочки подключений начальные задней toohello первоначального исходного узла.
* выходной слой Hello не может быть уровнем источника пакета соединения.  

## <a name="structure-specifications"></a>Спецификация структуры
Спецификация структуры нейронной сети состоит из трех разделов: hello **объявления константы**, hello **слоя объявление**, hello **объявление подключения**. а также дополнительного раздела **объявления общего доступа**. Hello разделы можно указать в любом порядке.  

## <a name="constant-declaration"></a>Объявление констант
Объявление констант является необязательным. Он предоставляет toodefine означает значения, используемые в определении hello нейронной сети. оператор объявления Hello состоит из идентификатора, за которым следует знак равенства и выражение значения.   

Например, следующем за инструкцией hello определяет константу **x**:  

    Const X = 28;  

toodefine несколько констант одновременно, заключите имена идентификаторов hello и значения в фигурные скобки и разделяйте их точкой с запятой. Например:  

    Const { X = 28; Y = 4; }  

правая часть каждого выражения присваивания Hello может быть целое число, вещественное число, логическое значение (True или False) или математическое выражение. Например:  

    Const { X = 17 * 2; Y = true; }  

## <a name="layer-declaration"></a>Объявление слоев
требуется объявление Hello слоя. Он определяет размер hello и источник hello слоя, включая атрибуты и пакеты подключения. Hello объявление оператора начинается с hello имя слоя hello (входной, скрытым или вывести), а затем по измерениям hello hello слоя (кортеж положительные целые числа). Например:  

    input Data auto;
    hidden Hidden[5,20] from Data all;
    output Result[2] from Hidden all;  

* Hello hello измерения является hello количество узлов в слое hello. В этом примере существует два измерения [5,20], это означает, что существует 100 узлов в слое hello.
* Hello слои, которые могут быть объявлены в любом порядке, за одним исключением: Если определено более одного входного слоя hello порядок, в котором они объявлены должен совпадать с порядком hello возможности hello входных данных.  

toospecify ее hello количество узлов в слое определяется автоматически, используйте hello **автоматически** ключевое слово. Hello **автоматически** ключевые слова имеют другой эффект, в зависимости от слоев hello:  

* В объявлении входного слоя hello количество узлов равно hello количеством признаков в hello входных данных.
* В объявлении скрытый слой hello узлов используется номер hello задается значение параметра hello для **число скрытых узлов**. 
* В объявлении выходной слой hello количество узлов равно 2 для классификации, 1 для равно toohello количество выходных узлов для мультиклассовой классификации и регрессии.   

Например hello следующее определение сети позволяет hello размер всех toobe слои определяется автоматически:  

    input Data auto;
    hidden Hidden auto from Data all;
    output Result auto from Hidden all;  


Объявление слой trainable слоя (hello скрытого или выходного слоев) при необходимости можно включить вывод функции hello (также называемый функцией активации), значение по умолчанию — слишком**сигмоидальной** для моделей классификации и **линейной** для моделей регрессии. (Даже если используется по умолчанию hello, можно явно указать функции hello активации, при необходимости для ясности.)

Hello выходных данных поддерживаются следующие функции:  

* sigmoid
* linear
* softmax
* rlinear
* square
* sqrt
* srlinear
* abs
* tanh 
* brlinear  

Например, следующие объявления hello использует hello **softmax** функции:  

    output Result [100] softmax from Hidden all;  

## <a name="connection-declaration"></a>Объявление подключений
Сразу после определения hello trainable слоя, необходимо объявить соединений между hello слои, которые вы определили. Объявление пакета соединения Hello начинается с ключевого слова hello **из**, а затем по имени hello hello пакета источник слоя и hello вида toocreate соединений пакета.   

В настоящее время поддерживается пять видов пакетов подключений:  

* **Полный** пакетов, обозначенном ключевое слово hello **все**
* **Отфильтрованные** пакетов, обозначенном ключевое слово hello **где**, а затем выражение предиката
* **Convolutional** пакетов, обозначенном ключевое слово hello **convolve**, а затем атрибуты свертки hello
* **Создание пулов** пакетов, обозначенном ключевые слова hello **max пула** или **означает пула**
* **Ответ нормализации** пакетов, обозначенном ключевое слово hello **нормы ответа**      

## <a name="full-bundles"></a>Полные пакеты
Пакет полного соединения включает соединения из каждого узла в узел tooeach слоя hello источника в целевой слой hello. Это тип сетевого подключения по умолчанию hello.  

## <a name="filtered-bundles"></a>Фильтрованные пакеты
Спецификация фильтрованного пакета подключений содержит предикат, выраженный синтаксически, практически так же, как лямбда-выражение в C#. Hello следующий пример определяет два отфильтрованные пакеты:  

    input Pixels [10, 20];
    hidden ByRow[10, 12] from Pixels where (s,d) => s[0] == d[0];
    hidden ByCol[5, 20] from Pixels where (s,d) => abs(s[1] - d[1]) <= 1;  

* В предикате hello для *ByRow*, **s** — это параметр, представляющий индекс в прямоугольный массив hello узлы входного слоя hello, *пикселей*, и **d**  — это параметр, представляющий индекс в массиве hello узлов скрытого слоя hello, *ByRow*. Здравствуйте, оба типа **s** и **d** кортеж длина двумя целыми числами. По сути, параметр **s** находится в диапазоне всех пар целых чисел с условиями *0 <= s[0] < 10* и *0 <= s[1] < 20*, а параметр **d** — в диапазоне всех пар целых чисел с условиями *0 <= d[0] < 10* и *0 <= d[1] < 12*. 
* В правой части выражения предиката hello hello имеется условие. В этом примере для каждого значения **s** и **d** таким образом, что hello условие имеет значение True, является ребром из источника hello слоя toohello узел назначения узла слоя. Таким образом, этот критерий фильтра показывает, что этот пакет hello включает подключения из узла "hello" определяется **s** toohello узла определяется **d** во всех случаях, где s [0] — равно tood [0].  

Дополнительно можно указать набор весов фильтрованного пакета. Здравствуйте, значение для hello **весов** атрибут должен быть кортеж из числа с плавающей запятой с длиной, совпадающий с номером hello соединений, определенных в пакете hello. По умолчанию веса генерируются случайно.  

Взвешенные значения группируются по hello индекс узла назначения. То есть, если подключен hello первый узел назначения заняло исходных узлов hello сначала *K* элементы hello **весов** кортежа, hello весов для hello первый целевой узел, в порядке индексирования источника. Здравствуйте, тоже относится к hello оставшихся узлов назначения.  

Это возможно toospecify весовые коэффициенты непосредственно как постоянные значения. Например если ранее вы узнали hello весовые коэффициенты, можно указать их как константы, используя следующий синтаксис:

    const Weights_1 = [0.0188045055, 0.130500451, ...]


## <a name="convolutional-bundles"></a>Сверточные пакеты
Если hello обучающих данных имеют однородную структуру, convolutional подключения являются toolearn часто используемые функции hello данных высокого уровня. Например, изображение, аудио- или видеоданные, пространственная или временная размерность могут быть достаточно однородными.  

Convolutional пакеты используют прямоугольный **ядер** , являются вбок и фиксируется по измерениям hello. По существу, каждая ядра определяет набором весовых коэффициентов, примененных в локальном близко расположенных домах, который ссылается tooas **приложений ядра**. Каждое приложение ядра соответствует tooa узел в hello исходного слоя — hello ссылка tooas **центральный узел**. Hello весов ядро совместно используемые много подключений. В набор convolutional каждого ядра прямоугольная и все ядра приложения hello же размера.  

Convolutional пакеты поддерживают hello следующие атрибуты:

**InputShape** определяет размерность hello слой источника hello целях hello convolutional пакет. Hello значение должно быть кортеж положительных целых чисел. Hello продукта hello целых чисел должно быть равно числу узлов в слой источника hello hello, но в противном случае она не должна toomatch hello размерность, объявленным для hello слой источника. Длина этого кортежа Hello становится hello **арность** значение для hello convolutional пакета. (Обычно арность ссылается toohello число аргументов или операндов, которые может выполнять функции).  

фигуры toodefine hello и расположения ядер hello использовать атрибуты hello **KernelShape**, **Stride**, **заполнение**, **LowerPad**, и **UpperPad**:   

* **KernelShape**: (обязательный) определяет размерность hello каждого ядра для hello convolutional пакета. Hello значение должно быть кортеж положительных целых чисел с длиной, равным hello арность hello пакета. Каждый компонент этот кортеж должен быть не больше, чем hello соответствующего компонента **InputShape**. 
* **STRIDE**: hello (необязательно) определяет, скользящий шаг размеры hello свертки (один шаг размер каждого измерения), hello расстояния между узлами центра hello. Hello значение должно быть кортеж положительных целых чисел с длиной, арность hello hello пакета. Каждый компонент этот кортеж должен быть не больше, чем hello соответствующего компонента **KernelShape**. значение по умолчанию Hello — кортеж с все равно tooone компонентов. 
* **Совместное использование**: hello вес (необязательно) определяет, для управления доступом для каждого измерения hello свертки. Hello значение может быть одиночное логическое значение или кортеж логических значений с длиной, арность hello hello пакета. Расширенные toobe кортеж hello правильную длину со всеми компонентами является одиночное логическое значение равно toohello заданное значение. значение по умолчанию Hello — кортеж, состоящий из всех значений True. 
* **MapCount**: сопоставления (необязательно) определяет hello количество компонентов для hello convolutional пакета. Hello значение может быть положительным целым числом или кортежа положительных целых чисел с длиной, арность hello hello пакета. Целочисленное значение расширяется toobe кортеж hello правильной длины с первой toohello равно hello компоненты указанное значение и все остальные компоненты равно tooone Здравствуйте. значение по умолчанию Hello — один. Общее число компонентов схемы Hello — hello совокупность hello компоненты hello кортежа. разбиение Hello это общее число во всех компонентах hello определяет, как значения карты компонента hello группируются в узлы назначения hello. 
* **Весовые коэффициенты**: (необязательно) определяет hello начальной весовые коэффициенты для hello пакета. Hello значение должно быть кортеж из числа с плавающей запятой с длиной, hello числа ядер раз hello весовых коэффициентов каждого ядра, описанных далее в этой статье. веса по умолчанию Hello случайным образом.  

Существует два набора свойств, определяющих заполнения, свойства hello, взаимно исключают друг друга.

* **Заполнение**: (необязательно) определяет ли hello ввода следует заполнены с помощью **схему заполнения по умолчанию**. Hello значением может быть одиночное логическое значение, или может быть кортеж логических значений с длиной, арность hello hello пакета. Расширенные toobe кортеж hello правильную длину со всеми компонентами является одиночное логическое значение равно toohello заданное значение. Значение hello измерения имеет значение True, источник hello логически недостающие в этом измерении с приложениями дополнительные ядра toosupport ячейки с нулевым значением, таким образом, hello центра узлы hello первый и последний ядер в этом измерении hello первый и последний узлы в этом измерении на уровне источника hello. Таким образом, число hello «пустой» узлов в каждом измерении определяется определяется автоматически, toofit точно *(InputShape [d] - 1) / Stride [d] + 1* ядер в слой источника дополняются hello. Если значение hello измерения имеет значение False, hello ядер определяются так, чтобы hello количество узлов для каждой стороны, опущены hello же (вверх разницу tooa 1). значение по умолчанию Hello этого атрибута — кортеж с все равно tooFalse компонентов.
* **UpperPad** и **LowerPad**: (необязательно) укажите больший контроль над hello объем toouse заполнения. **Важно:** эти атрибуты можно определить, если и только если hello **заполнение** свойство выше ***не*** определен. Hello значения должны быть целочисленный кортежей с длиной, арность hello hello пакета. Если эти атрибуты указаны, «пустой» узлы будут добавлены toohello нижнем и верхнем концах каждого измерения hello входного слоя. Hello количество узлов добавлен toohello нижнем и верхнем концах в каждом измерении определяется **LowerPad**[i] и **UpperPad**[i] соответственно. tooensure ядер соответствие только слишком «real» и не слишком «пустой» узлам hello следующие условия должны быть выполнены.
  * Каждый компонент атрибута **LowerPad** должен быть строго меньше, чем KernelShape[d]/2. 
  * Каждый компонент атрибута **UpperPad** должен быть не больше, чем KernelShape[d]/2. 
  * значение по умолчанию Hello этих атрибутов — кортеж с все равно too0 компонентов. 

параметр Hello **заполнение** = true позволяет при необходимости tookeep hello «центр» hello ядра внутри hello «real» введите размер внутреннего отступа как есть. При этом изменяется математические hello немного для вычисления размера выходного hello. Как правило, hello выходной размер *D* вычисляется как *D = (I - K) / S + 1*, где *я* — hello размер входных данных, *K* размер ядра hello, *S* — hello stride и  */*  — целочисленное деление (round к нулю). Если значение UpperPad = [1, 1] hello указать размер *я* — 29 и, следовательно, *D = (29-5) / 2 + 1 = 13*. Но если **Padding** = true, тогда и *I* фактически вытесняется *K - 1*; следовательно *D = ((28 + 4) - 5) / 2 + 1 = 27 / 2 + 1 = 13 + 1 = 14*. При задании значений для **UpperPad** и **LowerPad** вы получаете гораздо больший контроль над hello заполнение не вы просто набор **заполнение** = true.

Дополнительную информацию о сверточных сетях и их приложениях см. в следующих статьях:  

* [http://deeplearning.net/tutorial/lenet.html ](http://deeplearning.net/tutorial/lenet.html)
* [http://research.microsoft.com/pubs/68920/icdar03.pdf](http://research.microsoft.com/pubs/68920/icdar03.pdf) 
* [http://people.csail.mit.edu/jvb/papers/cnn_tutorial.pdf](http://people.csail.mit.edu/jvb/papers/cnn_tutorial.pdf)  

## <a name="pooling-bundles"></a>Группирующие пакеты
Объект **пулов пакета** применяется geometry аналогичные tooconvolutional возможность подключения, но он использует стандартные функции toosource значения tooderive hello целевой узел значение узла. Следовательно, группирующие пакеты не имеют обучаемого состояния (весов или смещений). Поддержка пакетов, всех hello convolutional атрибуты за исключением организации пулов **доступ**, **MapCount**, и **весов**.  

Как правило hello ядер, представленные на смежные пулов единицы не перекрываются. Если Stride [d] [d] равно tooKernelShape в каждом измерении, полученный слоя hello — hello традиционные локальные пулов уровня, который обычно используются в convolutional нейронных сетей. Каждый узел назначения вычисляет hello максимальное и среднее hello действий hello объекта его ядра в слой источника hello.  

Следующий пример Hello рассмотрены пулов пакета: 

    hidden P1 [5, 12, 12]
      from C1 max pool {
        InputShape  = [ 5, 24, 24];
        KernelShape = [ 1,  2,  2];
        Stride      = [ 1,  2,  2];
      }  

* арность Hello набора hello равно 3 (hello длины кортежей hello **InputShape**, **KernelShape**, и **Stride**). 
* Hello количество узлов в слое источника hello *5 * 24 * 24 = 2880*. 
* Это стандартный локальный группирующий слой, так как **KernelShape** = **Stride**. 
* Hello количество узлов в слое назначения hello *5 * 12 * 12 = 1440*.  

Дополнительную информацию о группирующих слоях см. в статьях:  

* [http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf) (Section 3.4)
* [http://cs.nyu.edu/~koray/publis/lecun-iscas-10.pdf](http://cs.nyu.edu/~koray/publis/lecun-iscas-10.pdf) 
* [http://cs.nyu.edu/~koray/publis/jarrett-iccv-09.pdf](http://cs.nyu.edu/~koray/publis/jarrett-iccv-09.pdf)

## <a name="response-normalization-bundles"></a>Пакеты нормализации ответов
**Ответ нормализации** схема локального нормализации, появившийся Geoffrey Hinton и т. п., в документе hello [ImageNet Classiﬁcation с глубокой Convolutional нейронных сетей](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf). Ответ Нормализацией называют обобщение используется tooaid в Нейронная сеть. При один нейрон срабатывания на уровне очень высокий уровень активации, слой нормализации локальной ответа подавляет уровень активации hello hello вокруг нейронов. Это выполняется с помощью трех параметров (***α***, ***β*** и ***k***) и сверточной структуры (или формы окрестности). Каждый нейрон в целевой слой hello ***y*** соответствует нейрон tooa ***x*** в слой источника hello. Здравствуйте, уровень активации ***y*** определяется hello следующую формулу, где ***f*** уровень активации hello нейрона, и ***Nx*** ядра hello (или hello набор, содержащий hello нейроны в районе hello ***x***), в соответствии с определением hello, следуя convolutional структуры:  

![][1]  

Пакеты нормализации ответа поддерживает все атрибуты convolutional hello, за исключением **доступ**, **MapCount**, и **весов**.  

* Если ядра hello содержит нейронов hello же карту в качестве ***x***, схема нормализации hello — ссылка tooas **же сопоставить нормализации**. toodefine же сопоставить нормализации, первая координата hello в **InputShape** должно иметь значение 1, hello.
* Если ядра hello содержит нейронов hello же пространственных позиции ***x***, но нейронов hello в других сопоставлений, hello нормализации схема называется **через сопоставляет нормализации**. Этот тип ответа нормализации реализует один из видов боковое inhibition по типа hello, обнаруженные в реальном нейронов Создание конкуренции за большой активации уровни среди нейрон выходов, вычисляемый на разных картах. toodefine через сопоставляет нормализации, hello первой оси должно быть целым числом, больше единицы и не должен превышать число hello карты и rest hello координат hello должен иметь значение hello 1.  

Поскольку пакеты ответа нормализации применяются Предопределенная функция toosource значения toodetermine hello целевой узел значение узла, они имеют состояние не trainable (веса или отклонения от).   

**Предупреждения**: hello узлов в слое назначения hello соответствуют tooneurons, которые являются узлами центра hello hello ядер. Например, если KernelShape [d] является нечетным, затем *KernelShape [d] / 2* соответствует toohello ядра центральный узел. Если *KernelShape [d]* является четным, hello центральный узел находится на *KernelShape [d] / 2-1*. Таким образом Если **заполнение**[d] имеет значение False, сначала hello и hello последнего *KernelShape [d] / 2* узлы не имеют соответствующие узлы в целевой слой hello. tooavoid этой ситуации определить **заполнение** как [true значение равно true, true,...,].  

В дополнение к этому toohello четыре атрибута как описано выше, пакеты нормализации ответ также hello поддержки следующие атрибуты:  

* **Альфа-канал**: (обязательный) определяет значение с плавающей запятой, соответствующий слишком***α*** в предыдущей формуле hello. 
* **Бета-версии**: (обязательный) определяет значение с плавающей запятой, соответствующий слишком***β*** в предыдущей формуле hello. 
* **Смещение**: (необязательно) задает значение с плавающей запятой, соответствующий слишком***k*** в предыдущей формуле hello. По умолчанию too1.  

Hello следующий пример определяет пакет ответа нормализации с помощью этих атрибутов:  

    hidden RN1 [5, 10, 10]
      from P1 response norm {
        InputShape  = [ 5, 12, 12];
        KernelShape = [ 1,  3,  3];
        Alpha = 0.001;
        Beta = 0.75;
      }  

* слой источника Hello включает пять карты с измерением aof 12 x 12, объединенными в узлы 1440. 
* Здравствуйте, значение **KernelShape** указывает, что один слой карты нормализации, где окружение hello представляет собой прямоугольник 3 x 3. 
* значение по умолчанию Hello **заполнение** имеет значение False, таким образом hello целевой слой имеет только 10 узлов в каждом измерении. tooinclude на одном узле в целевой слой hello, соответствующий узел tooevery в слой источника hello, добавлять заполнение = [true, true, true]; и измените размер hello RN1 слишком [5, 12, 12].  

## <a name="share-declaration"></a>Объявление общего доступа
Net# дополнительно поддерживает определение нескольких пакетов с общими весами. Весовые коэффициенты Hello любой двух пакетов можно использовать совместно, если их структур являются одинаковыми hello. Привет, используя синтаксис определяет пакеты с общего веса:  

    share-declaration:
        share    {    layer-list    }
        share    {    bundle-list    }
       share    {    bias-list    }

    layer-list:
        layer-name    ,    layer-name
        layer-list    ,    layer-name

    bundle-list:
       bundle-spec    ,    bundle-spec
        bundle-list    ,    bundle-spec

    bundle-spec:
       layer-name    =>     layer-name

    bias-list:
        bias-spec    ,    bias-spec
        bias-list    ,    bias-spec

    bias-spec:
        1    =>    layer-name

    layer-name:
        identifier  

К примеру hello следующей общей папки объявление указывает имена слоев hello, указывающее, весовые коэффициенты и дисбаланса должны совместно:  

    Const {
      InputSize = 37;
      HiddenSize = 50;
    }
    input {
      Data1 [InputSize];
      Data2 [InputSize];
    }
    hidden {
      H1 [HiddenSize] from Data1 all;
      H2 [HiddenSize] from Data2 all;
    }
    output Result [2] {
      from H1 all;
      from H2 all;
    }
    share { H1, H2 } // share both weights and biases  

* Hello входных признаков разделена на два равен по размеру входного слоя. 
* для вычисления Hello скрытые слои выше уровня компонентов на hello два входного слоя. 
* Указывает, что общий ресурс объявления Hello *H1* и *H2* должно быть вычислено в hello так же, как их соответствующих входных данных.  

В качестве альтернативы это можно задать с помощью двух отдельных объявлений общего доступа следующим образом:  

    share { Data1 => H1, Data2 => H2 } // share weights  

<!-- -->

    share { 1 => H1, 1 => H2 } // share biases  

Краткая форма hello можно использовать только в том случае, когда слои hello содержат одного пакета. Как правило для управления доступом возможна только при идентичен hello соответствующие структуры, это означает, что они имеют hello размеры же convolutional геометрии и так далее.  

## <a name="examples-of-net-usage"></a>Примеры использования Net#
Этот раздел содержит несколько примеров того, как можно использовать язык Net # tooadd скрытые слои, определяют способ hello взаимодействовать с другими слоями скрытые слои и построения convolutional сетей.   

### <a name="define-a-simple-custom-neural-network-hello-world-example"></a>Определение простой настраиваемой нейронной сети: пример «Привет, мир!»
Этот простой пример демонстрирует, как toocreate a нейронной сети модель, которая содержит один скрытый слой.  

    input Data auto;
    hidden H [200] from Data all;
    output Out [10] sigmoid from H all;  

пример Hello рассмотрены некоторые основные команды следующим образом:  

* Hello первая строка определяет hello входного слоя (с именем *данные*). При использовании hello **автоматически** ключевое слово hello нейронной сети автоматически включает все столбцы признаков в примерах входной hello. 
* Вторая строка Hello создает hello скрытого слоя. Имя Hello *H* назначается toohello скрытого слоя, имеющего 200 узла. Этот уровень является полностью соединенными toohello входного слоя.
* Третья строка Hello определяет hello выходной слой (с именем *O*), который содержит 10 узлов на выходе. Если hello нейронной сети используется для классификации, имеется один выходной узел для каждого класса. Ключевое слово Hello **сигмоидальной** указывает, что выходные данные функции hello примененных toohello выходного слоя.   

### <a name="define-multiple-hidden-layers-computer-vision-example"></a>Определение нескольких скрытых слоев: пример машинного зрения
Hello следующем примере показано, как toodefine немного более сложными нейронной сети с помощью нескольких пользовательских скрытых слоев.  

    // Define hello input layers 
    input Pixels [10, 20];
    input MetaData [7];

    // Define hello first two hidden layers, using data only from hello Pixels input
    hidden ByRow [10, 12] from Pixels where (s,d) => s[0] == d[0];
    hidden ByCol [5, 20] from Pixels where (s,d) => abs(s[1] - d[1]) <= 1;

    // Define hello third hidden layer, which uses as source hello hidden layers ByRow and ByCol
    hidden Gather [100] 
    {
      from ByRow all;
      from ByCol all;
    }

    // Define hello output layer and its sources
    output Result [10]  
    {
      from Gather all;
      from MetaData all;
    }  

В этом примере показано несколько функций hello языку описания нейронных сетей.  

* Структура Hello имеет два входных слоя, *пикселей* и *метаданные*.
* Hello *пикселей* слой является уровнем источника для двух пакетов соединения со слоями назначения *ByRow* и *ByCol*.
* Здравствуйте, слои *сбора* и *результат* назначения уровней в несколько пакетов для соединения.
* выходной слой Hello, *результат*, представляет собой конечный уровень в двух пакетов соединения, по одной с hello второго уровня скрытый (сбор) как целевой слой и Здравствуйте другая hello входного слоя (метаданные), как конечный уровень.
* Здравствуйте, скрытые слои *ByRow* и *ByCol*, укажите с помощью выражения предиката отфильтрованного подключения. Точнее, узел hello в *ByRow* в [x, y] — подключенных toohello узлов в *пикселей* , имеющие первый координат, x hello первый индекс координат равно toohello узла. Аналогичным образом, узел hello в *ByCol в [x, y] — подключенных toohello узлов в _Pixels* , имеющих hello вторые координаты индекса в один узел hello второй оси, y.  

### <a name="define-a-convolutional-network-for-multiclass-classification-digit-recognition-example"></a>Определение сверточной сети для многоклассовой классификации: пример распознавания цифр
Определение Hello hello, следуя сети состоит из цифр спроектированный toorecognize и он иллюстрирует некоторые дополнительные методы для настройки нейронной сети.  

    input Image [29, 29];
    hidden Conv1 [5, 13, 13] from Image convolve 
    {
       InputShape  = [29, 29];
       KernelShape = [ 5,  5];
       Stride      = [ 2,  2];
       MapCount    = 5;
    }
    hidden Conv2 [50, 5, 5]
    from Conv1 convolve 
    {
       InputShape  = [ 5, 13, 13];
       KernelShape = [ 1,  5,  5];
       Stride      = [ 1,  2,  2];
       Sharing     = [false, true, true];
       MapCount    = 10;
    }
    hidden Hid3 [100] from Conv2 all;
    output Digit [10] from Hid3 all;  


* Структура Hello имеет один входной слой *изображения*.
* Ключевое слово Hello **convolve** указывает, что hello слои с именем *Conv1* и *Conv2* convolutional уровней. Каждое из этих объявлений слоев следует список атрибутов свертки hello.
* Hello net третий скрытых слоев, *Hid3*, который полностью подключен toohello второй скрытого слоя, *Conv2*.
* выходной слой Hello, *цифра*, подключенных toohello только третий скрытый слой, *Hid3*. Ключевое слово Hello **все** указывает, что hello выходной слой полностью связан слишком*Hid3*.
* Hello арность свертки hello равно трем (hello длины кортежей hello **InputShape**, **KernelShape**, **Stride**, и **доступ**). 
* Номер Hello весовых коэффициентов каждого ядра *1 + **KernelShape**\[0] * **KernelShape**\[1] * **KernelShape** \[2] = 1 + 1 * 5 * 5 = 26. Или 26 * 50 = 1300*.
* Узлы hello в каждом скрытом слое можно рассчитать следующим образом:
  * **NodeCount**\[0] = (5 - 1) / 1 + 1 = 5.
  * **NodeCount**\[1] = (13 - 5) / 2 + 1 = 5. 
  * **NodeCount**\[2] = (13 - 5) / 2 + 1 = 5. 
* Hello общее число узлов можно вычислить с помощью hello объявлен размерность hello слоя, [50, 5, 5], следующим образом:  ***MapCount** * **NodeCount** \[ 0] * **NodeCount**\[1] * **NodeCount**\[2] = 10 * 5 * 5 * 5*
* Поскольку **доступ**[d] имеет значение False только для *d == 0*, hello число ядер —  ***MapCount** * **NodeCount** \[0] = 10 * 5 = 50*. 

## <a name="acknowledgements"></a>Благодарности
Hello языку Net # для настройки архитектура hello нейронных сетей, был разработан в корпорации Майкрософт Shon Katzenberger (архитектор, машинное обучение) и Алексей Kamenev (разработчик программного обеспечения, Microsoft Research). Он используется системой для машинного обучения проектов и приложений в диапазоне от аналитика tootext образа обнаружения. Дополнительные сведения см. в разделе [Нейронная сеть в Azure ML - введение tooNet #](http://blogs.technet.com/b/machinelearning/archive/2015/02/16/neural-nets-in-azure-ml-introduction-to-net.aspx)

[1]:./media/machine-learning-azure-ml-netsharp-reference-guide/formula_large.gif

