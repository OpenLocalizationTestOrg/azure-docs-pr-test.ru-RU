---
title: "Краткое руководство по языку программирования R для службы машинного обучения | Документация Майкрософт"
description: "Это руководство по языку программирования R поможет быстро создать прогностическое решение, используя язык R в Студии машинного обучения Azure."
keywords: "краткое руководство, язык r, язык программирования r, руководство по программированию на языке r"
services: machine-learning
documentationcenter: 
author: garyericson
manager: jhubbard
editor: cgronlun
ms.assetid: 99a3a0fd-b359-481a-b236-66868deccd96
ms.service: machine-learning
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: garye
ms.openlocfilehash: 40cc3728d1361b9304896bf0cc4ceed439291d45
ms.sourcegitcommit: 6699c77dcbd5f8a1a2f21fba3d0a0005ac9ed6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2017
---
# <a name="quickstart-tutorial-for-the-r-programming-language-for-azure-machine-learning"></a>Краткое руководство по языку программирования R для службы машинного обучения Azure

<!-- Stephen F Elston, Ph.D. -->

## <a name="introduction"></a>Введение
Этот учебник поможет быстро расширить возможности службы машинного обучения Azure с помощью языка программирования R. Выполнив приведенные в этом учебнике инструкции, вы научитесь создавать, тестировать и выполнять код R в службе машинного обучения Azure. Во время работы с руководством вы создадите полноценное прогностическое решение, используя язык R в службе машинного обучения Azure.  

Машинное обучение Microsoft Azure содержит множество эффективных модулей машинного обучения и обработки данных. Высокоэффективный язык R считается универсальным языком аналитики. К счастью, возможности аналитики и обработки данных, которыми располагает Машинное обучение Azure, можно расширить благодаря использованию языка R. Это сочетание позволяет объединить масштабируемость при развертывании Машинного обучения Azure с гибкостью и глубиной аналитики языка R.

[!INCLUDE [machine-learning-free-trial](../../../includes/machine-learning-free-trial.md)]

### <a name="forecasting-and-the-dataset"></a>Прогнозирование и набор данных
Прогнозирование — широко распространенный и чрезвычайно полезный метод аналитики. Сфера его применения охватывает широкий диапазон: от прогноза объема продаж сезонных товаров, определяющего уровень заполнения склада, до расчета макроэкономических переменных. Преимущественно при прогнозировании используются модели временных рядов.

Данные временных рядов — данные, значения которых имеют индекс времени. Значение индекса времени может быть регулярным (например, помесячным или поминутным), или нерегулярным. Модель временных рядов основана на данных временных рядов. Язык программирования R располагает гибкой структурой и широкими аналитическими возможностями для временных данных.

В этом руководстве мы будем использовать данные о производстве молочных продуктов в Калифорнии и ценах на них. Эти данные включают в себя информацию о производстве нескольких молочных продуктов и цену молочного жира — эталонного товара за каждый месяц.

Данные, использующиеся в этой статье, а также сценарии на языке R можно [скачать здесь][download]. Эти данные основаны на информации, собранной университетом Висконсина и доступной по адресу http://future.aae.wisc.edu/tab/production.html.

### <a name="organization"></a>План
Вам потребуется несколько шагов, чтобы научиться создавать, тестировать и выполнять код на R для анализа и обработки данных в среде Машинного обучения Azure.  

* Сначала мы изучим основы использования языка R в Студии машинного обучения Azure.
* Затем рассмотрим различные аспекты ввода и вывода данных, кода на R и графики в среде Машинного обучения Azure.
* После этого мы построим первую часть прогнозного решения, создав код для очистки и преобразования данных.
* Подготовив данные, мы проанализируем корреляцию нескольких переменных нашего набора данных.
* Наконец, мы создадим прогнозную модель сезонного временного ряда для молочного производства.

## <a id="mlstudio"></a>Работа с языком R в Студии машинного обучения
В этом разделе вы ознакомитесь с основами работы с языком программирования R в Студии машинного обучения. Язык R — мощный инструмент для создания настраиваемых модулей анализа и обработки данных в среде Машинного обучения Azure.

Для разработки, тестирования и отладки небольших фрагментов кода на языке R мы будем использовать RStudio. Впоследствии мы вставим эти готовые фрагменты в модуль [Выполнить сценарий R][execute-r-script] в Студии машинного обучения.  

### <a name="the-execute-r-script-module"></a>Модуль «Выполнение сценария R»
В Студии машинного обучения сценарии на языке R выполняются в модуле [Выполнить сценарий R][execute-r-script]. Пример модуля [Выполнить сценарий R][execute-r-script] в Студии машинного обучения показан на рис. 1.

 ![Язык программирования R: в Студии машинного обучения выбран модуль «Выполнение сценария R»][1]

*Рис. 1. Среда Студии машинного обучения с выбранным модулем «Выполнение сценария R»*

Используя рис. 1, рассмотрим основные элементы среды Студии машинного обучения для работы с модулем [Выполнить сценарий R][execute-r-script].

* Модули эксперимента отображаются на центральной панели.
* В верхней части правой панели находится окно просмотра и изменения скриптов R.  
* В нижней части правой панели отображаются свойства модуля [Выполнить сценарий R][execute-r-script]. Журнал ошибок и журнал выходных данных можно просмотреть, щелкнув соответствующие элементы панели.

Разумеется, в оставшейся части этого документа мы рассмотрим модуль [Выполнить сценарий R][execute-r-script] подробнее.

При работе с более сложными функциями R для изменения, тестирования и отладки кода я рекомендую использовать RStudio. Как и в случае разработки любого программного обеспечения, создавайте код пошагово, отдельными фрагментами, и тестируйте его на небольших, простых проверочных примерах. Затем вырезайте и вставляйте готовые функции в окно сценария модуля [Выполнить сценарий R][execute-r-script]. Такой подход позволяет в полной мере использовать как интегрированную среду разработки (IDE) RStudio, так и возможности Машинного обучения Azure.  

#### <a name="execute-r-code"></a>Выполнение кода R
Любой код на R в модуле [Выполнить сценарий R][execute-r-script] выполняется при запуске эксперимента нажатием кнопки **Запуск**. Когда код выполнен, на значке модуля [Выполнить сценарий R][execute-r-script] появляется флажок.

#### <a name="defensive-r-coding-for-azure-machine-learning"></a>Защищенное программирование на R для Машинного обучения Azure
При разработке кода на R для, скажем, какой-нибудь веб-службы с помощью Машинного обучения Azure необходимо предусмотреть, как ваш код будет реагировать на непредвиденные входные данные и исключения. Чтобы не усложнять, я не стал добавлять проверку или обработку исключений во все примеры кода. Однако далее я приведу несколько примеров функций, использующих возможности языка R для обработки исключений.  

Если вас интересует более подробная информация об обработке исключений на R, советую прочитать соответствующие разделы книги Викхема (Wickham) из [Приложения Б. Дополнительные материалы](#appendixb).

#### <a name="debug-and-test-r-in-machine-learning-studio"></a>Отладка и тестирование кода R в Студии машинного обучения
Повторюсь: я рекомендую использовать RStudio для отладки и тестирования небольших фрагментов кода на R. Но бывают случаи, когда необходимо отслеживать проблемы кода непосредственно в модуле [Выполнить сценарий R][execute-r-script]. Кроме того, это неплохая привычка — проверять результаты работы в Студии машинного обучения.

Большая часть выходных данных при выполнении кода на R на платформе Машинного обучения Azure находится в файле output.log. Дополнительная информация отображается в файле error.log.  

Если при выполнении вашего кода в Студии машинного обучения происходит сбой, в первую очередь нужно просмотреть файл error.log. В этом файле могут быть полезные сообщения об ошибках, которые помогут вам понять и исправить свою ошибку. Чтобы просмотреть файл error.log, щелкните **View error log** (Просмотреть журнал ошибок) на **панели свойств** модуля [Выполнить сценарий R][execute-r-script], содержащего ошибку.

Например, запустим этот код на R с неопределенной переменной y в модуле [Выполнить сценарий R][execute-r-script]:

    x <- 1.0
    z <- x + y

Выполнить этот код не удается, возникает условие ошибки. Если щелкнуть **View error log** (Просмотреть журнал ошибок) на **панели свойств**, появится всплывающее окно (см. рис. 2).

  ![Всплывающее окно сообщения об ошибке][2]

*Рис. 2. Всплывающее окно сообщения об ошибке*

Похоже, нужно просмотреть файл output.log, чтобы прочитать сообщение об ошибке в коде на R. Щелкнем [Выполнить сценарий R][execute-r-script], а затем — **View output log** (Просмотр журнала выходных данных) на **панели свойств** справа. Откроется новое окно браузера, где мы увидим следующее:

    [Critical]     Error: Error 0063: The following error occurred during evaluation of R script:
    ---------- Start of error message from R ----------
    object 'y' not found


    object 'y' not found
    ----------- End of error message from R -----------

В сообщении об ошибке нет ничего неожиданного: проблема четко определена.

Чтобы проверить значение любого объекта в коде на R, можно обеспечить вывод этих значений в файл output.log. Правила проверки значений объектов в принципе те же, что и при интерактивном сеансе работы с R. Например, если ввести в строке имя переменной, значение объекта выводится в файл output.log.  

#### <a name="packages-in-machine-learning-studio"></a>Пакеты в Студии машинного обучения
Служба машинного обучения Azure содержит более 350 предустановленных пакетов на языке R. Чтобы увидеть список предустановленных пакетов, используйте приведенный ниже код в модуле [Выполнить сценарий R][execute-r-script].

    data.set <- data.frame(installed.packages())
    maml.mapOutputPort("data.set")

Если вам пока не понятна последняя строка кода, не останавливайтесь. Далее в этом документе мы подробно рассмотрим использование R в среде Машинного обучения Azure.

### <a name="introduction-to-rstudio"></a>Основные сведения об RStudio
RStudio — широко распространенная среда IDE для языка R. Я буду использовать RStudio для изменения, тестирования и отладки фрагментов кода на R, используемых в этом руководстве. Когда код на R готов и проверен, его можно просто вырезать из редактора RStudio и вставить в модуль [Выполнить сценарий R][execute-r-script] в Студии машинного обучения.  

Если на вашем компьютере еще не установлен язык R, советую сделать это сейчас. Вы можете бесплатно загрузить R с открытым исходным кодом на сайте Comprehensive R Archive Network (CRAN) по адресу [http://www.r-project.org/](http://www.r-project.org/). Доступны файлы для скачивания для Windows, Mac OS и Linux или UNIX. Выберите любое зеркало и следуйте инструкциям по загрузке. CRAN также содержит множество полезных пакетов для аналитики и обработки данных.

Если вы еще не знакомы с RStudio, вам лучше загрузить и установить версию для настольного компьютера. Скачать RStudio для Windows, Mac OS и Linux (UNIX) можно по ссылке http://www.rstudio.com/products/RStudio/. Следуйте инструкциям по установке RStudio на компьютер.  

Руководство по основам работы с RStudio доступно по адресу https://support.rstudio.com/hc/sections/200107586-Using-RStudio.

Дополнительные сведения по использованию RStudio можно найти в [Приложении А][appendixa].  

## <a id="scriptmodule"></a>Добавление данных в модуль «Выполнение сценария R» и их извлечение оттуда
В этом разделе мы рассмотрим ввод и вывод данных модуля [Выполнить сценарий R][execute-r-script]. Мы ознакомимся с обработкой различных типов данных, передаваемых в модуль [Выполнить сценарий R][execute-r-script] и получаемых из него.

Полный код для этого раздела есть в ZIP-файле, который вы загрузили ранее.

### <a name="load-and-check-data-in-machine-learning-studio"></a>Загрузка и проверка данных в Студии машинного обучения
#### <a id="loading"></a>Загрузка набора данных
Для начала загрузим в Студию машинного обучения Azure файл **csdairydata.csv** .

* Запустите среду Студии машинного обучения Azure.
* Щелкните **+ NEW** (+ Создать) в нижнем левом углу экрана и выберите **Dataset** (Набор данных).
* Выберите **From Local File** (Из локального файла) и нажмите кнопку **Browse** (Обзор), чтобы выбрать файл.
* Убедитесь, что в качестве типа набора данных выбран вариант **Универсальный CSV-файл с заголовком** .
* Щелкните значок галочки.
* После загрузки набора данных он появится на вкладке **Наборы данных** .  

#### <a name="create-an-experiment"></a>Создание эксперимента
Теперь, когда у нас есть определенные данные в Студии машинного обучения, нужно создать эксперимент, чтобы выполнить анализ.  

* Щелкните **+ NEW** (+ Создать) в левом нижнем углу и выберите **Experiment** (Эксперимент), а затем — **Blank Experiment** (Пустой эксперимент).
* Чтобы задать для него название, выделите и отредактируйте заголовок **Эксперимент создан...** вверху страницы. Например, можно изменить его на **Анализ молочных продуктов**.
* В левой части страницы эксперимента разверните узел **Saved Datasets** (Сохраненные наборы данных), а затем – **My Datasets** (Мои наборы данных). Вы должны увидеть загруженный ранее файл **cadairydata.csv** .
* Перетащите **набор данных csdairydata.csv** на рабочую область эксперимента.
* В поле **Search experiment items** (Поиск элементов эксперимента) в верхней части левой панели введите текст [Выполнить сценарий R][execute-r-script]. Этот модуль появится в списке результатов поиска.
* Перетащите модуль [Выполнить сценарий R][execute-r-script] на палитру.  
* Соедините порт вывода **набора данных csdairydata.csv** с крайним левым портом ввода (**Набор данных 1**) модуля [Выполнить сценарий R][execute-r-script].
* **Не забудьте нажать кнопку «Сохранить»!**  

На этом этапе ваш эксперимент должен выглядеть, как показано на рисунке 3.

![Эксперимент «Анализ молочных продуктов»: набор данных и модуль «Выполнение сценария R»][3]

*Рис. 3. Эксперимент «Анализ молочных продуктов»: набор данных и модуль «Выполнение сценария R»*

#### <a name="check-on-the-data"></a>Проверка данных
Рассмотрим данные, загруженные в наш эксперимент. В эксперименте щелкните порт вывода **набора данных cadairydata.csv** и выберите **Visualize** (Визуализировать). Вы увидите нечто вроде этого (рис. 4):  

![Сводка набора данных cadairydata.csv][4]

*Рис. 4. Сводка набора данных cadairydata.csv*

Здесь представлено много полезной информации. Также видны первые несколько строк этого набора данных. Если выбрать какой-либо столбец, в разделе «Статистика» появится более подробная информация об этом столбце. Например, строка «Тип компонента» показывает, какие типы данных присвоены этому в студии машинного обучения Azure. Такой беглый просмотр данных — хорошая проверка перед началом серьезной работы.

### <a name="first-r-script"></a>Первый сценарий R
Создадим простой первый сценарий на R, с которым и будем работать в Студии машинного обучения Azure. Я создал и протестировал такой сценарий в RStudio:  

    ## Only one of the following two lines should be used
    ## If running in Machine Learning Studio, use the first line with maml.mapInputPort()
    ## If in RStudio, use the second line with read.csv()
    cadairydata <- maml.mapInputPort(1)
    # cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
    str(cadairydata)
    pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata)
    ## The following line should be executed only when running in
    ## Azure Machine Learning Studio
    maml.mapOutputPort('cadairydata')

Теперь мне нужно перенести его в Студию машинного обучения Azure. Можно было бы его просто вырезать и вставить. Но в данном случае я перенесу свой скрипт R при помощи ZIP-файла.

### <a name="data-input-to-the-execute-r-script-module"></a>Ввод данных в модуль "Выполнение скрипта R"
Рассмотрим порты ввода модуля [Выполнить сценарий R][execute-r-script]. В этом примере мы считаем данные по молочной продукции Калифорнии в модуль [Выполнить сценарий R][execute-r-script].  

У модуля [Выполнить сценарий R][execute-r-script] может быть три порта ввода. В зависимости от приложения можно использовать любой из них или все. Кроме того, иногда целесообразно использовать сценарий R вообще без портов ввода.  

Рассмотрим все порты ввода по порядку слева направо. Наведя курсор на порт, можно увидеть всплывающую подсказку с его именем.  

#### <a name="script-bundle"></a>Пакет скриптов
Порт ввода "Пакет сценариев" позволяет передать содержимое ZIP-файла в модуль [Выполнить сценарий R][execute-r-script]. Для считывания содержимого ZIP-файла в код на R можно использовать одну из этих команд.

    source("src/yourfile.R") # Reads a zipped R script
    load("src/yourData.rdata") # Reads a zipped R data file

> [!NOTE]
> Машинное обучение Azure обрабатывает файлы ZIP-архива, как если бы они находились в каталоге src/, поэтому необходимо добавлять имя этого каталога в начало имен файлов. Например, если ZIP-файл содержит файлы `yourfile.R` и `yourData.rdata` в корне, вы будете рассматривать их как `src/yourfile.R` и `src/yourData.rdata` при использовании `source` и `load`.
> 
> 

Загрузка наборов данных уже рассматривалась в разделе [Загрузка набора данных](#loading). После создания и тестирования сценария R, описанного в предыдущем разделе, сделайте следующее:

1. Сохраните скрипт R в файл с расширением .R. Я назвал свой файл скрипта "simpleplot.R". Вот содержимое.
   
        ## Only one of the following two lines should be used
        ## If running in Machine Learning Studio, use the first line with maml.mapInputPort()
        ## If in RStudio, use the second line with read.csv()
        cadairydata <- maml.mapInputPort(1)
        # cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
        str(cadairydata)
        pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata)
        ## The following line should be executed only when running in
        ## Azure Machine Learning Studio
        maml.mapOutputPort('cadairydata')
2. Создайте ZIP-файл и скопируйте в него свой скрипт. В Windows щелкните файл правой кнопкой мыши и выберите **Отправить**, а затем — **Сжатая ZIP-папка**. Будет создан ZIP-файл, содержащий файл "simpleplot.R".
3. Добавьте свой файл в **наборы данных** в студии машинного обучения, указав тип файла **ZIP**. Теперь вы увидите ZIP-файл среди своих наборов данных.
4. Перетащите ZIP-файл из **наборов данных** на **холст студии машинного обучения**.
5. Соедините порт вывода значка **ZIP-данных** с портом ввода **Пакет сценариев** модуля [Выполнить сценарий R][execute-r-script].
6. В окне кода модуля [Выполнить сценарий R][execute-r-script] введите функцию `source()` с именем вашего ZIP-файла. В данном случае введено `source("src/simpleplot.R")`.  
7. Обязательно щелкните **Сохранить**.

После выполнения этих шагов модуль [Выполнить сценарий R][execute-r-script] выполнит сценарий R в ZIP-файле при запуске эксперимента. На этом этапе ваш эксперимент должен выглядеть, как изображено на рисунке 5.

![Эксперимент с использованием сценария R, сжатого в ZIP-файл][6]

*Рис. 5. Эксперимент с использованием сценария R, сжатого в ZIP-файл*

#### <a name="dataset1"></a>Набор данных 1
С помощью порта ввода «Набор данных 1» можно передать прямоугольную таблицу данных в код на R. В нашем простом сценарии функция `maml.mapInputPort(1)` считывает данные из порта 1. Затем эти данные присваиваются имени переменной в вашем коде, тип которой — таблица данных. В нашем примере скрипта присвоение выполняет первая строка кода.

    cadairydata <- maml.mapInputPort(1)

Выполните эксперимент, нажав кнопку **Запуск** . По завершении выполнения щелкните модуль [Выполнить сценарий R][execute-r-script], а затем — **View output log** (Просмотр журнала выходных данных) на панели свойств. В браузере откроется новая страница с содержимым файла output.log. Прокрутив ее вниз, вы увидите следующее:

    [ModuleOutput] InputDataStructure
    [ModuleOutput]
    [ModuleOutput] {
    [ModuleOutput]  "InputName":Dataset1
    [ModuleOutput]  "Rows":228
    [ModuleOutput]  "Cols":9
    [ModuleOutput]  "ColumnTypes":System.Int32,3,System.Double,5,System.String,1
    [ModuleOutput] }

Далее в нижней части страницы содержатся более подробные сведения в столбцах, которые будут выглядеть примерно следующим образом.

    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput]
    [ModuleOutput] 'data.frame':    228 obs. of  9 variables:
    [ModuleOutput]
    [ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput]
    [ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
    [ModuleOutput]
    [ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput]
    [ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
    [ModuleOutput]
    [ModuleOutput]  $ Month            : chr  "Jan" "Feb" "Mar" "Apr" ...
    [ModuleOutput]
    [ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
    [ModuleOutput]
    [ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
    [ModuleOutput]
    [ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
    [ModuleOutput]
    [ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...

Результаты преимущественно ожидаемые. В таблице данных 228 наблюдений и 9 столбцов. Отображаются имена столбцов, тип данных R и пример каждого столбца.

> [!NOTE]
> Эти же результаты можно получить с помощью порта вывода "Устройство R" модуля [Выполнить сценарий R][execute-r-script]. Порты вывода модуля [Выполнить сценарий R][execute-r-script] мы рассмотрим подробнее в следующем разделе.  
> 
> 

#### <a name="dataset2"></a>Набор данных 2
Поведение портов ввода "Набор данных 2" такое же, как у портов "Набор данных 1". С помощью этого порта можно передать еще одну прямоугольную таблицу данных в код на R. Для передачи этих данных используется функция `maml.mapInputPort(2)`с аргументом 2.  

### <a name="execute-r-script-outputs"></a>Порты вывода модуля "Выполнение скрипта R"
#### <a name="output-a-dataframe"></a>Вывод таблицы данных
Через порт «Итоговый набор данных 1» можно вывести содержимое таблицы данных на R в виде прямоугольной таблицы с помощью функции `maml.mapOutputPort()` . В нашем примере простого сценария R это выполняется с помощью такой строки:

    maml.mapOutputPort('cadairydata')

Выполнив эксперимент, щелкните порт вывода Result Dataset1 (Итоговый набор данных 1), а затем — **Visualize** (Визуализировать). Вы увидите нечто вроде этого (рис. 6):

![Визуализация вывода данных по молочной продукции Калифорнии][7]

*Рис. 6. Визуализация вывода данных по молочной продукции Калифорнии*

Выходные данные выглядят в точности так, как и входные — как и предполагалось.  

### <a name="r-device-output"></a>Порт вывода "Устройство R"
Порт вывода "Устройство R" модуля [Выполнить сценарий R][execute-r-script] предназначен для вывода сообщений и графики. Как стандартный вывод данных, так и сообщения об ошибках на R направляются в порт вывода "Устройство R".  

Чтобы просмотреть выходные данные порта «Устройство R», щелкните этот порт и выберите **Визуализировать**. На рисунке 7 показаны стандартный вывод данных и стандартный вывод ошибок.

![Стандартный вывод данных и стандартный вывод ошибок из порта «Устройство R»][8]

*Рис. 7. Стандартный вывод данных и стандартный вывод ошибок из порта «Устройство R»*

Прокрутив вниз, увидим графический вывод данных скрипта R (рис. 8).  

![Графический вывод данных из порта «Устройство R»][9]

*Рис. 8. Графический вывод данных из порта «Устройство R»*  

## <a id="filtering"></a>Фильтрация и преобразование данных
В этом разделе мы выполним простые операции фильтрации и преобразования данных по молочной продукции Калифорнии. В конце мы получим данные в формате, удобном для построения аналитической модели.  

В частности, в этом разделе мы выполним несколько распространенных задач по очистке и преобразованию данных: преобразование типа данных, фильтрацию кадров данных, добавление новых вычисляемых столбцов и преобразование значений. Эти базовые навыки помогут вам справиться с любыми видами задач при решении практических проблем.

Полный код на R для этого раздела доступен в ZIP-файле, который вы загрузили ранее.

### <a name="type-transformations"></a>Преобразование типов данных
Мы уже можем считать данные по молочной продукции Калифорнии в код на R модуля [Выполнить сценарий R][execute-r-script], но нужно убедиться, что данные в столбцах имеют нужный тип и формат.  

R — динамически типизированный язык. Другими словами, при необходимости типы данных преобразуются из одного в другой. Атомарные типы данных в языке R включают числовые, логические и символьные. Факторы используются для компактного хранения категориальных данных. Подробные сведения о типах данных можно найти в разделе [Приложение Б. Дополнительные материалы](#appendixb).

При считывании в R табличных данных из внешних источников рекомендуется всегда проверять в столбцах результирующие типы. Зачастую может оказаться, что данные в столбце не символьного типа, как предполагалось, а относятся к типу фактор (или наоборот). В других случаях столбец, который должен содержать числовые данные, содержит символьные данные, например «1,23» вместо 1,23 — числа с плавающей запятой.  

К счастью, можно легко преобразовывать один тип данных в другой, при условии что их сопоставление возможно. Например, нельзя преобразовать слово "Самара" в числовое значение, но его можно преобразовать в фактор (категориальную переменную). Еще один пример. Числовое значение 1 можно преобразовать в символ '1' или в фактор.  

Синтаксис любого из этих преобразований прост: `as.datatype()`. Вот функции преобразования типов данных:

* `as.numeric()`
* `as.character()`
* `as.logical()`
* `as.factor()`

Рассмотрим типы данных столбцов, которые мы ввели в предыдущем разделе. Тип всех столбцов числовой, кроме столбца Month, тип которого символьный. Преобразуем его в фактор и проверим результат.  

Я удалил строку, создававшую матрицу точечной диаграммы, и добавил строку, преобразующую тип столбца Month в фактор. В моем эксперименте я просто вырежу код на R и вставлю его в окно кода модуля [Выполнить сценарий R][execute-r-script]. Также можно обновить ZIP-файл и передать его в Студию машинного обучения Azure, но это будет дольше.  

    ## Only one of the following two lines should be used
    ## If running in Machine Learning Studio, use the first line with maml.mapInputPort()
    ## If in RStudio, use the second line with read.csv()
    cadairydata <- maml.mapInputPort(1)
    # cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
    ## Ensure the coding is consistent and convert column to a factor
    cadairydata$Month <- as.factor(cadairydata$Month)
    str(cadairydata) # Check the result
    ## The following line should be executed only when running in
    ## Azure Machine Learning Studio
    maml.mapOutputPort('cadairydata')

Выполните этот код и найдите в журнале сценарий R. Соответствующие данные журнала показаны на рис. 9.

    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput] 
    [ModuleOutput] 'data.frame':    228 obs. of  9 variables:
    [ModuleOutput] 
    [ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month            : Factor w/ 14 levels "Apr","April",..: 6 5 9 1 11 8 7 3 14 13 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
    [ModuleOutput] 
    [ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving variable  cadairydata  ..."
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"

*Рис. 9. Сводка таблицы данных с фактором в качестве переменной*

Тип столбца Month изменился на**Factor w/ 14 levels**. Такой вариант нас не устраивает, поскольку в году всего 12 месяцев. Также можно убедиться, что тип выходных данных — **Categorical** (Категориальный), выбрав **Visualize** (Визуализировать) в меню порта Result Dataset (Итоговый набор данных).

Проблема в том, что кодирование столбца "Месяц" было бессистемным. В некоторых случаях месяц назван April, а в других — сокращенно Apr. Эту проблему можно решить, сократив строку до трех символов. Теперь строка кода выглядит так:

    ## Ensure the coding is consistent and convert column to a factor
    cadairydata$Month <- as.factor(substr(cadairydata$Month, 1, 3))

Запустите эксперимент еще раз и проверьте журнал. Ожидаемые результаты показаны на рис. 10.  

    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput] 
    [ModuleOutput] 'data.frame':    228 obs. of  9 variables:
    [ModuleOutput] 
    [ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
    [ModuleOutput] 
    [ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving variable  cadairydata  ..."
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"

*Рис. 10. Сводка таблицы данных с правильным количеством уровней фактора*

Теперь у нашей переменной — фактора — 12 уровней, как и положено.

### <a name="basic-data-frame-filtering"></a>Базовая фильтрация таблицы данных
Таблицы данных R поддерживают массу возможностей фильтрации. Наборы данных можно разбивать на подмножества, используя логическую фильтрацию по строкам или столбцам. Во многих случаях вам потребуются сложные критерии фильтрации. В материалах из [Приложения Б. Дополнительные материалы](#appendixb) содержится множество примеров фильтрации таблиц данных.  

Выполним операцию фильтрации в нашем наборе данных. Если рассмотреть столбцы таблицы данных cadariydata, можно заметить два ненужных столбца. Первый содержит только номер строки — который не так уж и важен. Второй, Year.Month, содержит избыточную информацию. С помощью кода на R мы можем легко исключить эти столбцы.

> [!NOTE]
> С этого момента я буду показывать только дополнительный код, который добавляется в модуль [Выполнить сценарий R][execute-r-script]. Новые строки будут добавляться **перед** функцией `str()`. Эта функция нужна для проверки результатов в Студии машинного обучения Azure.
> 
> 

Добавим следующую строку в код на R в модуле [Выполнить сценарий R][execute-r-script].

    # Remove two columns we do not need
    cadairydata <- cadairydata[, c(-1, -2)]

Выполните этот код в своем эксперименте и проверьте результат по журналу. Результат приведен на рис. 11.

    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput] 
    [ModuleOutput] 'data.frame':    228 obs. of  7 variables:
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
    [ModuleOutput] 
    [ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving variable  cadairydata  ..."
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"

*Рис. 11. Сводка таблицы данных после удаления двух столбцов*

Отличная новость! Результат оправдал ожидания.

### <a name="add-a-new-column"></a>Добавление нового столбца
При создании модели временных рядов удобно иметь столбец, отсчитывающий месяцы с начала временного ряда. Мы создадим столбец Month.Count (Количество месяцев).

Для упрощения кодирования создадим первую простую функцию `num.month()`. Затем применим эту функцию для создания столбца в таблице данных. Вот новый код:

    ## Create a new column with the month count
    ## Function to find the number of months from the first
    ## month of the time series
    num.month <- function(Year, Month) {
      ## Find the starting year
      min.year  <- min(Year)

      ## Compute the number of months from the start of the time series
      12 * (Year - min.year) + Month - 1
    }

    ## Compute the new column for the dataframe
    cadairydata$Month.Count <- num.month(cadairydata$Year, cadairydata$Month.Number)

Теперь выполните обновленный эксперимент и посмотрите результаты в журнале. Этот результат приведен на рисунке 12.

    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput] 
    [ModuleOutput] 'data.frame':    228 obs. of  8 variables:
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
    [ModuleOutput] 
    [ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving variable  cadairydata  ..."
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"

*Рис. 12. Сводка таблицы данных с добавленным столбцом*

Похоже, все работает. У нас появился новый столбец с заданными значениями.

### <a name="value-transformations"></a>Преобразование значений
В этом разделе мы выполним несколько простых преобразований значений в некоторых столбцах таблицы данных. Язык R поддерживает практически любые преобразования значений. В материалах из [Приложения Б. Дополнительные материалы](#appendixb) содержится множество примеров.

Изучив значения в сводках таблиц данных, можно заметить нечто странное. Неужели мороженого в Калифорнии производят больше, чем молока? Разумеется, нет. Это просто не имеет смысла — как это ни печально для всех любителей мороженого. Просто использованы разные единицы измерения. Цена привязана к фунтам веса. Количество молока измеряется в миллионах фунтов, мороженого — в тысячах галлонов, а творога — в тысячах фунтов. Зная, что вес мороженого составляет около 6,5 фунтов на галлон, мы легко преобразуем все значения, чтобы привести их к одной единице измерения — 1000 фунтов.

В нашей модели прогнозирования мы используем мультипликативную модель для корректировки этих данных. Логарифмическое преобразование позволяет использовать линейную модель, что упрощает этот процесс. Логарифмическое преобразование можно применить в той же функции, в которой применяется множитель.

В следующем примере кода я определил новую функцию `log.transform()`и применил ее к строкам, содержащим числовые значения. Функция R `Map()` используется для того, чтобы применить функцию `log.transform()` к выбранным столбцам таблицы данных. Функция `Map()` сходна с функцией `apply()`, но позволяет добавлять в функцию несколько списков аргументов. Обратите внимание, что список множителей предоставляет второй аргумент функции `log.transform()` . Функция `na.omit()` используется для очистки, чтобы убедиться, что в таблице данных нет недостающих или неопределенных значений.

    log.transform <- function(invec, multiplier = 1) {
      ## Function for the transformation, which is the log
      ## of the input value times a multiplier

      warningmessages <- c("ERROR: Non-numeric argument encountered in function log.transform",
                           "ERROR: Arguments to function log.transform must be greate than zero",
                           "ERROR: Aggurment multiplier to funcition log.transform must be a scaler",
                           "ERROR: Invalid time seies value encountered in function log.transform"
                           )

      ## Check the input arguments
      if(!is.numeric(invec) | !is.numeric(multiplier)) {warning(warningmessages[1]); return(NA)}  
      if(any(invec < 0.0) | any(multiplier < 0.0)) {warning(warningmessages[2]); return(NA)}
      if(length(multiplier) != 1) {{warning(warningmessages[3]); return(NA)}}

      ## Wrap the multiplication in tryCatch
      ## If there is an exception, print the warningmessage to
      ## standard error and return NA
      tryCatch(log(multiplier * invec),
               error = function(e){warning(warningmessages[4]); NA})
    }


    ## Apply the transformation function to the 4 columns
    ## of the dataframe with production data
    multipliers  <- list(1.0, 6.5, 1000.0, 1000.0)
    cadairydata[, 4:7] <- Map(log.transform, cadairydata[, 4:7], multipliers)

    ## Get rid of any rows with NA values
    cadairydata <- na.omit(cadairydata)  

Функция `log.transform()` выполняет большую работу. Большая часть кода выполняет поиск потенциальных проблем с использованием аргументов или обрабатывает исключения, которые могут возникать во время вычислений. Фактически, только несколько строк кода выполняют вычисления.

Цель такого защищенного программирования — не допустить, чтобы сбой одной функции привел к нарушению всей работы. Внезапный сбой продолжительного анализа — вещь довольно неприятная. Чтобы избежать этого, необходимо выбрать значения, возвращаемые по умолчанию, что уменьшит возможные негативные последствия. Также выдается сообщение, предупреждающее пользователя о проблеме.

Если вы не знакомы с защищенным программированием на R, понять этот код может быть трудно. Поясню основные шаги:

1. Определяется вектор четырех сообщений. Они используются для передачи информации о некоторых потенциальных ошибках и исключениях, которые могут возникнуть при выполнении кода.
2. Во всех этих случаях возвращается значение NA (нет данных). Есть и другие возможности, у которых может быть меньше побочных эффектов. Например, можно было бы возвращать вектор нулей или вектор исходного входного объекта.
3. Выполняются проверки аргументов функций. В каждом случае при обнаружении ошибки возвращается значение по умолчанию и создается сообщение с помощью функции `warning()`. Я использую `warning()`, а не `stop()`, так как последняя функция прерывает выполнение, а именно этого я и хочу избежать. Обратите внимание, что при написании этого кода я использовал процедуры, поскольку использование функций сделало бы его сложнее и непонятнее.
4. Вычисления журнала выполняются внутри вызова `tryCatch()` , чтобы исключения не привели к внезапному прерыванию обработки. Без функции `tryCatch()` большинство ошибок, вызванных функциями R, вызывает сигнал остановки, что приводит именно к прерыванию.

Выполните этот код на R в своем эксперименте и просмотрите вывод данных в файле output.log. Преобразованные значения четырех столбцов появятся в журнале (см. рис. 13).

    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput] 
    [ModuleOutput] 'data.frame':    228 obs. of  8 variables:
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
    [ModuleOutput] 
    [ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving variable  cadairydata  ..."
    [ModuleOutput] 
    [ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"

*Рис. 13. Сводка преобразованных значений в таблице данных*

Как мы видим, значения изменились. Теперь производство молока значительно превышает по объемам производство остальных молочных продуктов (не забывайте, что мы используем логарифмическую шкалу).

Теперь все наши данные в порядке и мы можем приступать к моделированию. Просмотрев визуализацию вывода данных через порт "Итоговый набор данных" модуля [Выполнить сценарий R][execute-r-script], вы увидите, что тип столбца Month теперь "Категориальный" с 12 уникальными значениями, как мы и хотели.

## <a id="timeseries"></a>Объекты временного ряда и корреляционный анализ
В этом разделе мы исследуем несколько базовых объектов временных рядов R и проанализируем взаимосвязи некоторых переменных. Наша задача — вывод таблицы данных, содержащей сведения о попарной корреляции с несколькими задержками.

Полный код на R для этого раздела доступен в ZIP-файле, который вы загрузили ранее.

### <a name="time-series-objects-in-r"></a>Объекты временных рядов в языке R
Как уже упоминалось, временные ряды представляют собой ряды значений данных, индексированные по времени. Объекты временных рядов на R используются для создания индексов времени и управления ними. Использование объектов временных рядов имеет несколько преимуществ. Оно избавляет от необходимости вникать в подробности управления значениями индексов временных рядов, которые уже включены в объект. Кроме того, использование объектов временных рядов позволяет применять многочисленные методы временных рядов для построения диаграмм, моделирования и много другого.

Класс временных рядов POSIXct довольно распространен и относительно прост. Этот класс временных рядов измеряет количество времени, прошедшее с начала эры UNIX — 1 января 1970 г. В этом примере мы будем использовать объекты временных рядов POSIXct. Другие распространенные классы объектов временных рядов включают zoo и xts (расширяемые временные ряды).
<!-- Additional information on R time series objects is provided in the references in Section 5.7. [commenting because this section doesn't exist, even in the original] -->

### <a name="time-series-object-example"></a>Пример объекта временных рядов
Приступим к разбору примера. Перетащим **новый** модуль [Выполнить сценарий R][execute-r-script] в свой эксперимент. Соединим порт вывода "Итоговый набор данных 1" существующего модуля [Выполнить сценарий R][execute-r-script] с портом ввода "Набор данных 1" нового модуля [Выполнить сценарий R][execute-r-script].

Как и в предыдущих случаях, с определенного момента работы над примером я буду показывать только отдельные фрагменты кода на R, которые добавляются на каждом этапе.  

#### <a name="reading-the-dataframe"></a>Чтение таблицы данных
Для начала давайте считаем таблицу данных и убедимся, что мы получили тот результат, на который рассчитывали. Эту работу может выполнить следующий код:

    # Comment the following if using RStudio
    cadairydata <- maml.mapInputPort(1)
    str(cadairydata) # Check the results

Теперь выполним эксперимент. Журнал новой формы «Выполнение скрипта R» должен выглядеть как на рис. 14.

    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput] 
    [ModuleOutput] 'data.frame':    228 obs. of  8 variables:
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
    [ModuleOutput] 
    [ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...

*Рис. 14. Сводка таблицы данных в модуле «Выполнение сценария R»*

У этих данных ожидаемый тип и формат. Тип данных столбца "Месяц" — фактор с верным количеством уровней.

#### <a name="creating-a-time-series-object"></a>Создание объекта временных рядов
В нашу таблицу данных нужно добавить объект временного ряда. Замените текущий код следующим, добавляющим новый столбец класса POSIXct:

    # Comment the following if using RStudio
    cadairydata <- maml.mapInputPort(1)

    ## Create a new column as a POSIXct object
    Sys.setenv(TZ = "PST8PDT")
    cadairydata$Time <- as.POSIXct(strptime(paste(as.character(cadairydata$Year), "-", as.character(cadairydata$Month.Number), "-01 00:00:00", sep = ""), "%Y-%m-%d %H:%M:%S"))

    str(cadairydata) # Check the results

Теперь проверьте журнал. Результат приведен на рисунке 15.

    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput] 
    [ModuleOutput] 'data.frame':    228 obs. of  9 variables:
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
    [ModuleOutput] 
    [ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Time             : POSIXct, format: "1995-01-01" "1995-02-01" ...

*Рис. 15. Сводка таблицы данных с объектом временных рядов*

Как мы видим, действительно появился новый столбец класса POSIXct.

### <a name="exploring-and-transforming-the-data"></a>Исследование и преобразование данных
Рассмотрим некоторые из переменных в этом наборе данных. Для этого прекрасно подойдет точечная диаграмма. Заменим функцию `str()` в предыдущем фрагменте кода на R следующей строкой:

    pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata, main = "Pairwise Scatterplots of dairy time series")

Выполним этот код и посмотрим на результат. Диаграмма, полученная через порт "Устройство R", приведена на рисунке 16.

![Точечная диаграмма выбранных переменных][17]

*Рис. 16. Матрица точечной диаграммы выбранных переменных*

Во взаимосвязях этих переменных можно заметить необычную структуру. Возможно, это результат наличия тренда в данных или вызвано тем, что переменные не стандартизованы.

### <a name="correlation-analysis"></a>Корреляционный анализ
Для осуществления корреляционного анализа необходимо произвести как вычитание тренда, так и стандартизацию переменных. Можно просто использовать функцию R `scale()` , которая масштабирует переменные и размещает их по центру. Возможно, это было бы быстрее. Однако я хочу продемонстрировать защищенное программирование на R.

Функция `ts.detrend()` , показанная ниже, выполняет обе эти операции. Следующие две строки кода вычитают тренд из данных и приводят значения к одному стандарту.

    ts.detrend <- function(ts, Time, min.length = 3){
      ## Function to de-trend and standardize a time series

      ## Define some messages if they are NULL  
      messages <- c('ERROR: ts.detrend requires arguments ts and Time to have the same length',
                    'ERROR: ts.detrend requires argument ts to be of type numeric',
                    paste('WARNING: ts.detrend has encountered a time series with length less than', as.character(min.length)),
                    'ERROR: ts.detrend has encountered a Time argument not of class POSIXct',
                    'ERROR: Detrend regression has failed in ts.detrend',
                    'ERROR: Exception occurred in ts.detrend while standardizing time series in function ts.detrend'
      )
      # Create a vector of zeros to return as a default in some cases
      zerovec  <- rep(length(ts), 0.0)

      # The input arguments are not of the same length, return ts and quit
      if(length(Time) != length(ts)) {warning(messages[1]); return(ts)}

      # If the ts is not numeric, just return a zero vector and quit
      if(!is.numeric(ts)) {warning(messages[2]); return(zerovec)}

      # If the ts is too short, just return it and quit
      if((ts.length <- length(ts)) < min.length) {warning(messages[3]); return(ts)}

      ## Check that the Time variable is of class POSIXct
      if(class(cadairydata$Time)[[1]] != "POSIXct") {warning(messages[4]); return(ts)}

      ## De-trend the time series by using a linear model
      ts.frame  <- data.frame(ts = ts, Time = Time)
      tryCatch({ts <- ts - fitted(lm(ts ~ Time, data = ts.frame))},
               error = function(e){warning(messages[5]); zerovec})

      tryCatch( {stdev <- sqrt(sum((ts - mean(ts))^2))/(ts.length - 1)
                 ts <- ts/stdev},
                error = function(e){warning(messages[6]); zerovec})

      ts
    }  
    ## Apply the detrend.ts function to the variables of interest
    df.detrend <- data.frame(lapply(cadairydata[, 4:7], ts.detrend, cadairydata$Time))

    ## Plot the results to look at the relationships
    pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = df.detrend, main = "Pairwise Scatterplots of detrended standardized time series")

Функция `ts.detrend()` выполняет большую работу. Большая часть кода выполняет поиск потенциальных проблем с использованием аргументов или обрабатывает исключения, которые могут возникать во время вычислений. Фактически, только несколько строк кода выполняют вычисления.

Мы уже обсуждали пример защищенного программирования в разделе [Преобразование значений](#valuetransformations). Оба блока вычислений выполняются внутри функции `tryCatch()`. Для некоторых ошибок имеет смысл возвращать вектор исходного входного объекта, а в других случаях я возвращаю вектор нулей.  

Обратите внимание, что линейная регрессия, использующаяся для вычитания тренда, является регрессией временного ряда. Прогнозирующая переменная — это объект временного ряда.  

Когда функция `ts.detrend()` определена, применим ее к интересующим нас переменным таблицы данных. Нужно привести список, созданный функцией `lapply()`, в соответствие с данными таблицы данных с помощью функции `as.data.frame()`. Благодаря защищенности `ts.detrend()`сбой обработки одной переменной не помешает обработке остальных.  

Последняя строка кода создает попарную точечную диаграмму. Точечная диаграмма, полученная в результате выполнения этого кода на R, приведена на рис. 17.

![Попарная точечная диаграмма после вычитания тренда и стандартизации временных рядов][18]

*Рис. 17. Попарная точечная диаграмма после вычитания тренда и стандартизации временных рядов*

Вы можете сравнить эти результаты с приведенными на рис. 16. После удаления тренда и стандартизации переменных мы видим, что взаимосвязи переменных гораздо менее структурированы.

Код для вычисления корреляций как объектов взаимнокорреляционной функции (CCF-объектов) R следующий:

    ## A function to compute pairwise correlations from a
    ## list of time series value vectors
    pair.cor <- function(pair.ind, ts.list, lag.max = 1, plot = FALSE){
      ccf(ts.list[[pair.ind[1]]], ts.list[[pair.ind[2]]], lag.max = lag.max, plot = plot)
    }

    ## A list of the pairwise indices
    corpairs <- list(c(1,2), c(1,3), c(1,4), c(2,3), c(2,4), c(3,4))

    ## Compute the list of ccf objects
    cadairycorrelations <- lapply(corpairs, pair.cor, df.detrend)  

    cadairycorrelations

При выполнении этого кода создается журнал, показанный на рис. 18.

    [ModuleOutput] Loading objects:
    [ModuleOutput]   port1
    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput] [[1]]
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput] Autocorrelations of series 'X', by lag
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput]    -1     0     1 
    [ModuleOutput] 0.148 0.358 0.317 
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput] [[2]]
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput] Autocorrelations of series 'X', by lag
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput]     -1      0      1 
    [ModuleOutput] -0.395 -0.186 -0.238 
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput] [[3]]
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput] Autocorrelations of series 'X', by lag
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput]     -1      0      1 
    [ModuleOutput] -0.059 -0.089 -0.127 
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput] [[4]]
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput] Autocorrelations of series 'X', by lag
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput]    -1     0     1 
    [ModuleOutput] 0.140 0.294 0.293 
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput] [[5]]
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput] Autocorrelations of series 'X', by lag
    [ModuleOutput] 
    [ModuleOutput] 
    [ModuleOutput]     -1      0      1 
    [ModuleOutput] -0.002 -0.074 -0.124 

*Рис. 18. Список CCF-объектов после попарного корреляционного анализа*

Каждой задержке соответствует значение корреляции. Все эти значения корреляции слишком малы, чтобы быть значимыми. Таким образом, можно заключить, что каждую переменную можно моделировать независимо от других.

### <a name="output-a-dataframe"></a>Вывод таблицы данных
Мы рассчитали попарные корреляции в виде списка CCF-объектов. Это представляет определенные сложности, поскольку порту вывода "Итоговый набор данных" требуется таблица данных на R. Более того, CCF-объект сам по себе является списком, а нас интересуют только значения первого элемента этого списка, корреляции с различными задержками.

Следующий код извлекает значения задержек из списка CCF-объектов, которые и сами являются списками.

    df.correlations <- data.frame(do.call(rbind, lapply(cadairycorrelations, '[[', 1)))

    c.names <- c("correlation pair", "-1 lag", "0 lag", "+1 lag")
    r.names  <- c("Corr Cot Cheese - Ice Cream",
                  "Corr Cot Cheese - Milk Prod",
                  "Corr Cot Cheese - Fat Price",
                  "Corr Ice Cream - Mik Prod",
                  "Corr Ice Cream - Fat Price",
                  "Corr Milk Prod - Fat Price")

    ## Build a dataframe with the row names column and the
    ## correlation data frame and assign the column names
    outframe <- cbind(r.names, df.correlations)
    colnames(outframe) <- c.names
    outframe


    ## WARNING!
    ## The following line works only in Azure Machine Learning
    ## When running in RStudio, this code will result in an error
    #maml.mapOutputPort('outframe')

Первая строка кода довольно сложная. Возможно, объяснения помогут понять ее. Проанализируем по порядку, от вложенных операторов к внешним:

1. Оператор **[[** с аргументом **1** выбирает вектор корреляций с задержками из первого элемента списка CCF-объектов.
2. Функция `do.call()` применяет функцию `rbind()` к элементам списка возвращаемых значений с помощью `lapply()`.
3. Функция `data.frame()` относит результаты, полученные от `do.call()`, к таблице данных.

Обратите внимание, что имена строк находятся в столбце таблицы данных. Благодаря этому имена строк сохраняются при выводе из модуля [Выполнить сценарий R][execute-r-script].

Результат выполнения кода после применения **визуализации** вывода из порта Result Dataset (Итоговый набор данных) показан на рис. 19. Имена строк находятся в первом столбце, как и предполагалось.

![Вывод результатов корреляционного анализа][20]

*Рис. 19. Вывод результатов корреляционного анализа*

## <a id="seasonalforecasting"></a>Пример временных рядов: сезонное прогнозирование
Сейчас наши данные приведены к виду, удобному для анализа, и мы установили, что между переменными нет значимых корреляций. Пойдем дальше и создадим прогностическую модель временных рядов. С помощью этой модели мы спрогнозируем производство молока в Калифорнии на 12 месяцев 2013 г.

У нашей прогностической модели будет два компонента: тренд и сезонный компонент. Окончательный прогноз будет произведением этих двух компонентов. Модели такого типа называются мультипликативными. Альтернативой является аддитивная модель. Мы уже применили логарифмическое преобразование к интересующим нас переменным, благодаря чему будет легко обработать результаты анализа.

Полный код на R для этого раздела доступен в ZIP-файле, который вы загрузили ранее.

### <a name="creating-the-dataframe-for-analysis"></a>Создание таблицы данных для анализа
В первую очередь добавьте в эксперимент **новый** модуль [Выполнить сценарий R][execute-r-script]. Соедините порт вывода **Итоговый набор данных** существующего модуля [Выполнить сценарий R][execute-r-script] с портом ввода **Набор данных 1** нового модуля. Результат изображен на рисунке 20.

![Эксперимент после добавления нового модуля «Выполнение сценария R»][21]

*Рис. 20. Эксперимент после добавления нового модуля «Выполнение сценария R»*

Как и в случае недавно выполненного корреляционного анализа, нужно добавить столбец с объектом временных рядов POSIXct. Это может выполнить следующий код.

    # If running in Machine Learning Studio, uncomment the first line with maml.mapInputPort()
    cadairydata <- maml.mapInputPort(1)

    ## Create a new column as a POSIXct object
    Sys.setenv(TZ = "PST8PDT")
    cadairydata$Time <- as.POSIXct(strptime(paste(as.character(cadairydata$Year), "-", as.character(cadairydata$Month.Number), "-01 00:00:00", sep = ""), "%Y-%m-%d %H:%M:%S"))

    str(cadairydata)

Выполните этот код и проверьте журнал. Результат приведен на рисунке 21.

    [ModuleOutput] [1] "Loading variable port1..."
    [ModuleOutput] 
    [ModuleOutput] 'data.frame':    228 obs. of  9 variables:
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
    [ModuleOutput] 
    [ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
    [ModuleOutput] 
    [ModuleOutput]  $ Time             : POSIXct, format: "1995-01-01" "1995-02-01" ...

*Рис. 21. Сводка таблицы данных*

Получив такой результат, мы можем приступить к анализу.

### <a name="create-a-training-dataset"></a>Создание набора данных для обучения
Имея готовую таблицу данных, нужно создать учебный набор данных. Эти данные будут включать все наблюдения за исключением последних 12 (за 2013 год), которые станут тестовым набором данных. Приведенный ниже код разбивает таблицу данных на подмножества и создает диаграммы переменных: цены и производства молочных продуктов. Затем создаем диаграммы четырех переменных: цены и производства молочных продуктов. Анонимная функция используется для определения приращений диаграммы и последующей итерации для списка оставшихся двух аргументов с помощью `Map()`. Если вам кажется, что здесь пригодилась бы структура for ... loop, вы совершенно правы. Но поскольку язык R оперирует функциями, я продемонстрирую решение с использованием функций.

    cadairytrain <- cadairydata[1:216, ]

    Ylabs  <- list("Log CA Cotage Cheese Production, 1000s lb",
                   "Log CA Ice Cream Production, 1000s lb",
                   "Log CA Milk Production 1000s lb",
                   "Log North CA Milk Milk Fat Price per 1000 lb")

    Map(function(y, Ylabs){plot(cadairytrain$Time, y, xlab = "Time", ylab = Ylabs, type = "l")}, cadairytrain[, 4:7], Ylabs)

После выполнения кода получаем серию диаграмм временных рядов через порт вывода "Устройство R" (см. рис. 22). Заметьте, что по оси времени расположены даты. Это приятный бонус при использовании метода построения диаграмм временных рядов.

![Первая диаграмма временных рядов данных по ценам и производству молочных продуктов в Калифорнии](./media/r-quickstart/unnamed-chunk-161.png)

![Вторая диаграмма временных рядов данных по ценам и производству молочных продуктов в Калифорнии](./media/r-quickstart/unnamed-chunk-162.png)

![Третья диаграмма временных рядов данных по ценам и производству молочных продуктов в Калифорнии](./media/r-quickstart/unnamed-chunk-163.png)

![Четвертая диаграмма временных рядов данных по ценам и производству молочных продуктов в Калифорнии](./media/r-quickstart/unnamed-chunk-164.png)

*Рис. 22. Диаграммы временных рядов данных по ценам и производству молочных продуктов в Калифорнии*

### <a name="a-trend-model"></a>Модель тренда
Создав объект временных рядов и просмотрев данные, приступим к созданию модели тренда для данных по производству молочных продуктов в Калифорнии. Для этого можно использовать регрессию временного ряда. Но по диаграмме видно, что для точного моделирования наблюдаемого в данных для обучения тренда недостаточно знать только наклон и смещение.

Учитывая небольшой объем данных, создадим модель для тренда в RStudio, а затем вырежем результат и вставим его в Машинное обучение Azure. RStudio предоставляет интерактивную среду для такого рода интерактивного анализа.

Для начала попробуем применить полиномиальную регрессию со степенями до 3. При создании таких моделей существует высокая вероятность образования лжевзаимосвязей. Поэтому лучше не использовать члены со степенями высокого порядка. Функция `I()` запрещает интерпретацию содержимого (интерпретирует содержимое «как есть») и позволяет записать интерпретируемую буквально функцию в уравнение регрессии.

    milk.lm <- lm(Milk.Prod ~ Time + I(Month.Count^2) + I(Month.Count^3), data = cadairytrain)
    summary(milk.lm)

Это дает следующий результат:

    ##
    ## Call:
    ## lm(formula = Milk.Prod ~ Time + I(Month.Count^2) + I(Month.Count^3),
    ##     data = cadairytrain)
    ##
    ## Residuals:
    ##      Min       1Q   Median       3Q      Max
    ## -0.12667 -0.02730  0.00236  0.02943  0.10586
    ##
    ## Coefficients:
    ##                   Estimate Std. Error t value Pr(>|t|)
    ## (Intercept)       6.33e+00   1.45e-01   43.60   <2e-16 ***
    ## Time              1.63e-09   1.72e-10    9.47   <2e-16 ***
    ## I(Month.Count^2) -1.71e-06   4.89e-06   -0.35    0.726
    ## I(Month.Count^3) -3.24e-08   1.49e-08   -2.17    0.031 *  
    ## ---
    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ##
    ## Residual standard error: 0.0418 on 212 degrees of freedom
    ## Multiple R-squared:  0.941,    Adjusted R-squared:  0.94
    ## F-statistic: 1.12e+03 on 3 and 212 DF,  p-value: <2e-16

По значениям P (Pr(>|t|)) можно видеть, что значением члена со степенью 2 можно пренебречь. С помощью функции `update()` изменим эту модель, опустив член со степенью 2.

    milk.lm <- update(milk.lm, . ~ . - I(Month.Count^2))
    summary(milk.lm)

Это дает следующий результат:

    ##
    ## Call:
    ## lm(formula = Milk.Prod ~ Time + I(Month.Count^3), data = cadairytrain)
    ##
    ## Residuals:
    ##      Min       1Q   Median       3Q      Max
    ## -0.12597 -0.02659  0.00185  0.02963  0.10696
    ##
    ## Coefficients:
    ##                   Estimate Std. Error t value Pr(>|t|)
    ## (Intercept)       6.38e+00   4.07e-02   156.6   <2e-16 ***
    ## Time              1.57e-09   4.32e-11    36.3   <2e-16 ***
    ## I(Month.Count^3) -3.76e-08   2.50e-09   -15.1   <2e-16 ***
    ## ---
    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ##
    ## Residual standard error: 0.0417 on 213 degrees of freedom
    ## Multiple R-squared:  0.941,  Adjusted R-squared:  0.94
    ## F-statistic: 1.69e+03 on 2 and 213 DF,  p-value: <2e-16

Теперь значительно лучше. Остались только значимые члены. Однако значение 2e-16 — значение по умолчанию, и ему не стоит придавать большого значения.  

Для проверки корректности создадим диаграмму временных рядов данных молочного производства Калифорнии с использованием полученной линии тренда. Для создания модели и построения диаграммы я добавил приведенный ниже код в модуль [Выполнить сценарий R][execute-r-script] в Машинном обучении Azure (а не RStudio). Результат показан на рис. 23.

    milk.lm <- lm(Milk.Prod ~ Time + I(Month.Count^3), data = cadairytrain)

    plot(cadairytrain$Time, cadairytrain$Milk.Prod, xlab = "Time", ylab = "Log CA Milk Production 1000s lb", type = "l")
    lines(cadairytrain$Time, predict(milk.lm, cadairytrain), lty = 2, col = 2)

![Данные молочного производства Калифорнии с моделью тренда](./media/r-quickstart/unnamed-chunk-18.png)

*Рис. 23. Данные молочного производства Калифорнии с моделью тренда*

Как видим, модель тренда идеально соответствует данным. Более того, нет никаких признаков чрезмерной детализации вроде случайных колебаний линии модели.  

### <a name="seasonal-model"></a>Сезонная модель
Получив модель тренда, можно двигаться дальше и добавить сезонные составляющие. Мы используем месяц года в качестве фиктивной переменной линейной модели, чтобы отследить изменения по месяцам. Обратите внимание, что при внесении в модель переменных факторов расчет смещения не выполняют. Если это сделать, формула будет слишком детализирована, и R проигнорирует один из требуемых факторов, но сохранит определяющий смещение член.

Так как у нас удовлетворительная модель тренда, можно добавить новые члены в существующую модель с помощью функции `update()` . -1 в формуле обновления удаляет определяющий смещение член. Теперь продолжим в RStudio:

    milk.lm2 <- update(milk.lm, . ~ . + Month - 1)
    summary(milk.lm2)

Это дает следующий результат:

    ##
    ## Call:
    ## lm(formula = Milk.Prod ~ Time + I(Month.Count^3) + Month - 1,
    ##     data = cadairytrain)
    ##
    ## Residuals:
    ##      Min       1Q   Median       3Q      Max
    ## -0.06879 -0.01693  0.00346  0.01543  0.08726
    ##
    ## Coefficients:
    ##                   Estimate Std. Error t value Pr(>|t|)
    ## Time              1.57e-09   2.72e-11    57.7   <2e-16 ***
    ## I(Month.Count^3) -3.74e-08   1.57e-09   -23.8   <2e-16 ***
    ## MonthApr          6.40e+00   2.63e-02   243.3   <2e-16 ***
    ## MonthAug          6.38e+00   2.63e-02   242.2   <2e-16 ***
    ## MonthDec          6.38e+00   2.64e-02   241.9   <2e-16 ***
    ## MonthFeb          6.31e+00   2.63e-02   240.1   <2e-16 ***
    ## MonthJan          6.39e+00   2.63e-02   243.1   <2e-16 ***
    ## MonthJul          6.39e+00   2.63e-02   242.6   <2e-16 ***
    ## MonthJun          6.38e+00   2.63e-02   242.4   <2e-16 ***
    ## MonthMar          6.42e+00   2.63e-02   244.2   <2e-16 ***
    ## MonthMay          6.43e+00   2.63e-02   244.3   <2e-16 ***
    ## MonthNov          6.34e+00   2.63e-02   240.6   <2e-16 ***
    ## MonthOct          6.37e+00   2.63e-02   241.8   <2e-16 ***
    ## MonthSep          6.34e+00   2.63e-02   240.6   <2e-16 ***
    ## ---
    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ##
    ## Residual standard error: 0.0263 on 202 degrees of freedom
    ## Multiple R-squared:     1,    Adjusted R-squared:     1
    ## F-statistic: 1.42e+06 on 14 and 202 DF,  p-value: <2e-16

Мы видим, что в модели отсутствует определяющий смещение член, но есть 12 значимых факторов месяца. Именно к этому мы и стремились.

Построим еще одну диаграмму временного ряда данных по молочному производству Калифорнии, чтобы проверить работу модели. Я добавил следующий код в модуль [Выполнить сценарий R][execute-r-script] Машинного обучения Azure, чтобы создать модель и построить диаграмму.

    milk.lm2 <- lm(Milk.Prod ~ Time + I(Month.Count^3) + Month - 1, data = cadairytrain)

    plot(cadairytrain$Time, cadairytrain$Milk.Prod, xlab = "Time", ylab = "Log CA Milk Production 1000s lb", type = "l")
    lines(cadairytrain$Time, predict(milk.lm2, cadairytrain), lty = 2, col = 2)

Диаграмма, полученная в результате выполнения этого кода в Машинном обучении Azure, приведена на рис. 24.

![Данные молочного производства Калифорнии с моделью, включающей сезонные составляющие](./media/r-quickstart/unnamed-chunk-20.png)

*Рис. 24. Данные молочного производства Калифорнии с моделью, включающей сезонные составляющие*

Соответствие данных на рисунке 24 довольно обнадеживающее. И тренд, и сезонная составляющая (в помесячном варианте) выглядят вполне разумно.

В качестве еще одной проверки нашей модели рассмотрим остатки. Приведенный ниже код вычисляет прогнозируемые значения наших двух моделей, вычисляет остатки для сезонной модели и отображает эти остатки для данных для обучения.

    ## Compute predictions from our models
    predict1  <- predict(milk.lm, cadairydata)
    predict2  <- predict(milk.lm2, cadairydata)

    ## Compute and plot the residuals
    residuals <- cadairydata$Milk.Prod - predict2
    plot(cadairytrain$Time, residuals[1:216], xlab = "Time", ylab ="Residuals of Seasonal Model")

Диаграмма остатков приведена на рисунке 25.

![Остатки сезонной модели для данных для обучения](./media/r-quickstart/unnamed-chunk-21.png)

*Рис. 25. Остатки сезонной модели для данных для обучения*

Выглядит вполне логично. Определенная структура отсутствует, за исключением влияния экономического спада 2008–2009 годов, который не слишком хорошо отражен в нашей модели.

Диаграмма на рис. 25 помогает определить любые связанные со временем закономерности в остатках. Благодаря использованию эксплицитного подхода к вычислению и визуальному представлению остатков они располагаются на диаграмме во временной последовательности. Если бы для построения диаграммы использовалось `milk.lm$residuals`, диаграмма не отражала бы зависимость от времени.

Для построения ряда диагностических диаграмм можно также использовать функцию `plot.lm()`.

    ## Show the diagnostic plots for the model
    plot(milk.lm2, ask = FALSE)

Пример ряда диагностических диаграмм, созданных с помощью этого кода, приведен на рис. 26.

![Первая диагностическая диаграмма для сезонной модели](./media/r-quickstart/unnamed-chunk-221.png)

![Вторая диагностическая диаграмма для сезонной модели](./media/r-quickstart/unnamed-chunk-222.png)

![Третья диагностическая диаграмма для сезонной модели](./media/r-quickstart/unnamed-chunk-223.png)

![Четвертая диагностическая диаграмма для сезонной модели](./media/r-quickstart/unnamed-chunk-224.png)

*Рис. 26. Диагностические диаграммы для сезонной модели*

На этих диаграммах можно увидеть несколько точек влияния, но они не дают поводов для серьезного беспокойства. Более того, на графике Q-Q видно, что распределение остатков близко к нормальному, что важно для линейных моделей.

### <a name="forecasting-and-model-evaluation"></a>Прогнозирование и оценка моделей
Остался последний шаг до завершения работы. Необходимо рассчитать прогнозы и измерить их отклонения от фактических данных. Составим прогноз на 12 месяцев 2013 года. Можно рассчитать величину отклонений для этого прогноза по отношению к фактическим данным, не входящим в наш набор данных для обучения. Кроме того, можно сравнить эффективность, используя учебные данные за 18 лет и тестовые данные за 12 месяцев.  

Для измерения эффективности моделей временных рядов используется несколько показателей. В нашем случае мы используем среднеквадратическое отклонение. Следующая функция вычисляет среднеквадратическое отклонение между двумя рядами.  

    RMS.error <- function(series1, series2, is.log = TRUE, min.length = 2){
      ## Function to compute the RMS error or difference between two
      ## series or vectors

      messages <- c("ERROR: Input arguments to function RMS.error of wrong type encountered",
                    "ERROR: Input vector to function RMS.error is too short",
                    "ERROR: Input vectors to function RMS.error must be of same length",
                    "WARNING: Funtion rms.error has received invald input time series.")

      ## Check the arguments
      if(!is.numeric(series1) | !is.numeric(series2) | !is.logical(is.log) | !is.numeric(min.length)) {
        warning(messages[1])
        return(NA)}

      if(length(series1) < min.length) {
        warning(messages[2])
        return(NA)}

      if((length(series1) != length(series2))) {
           warning(messages[3])
        return(NA)}

      ## If is.log is TRUE exponentiate the values, else just copy
      if(is.log) {
        tryCatch( {
          temp1 <- exp(series1)
          temp2 <- exp(series2) },
          error = function(e){warning(messages[4]); NA}
        )
      } else {
        temp1 <- series1
        temp2 <- series2
      }

     ## Compute predictions from our models
    predict1  <- predict(milk.lm, cadairydata)
    predict2  <- predict(milk.lm2, cadairydata)

    ## Compute the RMS error in a dataframe
      tryCatch( {
        sqrt(sum((temp1 - temp2)^2) / length(temp1))},
        error = function(e){warning(messages[4]); NA})
    }

Как и в случае с функцией `log.transform()` , которую мы рассматривали в разделе «Преобразование значений», значительная часть кода данной функции занимается проверкой и обработкой исключений. Задействованы те же принципы. Работа выполняется двумя фрагментами кода внутри функций `tryCatch()`. В первом фрагменте временные ряды возводятся в степень, поскольку до этого мы работали с логарифмами значений. Во втором фрагменте вычисляется фактическое среднеквадратическое отклонение.  

Вооружившись функцией для измерения среднеквадратического отклонения, построим и выведем таблицу данных с отклонениями. Введем только члены для модели тренда и полную модель с сезонными факторами. Приведенный ниже код выполнит эту задачу с помощью двух линейных моделей, созданных ранее.

    ## Compute the RMS error in a dataframe
    ## Include the row names in the first column so they will
    ## appear in the output of the Execute R Script
    RMS.df  <-  data.frame(
    rowNames = c("Trend Model", "Seasonal Model"),
      Traing = c(
      RMS.error(predict1[1:216], cadairydata$Milk.Prod[1:216]),
      RMS.error(predict2[1:216], cadairydata$Milk.Prod[1:216])),
      Forecast = c(
        RMS.error(predict1[217:228], cadairydata$Milk.Prod[217:228]),
        RMS.error(predict2[217:228], cadairydata$Milk.Prod[217:228]))
    )
    RMS.df

    ## The following line should be executed only when running in
    ## Azure Machine Learning Studio
    maml.mapOutputPort('RMS.df')

Результат выполнения этого кода, выведенный через порт "Итоговый набор данных", приведен на рисунке 27

![Сравнение среднеквадратического отклонения для моделей][26]

*Рис. 27. Сравнение среднеквадратического отклонения для моделей*

Как видно по этим результатам, после добавления к модели сезонных факторов среднеквадратическое отклонение значительно уменьшилось. Вполне ожидаемо, что отклонение для учебных данных чуть меньше, чем для прогноза.

## <a id="appendixa"></a>ПРИЛОЖЕНИЕ А. Руководство по RStudio
Среда разработки RStudio хорошо описана, поэтому в данном приложении приведены некоторые ссылки на ключевые разделы документации по RStudio, которые помогут вам приступить к работе

1. Создание проектов
   
   С помощью RStudio можно организовывать свой код на R в проекты и управлять ими. Документацию по использованию проектов можно найти по адресу https://support.rstudio.com/hc/articles/200526207-Using-Projects.
   
   Рекомендую следовать этим инструкциям и создать проект для примеров кода на R, приведенных в данном документе.  
2. Изменение и выполнение кода на R
   
   RStudio предоставляет интегрированную среду для изменения и выполнения кода на R. Документацию можно найти по адресу https://support.rstudio.com/hc/articles/200484448-Editing-and-Executing-Code.
3. Отладка
   
   RStudio располагает эффективными возможностями отладки. Документацию по этим функциям можно найти по адресу https://support.rstudio.com/hc/articles/200713843-Debugging-with-RStudio.
   
   Функции устранения ошибок точек останова описаны в документе по адресу https://support.rstudio.com/hc/articles/200534337-Breakpoint-Troubleshooting.

## <a id="appendixb"></a>ПРИЛОЖЕНИЕ Б. Дополнительные материалы
В этом руководстве по программированию на языке R описываются основные компоненты, которые нужны для использования языка R со Студией машинного обучения Azure. Если вы еще не знакомы с языком R, на ресурсе CRAN можно найти два вводных курса:

* "R для начинающих" Эммануэля Паради (Emmanuel Paradis) — замечательный учебник для начала работы, который доступен по адресу http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf;  
* "Введение в язык R" В. Н. Венаблес (W. N. Venables) и др. — немного более углубленный курс, доступный по адресу http://cran.r-project.org/doc/manuals/R-intro.html.

По языку R написано много книг, которые могут помочь в его освоении. Вот некоторые из них, которые показались мне наиболее полезными:

* Книга Нормана Мэтлофа (Norman Matloff) The Art of R Programming: A Tour of Statistical Software Design — хороший пример введения в программирование на R.  
* Книга Пола Титора (Paul Teetor) R Cookbook содержит проблемы и их решение на R.  
* «R в действии» Роберта Кабакова (Robert Kabacoff) — еще одна полезная книга. Веб-сайт Quick R — полезный ресурс по адресу http://www.statmethods.net/.
* В книге R Inferno (Адский язык R) Патрика Бернса (Patrick Burns), написанной в неожиданно юмористическом ключе, рассматриваются сложные проблемы, с которыми можно столкнуться при программировании на R. Книгу можно скачать бесплатно по адресу http://www.burns-stat.com/documents/books/the-r-inferno/.
* Если вы хотите углубиться в сложные темы языка R, почитайте новую книгу Хэдли Викхема (Hadley Wickham) Advanced R. Электронную версию этой книги можно найти по адресу http://adv-r.had.co.nz/.

В разделе Task View (Представление задач) ресурса CRAN можно найти каталог пакетов временных рядов на R для анализа временных рядов: http://cran.r-project.org/web/views/TimeSeries.html. Информацию по определенным пакетам объектов временных рядов см. в документации к этим пакетам.

Книга Introductory Time Series with R Пола Каупертвейта (Paul Cowpertwait) и Эндрю Меткалфа (Andrew Metcalfe) представляет собой введение в использование языка R для анализа временных рядов. Множество других теоретических работ содержат примеры на языке R.

Некоторые полезные ресурсы в Интернете:

* DataCamp — на сайте DataCamp обучение R происходит в вашем браузере с помощью видеозанятий и упражнений по кодированию. Здесь представлены интерактивные учебники по последним методам кодирования на R и пакетам R. Пройдите бесплатный интерактивный курс по языку R на странице https://www.datacamp.com/courses/introduction-to-r.
* Руководство по началу работы с R из Programiz: https://www.programiz.com/r-programming
* Краткое руководство по R от Келли Блэк (Kelly Black) из университета Кларксон по адресу http://www.cyclismo.org/tutorial/R/.
* Ссылки на более чем 60 ресурсов по R: http://www.computerworld.com/article/2497464/business-intelligence-60-r-resources-to-improve-your-data-skills.html.

<!--Image references-->
[1]: ./media/r-quickstart/fig1.png
[2]: ./media/r-quickstart/fig2.png
[3]: ./media/r-quickstart/fig3.png
[4]: ./media/r-quickstart/fig4.png
[5]: ./media/r-quickstart/fig5.png
[6]: ./media/r-quickstart/fig6.png
[7]: ./media/r-quickstart/fig7.png
[8]: ./media/r-quickstart/fig8.png
[9]: ./media/r-quickstart/fig9.png
[10]: ./media/r-quickstart/fig10.png
[11]: ./media/r-quickstart/fig11.png
[12]: ./media/r-quickstart/fig12.png
[13]: ./media/r-quickstart/fig13.png
[14]: ./media/r-quickstart/fig14.png
[15]: ./media/r-quickstart/fig15.png
[16]: ./media/r-quickstart/fig16.png
[17]: ./media/r-quickstart/fig17.png
[18]: ./media/r-quickstart/fig18.png
[19]: ./media/r-quickstart/fig19.png
[20]: ./media/r-quickstart/fig20.png
[21]: ./media/r-quickstart/fig21.png
[22]: ./media/r-quickstart/fig22.png

[26]: ./media/r-quickstart/fig26.png

<!--links-->
[appendixa]: #appendixa
[download]: https://azurebigdatatutorials.blob.core.windows.net/rquickstart/RFiles.zip


<!-- Module References -->
[execute-r-script]: https://msdn.microsoft.com/library/azure/30806023-392b-42e0-94d6-6b775a6e0fd5/
