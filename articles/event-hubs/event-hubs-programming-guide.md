---
title: "Руководство по программированию для концентраторов событий Azure | Документация Майкрософт"
description: "Написание кода для концентраторов событий Azure с помощью пакета SDK Azure .NET."
services: event-hubs
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 64cbfd3d-4a0e-4455-a90a-7f3d4f080323
ms.service: event-hubs
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: tbd
ms.date: 08/17/2017
ms.author: sethm
ms.openlocfilehash: 405ec2b27b488b570c4a5c86e4950ff98233360e
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2017
---
# <a name="event-hubs-programming-guide"></a><span data-ttu-id="d65b9-103">Руководство по программированию концентраторов событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-103">Event Hubs programming guide</span></span>

<span data-ttu-id="d65b9-104">В этой статье обсуждаются некоторые распространенные сценарии написания кода с помощью концентраторов событий Azure и пакетов SDK для Azure .NET.</span><span class="sxs-lookup"><span data-stu-id="d65b9-104">This article discusses some common scenarios in writing code using Azure Event Hubs and the Azure .NET SDK.</span></span> <span data-ttu-id="d65b9-105">Предполагается, что вы уже имеете представление о концентраторах событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-105">It assumes a preliminary understanding of Event Hubs.</span></span> <span data-ttu-id="d65b9-106">Общие сведения о концентраторах событий см. в статье [Общие сведения о концентраторах событий Azure](event-hubs-what-is-event-hubs.md).</span><span class="sxs-lookup"><span data-stu-id="d65b9-106">For a conceptual overview of Event Hubs, see the [Event Hubs overview](event-hubs-what-is-event-hubs.md).</span></span>

## <a name="event-publishers"></a><span data-ttu-id="d65b9-107">Издатели событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-107">Event publishers</span></span>

<span data-ttu-id="d65b9-108">Отправка событий в концентратор событий осуществляется с использованием HTTP POST или через подключение AMQP 1.0.</span><span class="sxs-lookup"><span data-stu-id="d65b9-108">You send events to an event hub either using HTTP POST or via an AMQP 1.0 connection.</span></span> <span data-ttu-id="d65b9-109">Выбор способа и времени зависит от определенного сценария, к которому выполняется обращение.</span><span class="sxs-lookup"><span data-stu-id="d65b9-109">The choice of which to use and when depends on the specific scenario being addressed.</span></span> <span data-ttu-id="d65b9-110">Подключения AMQP 1.0 измеряются как подключения через посредника по служебной шине. Они больше всего подходят для сценариев с большими объемами сообщений и менее строгими требованиями к задержке, так как такие подключения обеспечивают постоянный канал обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="d65b9-110">AMQP 1.0 connections are metered as brokered connections in Service Bus and are more appropriate in scenarios with frequent higher message volumes and lower latency requirements, as they provide a persistent messaging channel.</span></span>

<span data-ttu-id="d65b9-111">Концентраторы событий создаются и обрабатываются с помощью класса [NamespaceManager][] .</span><span class="sxs-lookup"><span data-stu-id="d65b9-111">You create and manage Event Hubs using the [NamespaceManager][] class.</span></span> <span data-ttu-id="d65b9-112">При использовании управляемых API .NET основными конструктивными элементами для публикации данных в концентраторах событий являются классы [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) и [EventData][].</span><span class="sxs-lookup"><span data-stu-id="d65b9-112">When using the .NET managed APIs, the primary constructs for publishing data to Event Hubs are the [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) and [EventData][] classes.</span></span> <span data-ttu-id="d65b9-113">[EventHubClient][] обеспечивает канал связи AMQP, по которому события отправляются в концентратор событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-113">[EventHubClient][] provides the AMQP communication channel over which events are sent to the event hub.</span></span> <span data-ttu-id="d65b9-114">Класс [EventData][] представляет собой событие и используется для публикации сообщений в концентраторе событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-114">The [EventData][] class represents an event, and is used to publish messages to an event hub.</span></span> <span data-ttu-id="d65b9-115">Этот класс содержит текст, некоторые метаданные и данные заголовка о событии.</span><span class="sxs-lookup"><span data-stu-id="d65b9-115">This class includes the body, some metadata, and header information about the event.</span></span> <span data-ttu-id="d65b9-116">По мере перемещения объекта [EventData][] через концентратор событий к объекту добавляются другие свойства.</span><span class="sxs-lookup"><span data-stu-id="d65b9-116">Other properties are added to the [EventData][] object as it passes through an event hub.</span></span>

## <a name="get-started"></a><span data-ttu-id="d65b9-117">Начало работы</span><span class="sxs-lookup"><span data-stu-id="d65b9-117">Get started</span></span>

<span data-ttu-id="d65b9-118">Классы .NET, которые поддерживают концентраторы событий, входят в сборку Microsoft.ServiceBus.dll.</span><span class="sxs-lookup"><span data-stu-id="d65b9-118">The .NET classes that support Event Hubs are provided in the Microsoft.ServiceBus.dll assembly.</span></span> <span data-ttu-id="d65b9-119">Самый простой способ получить API служебной шины и настроить свое приложение с учетом всех зависимостей служебной шины — это скачать [пакет NuGet для служебной шины](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span><span class="sxs-lookup"><span data-stu-id="d65b9-119">The easiest way to reference the Service Bus API and to configure your application with all of the Service Bus dependencies is to download the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span></span> <span data-ttu-id="d65b9-120">Кроме того, можно воспользоваться [консолью диспетчера пакетов](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="d65b9-120">Alternatively, you can use the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) in Visual Studio.</span></span> <span data-ttu-id="d65b9-121">Для этого выполните следующую команду в окне [консоли диспетчера пакетов](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) :</span><span class="sxs-lookup"><span data-stu-id="d65b9-121">To do so, issue the following command in the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) window:</span></span>

```
Install-Package WindowsAzure.ServiceBus
```

## <a name="create-an-event-hub"></a><span data-ttu-id="d65b9-122">Создание концентратора событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-122">Create an event hub</span></span>
<span data-ttu-id="d65b9-123">Для создания концентраторов событий можно использовать класс [NamespaceManager][] .</span><span class="sxs-lookup"><span data-stu-id="d65b9-123">You can use the [NamespaceManager][] class to create Event Hubs.</span></span> <span data-ttu-id="d65b9-124">Например:</span><span class="sxs-lookup"><span data-stu-id="d65b9-124">For example:</span></span>

```csharp
var manager = new Microsoft.ServiceBus.NamespaceManager("mynamespace.servicebus.windows.net");
var description = manager.CreateEventHub("MyEventHub");
```

<span data-ttu-id="d65b9-125">В большинстве случаев рекомендуется использовать методы [CreateEventHubIfNotExists][] , чтобы избежать возникновения исключений в случае перезапуска службы.</span><span class="sxs-lookup"><span data-stu-id="d65b9-125">In most cases, it is recommended that you use the [CreateEventHubIfNotExists][] methods to avoid generating exceptions if the service restarts.</span></span> <span data-ttu-id="d65b9-126">Например:</span><span class="sxs-lookup"><span data-stu-id="d65b9-126">For example:</span></span>

```csharp
var description = manager.CreateEventHubIfNotExists("MyEventHub");
```

<span data-ttu-id="d65b9-127">Для выполнения всех операций по созданию концентратора событий, включая [CreateEventHubIfNotExists][], требуется разрешение на **управление** необходимым пространством имен.</span><span class="sxs-lookup"><span data-stu-id="d65b9-127">All Event Hubs creation operations, including [CreateEventHubIfNotExists][], require **Manage** permissions on the namespace in question.</span></span> <span data-ttu-id="d65b9-128">Если вы хотите ограничить разрешения приложения издателя или потребителя, эти вызовы операций создания можно исключить из рабочего кода при использовании учетных данных с ограниченными разрешениями.</span><span class="sxs-lookup"><span data-stu-id="d65b9-128">If you want to limit the permissions of your publisher or consumer applications, you can avoid these create operation calls in production code when you use credentials with limited permissions.</span></span>

<span data-ttu-id="d65b9-129">Класс [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) содержит сведения о концентраторе событий, включая правила авторизации, интервал хранения сообщений, идентификаторы секций, состояние и путь.</span><span class="sxs-lookup"><span data-stu-id="d65b9-129">The [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) class contains details about an event hub, including the authorization rules, the message retention interval, partition IDs, status, and path.</span></span> <span data-ttu-id="d65b9-130">Этот класс можно использовать для обновления метаданных в концентраторе событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-130">You can use this class to update the metadata on an event hub.</span></span>

## <a name="create-an-event-hubs-client"></a><span data-ttu-id="d65b9-131">Создание клиента концентратора событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-131">Create an Event Hubs client</span></span>
<span data-ttu-id="d65b9-132">Основным классом для взаимодействия с концентраторами событий является класс [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient].</span><span class="sxs-lookup"><span data-stu-id="d65b9-132">The primary class for interacting with Event Hubs is [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient].</span></span> <span data-ttu-id="d65b9-133">Этот класс предоставляет возможности отправителя и получателя.</span><span class="sxs-lookup"><span data-stu-id="d65b9-133">This class provides both sender and receiver capabilities.</span></span> <span data-ttu-id="d65b9-134">Можно создать экземпляр этого класса с помощью метода [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) , как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="d65b9-134">You can instantiate this class using the [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) method, as shown in the following example.</span></span>

```csharp
var client = EventHubClient.Create(description.Path);
```

<span data-ttu-id="d65b9-135">Этот метод использует сведения о подключении к служебной шине в файле App.config в разделе `appSettings`.</span><span class="sxs-lookup"><span data-stu-id="d65b9-135">This method uses the Service Bus connection information in the App.config file, in the `appSettings` section.</span></span> <span data-ttu-id="d65b9-136">Пример раздела XML `appSettings`, в котором хранятся данные подключения к служебной шине, см. в документации по методу [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_).</span><span class="sxs-lookup"><span data-stu-id="d65b9-136">For an example of the `appSettings` XML used to store the Service Bus connection information, see the documentation for the [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method.</span></span>

<span data-ttu-id="d65b9-137">Кроме того, можно создать клиент из строки подключения.</span><span class="sxs-lookup"><span data-stu-id="d65b9-137">Another option is to create the client from a connection string.</span></span> <span data-ttu-id="d65b9-138">Это удобно в случаях, когда используются рабочие роли Azure, поскольку строку можно хранить в свойствах конфигурации для исполнителя.</span><span class="sxs-lookup"><span data-stu-id="d65b9-138">This option works well when using Azure worker roles, because you can store the string in the configuration properties for the worker.</span></span> <span data-ttu-id="d65b9-139">Например:</span><span class="sxs-lookup"><span data-stu-id="d65b9-139">For example:</span></span>

```csharp
EventHubClient.CreateFromConnectionString("your_connection_string");
```

<span data-ttu-id="d65b9-140">Строка подключения будет иметь тот же формат, в котором она представлена в файле App.config для предыдущих методов:</span><span class="sxs-lookup"><span data-stu-id="d65b9-140">The connection string will be in the same format as it appears in the App.config file for the previous methods:</span></span>

```
Endpoint=sb://[namespace].servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=[key]
```

<span data-ttu-id="d65b9-141">Наконец, можно также создать объект [EventHubClient][] из экземпляра [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory), как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="d65b9-141">Finally, it is also possible to create an [EventHubClient][] object from a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance, as shown in the following example.</span></span>

```csharp
var factory = MessagingFactory.CreateFromConnectionString("your_connection_string");
var client = factory.CreateEventHubClient("MyEventHub");
```

<span data-ttu-id="d65b9-142">Важно отметить, что дополнительные объекты [EventHubClient][] , созданные из экземпляра фабрики обмена сообщениями, будут повторно использовать одно и то же базовое подключение TCP.</span><span class="sxs-lookup"><span data-stu-id="d65b9-142">It is important to note that additional [EventHubClient][] objects created from a messaging factory instance will reuse the same underlying TCP connection.</span></span> <span data-ttu-id="d65b9-143">Таким образом эти объекты имеют ограничение на пропускную способность на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="d65b9-143">Therefore, these objects have a client-side limit on throughput.</span></span> <span data-ttu-id="d65b9-144">Метод [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) использует одну фабрику обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="d65b9-144">The [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method reuses a single messaging factory.</span></span> <span data-ttu-id="d65b9-145">Если требуется достаточно высокая пропускная способность от одного отправителя, то можно создать несколько фабрик обмена сообщениями и один объект [EventHubClient][] из каждой фабрики обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="d65b9-145">If you need very high throughput from a single sender, then you can create multiple message factories and one [EventHubClient][] object from each messaging factory.</span></span>

## <a name="send-events-to-an-event-hub"></a><span data-ttu-id="d65b9-146">Отправка событий в концентратор событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-146">Send events to an event hub</span></span>
<span data-ttu-id="d65b9-147">Для отправки событий в концентратор событий создается экземпляр [EventData][], который отправляется посредством метода [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_).</span><span class="sxs-lookup"><span data-stu-id="d65b9-147">You send events to an event hub by creating an [EventData][] instance and sending it via the [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) method.</span></span> <span data-ttu-id="d65b9-148">Этот метод принимает один параметр экземпляра [EventData][] и синхронно отправляет его в концентратор событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-148">This method takes a single [EventData][] instance parameter and synchronously sends it to an event hub.</span></span>

## <a name="event-serialization"></a><span data-ttu-id="d65b9-149">Сериализация событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-149">Event serialization</span></span>
<span data-ttu-id="d65b9-150">Класс [EventData][] имеет [четыре перегруженных конструктора](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_), которые принимают различные параметры, такие как объект и сериализатор, массив байтов или поток.</span><span class="sxs-lookup"><span data-stu-id="d65b9-150">The [EventData][] class has [four overloaded constructors](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_) that take a variety of parameters, such as an object and serializer, a byte array, or a stream.</span></span> <span data-ttu-id="d65b9-151">Кроме того, можно создать экземпляр класса [EventData][] и затем задать поток текста.</span><span class="sxs-lookup"><span data-stu-id="d65b9-151">It is also possible to instantiate the [EventData][] class and set the body stream afterwards.</span></span> <span data-ttu-id="d65b9-152">При использовании JSON совместно с [EventData][]можно применить метод **Encoding.UTF8.GetBytes()** для получения массива байтов для строки в кодировке JSON.</span><span class="sxs-lookup"><span data-stu-id="d65b9-152">When using JSON with [EventData][], you can use **Encoding.UTF8.GetBytes()** to retrieve the byte array for a JSON-encoded string.</span></span>

## <a name="partition-key"></a><span data-ttu-id="d65b9-153">Ключ секции</span><span class="sxs-lookup"><span data-stu-id="d65b9-153">Partition key</span></span>
<span data-ttu-id="d65b9-154">Класс [EventData][] имеет свойство [PartitionKey][], которое позволяет отправителю указывать значение, хэшируемое для создания назначения секции.</span><span class="sxs-lookup"><span data-stu-id="d65b9-154">The [EventData][] class has a [PartitionKey][] property that enables the sender to specify a value that is hashed to produce a partition assignment.</span></span> <span data-ttu-id="d65b9-155">Использование ключа секции гарантирует, что все события с одинаковым ключом отправляются в одну и ту же секцию концентратора событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-155">Using a partition key ensures that all the events with the same key are sent to the same partition in the event hub.</span></span> <span data-ttu-id="d65b9-156">Общие ключи секции включают идентификаторы сеансов пользователей и уникальные идентификаторы отправителей.</span><span class="sxs-lookup"><span data-stu-id="d65b9-156">Common partition keys include user session IDs and unique sender IDs.</span></span> <span data-ttu-id="d65b9-157">Свойство [PartitionKey][] использовать необязательно. Оно может быть указано при использовании метода [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) или [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_).</span><span class="sxs-lookup"><span data-stu-id="d65b9-157">The [PartitionKey][] property is optional and can be provided when using the [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) or [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) methods.</span></span> <span data-ttu-id="d65b9-158">Если не указать значение для свойства [PartitionKey][], отправленные события будут распространены в секции по принципу циклического перебора.</span><span class="sxs-lookup"><span data-stu-id="d65b9-158">If you do not provide a value for [PartitionKey][], sent events are distributed to partitions using a round-robin model.</span></span>

### <a name="availability-considerations"></a><span data-ttu-id="d65b9-159">Вопросы доступности</span><span class="sxs-lookup"><span data-stu-id="d65b9-159">Availability considerations</span></span>

<span data-ttu-id="d65b9-160">Ключ раздела использовать необязательно, поэтому следует внимательно обдумать, стоит ли его использовать.</span><span class="sxs-lookup"><span data-stu-id="d65b9-160">Using a partition key is optional, and you should consider carefully whether or not to use one.</span></span> <span data-ttu-id="d65b9-161">Однако если порядок событий важен, в большинстве случаев следует применять ключ раздела.</span><span class="sxs-lookup"><span data-stu-id="d65b9-161">In many cases, using a partition key is a good choice if event ordering is important.</span></span> <span data-ttu-id="d65b9-162">При использовании ключа раздела, этот раздел требует доступности на одном узле, при этом время от времени могут возникать сбои, например, при перезагрузке узлов и установке исправлений на них.</span><span class="sxs-lookup"><span data-stu-id="d65b9-162">When you use a partition key, these partitions require availability on a single node, and outages can occur over time; for example, when compute nodes reboot and patch.</span></span> <span data-ttu-id="d65b9-163">Таким образом, если задан идентификатор раздела и раздел по какой-либо причине становится недоступным, попытка получить доступ к данным в этом разделе завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="d65b9-163">As such, if you set a partition ID and that partition becomes unavailable for some reason, an attempt to access the data in that partition will fail.</span></span> <span data-ttu-id="d65b9-164">Если высокая доступность очень важна, не стоит указывать ключ раздела. В этом случае события будут отправляться в разделы с использованием описанной выше модели циклического перебора.</span><span class="sxs-lookup"><span data-stu-id="d65b9-164">If high availability is most important, do not specify a partition key; in that case events will be sent to partitions using the round-robin model described previously.</span></span> <span data-ttu-id="d65b9-165">В этом сценарии вы делаете явный выбор между доступностью (без использования идентификатора раздела) и согласованностью (закрепление событий в идентификаторе раздела).</span><span class="sxs-lookup"><span data-stu-id="d65b9-165">In this scenario, you are making an explicit choice between availability (no partition ID) and consistency (pinning events to a partition ID).</span></span>

<span data-ttu-id="d65b9-166">Вам также следует решить, как справиться с задержками в обработке событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-166">Another consideration is handling delays in processing events.</span></span> <span data-ttu-id="d65b9-167">В некоторых случаях рекомендуется удалить и повторно обработать данные, чем продолжить обработку. Это может привести к еще большим задержкам в последующей обработке.</span><span class="sxs-lookup"><span data-stu-id="d65b9-167">In some cases it might be better to drop data and retry than to try and keep up with processing, which can potentially cause further downstream processing delays.</span></span> <span data-ttu-id="d65b9-168">Например, с тикером котировок лучше подождать, пока появятся актуальные данные, но в чате реального времени или в сценарии VOIP лучше быстрее получить данные, даже если они не полные.</span><span class="sxs-lookup"><span data-stu-id="d65b9-168">For example, with a stock ticker it's better to wait for complete up-to-date data, but in a live chat or VOIP scenario you'd rather have the data quickly, even if it isn't complete.</span></span>

<span data-ttu-id="d65b9-169">Учитывая рекомендации по доступности, в этих сценариях можно использовать одну из следующих стратегий устранения ошибок:</span><span class="sxs-lookup"><span data-stu-id="d65b9-169">Given these availability considerations, in these scenarios you might choose one of the following error handling strategies:</span></span>

- <span data-ttu-id="d65b9-170">прекращение (прекратите чтение из концентраторов событий, пока не будут исправлены все ошибки);</span><span class="sxs-lookup"><span data-stu-id="d65b9-170">Stop (stop reading from Event Hubs until things are fixed)</span></span>
- <span data-ttu-id="d65b9-171">удаление (удалите ненужные сообщения);</span><span class="sxs-lookup"><span data-stu-id="d65b9-171">Drop (messages aren’t important, drop them)</span></span>
- <span data-ttu-id="d65b9-172">повторная попытка (обработайте сообщение повторно по своему усмотрению);</span><span class="sxs-lookup"><span data-stu-id="d65b9-172">Retry (retry the messages as you see fit)</span></span>
- <span data-ttu-id="d65b9-173">[недоставленные сообщения](../service-bus-messaging/service-bus-dead-letter-queues.md) (используйте очередь или другой концентратор событий только для недоставленных сообщений, которые не удалось обработать).</span><span class="sxs-lookup"><span data-stu-id="d65b9-173">[Dead letter](../service-bus-messaging/service-bus-dead-letter-queues.md) (use a queue or another event hub to dead letter only the messages you couldn’t process)</span></span>

<span data-ttu-id="d65b9-174">Дополнительные сведения и обсуждение компромиссов между доступностью и согласованностью см. в разделе [Доступность и согласованность в концентраторах событий](event-hubs-availability-and-consistency.md).</span><span class="sxs-lookup"><span data-stu-id="d65b9-174">For more information and a discussion about the trade-offs between availability and consistency, see [Availability and consistency in Event Hubs](event-hubs-availability-and-consistency.md).</span></span> 

## <a name="batch-event-send-operations"></a><span data-ttu-id="d65b9-175">Пакетные операции отправки событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-175">Batch event send operations</span></span>
<span data-ttu-id="d65b9-176">Пакетная отправка событий позволяет значительно повысить пропускную способность.</span><span class="sxs-lookup"><span data-stu-id="d65b9-176">Sending events in batches can dramatically increase throughput.</span></span> <span data-ttu-id="d65b9-177">Метод [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) принимает параметр **IEnumerable** типа [EventData][] и отправляет весь пакет в концентратор событий посредством атомарной операции.</span><span class="sxs-lookup"><span data-stu-id="d65b9-177">The [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) method takes an **IEnumerable** parameter of type [EventData][] and sends the entire batch as an atomic operation to the event hub.</span></span>

```csharp
public void SendBatch(IEnumerable<EventData> eventDataList);
```

<span data-ttu-id="d65b9-178">Обратите внимание на то, что размер одного пакета не должен превышать 256 КБ для события.</span><span class="sxs-lookup"><span data-stu-id="d65b9-178">Note that a single batch must not exceed the 256 KB limit of an event.</span></span> <span data-ttu-id="d65b9-179">Кроме того, каждое сообщение в пакете использует один и тот же идентификатор издателя.</span><span class="sxs-lookup"><span data-stu-id="d65b9-179">Additionally, each message in the batch uses the same publisher identity.</span></span> <span data-ttu-id="d65b9-180">Отправитель должен убедиться, что размер пакета не превышает максимальный размер события.</span><span class="sxs-lookup"><span data-stu-id="d65b9-180">It is the responsibility of the sender to ensure that the batch does not exceed the maximum event size.</span></span> <span data-ttu-id="d65b9-181">Если же размер больше, генерируется ошибка **Send** клиента.</span><span class="sxs-lookup"><span data-stu-id="d65b9-181">If it does, a client **Send** error is generated.</span></span>

## <a name="send-asynchronously-and-send-at-scale"></a><span data-ttu-id="d65b9-182">Асинхронная отправка и отправка в нужном масштабе</span><span class="sxs-lookup"><span data-stu-id="d65b9-182">Send asynchronously and send at scale</span></span>
<span data-ttu-id="d65b9-183">События можно отправлять в концентратор событий асинхронно.</span><span class="sxs-lookup"><span data-stu-id="d65b9-183">You can also send events to an event hub asynchronously.</span></span> <span data-ttu-id="d65b9-184">Асинхронная отправка позволяет увеличить скорость, с которой клиент способен отправлять события.</span><span class="sxs-lookup"><span data-stu-id="d65b9-184">Sending asynchronously can increase the rate at which a client is able to send events.</span></span> <span data-ttu-id="d65b9-185">В асинхронной версии доступны оба метода, [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) и [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__), которые возвращают объект [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx).</span><span class="sxs-lookup"><span data-stu-id="d65b9-185">Both the [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) and [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) methods are available in asynchronous versions that return a [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) object.</span></span> <span data-ttu-id="d65b9-186">Несмотря на то что этот способ позволяет увеличить пропускную способность, он также может привести к возникновению ситуации, когда клиент продолжает отправлять события, даже когда отправка регулируется службой концентраторов событий. В случае неправильной реализации это может привести к возникновению ошибок на стороне клиента или к потере сообщений.</span><span class="sxs-lookup"><span data-stu-id="d65b9-186">While this technique can increase throughput, it can also cause the client to continue to send events even while it is being throttled by the Event Hubs service and can result in the client experiencing failures or lost messages if not properly implemented.</span></span> <span data-ttu-id="d65b9-187">Кроме того, на стороне клиента можно использовать свойство [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) для управления параметрами повторного выполнения попыток клиентом.</span><span class="sxs-lookup"><span data-stu-id="d65b9-187">In addition, you can use the [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) property on the client to control client retry options.</span></span>

## <a name="create-a-partition-sender"></a><span data-ttu-id="d65b9-188">Создание отправителя секции</span><span class="sxs-lookup"><span data-stu-id="d65b9-188">Create a partition sender</span></span>
<span data-ttu-id="d65b9-189">Несмотря на то, что наиболее распространена отправка событий в концентратор событий без ключа секции, в некоторых случаях может потребоваться отправить события напрямую в указанную секцию.</span><span class="sxs-lookup"><span data-stu-id="d65b9-189">Although it is most common to send events to an event hub without a partition key, in some cases you might want to send events directly to a given partition.</span></span> <span data-ttu-id="d65b9-190">Например:</span><span class="sxs-lookup"><span data-stu-id="d65b9-190">For example:</span></span>

```csharp
var partitionedSender = client.CreatePartitionedSender(description.PartitionIds[0]);
```

<span data-ttu-id="d65b9-191">Метод [CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) возвращает объект [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender), который можно использовать для публикации событий в определенную секцию концентратора событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) returns an [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) object that you can use to publish events to a specific event hub partition.</span></span>

## <a name="event-consumers"></a><span data-ttu-id="d65b9-192">Получатели событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-192">Event consumers</span></span>
<span data-ttu-id="d65b9-193">Концентраторы событий имеют две основных модели потребления событий: прямые получатели и абстракции более высокого уровня, такие как [EventProcessorHost][].</span><span class="sxs-lookup"><span data-stu-id="d65b9-193">Event Hubs has two primary models for event consumption: direct receivers and higher-level abstractions, such as [EventProcessorHost][].</span></span> <span data-ttu-id="d65b9-194">Прямые получатели сами отвечают за собственную координацию доступа к секциям в группе потребителей.</span><span class="sxs-lookup"><span data-stu-id="d65b9-194">Direct receivers are responsible for their own coordination of access to partitions within a consumer group.</span></span>

### <a name="direct-consumer"></a><span data-ttu-id="d65b9-195">Прямой потребитель</span><span class="sxs-lookup"><span data-stu-id="d65b9-195">Direct consumer</span></span>
<span data-ttu-id="d65b9-196">Самый простой способ чтения из секции в группе потребителей — воспользоваться классом [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) .</span><span class="sxs-lookup"><span data-stu-id="d65b9-196">The most direct way to read from a partition within a consumer group is to use the [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) class.</span></span> <span data-ttu-id="d65b9-197">Чтобы создать экземпляр этого класса, необходимо использовать экземпляр класса [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) .</span><span class="sxs-lookup"><span data-stu-id="d65b9-197">To create an instance of this class, you must use an instance of the [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) class.</span></span> <span data-ttu-id="d65b9-198">В следующем примере необходимо указать идентификатор секции при создании получателя для группы получателей.</span><span class="sxs-lookup"><span data-stu-id="d65b9-198">In the following example, the partition ID must be specified when creating the receiver for the consumer group.</span></span>

```csharp
EventHubConsumerGroup group = client.GetDefaultConsumerGroup();
var receiver = group.CreateReceiver(client.GetRuntimeInformation().PartitionIds[0]);
```

<span data-ttu-id="d65b9-199">Метод [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) имеет несколько перегрузок, которые облегчают контроль над созданием модуля чтения.</span><span class="sxs-lookup"><span data-stu-id="d65b9-199">The [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) method has several overloads that facilitate control over the reader being created.</span></span> <span data-ttu-id="d65b9-200">Эти методы включают указание смещения в качестве строки или метки времени, а также возможность указать, следует ли включать это указанное смещение в возвращаемый поток или запустить после него.</span><span class="sxs-lookup"><span data-stu-id="d65b9-200">These methods include specifying an offset as either a string or timestamp, and the ability to specify whether to include this specified offset in the returned stream, or start after it.</span></span> <span data-ttu-id="d65b9-201">После создания получателя можно начать прием событий в возвращаемом объекте.</span><span class="sxs-lookup"><span data-stu-id="d65b9-201">After you create the receiver, you can start receiving events on the returned object.</span></span> <span data-ttu-id="d65b9-202">Метод [Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) имеет четыре перегрузки, которые управляют параметрами операции приема, такими как размер пакета и время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d65b9-202">The [Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) method has four overloads that control the receive operation parameters, such as batch size and wait time.</span></span> <span data-ttu-id="d65b9-203">Для увеличения пропускной способности потребителя можно использовать асинхронные версии этих методов.</span><span class="sxs-lookup"><span data-stu-id="d65b9-203">You can use the asynchronous versions of these methods to increase the throughput of a consumer.</span></span> <span data-ttu-id="d65b9-204">Например:</span><span class="sxs-lookup"><span data-stu-id="d65b9-204">For example:</span></span>

```csharp
bool receive = true;
string myOffset;
while(receive)
{
    var message = receiver.Receive();
    myOffset = message.Offset;
    string body = Encoding.UTF8.GetString(message.GetBytes());
    Console.WriteLine(String.Format("Received message offset: {0} \nbody: {1}", myOffset, body));
}
```

<span data-ttu-id="d65b9-205">В отношении к определенной секции сообщения получаются в том порядке, в котором они были отправлены в концентратор событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-205">With respect to a specific partition, the messages are received in the order in which they were sent to the event hub.</span></span> <span data-ttu-id="d65b9-206">Смещение представляет собой маркер строки, используемый для идентификации сообщения в секции.</span><span class="sxs-lookup"><span data-stu-id="d65b9-206">The offset is a string token used to identify a message in a partition.</span></span>

<span data-ttu-id="d65b9-207">Обратите внимание на то, что одновременно к одной секции в группе потребителей можно подключить не более 5 параллельных модулей чтения.</span><span class="sxs-lookup"><span data-stu-id="d65b9-207">Note that a single partition within a consumer group cannot have more than 5 concurrent readers connected at any time.</span></span> <span data-ttu-id="d65b9-208">При подключении или отключении модулей чтения их сеансы могут оставаться активным на несколько минут, прежде чем служба определит, что они были отключены.</span><span class="sxs-lookup"><span data-stu-id="d65b9-208">As readers connect or become disconnected, their sessions might stay active for several minutes before the service recognizes that they have disconnected.</span></span> <span data-ttu-id="d65b9-209">В течение этого времени повторное подключение к секции может завершиться сбоем.</span><span class="sxs-lookup"><span data-stu-id="d65b9-209">During this time, reconnecting to a partition may fail.</span></span> <span data-ttu-id="d65b9-210">Завершенный пример написания прямого получателя для концентраторов событий см. в статье [Event Hubs Direct Receivers](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) (Прямые получатели концентраторов событий).</span><span class="sxs-lookup"><span data-stu-id="d65b9-210">For a complete example of writing a direct receiver for Event Hubs, see the [Event Hubs Direct Receivers](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) sample.</span></span>

### <a name="event-processor-host"></a><span data-ttu-id="d65b9-211">Узел обработчика событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-211">Event processor host</span></span>
<span data-ttu-id="d65b9-212">Класс [EventProcessorHost][] обрабатывает данные из концентраторов событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-212">The [EventProcessorHost][] class processes data from Event Hubs.</span></span> <span data-ttu-id="d65b9-213">Эту реализацию следует использовать при создании модулей чтения событий на платформе .NET.</span><span class="sxs-lookup"><span data-stu-id="d65b9-213">You should use this implementation when building event readers on the .NET platform.</span></span> <span data-ttu-id="d65b9-214">[EventProcessorHost][] предоставляет потокобезопасную многопроцессную среду безопасного выполнения для реализаций обработчиков событий. Эта среда также предоставляет средства управления контрольными точками и аренды секций.</span><span class="sxs-lookup"><span data-stu-id="d65b9-214">[EventProcessorHost][] provides a thread-safe, multi-process, safe runtime environment for event processor implementations that also provides checkpointing and partition lease management.</span></span>

<span data-ttu-id="d65b9-215">Чтобы воспользоваться классом [EventProcessorHost][], можно реализовать интерфейс [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor).</span><span class="sxs-lookup"><span data-stu-id="d65b9-215">To use the [EventProcessorHost][] class, you can implement [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor).</span></span> <span data-ttu-id="d65b9-216">Этот интерфейс содержит три метода:</span><span class="sxs-lookup"><span data-stu-id="d65b9-216">This interface contains three methods:</span></span>

* [<span data-ttu-id="d65b9-217">OpenAsync</span><span class="sxs-lookup"><span data-stu-id="d65b9-217">OpenAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_OpenAsync_Microsoft_ServiceBus_Messaging_PartitionContext_)
* [<span data-ttu-id="d65b9-218">CloseAsync</span><span class="sxs-lookup"><span data-stu-id="d65b9-218">CloseAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_CloseAsync_Microsoft_ServiceBus_Messaging_PartitionContext_Microsoft_ServiceBus_Messaging_CloseReason_)
* [<span data-ttu-id="d65b9-219">ProcessEventsAsync</span><span class="sxs-lookup"><span data-stu-id="d65b9-219">ProcessEventsAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_ProcessEventsAsync_Microsoft_ServiceBus_Messaging_PartitionContext_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__)

<span data-ttu-id="d65b9-220">Чтобы начать обработку событий, следует создать [EventProcessorHost][], указав соответствующие параметры для концентратора событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-220">To start event processing, instantiate [EventProcessorHost][], providing the appropriate parameters for your event hub.</span></span> <span data-ttu-id="d65b9-221">Затем вызовите метод [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) для регистрации вашей реализации интерфейса [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="d65b9-221">Then, call [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) to register your [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) implementation with the runtime.</span></span> <span data-ttu-id="d65b9-222">На этом этапе узел попытается получить аренду для каждой секции в концентраторе событий, используя "жадный" алгоритм.</span><span class="sxs-lookup"><span data-stu-id="d65b9-222">At this point, the host will attempt to acquire a lease on every partition in the event hub using a "greedy" algorithm.</span></span> <span data-ttu-id="d65b9-223">Эти аренды будут продолжаться в течение заданного промежутка времени, после чего их необходимо продлить.</span><span class="sxs-lookup"><span data-stu-id="d65b9-223">These leases will last for a given timeframe and must then be renewed.</span></span> <span data-ttu-id="d65b9-224">По мере перехода новых узлов (в нашем случае это рабочие экземпляры) в оперативный режим они размещают резервирования аренды и со временем нагрузка смещается между узлами при каждой попытке получения дополнительной аренды.</span><span class="sxs-lookup"><span data-stu-id="d65b9-224">As new nodes, worker instances in this case, come online, they place lease reservations and over time the load shifts between nodes as each attempts to acquire more leases.</span></span>

![Узел обработчика событий](./media/event-hubs-programming-guide/IC759863.png)

<span data-ttu-id="d65b9-226">Со временем устанавливается равновесие.</span><span class="sxs-lookup"><span data-stu-id="d65b9-226">Over time, an equilibrium is established.</span></span> <span data-ttu-id="d65b9-227">Такая динамическая возможность позволяет применить к потребителям автоматическое масштабирование как вверх, так и вниз на основе использования ресурсов ЦП.</span><span class="sxs-lookup"><span data-stu-id="d65b9-227">This dynamic capability enables CPU-based autoscaling to be applied to consumers for both scale-up and scale-down.</span></span> <span data-ttu-id="d65b9-228">Поскольку концентраторы событий не имеют прямой концепции подсчета сообщений, среднее использование ресурсов ЦП зачастую является оптимальным механизмом для измерения масштабирования внутреннего сервера или потребителя.</span><span class="sxs-lookup"><span data-stu-id="d65b9-228">Because Event Hubs do not have a direct concept of message counts, average CPU utilization is often the best mechanism to measure back end or consumer scale.</span></span> <span data-ttu-id="d65b9-229">Если издатели начинают публиковать больше событий, чем могут обработать потребители, увеличение использования ресурсов ЦП потребителями можно использовать для автоматического масштабирования на основе числа экземпляров исполнителей.</span><span class="sxs-lookup"><span data-stu-id="d65b9-229">If publishers begin to publish more events than consumers can process, the CPU increase on consumers can be used to cause an auto-scale on worker instance count.</span></span>

<span data-ttu-id="d65b9-230">Класс [EventProcessorHost][] также реализует механизм создания контрольных точек на основе службы хранилища Azure.</span><span class="sxs-lookup"><span data-stu-id="d65b9-230">The [EventProcessorHost][] class also implements an Azure storage-based checkpointing mechanism.</span></span> <span data-ttu-id="d65b9-231">Этот механизм хранит смещение для каждой секции, чтобы каждый потребитель мог определить последнюю контрольную точку от предыдущего потребителя.</span><span class="sxs-lookup"><span data-stu-id="d65b9-231">This mechanism stores the offset on a per partition basis, so that each consumer can determine what the last checkpoint from the previous consumer was.</span></span> <span data-ttu-id="d65b9-232">По мере перехода секций между узлами перенос нагрузки осуществляется за счет механизма синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d65b9-232">As partitions transition between nodes via leases, this is the synchronization mechanism that facilitates load shifting.</span></span>

## <a name="publisher-revocation"></a><span data-ttu-id="d65b9-233">Отзыв издателя</span><span class="sxs-lookup"><span data-stu-id="d65b9-233">Publisher revocation</span></span>
<span data-ttu-id="d65b9-234">Наряду с дополнительными возможностями среды выполнения [EventProcessorHost][], концентраторы событий позволяют отзывать определенные издатели и таким образом блокировать для них возможность отправлять события в концентратор событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-234">In addition to the advanced run-time features of [EventProcessorHost][], Event Hubs enables publisher revocation in order to block specific publishers from sending event to an event hub.</span></span> <span data-ttu-id="d65b9-235">Эти функции особенно полезны, если маркер издателя был взломан или после обновления программного обеспечения эти функции перестали работать должным образом.</span><span class="sxs-lookup"><span data-stu-id="d65b9-235">These features are particularly useful if a publisher token has been compromised, or a software update is causing them to behave inappropriately.</span></span> <span data-ttu-id="d65b9-236">В этих случаях для идентификатора издателя, который является частью маркера SAS, можно заблокировать возможность публикации событий.</span><span class="sxs-lookup"><span data-stu-id="d65b9-236">In these situations, the publisher's identity, which is part of their SAS token, can be blocked from publishing events.</span></span>

<span data-ttu-id="d65b9-237">Дополнительные сведения об отзыве издателя и отправке в концентраторы событий в качестве издателя см. в примере, приведенном в статье [Event Hubs Large Scale Secure Publishing](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) (Крупномасштабная безопасная публикация концентраторов событий).</span><span class="sxs-lookup"><span data-stu-id="d65b9-237">For more information about publisher revocation and how to send to Event Hubs as a publisher, see the [Event Hubs Large Scale Secure Publishing](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) sample.</span></span>

## <a name="next-steps"></a><span data-ttu-id="d65b9-238">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="d65b9-238">Next steps</span></span>
<span data-ttu-id="d65b9-239">Дополнительные сведения о сценариях концентраторов событий см. в разделах, ссылки на которые указаны ниже.</span><span class="sxs-lookup"><span data-stu-id="d65b9-239">To learn more about Event Hubs scenarios, visit these links:</span></span>

* [<span data-ttu-id="d65b9-240">Общие сведения об API концентраторов событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-240">Event Hubs API overview</span></span>](event-hubs-api-overview.md)
* [<span data-ttu-id="d65b9-241">Что такое концентраторы событий?</span><span class="sxs-lookup"><span data-stu-id="d65b9-241">What is Event Hubs</span></span>](event-hubs-what-is-event-hubs.md)
* [<span data-ttu-id="d65b9-242">Доступность и согласованность в концентраторах событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-242">Availability and consistency in Event Hubs</span></span>](event-hubs-availability-and-consistency.md)
* [<span data-ttu-id="d65b9-243">Справочник по API узла обработчика событий</span><span class="sxs-lookup"><span data-stu-id="d65b9-243">Event processor host API reference</span></span>](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost)

<span data-ttu-id="d65b9-244">[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager</span><span class="sxs-lookup"><span data-stu-id="d65b9-244">[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager</span></span>
<span data-ttu-id="d65b9-245">[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient</span><span class="sxs-lookup"><span data-stu-id="d65b9-245">[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient</span></span>
<span data-ttu-id="d65b9-246">[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata</span><span class="sxs-lookup"><span data-stu-id="d65b9-246">[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata</span></span>
<span data-ttu-id="d65b9-247">[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists</span><span class="sxs-lookup"><span data-stu-id="d65b9-247">[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists</span></span>
<span data-ttu-id="d65b9-248">[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey</span><span class="sxs-lookup"><span data-stu-id="d65b9-248">[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey</span></span>
<span data-ttu-id="d65b9-249">[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost</span><span class="sxs-lookup"><span data-stu-id="d65b9-249">[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost</span></span>
