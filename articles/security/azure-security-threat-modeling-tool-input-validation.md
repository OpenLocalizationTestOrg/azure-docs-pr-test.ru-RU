---
title: "aaaInput проверки - Microsoft средства моделирования угроз - Azure | Документы Microsoft"
description: "защиту от угроз, которые представлены в hello средства моделирования угроз"
services: security
documentationcenter: na
author: RodSan
manager: RodSan
editor: RodSan
ms.assetid: na
ms.service: security
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 08/17/2017
ms.author: rodsan
ms.openlocfilehash: 823503881f4bae292ef021834d5e64acf2a0f54a
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="security-frame-input-validation--mitigations"></a>Механизм безопасности: проверки входных данных | Снижение риска 
| Продукт или служба | Статья |
| --------------- | ------- |
| **Веб-приложение** | <ul><li>[Отключайте скрипты XSLT для всех операций преобразования, использующих ненадежные таблицы стилей](#disable-xslt)</li><li>[Убедитесь, что каждая страница, на которой может быть содержимое, управляемое пользователем, не использует автоматическое обнаружение типов MIME](#out-sniffing)</li><li>[Усильте защиту для разрешения сущностей XML или отключите его](#xml-resolution)</li><li>[Приложения, использующие драйвер http.sys, выполняют проверку нормализации URL-адресов](#app-verification)</li><li>[Убедитесь, что при приеме файлов от пользователей обеспечиваются соответствующие меры безопасности](#controls-users)</li><li>[Убедитесь, что в веб-приложении для доступа к данным используются параметры типобезопасности](#typesafe)</li><li>[Используйте классы привязки отдельной модели или привязки списков уязвимость массового присваивания tooprevent MVC](#binding-mvc)</li><li>[Кодирование предыдущих toorendering вывода ненадежных веб](#rendering)</li><li>[Проверяйте и фильтруйте входные данные по всем свойствам модели строкового типа](#typemodel)</li><li>[Очищайте поля форм, принимающие все знаки, например редактор форматированного текста](#richtext)</li><li>[Не назначайте toosinks элементы DOM, не имеет встроенных кодировки](#inbuilt-encode)</li><li>[Проверить все закрытые или делать безопасно перенаправления приложения hello](#redirect-safe)</li><li>[Внедрите проверку входных данных для всех параметров строкового типа, принимаемых методами контроллера](#string-method)</li><li>[Задать время ожидания верхний предел для регулярного выражения, обработка DoS tooprevent из-за toobad регулярные выражения](#dos-expression)</li><li>[Не используйте метод Html.Raw в представлениях Razor](#html-razor)</li></ul> | 
| **База данных** | <ul><li>[Не используйте динамические запросы в хранимых процедурах](#stored-proc)</li></ul> |
| **Веб-интерфейс API** | <ul><li>[Убедитесь, что в методах веб-API выполнена проверка моделей](#validation-api)</li><li>[Внедрите проверку входных данных для всех параметров строкового типа, принимаемых методами веб-API](#string-api)</li><li>[Убедитесь, что в веб-API для доступа к данным используются параметры типобезопасности](#typesafe-api)</li></ul> | 
| **Azure DocumentDB** | <ul><li>[Используйте параметризованные SQL-запросы для DocumentDB](#sql-docdb)</li></ul> | 
| **WCF** | <ul><li>[Проверка входных данных WCF путем привязки к схеме](#schema-binding)</li><li>[Проверка входных данных WCF с помощью инспекторов параметров](#parameters)</li></ul> |

## <a id="disable-xslt"></a>Отключайте скрипты XSLT для всех операций преобразования, использующих ненадежные таблицы стилей

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Безопасность XSLT](https://msdn.microsoft.com/library/ms763800(v=vs.85).aspx), [XsltSettings.EnableScript Property](http://msdn.microsoft.com/library/system.xml.xsl.xsltsettings.enablescript.aspx) (Свойство XsltSettings.EnableScript) |
| **Действия** | XSLT поддерживает сценарии внутри таблицы стилей с помощью hello `<msxml:script>` элемента. Это позволяет toobe пользовательских функций, используемых в XSLT-преобразования. Hello сценарий выполняется в контексте hello hello процесса выполнения преобразования hello. Скрипт XSLT, необходимо отключить в ненадежной среде выполнения tooprevent ненадежный код. *Если с помощью .NET:* скрипты XSLT отключены по умолчанию; однако необходимо убедиться, что он не включен явно через hello `XsltSettings.EnableScript` свойство.|

### <a name="example"></a>Пример 

```C#
XsltSettings settings = new XsltSettings();
settings.EnableScript = true; // WRONG: THIS SHOULD BE SET toofalse
```

### <a name="example"></a>Пример
При использовании с помощью MSXML 6.0, скрипты XSLT отключены по умолчанию. Тем не менее необходимо убедиться, что он не включен явно через свойство объекта XML DOM hello AllowXsltScript. 

```C#
doc.setProperty("AllowXsltScript", true); // WRONG: THIS SHOULD BE SET toofalse
```

### <a name="example"></a>Пример
Если вы используете MSXML версии 5 или более ранней, скрипты XSLT включены по умолчанию. Их необходимо явно отключать. Задайте hello XML DOM объекта свойство AllowXsltScript toofalse. 

```C#
doc.setProperty("AllowXsltScript", false); // CORRECT. Setting toofalse disables XSLT scripting.
```

## <a id="out-sniffing"></a>Убедитесь, что каждая страница, на которой может быть содержимое, управляемое пользователем, не использует автоматическое обнаружение типов MIME

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [IE8 Security Part V — Comprehensive Protection](http://blogs.msdn.com/ie/archive/2008/07/02/ie8-security-part-v-comprehensive-protection.aspx) (Безопасность IE8, часть 5: комплексная защита)  |
| **Действия** | <p>Для каждой страницы, который может содержать управляемое содержимое пользователя, необходимо использовать hello заголовок HTTP `X-Content-Type-Options:nosniff`. toocomply с этим требованием, вы можете либо набор hello необходимые верхний колонтитул страницы для лишь те страницы, которые могут содержать настраиваемым пользователем содержимое, или может быть задана глобально для всех страниц приложения hello.</p><p>Каждый тип файлов, доставленных на веб-сервере имеет связанный [тип MIME](http://en.wikipedia.org/wiki/Mime_type) (также называется *content-type*), описывающий hello характер содержимого hello (то есть изображение, текст, приложения, и т. д.)</p><p>Заголовок X-содержимое-тип Options Hello является заголовком HTTP, которая позволяет разработчикам toospecify, что их содержимое не будут вносятся MIME. Этот заголовок является спроектированный toomitigate сканирование MIME атак. В Internet Explorer 8 (IE8) добавлена поддержка этого заголовка.</p><p>Заголовком X-Content-Type-Options смогут воспользоваться только пользователи Internet Explorer 8 (IE8). Предыдущие версии Internet Explorer не влияют на момент заголовок X-содержимое-тип Options hello</p><p>Internet Explorer 8 (и более поздние версии) hello только основные обозреватели возможность отказаться tooimplement сканирование MIME. При других основных браузеров (Firefox и Safari, Chrome) реализовать аналогичные функции, эта рекомендация будет tooinclude обновленный синтаксис для этих обозревателей также</p>|

### <a name="example"></a>Пример
обязательный заголовок tooenable hello глобально для всех страниц приложения hello, необходимо выполнить одно из следующих hello: 

* Добавить заголовок hello в файле web.config hello, если приложение hello размещается в Internet Information Services (IIS) 7 

```
<system.webServer> 
  <httpProtocol> 
    <customHeaders> 
      <add name=""X-Content-Type-Options"" value=""nosniff""/>
    </customHeaders>
  </httpProtocol>
</system.webServer> 
```

* Добавить заголовок hello через hello глобальные приложения\_BeginRequest 

``` 
void Application_BeginRequest(object sender, EventArgs e)
{
  this.Response.Headers[""X-Content-Type-Options""] = ""nosniff"";
} 
```

* Внедрите пользовательский HTTP-модуль. 

``` 
public class XContentTypeOptionsModule : IHttpModule 
  {
    #region IHttpModule Members 
    public void Dispose() 
    { 

    } 
    public void Init(HttpApplication context)
    { 
      context.PreSendRequestHeaders += newEventHandler(context_PreSendRequestHeaders); 
    } 
    #endregion 
    void context_PreSendRequestHeaders(object sender, EventArgs e) 
      { 
        HttpApplication application = sender as HttpApplication; 
        if (application == null) 
          return; 
        if (application.Response.Headers[""X-Content-Type-Options ""] != null) 
          return; 
        application.Response.Headers.Add(""X-Content-Type-Options "", ""nosniff""); 
      } 
  } 

``` 

* Обязательный заголовок hello только для отдельных страниц можно включить, добавив его tooindividual ответов: 

```
this.Response.Headers[""X-Content-Type-Options""] = ""nosniff""; 
``` 

## <a id="xml-resolution"></a>Усильте защиту для разрешения сущностей XML или отключите его

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [XML Entity Expansion](http://capec.mitre.org/data/definitions/197.html) (Расширения сущностей XML), [XML Denial of Service Attacks and Defenses](http://msdn.microsoft.com/magazine/ee335713.aspx) (XML: атаки типа "отказ в обслуживании" и способы защиты от них), [Общие сведения о безопасности MSXML](http://msdn.microsoft.com/library/ms754611(v=VS.85).aspx), [Рекомендации по обеспечению безопасности кода MSXML](http://msdn.microsoft.com/library/ms759188(VS.85).aspx), [NSXMLParserDelegate Protocol Reference](http://developer.apple.com/library/ios/#documentation/cocoa/reference/NSXMLParserDelegate_Protocol/Reference/Reference.html) (Справочник по протоколу NSXMLParserDelegate), [Разрешение внешних ресурсов](https://msdn.microsoft.com/library/5fcwybb2.aspx) |
| **Действия**| <p>Несмотря на то, что он широко не применяется, имеется функция XML, который позволяет tooexpand средство синтаксического анализа XML hello макрос сущностей с помощью значений, определенных в сам документ hello или из внешних источников. Например, документ hello определить сущность «companyname» со значением hello «Microsoft», чтобы каждый раз hello текст «&companyname;» отображается в документе hello, он автоматически заменяется текстом hello корпорации Майкрософт. Или hello документ может иметь собственное определение сущности «MSFTStock», который ссылается на внешний веб службы toofetch hello текущее значение Microsoft stock.</p><p>Затем в любое время «&MSFTStock;» отображается в документе hello автоматически заменяется hello текущего акций. Тем не менее эта функция может быть неправильно toocreate отказ в обслуживании (DoS). Злоумышленники могут быть вложены несколько сущностей toocreate механизм XML экспоненциального расширения, который использует всю доступную память в системе hello. </p><p>Кроме того он может создать внешних ссылок, который обрабатывает назад неограниченного количества данных или, просто зависает hello потока. В результате все команды необходимо отключить внутренним и внешним разрешение сущностей XML полностью в том случае, если приложение не использует его или вручную ограничить объем памяти и времени, приложение hello, может использовать для разрешения сущностей, если эта функциональность hello Это действительно необходимо. Если приложению не требуется разрешение сущностей, отключите его. </p>|

### <a name="example"></a>Пример
Для кода .NET Framework можно использовать hello следующие подходы:

```C#
XmlTextReader reader = new XmlTextReader(stream);
reader.ProhibitDtd = true;

XmlReaderSettings settings = new XmlReaderSettings();
settings.ProhibitDtd = true;
XmlReader reader = XmlReader.Create(stream, settings);

// for .NET 4
XmlReaderSettings settings = new XmlReaderSettings();
settings.DtdProcessing = DtdProcessing.Prohibit;
XmlReader reader = XmlReader.Create(stream, settings);
```
Обратите внимание, это значение по умолчанию hello объекта `ProhibitDtd` в `XmlReaderSettings` имеет значение true, однако в `XmlTextReader` — false. При использовании XmlReaderSettings tooset ProhibitDtd tootrue не требуется явно, но рекомендуется ради безопасности это сделать. Также Обратите внимание, что класс XmlDocument hello позволяет разрешение сущностей по умолчанию. 

### <a name="example"></a>Пример
разрешение toodisable сущностей для объектов XmlDocument, используйте hello `XmlDocument.Load(XmlReader)` перегрузка hello загрузить метод и задать hello соответствующие свойства в разрешении toodisable аргумент XmlReader hello, как показано в следующим hello: 

```C#
XmlReaderSettings settings = new XmlReaderSettings();
settings.ProhibitDtd = true;
XmlReader reader = XmlReader.Create(stream, settings);
XmlDocument doc = new XmlDocument();
doc.Load(reader);
```

### <a name="example"></a>Пример
Если отключение разрешения сущностей не поддерживается для приложения, задайте hello XmlReaderSettings.MaxCharactersFromEntities tooa разумное значение свойства в соответствии с потребностями приложения tooyour. Это ограничивает влияние hello потенциальных экспоненциального расширения DoS-атак. Hello после кода приведен пример такого подхода. 

```C#
XmlReaderSettings settings = new XmlReaderSettings();
settings.ProhibitDtd = false;
settings.MaxCharactersFromEntities = 1000;
XmlReader reader = XmlReader.Create(stream, settings);
```

### <a name="example"></a>Пример
Если вам требуется tooresolve Встроенные сущности, но не обязательно tooresolve внешние сущности, задайте свойство toonull hello XmlReaderSettings.XmlResolver. Например: 

```C#
XmlReaderSettings settings = new XmlReaderSettings();
settings.ProhibitDtd = false;
settings.MaxCharactersFromEntities = 1000;
settings.XmlResolver = null;
XmlReader reader = XmlReader.Create(stream, settings);
```
Обратите внимание, что в MSXML6, ProhibitDTD tootrue (отключение обработки DTD) по умолчанию имеет значение. Для кода Apple OSX или iOS можно использовать два средства синтаксического анализа XML: NSXMLParser и libXML2. 

## <a id="app-verification"></a>Приложения, использующие драйвер http.sys, выполняют проверку нормализации URL-адресов

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Действия** | <p>При работе с любым приложением, использующим драйвер http.sys, следует придерживаться следующих правил:</p><ul><li>Ограничьте длину toono hello URL-адрес больше 16 384 символов (ASCII или Юникод). Это hello абсолютный Максимальная длина URL-адреса на основе параметра Internet Information Services (IIS) 6 по умолчанию hello. По возможности для веб-сайтов следует создавать более короткие URL-адреса.</li><li>Использование стандартных классов файлового ввода-вывода .NET Framework hello (такой как FileStream), как они будут использовать преимущества hello правилам стандартизации в hello .NET FX</li><li>Создайте список разрешенных известных имен файлов явным образом.</li><li>Явно отклоните известные типы файлов, для которых не будет выдаваться отклонение UrlScan: EXE, BAT, CMD, COM, HTW, IDA, IDQ, HTR, IDC, SHTM[L], STM, PRINTER, INI, POL, DAT.</li><li>CATCH hello следующие исключения:<ul><li>System.ArgumentException (для имен устройств);</li><li>System.NotSupportedException (для потоков данных);</li><li>System.IO.FileNotFoundException (для недопустимых экранированных имен файлов);</li><li>System.IO.DirectoryNotFoundException (для недопустимых экранированных каталогов).</li></ul></li><li>*Не* вызов файла tooWin32 API-интерфейсов ввода-вывода. На недопустимый URL-адрес верного возврата пользователя toohello ошибке 400 и журналов действительно ошибка hello.</li></ul>|

## <a id="controls-users"></a>Убедитесь, что при приеме файлов от пользователей обеспечиваются соответствующие меры безопасности

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Unrestricted File Upload](https://www.owasp.org/index.php/Unrestricted_File_Upload) (Неограниченная передача файлов), [File Signature Table](http://www.garykessler.net/library/file_sigs.html) (Таблица подписей файлов) |
| **Действия** | <p>Переданные файлы представляют tooapplications серьезную угрозу.</p><p>Первым шагом Hello в многие атаки является tooget атаке некоторые toobe системы toohello кода. Затем атаки hello достаточно toofind выполнения кода hello tooget способом. Использование передачу файла позволяет злоумышленнику hello выполнения первого шага hello. последствия Hello передачу неограниченный файла может быть различной, включая перехват всей системы, перегруженные файловой системы или базы данных, пересылка системы tooback атак, а также простой вандализм.</p><p>Это зависит от какое приложение hello делает hello загружен файлом и особенно хранятся там. На стороне сервера не предусмотрена проверка передаваемых файлов. Для отправки файлов нужно внедрять следующие меры безопасности:</p><ul><li>Проверка расширений файлов (должны приниматься только определенные допустимые типы файлов).</li><li>Ограничение максимального размера файлов.</li><li>Файл не должен быть загруженного toowebroot; Hello расположение должно представлять каталог на несистемном диске</li><li>Соглашение об именовании следует выполнить, так, что hello имя отправленного файла некоторые случайности, так как tooprevent перезаписывает файл</li><li>Файлы должны сканироваться для защиты от вирусов перед записью toohello диска</li><li>Обеспечить проверку hello имя файла и любые другие метаданные (например, путь к файлу) для вредоносные символы</li><li>Формат подписи файла должны быть проверены, tooprevent пользователь загрузить файл masqueraded (например, передача exe-файла, изменив расширение tootxt)</li></ul>| 

### <a name="example"></a>Пример
Hello последней точки относительно проверку подписи файлов формата см. класс toohello ниже дополнительные сведения: 

```C#
        private static Dictionary<string, List<byte[]>> fileSignature = new Dictionary<string, List<byte[]>>
                    {
                    { ".DOC", new List<byte[]> { new byte[] { 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1 } } },
                    { ".DOCX", new List<byte[]> { new byte[] { 0x50, 0x4B, 0x03, 0x04 } } },
                    { ".PDF", new List<byte[]> { new byte[] { 0x25, 0x50, 0x44, 0x46 } } },
                    { ".ZIP", new List<byte[]> 
                                            {
                                              new byte[] { 0x50, 0x4B, 0x03, 0x04 },
                                              new byte[] { 0x50, 0x4B, 0x4C, 0x49, 0x54, 0x55 },
                                              new byte[] { 0x50, 0x4B, 0x53, 0x70, 0x58 },
                                              new byte[] { 0x50, 0x4B, 0x05, 0x06 },
                                              new byte[] { 0x50, 0x4B, 0x07, 0x08 },
                                              new byte[] { 0x57, 0x69, 0x6E, 0x5A, 0x69, 0x70 }
                                                }
                                            },
                    { ".PNG", new List<byte[]> { new byte[] { 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A } } },
                    { ".JPG", new List<byte[]>
                                    {
                                              new byte[] { 0xFF, 0xD8, 0xFF, 0xE0 },
                                              new byte[] { 0xFF, 0xD8, 0xFF, 0xE1 },
                                              new byte[] { 0xFF, 0xD8, 0xFF, 0xE8 }
                                    }
                                    },
                    { ".JPEG", new List<byte[]>
                                        { 
                                            new byte[] { 0xFF, 0xD8, 0xFF, 0xE0 },
                                            new byte[] { 0xFF, 0xD8, 0xFF, 0xE2 },
                                            new byte[] { 0xFF, 0xD8, 0xFF, 0xE3 }
                                        }
                                        },
                    { ".XLS", new List<byte[]>
                                            {
                                              new byte[] { 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1 },
                                              new byte[] { 0x09, 0x08, 0x10, 0x00, 0x00, 0x06, 0x05, 0x00 },
                                              new byte[] { 0xFD, 0xFF, 0xFF, 0xFF }
                                            }
                                            },
                    { ".XLSX", new List<byte[]> { new byte[] { 0x50, 0x4B, 0x03, 0x04 } } },
                    { ".GIF", new List<byte[]> { new byte[] { 0x47, 0x49, 0x46, 0x38 } } }
                };

        public static bool IsValidFileExtension(string fileName, byte[] fileData, byte[] allowedChars)
        {
            if (string.IsNullOrEmpty(fileName) || fileData == null || fileData.Length == 0)
            {
                return false;
            }

            bool flag = false;
            string ext = Path.GetExtension(fileName);
            if (string.IsNullOrEmpty(ext))
            {
                return false;
            }

            ext = ext.ToUpperInvariant();

            if (ext.Equals(".TXT") || ext.Equals(".CSV") || ext.Equals(".PRN"))
            {
                foreach (byte b in fileData)
                {
                    if (b > 0x7F)
                    {
                        if (allowedChars != null)
                        {
                            if (!allowedChars.Contains(b))
                            {
                                return false;
                            }
                        }
                        else
                        {
                            return false;
                        }
                    }
                }

                return true;
            }

            if (!fileSignature.ContainsKey(ext))
            {
                return true;
            }

            List<byte[]> sig = fileSignature[ext];
            foreach (byte[] b in sig)
            {
                var curFileSig = new byte[b.Length];
                Array.Copy(fileData, curFileSig, b.Length);
                if (curFileSig.SequenceEqual(b))
                {
                    flag = true;
                    break;
                }
            }

            return flag;
        }
```

## <a id="typesafe"></a>Убедитесь, что в веб-приложении для доступа к данным используются параметры типобезопасности

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Действия** | <p>При использовании коллекции Parameters hello SQL будет обрабатываться hello ввода — как буквенное значение, а не как исполняемый код. Hello коллекцию Parameters можно tooenforce используется тип и длина ограничения для входных данных. Значение за пределами диапазона hello вызвано исключение. Если строго типизированным SQL параметры не используются, злоумышленники могут быть атак путем внедрения кода может tooexecute, внедренных в hello нефильтрованные входные данные.</p><p>Используйте безопасные параметры типа, при построении SQL запросов tooavoid возможности атаки SQL injection, связанных с нефильтрованные входные данные. Эти параметры можно использовать с хранимыми процедурами и динамическими инструкциями SQL. Параметры обрабатываются как литеральные значения, hello базы данных, а не исполняемый код. Кроме того, проверяется тип и длина параметров.</p>|

### <a name="example"></a>Пример 
Hello следующий код показывает, как toouse безопасные параметры типа с hello SqlParameterCollection при вызове хранимой процедуры. 

```C#
using System.Data;
using System.Data.SqlClient;

using (SqlConnection connection = new SqlConnection(connectionString))
{ 
DataSet userDataset = new DataSet(); 
SqlDataAdapter myCommand = new SqlDataAdapter(LoginStoredProcedure", connection); 
myCommand.SelectCommand.CommandType = CommandType.StoredProcedure; 
myCommand.SelectCommand.Parameters.Add("@au_id", SqlDbType.VarChar, 11); 
myCommand.SelectCommand.Parameters["@au_id"].Value = SSN.Text; 
myCommand.Fill(userDataset);
}  
```
Входное значение hello hello предшествующий пример кода, не может быть длиннее 11 символов. Если тип toohello или длина, определенная параметром hello hello данные не соответствуют, hello SqlParameter класс вызывает исключение. 

## <a id="binding-mvc"></a>Используйте классы привязки отдельной модели или привязки списков уязвимость массового присваивания tooprevent MVC

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | MVC 5, MVC 6 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Атрибуты метаданных](http://msdn.microsoft.com/library/system.componentmodel.dataannotations.metadatatypeattribute), [открытый ключ безопасности и уязвимостей](https://github.com/blog/1068-public-key-security-vulnerability-and-mitigation), [tooMass полное руководство по присваивания в ASP.NET MVC](http://odetocode.com/Blogs/scott/archive/2012/03/11/complete-guide-to-mass-assignment-in-asp-net-mvc.aspx), [Приступая к работе с EF в MVC](http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc/implementing-basic-crud-functionality-with-the-entity-framework-in-asp-net-mvc-application#overpost) |
| **Действия** | <ul><li>**Когда следует искать уязвимости типа overposting?** Уязвимости типа overposting могут появляться на любом этапе привязки классов модели из входных данных пользователя. Платформы, такие как MVC, могут представлять данные пользователя в пользовательских классах .NET, включая Plain Old CLR Object (POCO). MVC автоматически заполняет эти классы модели с данными из запроса hello, предоставляя удобный способ представления для работы с вводимыми пользователем данными. Если эти классы содержат свойства, которые не следует задавать пользователем hello, hello приложение может быть уязвимым учета tooover атаки, в том разрешить пользовательский элемент управления данных, приложение hello никогда не предназначен. Как и привязка модели MVC, технологий доступа базы данных, таких как модули объектно реляционного сопоставления, такие как Entity Framework часто также поддерживают POCO объекты toorepresent базы данных с помощью. Эти классы модели данных обеспечивают hello же удобных в работе с данными базы данных, как и в MVC в работе с вводимыми пользователем данными. Поскольку база данных MVC и hello поддерживает аналогичные модели, как объекты POCO кажется hello легко tooreuse же классы для обоих назначений. Этот подход сбое разделение toopreserve проблемы и его общие сферами, где непредвиденные свойства предоставляются toomodel привязки, включение чрезмерное учета атак.</li><li>**Почему не следует использовать мой нефильтрованные классы базы данных модели как действия MVC toomy параметров -** Привязка модели MVC, так как привязки ничего в этом классе. Даже если Здравствуйте, данные не отображаются в представлении, пользователь-злоумышленник может отправлять HTTP-запроса с данными включены и MVC с удовольствием привязывается его так, как действие говорит, что класс базы данных является hello формы данных, он должен принять для ввода данных пользователем.</li><li>**Почему следует обратить внимание hello фигура, используемая для привязки модели? -** Привязка модели с помощью ASP.NET MVC с моделями слишком широкие предоставляет атак учета tooover приложения. Чрезмерное учета может позволить злоумышленникам данные приложения toochange за пределы какие hello разработчик, например переопределение hello цену для элемента или hello привилегии безопасности для учетной записи. Приложения должны использовать tooprovide привязки модели (или определенное свойство разрешенные списки фильтров) каждого действия прямого контракта для какой ненадежных входных tooallow посредством привязки модели.</li><li>**Дублируется ли код при наличии отдельных моделей привязки?** Нет. Дело касается разделения областей ответственности. При повторном модели базы данных в методах действий вы говорите любое свойство (или подсвойств) в том, что класс может задавать пользователем hello в HTTP-запроса. Если это не самое интересное MVC toodo, требуется список фильтров или отдельный класс фигуры tooshow MVC, какие данные могут поступать из вместо вводимых пользователем данных.</li><li>**Имея моделей отдельные привязки для ввода данных пользователем, нужно ли tooduplicate все атрибуты заметок Мои данные? -** Не обязательно. Можно использовать MetadataTypeAttribute на hello базы данных модели toolink toohello метаданные класса для класса привязки модели. Точно так же, обратите внимание, что тип ссылается hello MetadataTypeAttribute hello должен представлять собой подмножество hello, ссылающимся на тип (он может иметь меньше свойств, но не более).</li><li>**Перемещать данные между моделями входных данных пользователя и моделями базы данных утомительно. Можно ли просто скопировать все свойства с использованием отражения?** Да. Hello только свойства, отображаемые в моделях привязки hello: hello тех, которые вы определили toobe безопасным для ввода данных пользователем Нет причин безопасности, не позволяющая с помощью отражения toocopy через все свойства, которые хранятся в общем, между этими двумя моделями.</li><li>**Можно ли использовать свойство [Bind(Exclude ="â€¦")] вместо того, чтобы создавать отдельные модели привязки?** Мы не рекомендуем использовать такой подход. Если использовать свойство [Bind(Exclude ="â€¦")], любое новое свойство можно будет привязать по умолчанию. Когда добавляется новое свойство, защищено дополнительный шаг tooremember tookeep вещей, а не наличие hello конструктора быть безопасность по умолчанию. В зависимости от hello developer проверки этот список, каждый раз при добавлении свойства является опасной.</li><li>**Можно ли использовать атрибут [Bind(Include ="â€¦")] в операциях изменения?** Нет. Атрибут [Bind(Include ="â€¦")] поддерживает только операции вставки (добавление новых данных). Для операций обновления стиля (пересмотра существующих данных) использовать другой подход, такие как наличие отдельные привязки модели или передача явный список допустимых свойств tooUpdateModel или TryUpdateModel. Добавление [привязки (Include = "... в")] атрибута на операцию редактирования означает, что MVC будет создать экземпляр объекта и только hello в списке свойств, оставив все остальные значения по умолчанию. При сохранении данных hello, она полностью заменить существующую сущность hello, сброс значений hello для любого значения по умолчанию свойства, опущенные tootheir. Например, если было IsAdmin [привязки (Include = "... в")] атрибут операции изменения, любой пользователь, имя которого был изменен с помощью этого действия может быть tooIsAdmin сброса = false (любой пользователь, измененного теряли статусом администратора). Если вы хотите tooprevent обновляет свойства toocertain, воспользуйтесь одним из hello других подходов выше. Обратите внимание, что некоторые версии средств MVC создают классы контроллера с атрибутом [Bind(Include ="â€¦")] в действиях изменения. При этом подразумевается, что удалив свойство из этого списка, вы сократите риск атак типа overposting. Тем не менее как описано выше, этот подход не работает должным образом и вместо сбрасывает все данные в значения по умолчанию hello опущен свойства tootheir.</li><li>**Есть ли какие-либо особенности при использовании атрибута [Bind(Include ="â€¦")] вместо отдельных моделей привязки в операциях создания?** Да. Во-первых, этот подход не действует в операциях изменения. Чтобы устранить все уязвимости типа overposting, следует применять два отдельных подхода. Вторую, отдельную привязки моделей применить разделение между hello фигуру, используемую для пользователя вход и hello фигуру, используемую для сохранения состояния, что-нибудь [привязки (Include = "â...")] не имеет. В-третьих, обратите внимание, что [привязки (Include = "â...")] может обрабатывать только свойства верхнего уровня; в атрибуте hello не может разрешить только части вложенных свойств (например, «Details.Name»). Наконец и, возможно, что самое главное, с помощью [привязки (Include = "â...")] добавляет дополнительный этап, должны будут запомнены любой класс hello времени используется для привязки модели. Если новый метод действия привязывается toohello класс данных напрямую и забыл tooinclude [привязки (Include = "... в")] атрибут, он может быть уязвим учета tooover атак, поэтому hello [привязки (Include = "... в")] подход немного менее безопасен по умолчанию. При использовании [привязки (Include = "â...")], будьте внимательны всегда tooremember toospecify его каждый раз данных классов отображаются как параметры метода действия.</li><li>**Для операций Create, что размещение hello [привязки (Include = "â...")] атрибута самого класса hello модели? Не такой подход не hello необходимость tooremember размещение hello атрибут для каждого метода действия? -** Такой подход работает в некоторых случаях. С помощью [привязки (Include = "â...")] в самом типе модели hello (а не на параметров действий с помощью этого класса), избежать hello необходимость tooremember tooinclude hello [привязки (Include = "â...")] атрибута для каждого метода действия. Эффективное использование атрибута hello непосредственно для класса hello создает отдельный контактной зоны этого класса в целях привязки модели. Однако такой подход позволяет использовать привязку модели одного типа на класс модели. Если один метод действия должен привязки модели tooallow поля (например, только администратору действие, обновляющее ролей пользователей) и другие действия необходима привязка модели tooprevent этого поля, такой подход не будет работать. Каждый класс может иметь только одну фигуру привязки модели; Если разные действия требуется другую модель привязки фигур, они должны toorepresent эти отдельные фигур с помощью классов привязки либо отдельную модель или разделения [привязки (Include = "â...")] атрибутов в методы действий hello.</li><li>**Что такое модели привязки? Что они hello же, что и Просмотр моделей? -** Это две связанные понятия. модель привязки ссылается класс модели tooa, используемый в действии термин Hello — список параметров (hello форму, переданных из метода действия toohello привязка модели MVC). модель представления термин Hello ссылается класс модели tooa, передаваемый из tooa представления метод действия. С помощью модели представления — это распространенный способ передачи данных из представления tooa метода действия. Часто эта фигура также подходит для привязки модели, модель представления hello термин может быть hello используется toorefer же модель используется в обоих местах. toobe точным, эта процедура рассмотрен в частности привязки модели, сосредоточившись на фигуре hello, переданный toohello действие, которое является то, что важно для целей массового присваивания.</li></ul>| 

## <a id="rendering"></a>Кодирование предыдущих toorendering вывода ненадежных веб

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальные, веб-формы, MVC 5, MVC 6 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Как tooprevent межсайтовых сценариев в ASP.NET](http://msdn.microsoft.com/library/ms998274.aspx), [скриптов](http://cwe.mitre.org/data/definitions/79.html), [Памятка Предотвращение XSS (межсайтовых сценариев)](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet) |
| **Действия** | Межсайтовых сценариев (обычно называемого XSS) является атаки для Интернет-служб или приложение или компонент, который принимает входные данные из веб-hello. XSS может уязвимости злоумышленник tooexecute сценария на компьютере другого пользователя через уязвимым веб-приложения. Вредоносных скриптов можно использовать toosteal файлы cookie и в противном случае незаконно жертвы машины с помощью JavaScript. Чтобы обеспечить защиту от использования межсайтовых сценариев, следует проверять входные данные пользователя, их формат, а также кодировать их перед обработкой на веб-странице. Для проверки входных данных и кодирования выходных данных можно использовать библиотеку веб-защиты. Для управляемого кода (C\#, VB.net, т. д.), используйте один или несколько соответствующих методов кодирования из библиотеки Web защиты (Anti-XSS), в зависимости от контекста hello, где возвращает объявленное ввод данных пользователем hello hello:| 

### <a name="example"></a>Пример

```C#
* Encoder.HtmlEncode 
* Encoder.HtmlAttributeEncode 
* Encoder.JavaScriptEncode 
* Encoder.UrlEncode
* Encoder.VisualBasicScriptEncode 
* Encoder.XmlEncode 
* Encoder.XmlAttributeEncode 
* Encoder.CssEncode 
* Encoder.LdapEncode 
```

## <a id="typemodel"></a>Проверяйте и фильтруйте входные данные по всем свойствам модели строкового типа

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальные, MVC 5, MVC 6 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Adding Validation](http://www.asp.net/mvc/overview/getting-started/introduction/adding-validation) (Добавление проверки), [Validating Model Data in an MVC Application](http://msdn.microsoft.com/library/dd410404(v=vs.90).aspx) (Проверка данных модели в приложении MVC), [Основные принципы ваших приложений ASP.NET MVC](http://msdn.microsoft.com/magazine/dd942822.aspx) |
| **Действия** | <p>Все входные параметры hello необходимо проверить перед их использованием в tooensure приложения hello, приложение hello защищен от входных данных пользователь-злоумышленник. Проверка входных значений hello, используя регулярное выражение проверки на стороне сервера с стратегии проверки белого списка. Unsanitized данные, вводимые пользователем параметров, передаваемых методам toohello может привести к кода атак путем внедрения кода.</p><p>Точки входа для веб-приложений также включают поля форм, строки запросов, файлы cookie, заголовки HTTP и параметры веб-службы.</p><p>Hello следующие входные проверки необходимо выполнить после привязки модели:</p><ul><li>Свойства модели Hello должен сопровождаться атрибутом заметки регулярное выражение для приема допустимые символы и максимально допустимую длину</li><li>методы контроллера Hello должен выполнить действия ModelState</li></ul>|

## <a id="richtext"></a>Очищайте поля форм, принимающие все знаки, например редактор форматированного текста

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Кодирование небезопасных входных данных](https://msdn.microsoft.com/library/ff647397.aspx#paght000003_step3), [HTML Sanitizer](https://github.com/mganss/HtmlSanitizer) (Библиотека HtmlSanitizer) |
| **Действия** | <p>Определите все теги разметки static, что требуется toouse. Распространенной практикой является форматирование элементов toosafe HTML, такие как toorestrict `<b>` (полужирный) и `<i>` (курсивом).</p><p>Перед записью данных hello, HTML-кодирование его. Это делает любой вредоносный скрипт, безопасном инициируя toobe обрабатывать как текст, не как исполняемый код.</p><ol><li>Отключить запроса ASP.NET, проверки, добавив hello hello ValidateRequest = «false» атрибута toohello @ директивы страницы</li><li>Кодирование входная строка hello с помощью метода HtmlEncode hello</li><li>Используйте StringBuilder и вызов его замены метод tooselectively удалить кодировку для hello HTML-элементов, которые должны toopermit hello</li></ol><p>Hello ссылки на страницы в hello отключает проверки запроса ASP.NET, задав `ValidateRequest="false"`. Он кодирует в формате HTML hello ввода и выборочно позволяет hello `<b>` и `<i>` в качестве альтернативы библиотеки .NET для очистки HTML можно также использовать.</p><p>HtmlSanitizer — это библиотека .NET для очистки фрагменты HTML и документов из конструкций, которые могут привести к атакам tooXSS. Она использует AngleSharp tooparse, управления и визуализации HTML и CSS. HtmlSanitizer можно установить в виде пакета NuGet и ввод данных пользователем hello могут передаваться через соответствующие HTML и CSS очистки методы, где это применимо, на стороне сервера hello. Обратите внимание, что очистка — это крайняя мера безопасности.</p><p>Самые эффективные меры безопасности — это проверка входных данных и кодирование выходных данных.</p> |

## <a id="inbuilt-encode"></a>Не назначайте toosinks элементы DOM, не имеет встроенных кодировки

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Действия** | Многие функции JavaScript не выполняют кодирование по умолчанию. При назначении элементы ненадежных входных tooDOM через такие функции, может привести к между выполнениями скрипта (XSS) сайта.| 

### <a name="example"></a>Пример
Ниже приведены примеры ненадежных входных данных. 

```
document.getElementByID("div1").innerHtml = value;
$("#userName").html(res.Name);
return $('<div/>').html(value)
$('body').append(resHTML);   
```
Не используйте элемент `innerHtml`. Вместо него используйте `innerText`. Аналогичным образом вместо `$("#elm").html()` используйте `$("#elm").text()`. 

## <a id="redirect-safe"></a>Проверить все закрытые или делать безопасно перенаправления приложения hello

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Hello OAuth 2.0 Authorization Framework - откройте перенаправителями](http://tools.ietf.org/html/rfc6749#section-10.15) |
| **Действия** | <p>Разработка приложений, требующие перенаправления tooa пользовательское расположение необходимо ограничить hello перенаправления возможных целевых объектов tooa встроенный «безопасной» список сайты или домены. Все переадресации в приложение hello должен быть закрыт или безопасным.</p><p>toodo это:</p><ul><li>Определяйте все операции перенаправления.</li><li>Реализуйте подходящий метод защиты для каждого перенаправления. Сюда входит список разрешений для перенаправления или подтверждение пользователя. Если веб-узел или служба с уязвимостью в виде открытого перенаправления использует поставщиков удостоверений Facebook, OAuth или OpenID, злоумышленник может похитить маркер входа пользователя и выполнять действия от его имени. Это специфические риск при использовании OAuth, который описан в RFC 6749 «hello OAuth 2.0 Authorization Framework», аналогично статьи 10.15» откройте перенаправляет», учетные данные пользователей могут быть скомпрометированы, направленных фишинг-атаках с использованием открытых перенаправления</li></ul>|

## <a id="string-method"></a>Внедрите проверку входных данных для всех параметров строкового типа, принимаемых методами контроллера

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальные, MVC 5, MVC 6 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Validating Model Data in an MVC Application](http://msdn.microsoft.com/library/dd410404(v=vs.90).aspx) (Проверка данных модели в приложении MVC), [Основные принципы ваших приложений ASP.NET MVC](http://msdn.microsoft.com/magazine/dd942822.aspx) |
| **Действия** | Для методов, принимающих примитивные типы данных, а не модели в качестве аргументов, следует выполнять проверки входных данных с использованием регулярных выражений. Здесь следует использовать Regex.IsMatch с шаблоном допустимого регулярного выражения. Hello входные данные соответствуют hello указанному регулярному выражению, элемент управления не следует продолжить и отображать достаточно предупреждение об ошибке проверки подлинности.| 

## <a id="dos-expression"></a>Задать время ожидания верхний предел для регулярного выражения, обработка DoS tooprevent из-за toobad регулярные выражения

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальные, веб-формы, MVC 5, MVC 6  |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Свойство DefaultRegexMatchTimeout](https://msdn.microsoft.com/library/system.web.configuration.httpruntimesection.defaultregexmatchtimeout.aspx) |
| **Действия** | отказ в обслуживании законных пользователей tooensure неправильно создана регулярных выражений, которые связано со значительным поиск с возвратом, задать время ожидания hello глобальное значение по умолчанию. Если время обработки hello занимает больше времени, чем hello определенные верхний предел, он будет вызывать исключение времени ожидания. Если ничего не настроен, время ожидания hello будет бесконечным.| 

### <a name="example"></a>Пример
Например hello следующая конфигурация создаст исключение RegexMatchTimeoutException, если hello обработки занимает более 5 секунд: 

```C#
<httpRuntime targetFramework="4.5" defaultRegexMatchTimeout="00:00:05" />
```

## <a id="html-razor"></a>Не используйте метод Html.Raw в представлениях Razor

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | MVC 5, MVC 6 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Шаг | Веб-страницы ASP.NET (Razor) выполняют автоматическое кодирование HTML. Все строки, которые выводятся внедренными ограничителями кода (блоки @), автоматически преобразовываются в формат HTML. Однако при вызове метод `HtmlHelper.Raw` возвращает разметку без кодировки HTML. Если `Html.Raw()` вспомогательный метод используется, он пропускает hello автоматического кодирования защиты, который предоставляет Razor.|

### <a name="example"></a>Пример
Ниже приведены примеры ненадежных входных данных. 

```C#
<div class="form-group">
            @Html.Raw(Model.AccountConfirmText)
        </div>
        <div class="form-group">
            @Html.Raw(Model.PaymentConfirmText)
        </div>
</div>
```
Не используйте `Html.Raw()` при отсутствии необходимости toodisplay разметки. Этот метод помогает избежать неявного кодирования выходных данных. Используйте другие вспомогательные методы ASP.NET, например `@Html.DisplayFor()`. 

## <a id="stored-proc"></a>Не используйте динамические запросы в хранимых процедурах

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Действия** | <p>Атаки SQL injection может использовать уязвимости в произвольные команды toorun проверки входных данных в базе данных hello. Она возможна, когда приложение использует входной tooconstruct динамического tooaccess инструкций SQL hello базы данных. Кроме того, такая атака может выполняться, если код использует хранимые процедуры, передающие строки с необработанными входными данными пользователя. С помощью hello атак путем внедрения кода SQL, злоумышленник hello можно выполнять произвольные команды в базе данных hello. Все инструкции SQL (включая hello инструкций SQL в хранимых процедурах) должны быть параметризованы. Параметризованные инструкции SQL будет принимать символы, которые имеют специальное значение tooSQL (например, одинарная кавычка) без проблем, так как они являются строго типизированными. |

### <a name="example"></a>Пример
Ниже приведен пример небезопасной динамической хранимой процедуры. 

```C#
CREATE PROCEDURE [dbo].[uspGetProductsByCriteria]
(
  @productName nvarchar(200) = NULL,
  @startPrice float = NULL,
  @endPrice float = NULL
)
AS
 BEGIN
  DECLARE @sql nvarchar(max)
  SELECT @sql = ' SELECT ProductID, ProductName, Description, UnitPrice, ImagePath' +
       ' FROM dbo.Products WHERE 1 = 1 '
       PRINT @sql
  IF @productName IS NOT NULL
     SELECT @sql = @sql + ' AND ProductName LIKE ''%' + @productName + '%'''
  IF @startPrice IS NOT NULL
     SELECT @sql = @sql + ' AND UnitPrice > ''' + CONVERT(VARCHAR(10),@startPrice) + ''''
  IF @endPrice IS NOT NULL
     SELECT @sql = @sql + ' AND UnitPrice < ''' + CONVERT(VARCHAR(10),@endPrice) + ''''

  PRINT @sql
  EXEC(@sql)
 END
```

### <a name="example"></a>Пример
Ниже приведен hello безопасно реализации одной хранимой процедуре. 
```C#
CREATE PROCEDURE [dbo].[uspGetProductsByCriteriaSecure]
(
             @productName nvarchar(200) = NULL,
             @startPrice float = NULL,
             @endPrice float = NULL
)
AS
       BEGIN
             SELECT ProductID, ProductName, Description, UnitPrice, ImagePath
             FROM dbo.Products where
             (@productName IS NULL or ProductName like '%'+ @productName +'%')
             AND
             (@startPrice IS NULL or UnitPrice > @startPrice)
             AND
             (@endPrice IS NULL or UnitPrice < @endPrice)         
       END
```

## <a id="validation-api"></a>Убедитесь, что в методах веб-API выполнена проверка моделей

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-интерфейс API | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | MVC 5, MVC 6 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Model Validation in ASP.NET Web API ](http://www.asp.net/web-api/overview/formats-and-model-binding/model-validation-in-aspnet-web-api) (Проверка модели в веб-API ASP.NET) |
| **Действия** | Когда клиент отправляет данные tooa в веб-API, это обязательные toovalidate hello данных перед выполнением какой-либо обработки. Для ASP.NET веб-API, который принимает в качестве входных данных модели используйте заметок к данным на правила проверки модели tooset hello свойств модели hello.|

### <a name="example"></a>Пример
Привет, следующий код демонстрирует hello же: 

```C#
using System.ComponentModel.DataAnnotations;

namespace MyApi.Models
{
    public class Product
    {
        public int Id { get; set; }
        [Required]
        [RegularExpression(@"^[a-zA-Z0-9]*$", ErrorMessage="Only alphanumeric characters are allowed.")]
        public string Name { get; set; }
        public decimal Price { get; set; }
        [Range(0, 999)]
        public double Weight { get; set; }
    }
}
```

### <a name="example"></a>Пример
В метод действия hello hello API контроллеров допустимость модели hello имеет toobe проверены явно, как показано ниже: 

```C#
namespace MyApi.Controllers
{
    public class ProductsController : ApiController
    {
        public HttpResponseMessage Post(Product product)
        {
            if (ModelState.IsValid)
            {
                // Do something with hello product (not shown).

                return new HttpResponseMessage(HttpStatusCode.OK);
            }
            else
            {
                return Request.CreateErrorResponse(HttpStatusCode.BadRequest, ModelState);
            }
        }
    }
}
```

## <a id="string-api"></a>Внедрите проверку входных данных для всех параметров строкового типа, принимаемых методами веб-API

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-интерфейс API | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальные, MVC 5, MVC 6 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Validating Model Data in an MVC Application](http://msdn.microsoft.com/library/dd410404(v=vs.90).aspx) (Проверка данных модели в приложении MVC), [Основные принципы ваших приложений ASP.NET MVC](http://msdn.microsoft.com/magazine/dd942822.aspx) |
| **Действия** | Для методов, принимающих примитивные типы данных, а не модели в качестве аргументов, следует выполнять проверки входных данных с использованием регулярных выражений. Здесь следует использовать Regex.IsMatch с шаблоном допустимого регулярного выражения. Hello входные данные соответствуют hello указанному регулярному выражению, элемент управления не следует продолжить и отображать достаточно предупреждение об ошибке проверки подлинности.|

## <a id="typesafe-api"></a>Убедитесь, что в веб-API для доступа к данным используются параметры типобезопасности

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-интерфейс API | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Действия** | <p>При использовании коллекции Parameters hello SQL будет обрабатываться hello ввода — как буквенное значение, а не как исполняемый код. Hello коллекцию Parameters можно tooenforce используется тип и длина ограничения для входных данных. Значение за пределами диапазона hello вызвано исключение. Если строго типизированным SQL параметры не используются, злоумышленники могут быть атак путем внедрения кода может tooexecute, внедренных в hello нефильтрованные входные данные.</p><p>Используйте безопасные параметры типа, при построении SQL запросов tooavoid возможности атаки SQL injection, связанных с нефильтрованные входные данные. Эти параметры можно использовать с хранимыми процедурами и динамическими инструкциями SQL. Параметры обрабатываются как литеральные значения, hello базы данных, а не исполняемый код. Кроме того, проверяется тип и длина параметров.</p>|

### <a name="example"></a>Пример
Hello следующий код показывает, как toouse безопасные параметры типа с hello SqlParameterCollection при вызове хранимой процедуры. 

```C#
using System.Data;
using System.Data.SqlClient;

using (SqlConnection connection = new SqlConnection(connectionString))
{ 
DataSet userDataset = new DataSet(); 
SqlDataAdapter myCommand = new SqlDataAdapter(LoginStoredProcedure", connection); 
myCommand.SelectCommand.CommandType = CommandType.StoredProcedure; 
myCommand.SelectCommand.Parameters.Add("@au_id", SqlDbType.VarChar, 11); 
myCommand.SelectCommand.Parameters["@au_id"].Value = SSN.Text; 
myCommand.Fill(userDataset);
}  
```
Входное значение hello hello предшествующий пример кода, не может быть длиннее 11 символов. Если тип toohello или длина, определенная параметром hello hello данные не соответствуют, hello SqlParameter класс вызывает исключение. 

## <a id="sql-docdb"></a>Использование параметризованных SQL-запросов для Cosmos DB

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Azure DocumentDB | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Announcing SQL Parameterization in DocumentDB](https://azure.microsoft.com/blog/announcing-sql-parameterization-in-documentdb/) (Объявление о параметризации SQL в DocumentDB) |
| **Действия** | Несмотря на то что DocumentDB поддерживает исключительно запросы только для чтения, атака путем внедрения кода SQL по-прежнему возможна, если создавать запросы, объединяя их с входными данными пользователя. Могут быть доступны для toodata доступа toogain пользователя, не следует обращаться в hello одной коллекции разработать вредоносные запросы SQL. Используйте параметризованные SQL-запросы, если запросы создаются на основе входных данных пользователя. |

## <a id="schema-binding"></a>Проверка входных данных WCF путем привязки к схеме

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальные, .NET Framework 3 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [MSDN](https://msdn.microsoft.com/library/ff647820.aspx) |
| **Действия** | <p>Отсутствие проверки приводит toodifferent атак путем внедрения кода типа.</p><p>Проверка сообщений представляет одну линию обороны в защите hello приложения WCF. В этом случае проверка сообщений с помощью операций службы WCF tooprotect схемы от атак со стороны вредоносного клиента. Проверьте все сообщения, полученные клиентом hello клиента tooprotect hello от атак на вредоносной службе. Проверка сообщений упрощает возможных toovalidate сообщений при операции потреблять контрактов сообщений или контрактов данных, которые невозможно выполнить с помощью проверки параметров. Проверка сообщений позволяет toocreate логику проверки в схемах, тем самым обеспечивая большую гибкость и сократить время разработки. Схемы можно использовать в различных приложениях внутри организации hello, создание стандарты для представления данных. Кроме того Проверка сообщений позволяет tooprotect операции когда они используют более сложных типов данных, связанных с контрактами, представляющий бизнес-логики.</p><p>проверки сообщений tooperform вначале построить схему, которая представляет hello операции службы и hello типов данных потребляет выполнения этих операций. Создайте класс .NET, который реализует пользовательского клиентского инспектора сообщений и пользовательский диспетчер message inspector toovalidate hello сообщений отправленных и полученных от службы hello. Далее необходимо реализовать проверку сообщения tooenable поведение пользовательской конечной точки на приветствия клиента и службы hello. Наконец необходимо реализовать пользовательский элемент конфигурации на hello класс, который позволяет tooexpose hello расширенной настраиваемые поведения конечной точки в файле конфигурации hello hello службы или клиента hello»</p>|

## <a id="parameters"></a>Проверка входных данных WCF с помощью инспекторов параметров

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальные, .NET Framework 3 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [MSDN](https://msdn.microsoft.com/library/ff647875.aspx) |
| **Действия** | <p>Ввод и проверка данных представляет один важные линией обороны в защите hello приложения WCF. Следует проверить все параметры, предоставленные служба WCF службы операций tooprotect hello от атак со стороны вредоносного клиента. И наоборот следует проверить все возвращаемые значения, полученных hello клиент tooprotect hello клиент от атак вредоносного службой</p><p>WCF предоставляет точки различные расширения, обеспечивающие поведение среды выполнения WCF hello toocustomize путем создания пользовательских расширений. Сообщение, инспекторы и Инспекторы параметров являются двумя механизмами расширяемости использовать toogain больший контроль над hello данных, передаваемых между клиентом и службой. Следует использовать инспекторов параметров для проверки входных данных и используйте инспекторы сообщений только в том случае, если требуются все сообщение hello tooinspect проходящие через службу.</p><p>tooperform проверку входных данных, будут построены класс .NET и реализовать пользовательский инспектор параметров в параметры toovalidate заказа на операции в службе. Затем будет реализовывать tooenable проверки поведения пользовательской конечной точки на приветствия клиента и службы hello. Наконец будет реализовать пользовательский элемент конфигурации на hello класс, который позволяет tooexpose hello расширенной настраиваемые поведения конечной точки в файле конфигурации hello hello службы или клиента hello</p>|
