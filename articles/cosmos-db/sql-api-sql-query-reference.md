---
title: "Azure Cosmos DB. Справочник по синтаксису запроса SQL | Документация Майкрософт"
description: "Справочная документация по языку SQL-запросов в Azure Cosmos DB."
services: cosmos-db
author: LalithaMV
manager: jhubbard
editor: mimig
documentationcenter: 
ms.assetid: 
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: reference
ms.date: 10/18/2017
ms.author: laviswa
ms.openlocfilehash: 968f9e4d643228e02a1d09aae1b6ce82d6775f25
ms.sourcegitcommit: 6fb44d6fbce161b26328f863479ef09c5303090f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/10/2018
---
# <a name="azure-cosmos-db-sql-syntax-reference"></a>Справочник по синтаксису SQL в Azure Cosmos DB

[!INCLUDE [cosmos-db-sql-api](../../includes/cosmos-db-sql-api.md)]

Azure Cosmos DB позволяет выполнять запросы к документам с помощью знакомой грамматики SQL, например к иерархическим файлам JSON, без использования явных схем или создания вторичных индексов. В этой статье содержится справочная документация по языку SQL-запросов, совместимому с учетными записями API SQL.

Пошаговое руководство по языку SQL-запросов см. в статье об [SQL-запросах в Azure Cosmos DB](sql-api-sql-query.md).  
  
Мы также предлагаем вам посетить сайт [Query Playground](http://www.documentdb.com/sql/demo), где вы можете испытать базу данных Azure Cosmos DB в действии и выполнить запросы SQL к нашему набору данных.  
  
## <a name="select-query"></a>Запрос SELECT  
Этот запрос извлекает документы JSON из базы данных. Он поддерживает вычисление выражений, проектирование, фильтрацию и соединение.  Соглашения, используемые для описания инструкций SELECT, приведены в разделе "Соглашения о синтаксисе".  
  
**Синтаксис**  
  
```
<select_query> ::=  
SELECT <select_specification>   
    [ FROM <from_specification>]   
    [ WHERE <filter_condition> ]  
    [ ORDER BY <sort_specification> ]  
```  
  
 **Примечания**  
  
 Сведения о каждом из этих предложений см. в следующих разделах:  
  
-   [Предложение SELECT](#bk_select_query)  
  
-   [Предложение FROM](#bk_from_clause)  
  
-   [Предложение WHERE](#bk_where_clause)  
  
-   [Предложение ORDER BY](#bk_orderby_clause)  
  
Предложения в инструкции SELECT необходимо упорядочить, как показано выше. Необязательные предложения можно опустить, но если вы используете их, их необходимо упорядочить в правильном порядке.  
  
**Логические этапы обработки инструкции SELECT**  
  
Порядок обработки предложений:  

1.  [Предложение FROM](#bk_from_clause)  
2.  [Предложение WHERE](#bk_where_clause)  
3.  [Предложение ORDER BY](#bk_orderby_clause)  
4.  [Предложение SELECT](#bk_select_query)  

Обратите внимание, что этот порядок отличается от порядка в синтаксисе. Такое упорядочение связано с тем, что все новые символы, представленные в обработанном предложении, отображаются. Их можно использовать на следующих этапах. Например, псевдонимы, объявленные в предложении FROM, доступны в предложениях WHERE и SELECT.  

**Пробелы и комментарии**  

Все пробели за пределами строки в кавычках или нестандартного идентификатора не входят в грамматику языка. Во время синтаксического анализа они игнорируются.  

Язык запросов поддерживает комментарии T-SQL. Например:  

-   Инструкция SQL `-- comment text [newline]`  

Пробелы и комментарии не имеют значения в грамматике. Их следует использовать для разделения лексем. Например, `-1e5` представляет лексему с одним номером, а `: – 1 e5` — лексему "минус" (–), за которой следует номер 1 и идентификатор e5.  

##  <a name="bk_select_query"></a>Предложение SELECT  
Предложения в инструкции SELECT необходимо упорядочить, как показано выше. Необязательные предложения можно опустить, но если вы используете их, их необходимо упорядочить в правильном порядке.  

**Синтаксис**  
```  
SELECT <select_specification>  

<select_specification> ::=   
      '*'   
      | <object_property_list>   
      | VALUE <scalar_expression> [[ AS ] value_alias]  
  
<object_property_list> ::=   
{ <scalar_expression> [ [ AS ] property_alias ] } [ ,...n ]  
  
```  
  
 **Аргументы**  
  
 `<select_specification>`  
  
 Свойства или значения, выбираемые для результирующего набора.  
  
 `'*'`  
  
Указывает, что значение необходимо извлечь без внесения изменений. В частности, если обработанное значение — это объект, извлекаются все свойства.  
  
 `<object_property_list>`  
  
Указывает список свойств, которые требуется извлечь. Каждое возвращаемое значение представляет собой объект с указанными свойствами.  
  
`VALUE`  
  
Указывает, что следует извлечь только значение JSON, а не весь объект JSON. Этот аргумент, в отличие от аргумента `<property_list>`, не выделяет прогнозируемое значение в объекте.  
  
`<scalar_expression>`  
  
Выражение, представляющее вычисляемое значение. Дополнительные сведения см. в разделе [Скалярные выражения](#bk_scalar_expressions).  
  
**Примечания**  
  
Если предложение FROM объявило один псевдоним, действителен только синтаксис `SELECT *`. Синтаксис `SELECT *` обеспечивает проекцию удостоверения, что может пригодиться, если проекция не требуется. Кроме того, это единственный действительный синтаксис, если в предложении FROM указан один источник входных данных.  
  
Обратите внимание, что `SELECT <select_list>` и `SELECT *` — это "синтаксический сахар". При необходимости их можно выразить с помощью простых инструкций SELECT, как показано ниже.  
  
1.  `SELECT * FROM ... AS from_alias ...`  
  
     эквивалентно правилу  
  
     `SELECT from_alias FROM ... AS from_alias ...`  
  
2.  `SELECT <expr1> AS p1, <expr2> AS p2,..., <exprN> AS pN [other clauses...]`  
  
     эквивалентно правилу  
  
     `SELECT VALUE { p1: <expr1>, p2: <expr2>, ..., pN: <exprN> }[other clauses...]`  
  
**См. также**  
  
[Скалярные выражения](#bk_scalar_expressions)  
[Предложение SELECT](#bk_select_query)  
  
##  <a name="bk_from_clause"></a>Предложение FROM  
Это предложение указывает источник или несколько соединенных источников. Предложение FROM можно не указывать. Даже без него другие приложения по-прежнему выполнятся.  
  
**Синтаксис**  
  
```  
FROM <from_specification>  
  
<from_specification> ::=   
        <from_source> {[ JOIN <from_source>][,...n]}  
  
<from_source> ::=   
          <collection_expression> [[AS] input_alias]  
        | input_alias IN <collection_expression>  
  
<collection_expression> ::=   
        ROOT   
     | collection_name  
     | input_alias  
     | <collection_expression> '.' property_name  
     | <collection_expression> '[' "property_name" | array_index ']'  
```  
  
**Аргументы**  
  
`<from_source>`  
  
Указывает источник данных с псевдонимом или без него. Если псевдоним не указан, он выводится из аргумента `<collection_expression>` на основе следующих правил:  
  
-   При использовании выражения collection_name оно указывается в качестве псевдонима.  
  
-   При использовании выражения `<collection_expression>` в качестве псевдонима указывается свойство property_name. При использовании выражения collection_name оно указывается в качестве псевдонима.  
  
AS `input_alias`  
  
Указывает, что аргумент `input_alias` — это набор значений, возвращенный базовым выражением коллекции.  
 
`input_alias` IN  
  
Указывает, что аргумент `input_alias` должен представлять набор значений, полученных путем итерации всех элементов в каждом массиве, возвращенном базовым выражением коллекции. Значения, возвращенные базовым выражением коллекции, которые не являются массивом, игнорируются.  
  
`<collection_expression>`  
  
Указывает выражение коллекции, используемое для получения документов.  
  
`ROOT`  
  
Указывает, что документ необходимо извлечь из подключенной в настоящий момент коллекции по умолчанию.  
  
`collection_name`  
  
Указывает, что документ необходимо извлечь из предоставленной коллекции. Имя этой коллекции должно совпадать с именем подключенной в настоящий момент коллекции.  
  
`input_alias`  
  
Указывает, что документ необходимо извлечь из источника, определенного предоставленным псевдонимом.  
  
`<collection_expression> '.' property_`  
  
Указывает, что документ необходимо извлечь из свойства `property_name` или элемента массива array_index всех документов, полученных указанным выражением коллекции.  
  
`<collection_expression> '[' "property_name" | array_index ']'`  
  
Указывает, что документ необходимо извлечь из свойства `property_name` или элемента массива array_index всех документов, полученных указанным выражением коллекции.  
  
**Примечания**  
  
Все псевдонимы, предоставленные или выведенные в аргументе `<from_source>(`, должны быть уникальными. Синтаксис `<collection_expression>.`property_name совпадает с синтаксисом `<collection_expression>' ['"property_name"']'`. Второй синтаксис можно использовать, если имя свойства содержит знаки, не являющиеся идентификатором.  
  
**Обработка отсутствующих свойств, элементов массива и неопределенных значений**  
  
Если выражение коллекции обращается к свойствам или элементам массива и необходимое значение отсутствует, это значение игнорируется и не проходит дальнейшую обработку.  
  
**Определение области контекста выражения коллекции**  
  
Выражение коллекции может указываться на уровне коллекции или документа:  
  
-   Если в качестве базового источника выражения коллекции используется ROOT или `collection_name`, выражение определено на уровне коллекции. Такое выражение представляет набор документов, полученный напрямую из коллекции. Оно не зависит от обработки других выражений коллекции.  
  
-   Если в качестве базового источника выражения коллекции используется аргумент `input_alias`, сформированный ранее в запросе, выражение определено на уровне документа. Такое выражение представляет набор документов, полученный при оценке выражения коллекции в области каждого документа, который входит в набор, связанный с коллекцией, содержащей псевдоним.  Результирующий набор в этом случае представляет собой ряд наборов, полученных в результате вычисления выражения коллекции для всех документов в базовом наборе.  
  
**Соединения**  
  
В текущем выпуске Azure Cosmos DB поддерживает внутренние соединения. Дополнительные возможности соединения будут добавлены позже.

Результат внутренних соединений —это полное векторное произведение множеств, участвующих в соединении. Результатом других типов соединений является набор кортежей элементов того же типа, где каждое значение в кортеже связано с набором с псевдонимом, участвующим в соединении. Доступ к этому набору можно получить, создав ссылку на этот псевдоним в остальных предложениях.  
  
Вычисление соединения зависит от области контекста участвующих наборов:  
  
-  Результатом соединения набора элементов набора A и набора Б уровня коллекции является векторное произведение всех элементов в наборе А и Б.
  
-   Соединение набора A и набора Б уровня документа приводит к объединению всех наборов, полученных при оценке набора Б уровня документа для каждого документа из набора А.  
  
 В текущем выпуске обработчик запросов поддерживает максимум одно выражение уровня коллекции.  
  
**Примеры соединений**  
  
Рассмотрим следующее выражение FROM: `<from_source1> JOIN <from_source2> JOIN ... JOIN <from_sourceN>`.  
  
 Разрешите каждому источнику определить `input_alias1, input_alias2, …, input_aliasN`. Это предложение FROM возвращает набор N-кортежей (кортежей, у которых число значений равно N). Каждый кортеж будет иметь значения, полученные путем итерации всех псевдонимов коллекции среди их наборов.  
  
*Пример соединения 1 с 2 источниками:*  
  
- Определите аргумент `<from_source1>` на уровне коллекции. Он должен представлять набор {A, B, C}.  
  
- Определите аргумент `<from_source2>` на уровне документа и добавьте ссылку на input_alias1. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- В результате выполнения предложения FROM `<from_source1> JOIN <from_source2>` вернутся следующие кортежи:  
  
    (`input_alias1, input_alias2`):  
  
    `(A, 1), (A, 2), (B, 3), (C, 4), (C, 5)`  
  
*Пример соединения 2 с 3 источниками:*  
  
- Определите аргумент `<from_source1>` на уровне коллекции. Он должен представлять набор {A, B, C}.  
  
- Определите аргумент `<from_source2>` на уровне документа и добавьте ссылку на `input_alias1`. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- Определите аргумент `<from_source3>` на уровне документа и добавьте ссылку на `input_alias2`. Он должен представлять следующие наборы:  
  
    {100, 200} для `input_alias2 = 1,`;  
  
    {300} для `input_alias2 = 3,`.  
  
- В результате выполнения предложения FROM `<from_source1> JOIN <from_source2> JOIN <from_source3>` вернутся следующие кортежи:  
  
    (input_alias1, input_alias2, input_alias3):  
  
    (A, 1, 100), (A, 1, 200), (B, 3, 300)  
  
> [!NOTE]
> Другие значения `input_alias1`, например `input_alias2`, для которых `<from_source3>` не вернул значения, не имеют кортежей.  
  
*Пример соединения 3 с 3 источниками:*  
  
- Определите аргумент <from_source1> на уровне коллекции. Он должен представлять набор {A, B, C}.  
  
- Определите аргумент `<from_source1>` на уровне коллекции. Он должен представлять набор {A, B, C}.  
  
- Определите аргумент <from_source2> на уровне документа и добавьте ссылку на input_alias1. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- Определите аргумент `<from_source3>` в области `input_alias1`. Он должен представлять следующие наборы:  
  
    {100, 200} для `input_alias2 = A,`;  
  
    {300} для `input_alias2 = C,`.  
  
- В результате выполнения предложения FROM `<from_source1> JOIN <from_source2> JOIN <from_source3>` вернутся следующие кортежи:  
  
    (`input_alias1, input_alias2, input_alias3`):  
  
    (A, 1, 100), (A, 1, 200), (A, 2, 100), (A, 2, 200),  (C, 4, 300) ,  (C, 5, 300)  
  
> [!NOTE]
> В результате этого соединения образовалось векторное произведение между `<from_source2>` и `<from_source3>`. Это связано с тем, что оба этих аргумента относятся к аргументу `<from_source1>`.  Это привело к созданию 4 (2 x 2) кортежей со значением A, 0 кортежей (1 x 0) со значением B и 2 (2x1) кортежей со значением C.  
  
**См. также**  
  
 [Предложение SELECT](#bk_select_query)  
  
##  <a name="bk_where_clause"></a>Предложение WHERE  
 Это предложение указывает условие поиска для документов, возвращенных запросом.  
  
 **Синтаксис**  
  
```  
WHERE <filter_condition>  
<filter_condition> ::= <scalar_expression>  
  
```  
  
 **Аргументы**  
  
-   `<filter_condition>`  
  
     Указывает рекомендованное условие для возвращаемых документов.  
  
-   `<scalar_expression>`  
  
     Выражение, представляющее вычисляемое значение. Дополнительные сведения см. в разделе [Скалярные выражения](#bk_scalar_expressions).  
  
 **Примечания**  
  
 Чтобы вернуть документ, выражение, указанное в качестве условия фильтра, должно иметь значение true. Только логическое значение true соответствует условию. Все остальные значения, например undefined, Null, false, число, массив, объект, не подходят.  
  
##  <a name="bk_orderby_clause"></a>Предложение ORDER BY  
 Это предложение указывает порядок сортировки результатов, возвращаемых запросом.  
  
 **Синтаксис**  
  
```  
ORDER BY <sort_specification>  
<sort_specification> ::= <sort_expression> [, <sort_expression>]  
<sort_expression> ::= <scalar_expression> [ASC | DESC]  
  
```  
  
 **Аргументы**  
  
-   `<sort_specification>`  
  
     Указывает свойство или выражение, по которому производится сортировка результирующего набора запроса. Столбец сортировки можно указать в качестве имени или псевдонима.  
  
     Вы можете указать несколько столбцов сортировки. Имена столбцов должны быть уникальными. Последовательность столбцов сортировки в предложении ORDER BY определяет организацию упорядоченного результирующего набора. То есть результирующий набор сортируется по первому свойству, а затем упорядоченный список сортируется по второму свойству и т. д.  
  
     Имена столбцов, на которые указываются ссылки в предложении ORDER BY, должны соответствовать столбцу в списке выбора или столбцу в таблице, указанной в предложении FROM.  
  
-   `<sort_expression>`  
  
     Указывает одно свойство или выражение, по которому производится сортировка результирующего набора запроса.  
  
-   `<scalar_expression>`  
  
     Дополнительные сведения см. в разделе [Скалярные выражения](#bk_scalar_expressions).  
  
-   `ASC | DESC`  
  
     Указывает порядок сортировки значений в указанном столбце (по возрастанию или по убыванию). Если указать ASC, значения сортируются по возрастанию, а если DESC — по убыванию. По умолчанию значения сортируются по возрастанию. Значения Null рассматриваются как минимальные возможные значения.  
  
 **Примечания**  
  
 Хотя грамматика запроса поддерживает несколько параметров сортировки по свойствам, среда выполнения запросов Azure Cosmos DB поддерживает только сортировку по одному свойству и по именам свойств (т. е. не по вычисляемым свойствам). Кроме того, требуется, чтобы политика индексации содержала максимально точный индекс диапазона свойства и указанного типа. Дополнительные сведения см. в документации по политике индексации.  
  
##  <a name="bk_scalar_expressions"></a>Скалярные выражения  
 Скалярное выражение — это сочетание символов и операторов, в результате вычисления которых возвращается одно значение. К простым выражениям можно отнести константы, ссылки на свойства, ссылки на элементы массива, ссылки на псевдонимы или вызовы функций. C помощью операторов простые выражения можно объединить в сложные.  
  
 Дополнительные сведения о значениях скалярных выражений см. в разделе [Константы](#bk_constants).  
  
 **Синтаксис**  
  
```  
<scalar_expression> ::=  
       <constant>   
     | input_alias   
     | parameter_name  
     | <scalar_expression>.property_name  
     | <scalar_expression>'['"property_name"|array_index']'  
     | unary_operator <scalar_expression>  
     | <scalar_expression> binary_operator <scalar_expression>    
     | <scalar_expression> ? <scalar_expression> : <scalar_expression>  
     | <scalar_function_expression>  
     | <create_object_expression>   
     | <create_array_expression>  
     | (<scalar_expression>)   
  
<scalar_function_expression> ::=  
        'udf.' Udf_scalar_function([<scalar_expression>][,…n])  
        | builtin_scalar_function([<scalar_expression>][,…n])  
  
<create_object_expression> ::=  
   '{' [{property_name | "property_name"} : <scalar_expression>][,…n] '}'  
  
<create_array_expression> ::=  
   '[' [<scalar_expression>][,…n] ']'  
  
```  
  
 **Аргументы**  
  
-   `<constant>`  
  
     Представляет значение константы. Дополнительные сведения см. в разделе [Константы](#bk_constants).  
  
-   `input_alias`  
  
     Представляет значение, определяемое аргументом `input_alias` в предложении `FROM`.  
    Выражение гарантировано не может принять значение **undefined**. Значения **undefined** пропускаются.  
  
-   `<scalar_expression>.property_name`  
  
     Представляет значение свойства объекта. Если свойство не существует или ссылается на значение, которое не является объектом, выражение принимает значение **undefined**.  
  
-   `<scalar_expression>'['"property_name"|array_index']'`  
  
     Представляет значение свойства с именем `property_name` или элемент массива с индексом `array_index` из объекта или массива. Если объект или массив не существует или ссылается на значение, которое не является объектом или массивом, выражение принимает значение undefined.  
  
-   `unary_operator <scalar_expression>`  
  
     Представляет оператор, применяемый к одному значению. Дополнительные сведения см. в разделе [Операторы](#bk_operators).  
  
-   `<scalar_expression> binary_operator <scalar_expression>`  
  
     Представляет оператор, применяемый к двум значениям. Дополнительные сведения см. в разделе [Операторы](#bk_operators).  
  
-   `<scalar_function_expression>`  
  
     Представляет значение, определяемое результатом вызова функции.  
  
-   `udf_scalar_function`  
  
     Имя определяемой пользователем скалярной функции.  
  
-   `builtin_scalar_function`  
  
     Имя встроенной скалярной функции.  
  
-   `<create_object_expression>`  
  
     Представляет значение, полученное в процессе создания объекта с заданными свойствами и их значениями.  
  
-   `<create_array_expression>`  
  
     Представляет значение, полученное в процессе создания массива с заданными значениями в качестве элементов.  
  
-   `parameter_name`  
  
     Представляет значение указанного имени параметра. Имена параметров должны начинаться со знака "@".  
  
 **Примечания**  
  
 При вызове встроенной или определяемой пользователем скалярной функции необходимо определить все аргументы. Если любой из аргументов не определен, функция не будет вызвана, и значение не будет определено.  
  
 При создании объекта все свойства со значением undefined пропускаются и не включаются в созданный объект.  
  
 При создании массива все элементы со значением **undefined** пропускаются и не включаются в созданный объект. В этом случае место неопределенного элемента занимает следующий определенный элемент, таким образом в созданном массиве не будет пропущенных индексов.  
  
##  <a name="bk_operators"></a>Операторы  
 В этом разделе описываются поддерживаемые операторы. Каждый оператор может назначаться только одной категории.  
  
 В таблице **Категории операторов** ниже приведены сведения об обработке значений **undefined**, требованиях к типу входных значений и обработке значений несоответствующего типа.  
  
 **Категории операторов**  
  
|**Категория**|**Дополнительные сведения**|  
|-|-|  
|**Арифметические**|Ожидаемые входные и выходные данные — числа. Если любое входное значение **не определено** или имеет другой тип (не число), выражение принимает значение **undefined**.|  
|**Битовые**|Ожидаемые входные и выходные данные — 32-разрядные целые числа со знаками.<br /><br /> Все нецелочисленные значения округляются. Положительные значения округляются в меньшую сторону, а отрицательные — в большую.<br /><br /> Все не 32-разрядные целые числа со знаками преобразовываются (берутся последние 32 бита их нотации дополнительного кода).<br /><br /> Если любое входное значение **не определено** или имеет другой тип (не число), выражение принимает значение **undefined**.<br /><br /> **Примечание.** Описанное выше поведение совместимо с поведением побитового оператора JavaScript.|  
|**Логические**|Ожидаемые входные и выходные данные — логические значения.<br />Если любое входное значение **не определено** или имеет другой тип (не логический), выражение принимает значение **undefined**.|  
|**Сравнение**|Ожидаемые входные данные — определенные значения одного типа. Выходные данные — логические значения.<br /><br /> Если любое входное значение **не определено** или тип входных данных не совпадает, выражение принимает значение **undefined**.<br /><br /> Сведения об упорядочении значений см. в таблице **Упорядочение сравниваемых значений**.|  
|**string**|Ожидаемые входные и выходные данные — строки.<br />Если любое входное значение **не определено** или имеет другой тип (не строка), выражение принимает значение **undefined**.|  
  
 **Унарные операторы**  
  
|**Имя**|**Оператор**|**Дополнительные сведения**|  
|-|-|-|  
|**Арифметические**|+<br /><br /> -|Возвращает числовое значение.<br /><br /> Выполняет побитовую операцию. Возвращает отрицательное числовое значение.|  
|**Битовые**|~|Дополнение. Возвращает дополнение числового значения.|  
|**Логические**|**NOT**|Отрицание. Возвращает отрицательное логическое значение.|  
  
 **Бинарные операторы**  
  
|**Имя**|**Оператор**|**Дополнительные сведения**|  
|-|-|-|  
|**Арифметические**|+<br /><br /> -<br /><br /> *<br /><br /> /<br /><br /> %|Сложение.<br /><br /> Вычитание.<br /><br /> Умножение.<br /><br /> Деление.<br /><br /> Модуляция.|  
|**Битовые**|&#124;<br /><br /> &<br /><br /> ^<br /><br /> <<<br /><br /> >><br /><br /> >>>|Битовый OR.<br /><br /> Битовый AND.<br /><br /> Битовый XOR.<br /><br /> Сдвиг влево.<br /><br /> Сдвиг вправо.<br /><br /> Сдвиг вправо с заполнением нулями.|  
|**Логические**|**AND**<br /><br /> **OR**|Логическое умножение. Возвращает значение **true**, если оба аргумента имеют значение **true**. В противном случае возвращает **false**.<br /><br /> Логическое умножение. Возвращает значение **true**, если оба аргумента имеют значение **true**. В противном случае возвращает **false**.|  
|**Сравнение**|**=**<br /><br /> **!=, <>**<br /><br /> **>**<br /><br /> **>=**<br /><br /> **<**<br /><br /> **<=**<br /><br /> **??**|Равно. Возвращает значение **true**, если оба аргумента равны. В противном случае возвращает **false**.<br /><br /> Не равно. Возвращает значение **true**, если оба аргумента не равны. В противном случае возвращает **false**.<br /><br /> Больше. Возвращает значение **true**, если первый аргумент больше второго. В противном случае возвращает **false**.<br /><br /> Больше или равно. Возвращает значение **true**, если первый аргумент больше второго или равен ему. В противном случае возвращает **false**.<br /><br /> Меньше. Возвращает значение **true**, если первый аргумент меньше второго. В противном случае возвращает **false**.<br /><br /> Меньше или равно. Возвращает значение **true**, если первый аргумент меньше второго или равен ему. В противном случае возвращает **false**.<br /><br /> Слияние. Возвращает второй аргумент, если первый аргумент имеет значение **undefined**.|  
|**Строка**|**&#124;&#124;**|Объединение. Возвращает объединение обоих аргументов.|  
  
 **Тернарные операторы**  
  
|Тернарный оператор|?|Возвращает второй аргумент, если первый аргумент принимает значение **true**. В противном случае возвращает третий аргумент.|  
|-|-|-|  
  
 **Упорядочение сравниваемых значений**  
  
|**Тип**|**Порядок значений**|  
|-|-|  
|**Неопределенное**|Невозможно сравнить.|  
|**Null**|Доступное значение: **Null**|  
|**Число**|Натуральное вещественное число.<br /><br /> Отрицательное значение бесконечности меньше любого другого числового значения.<br /><br /> Положительное значение бесконечности больше любого другого числового значения. Значение **NaN** невозможно сравнить. При сравнение с **NaN** возвращается значение **undefined**.|  
|**Строка**|Лексикографический порядок.|  
|**Массив**|Не поддерживает упорядочивание, но равнозначные.|  
|**Объект**|Не поддерживает упорядочивание, но равнозначные.|  
  
 **Примечания**  
  
 В базе данных Azure Cosmos DB типы значений часто невозможно определить до их фактического извлечения. Чтобы обеспечить эффективное выполнение запросов, большинство операторов имеют строгие требования к типам. Кроме того, операторы сами по себе не выполняют неявное преобразование.  
  
 Это означает, что запрос, такой как SELECT * FROM ROOT r WHERE r.Age = 21, вернет только документы со свойством Age равным числу 21. Документы со свойством Age равным строке "21" или "0021" не соответствуют, так как выражение "21" = 21 принимает значение undefined. Это позволяет лучше использовать индексы, так как поиск конкретного значения (например, числа 21) выполняется быстрее, чем поиск неопределенного количества возможных совпадений (например, числа 21 или строк "21", "021", "21.0" и т. д.). Это отличается от способа вычисления операторов в значениях различных типов на языке JavaScript.  
  
 **Равенство и сравнение массивов и объектов**  
  
 При сравнении значений массивов или объектов с использованием операторов диапазона (>, >=, <, <=) возвращается значение undefined, так как порядок этих значений не определен. Но выполнить структурное сравнение можно с помощью операторов равенства и неравенства (=, !=, <>).  
  
 Два массива считаются равными, если они имеют одинаковое число элементов и сопоставляемые элементы также равны. Если при сравнении пары элементов возвращается значение undefined, сравнение массива также вернет значение undefined.  
  
 Два объекта считаются равными, если они имеют одинаковые свойства и сопоставляемые свойства также равны. Если при сравнении пары значений свойств возвращается значение undefined, сравнение объекта также вернет значение undefined.  
  
##  <a name="bk_constants"></a>Константы  
 Константа (также известная как литерал или скаляр) — это символ, представляющий определенное значение данных. Формат константы зависит от типа данных значения, которое она представляет.  
  
 **Поддерживаемые скалярные типы данных**  
  
|**Тип**|**Порядок значений**|  
|-|-|  
|**Неопределенное**|Доступное значение: **undefined**|  
|**Null**|Доступное значение: **Null**|  
|**Логический**|Доступные значения: **false**, **true**|  
|**Число**|Число с плавающей запятой двойной точности, стандарт IEEE 754.|  
|**Строка**|Последовательности из нуля или более знаков Юникода. Строки необходимо заключить в одинарные или двойные кавычки.|  
|**Массив**|Последовательность из нуля или более элементов. Каждый элемент может иметь значение любого скалярного типа данных (за исключением типа "Неопределенное").|  
|**Объект**|Неупорядоченный набор из нуля или более пар "имя — значение". Имя является строкой Юникода. Значение может иметь любой скалярный тип данных (за исключением типа **Неопределенное**).|  
  
 **Синтаксис**  
  
```  
<constant> ::=  
   <undefined_constant>  
     | <null_constant>   
     | <boolean_constant>   
     | <number_constant>   
     | <string_constant>   
     | <array_constant>   
     | <object_constant>   
  
<undefined_constant> ::= undefined  
  
<null_constant> ::= null  
  
<boolean_constant> ::= false | true  
  
<number_constant> ::= decimal_literal | hexadecimal_literal  
  
<string_constant> ::= string_literal  
  
<array_constant> ::=  
    '[' [<constant>][,...n] ']'  
  
<object_constant> ::=   
   '{' [{property_name | "property_name"} : <constant>][,...n] '}'  
  
```  
  
 **Аргументы**  
  
1.  `<undefined_constant>; undefined`  
  
     Представляет неопределенное значение типа "Неопределенное".  
  
2.  `<null_constant>; null`  
  
     Представляет значение **Null** типа **Null**.  
  
3.  `<boolean_constant>`  
  
     Представляет константу типа "Логический".  
  
4.  `false`  
  
     Представляет значение **false** типа "Логический".  
  
5.  `true`  
  
     Представляет значение **true** типа "Логический".  
  
6.  `<number_constant>`  
  
     Представляет константу.  
  
7.  `decimal_literal`  
  
     Десятичные литералы — это числа, представленные в десятичном или экспоненциальном представлении.  
  
8.  `hexadecimal_literal`  
  
     Шестнадцатеричные литералы — это числа, представленные с помощью префикса 0x, за которым следуют одна или несколько шестнадцатеричных цифр.  
  
9. `<string_constant>`  
  
     Представляет константу типа "Строка".  
  
10. `string _literal`  
  
     Строковые литералы — это строки Юникода, представленные в виде последовательности из нуля или более знаков Юникода или escape-последовательностей. Строковые литералы заключаются в одинарные кавычки (апостроф — ') или двойные кавычки (кавычки — ").  
  
 Допускаются следующие escape-последовательности:  
  
|**escape-последовательность**|**Описание**|**Символ Юникода**|  
|-|-|-|  
|\\'|Апостроф (')|U+0027|  
|\\"|Кавычки (")|U+0022|  
|\\\|Обратная косая черта (\\)|U+005C|  
|\\/|Косая черта (/)|U+002F|  
|\b|BACKSPACE|U+0008|  
|\f|Смена страницы|U+000C|  
|\n|Перевод строки|U+000A|  
|\r|Возврат каретки|U+000D|  
|\t|TAB|U+0009|  
|\uXXXX|Символ Юникода, определяемый 4 шестнадцатеричными цифрами.|U+XXXX|  
  
##  <a name="bk_query_perf_guidelines"></a> Рекомендации по повышению производительности запросов  
 Чтобы повысить эффективность запросов для больших коллекций, следует применить фильтры, которые могут обрабатываться одним или несколькими индексами.  
  
 При поиске по индексу можно применять следующие фильтры:  
  
-   Используйте оператор равенства (=) с выражением пути к документу и константой.  
  
-   Используйте операторы диапазона (<, \<=, >, >=) с выражением пути к документу и числовыми константами.  
  
-   Выражение пути к документу — это любое выражение, которое определяет постоянный путь в документах из указанной коллекции баз данных.  
  
 **Выражение пути к документу**  
  
 Выражения пути к документу — это выражения, которые оценивают путь свойства или индексатор массива в документе из коллекции баз данных. Этот путь позволяет определить расположение значений, указанных в фильтре непосредственно в документах из коллекции баз данных.  
  
 Чтобы выражение рассматривалось как выражение пути к документу, оно должно:  
  
1.  Ссылаться непосредственно на корневую коллекцию.  
  
2.  Ссылаться на свойство или индексатор массива констант любого выражения пути к документу.  
  
3.  Ссылаться на псевдоним, который представляет выражение пути к документу.  
  
     **Соглашения о синтаксисе**  
  
     В таблице ниже указаны соглашения, используемые для описания синтаксиса в следующем справочнике по SQL.  
  
    |**Соглашение**|**Область использования**|  
    |-|-|    
    |Прописные буквы|Ключевые слова, не учитывающие регистр.|  
    |Нижний регистр|Ключевые слова, учитывающие регистр.|  
    |\<Нетерминальный символ>|Нетерминальный символ, определяется отдельно.|  
    |\<Нетерминальный символ> ::=|Определение синтаксиса нетерминального символа.|  
    |Другие терминальные символы|Терминальный символ (лексема) подробно описывается в словах.|  
    |Идентификатор|Идентификатор. Поддерживает только следующие знаки: a–z, A–Z, 0–9. Первый знак не может быть цифрой.|  
    |Строка|Строка в кавычках. Разрешает любые допустимые строки. См. описание аргумента string_literal.|  
    |Символ|Литеральный символ, который является частью синтаксиса.|  
    |&#124; (вертикальная линия)|Варианты элементов синтаксиса. Можно использовать только один из указанных элементов.|  
    |[ ] /(квадратные скобки)|В квадратных скобках указывается один или несколько дополнительных элементов.|  
    |[ ,…n ]|Указывает, что предшествующий элемент может повторяться несколько раз. Отдельные вхождения элемента разделяются запятыми.|  
    |[ …n ]|Указывает, что предшествующий элемент может повторяться несколько раз. Отдельные вхождения элемента разделяются пробелами.|  
  
##  <a name="bk_built_in_functions"></a>Встроенные функции  
 Azure Cosmos DB предоставляет множество встроенных функций SQL. Ниже перечислены их категории.  
  
|Функция|ОПИСАНИЕ|  
|--------------|-----------------|  
|[Математические функции](#bk_mathematical_functions)|Математические функции выполняют вычисление, которое обычно основано на входных значениях, предоставляемых в форме аргументов, и возвращают числовое значение.|  
|[Функции проверки типа](#bk_type_checking_functions)|Функции проверки типа позволяют проверять тип выражения в запросах SQL.|  
|[Строковые функции](#bk_string_functions)|Cтроковые функции выполняют операцию над входным строковым значением и возвращают строковое, числовое или логическое значение.|  
|[Функции массивов](#bk_array_functions)|Функции массивов выполняют операцию над входным массивом и возвращают числовое, логическое значение либо массив.|  
|[Пространственные функции](#bk_spatial_functions)|Пространственные функции выполняют операцию над входным пространственным объектом и возвращают числовое или логическое значение.|  
  
###  <a name="bk_mathematical_functions"></a>Математические функции  
 Следующие функции выполняют вычисление, которое обычно основано на входных значениях, предоставляемых в форме аргументов, и возвращают числовое значение.  
  
||||  
|-|-|-|  
|[ABS](#bk_abs)|[ACOS](#bk_acos)|[ASIN](#bk_asin)|  
|[ATAN](#bk_atan)|[ATN2](#bk_atn2)|[CEILING](#bk_ceiling)|  
|[COS](#bk_cos)|[COT](#bk_cot)|[DEGREES](#bk_degrees)|  
|[EXP](#bk_exp)|[FLOOR](#bk_floor)|[LOG](#bk_log)|  
|[LOG10](#bk_log10)|[PI](#bk_pi)|[POWER](#bk_power)|  
|[RADIANS](#bk_radians)|[ROUND](#bk_round)|[SIN](#bk_sin)|  
|[SQRT](#bk_sqrt)|[SQUARE](#bk_square)|[SIGN](#bk_sign)|  
|[TAN](#bk_tan)|[TRUNC](#bk_trunc)||  
  
####  <a name="bk_abs"></a> ABS  
 Возвращает модуль (положительное значение) указанного числового выражения.  
  
 **Синтаксис**  
  
```  
ABS (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В приведенном ниже примере показаны результаты применения функции ABS к трем различным числам.  
  
```  
SELECT ABS(-1), ABS(0), ABS(1)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 1, $2: 0, $3: 1}]  
```  
  
####  <a name="bk_acos"></a> ACOS  
 Возвращает угол в радианах, косинус которого равен указанному числовому выражению; также называется арккосинусом.  
  
 **Синтаксис**  
  
```  
ACOS(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает значение функции ACOS от –1.  
  
```  
SELECT ACOS(-1)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": 3.1415926535897931}]  
```  
  
####  <a name="bk_asin"></a> ASIN  
 Возвращает угол в радианах, синус которого равен указанному числовому выражению. Также называется арксинусом.  
  
 **Синтаксис**  
  
```  
ASIN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает значение функции ASIN от –1.  
  
```  
SELECT ASIN(-1)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": -1.5707963267948966}]  
```  
  
####  <a name="bk_atan"></a> ATAN  
 Возвращает угол в радианах, тангенс которого равен указанному числовому выражению. Также называется арктангенсом.  
  
 **Синтаксис**  
  
```  
ATAN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает значение функции ASIN от указанного значения.  
  
```  
SELECT ATAN(-45.01)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": -1.5485826962062663}]  
```  
  
####  <a name="bk_atn2"></a> ATN2  
 Возвращает основное значение арктангенса y/x, выраженное в радианах.  
  
 **Синтаксис**  
  
```  
ATN2(<numeric_expression>, <numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже вычисляется ATN2 для указанных компонентов x и y.  
  
```  
SELECT ATN2(35.175643, 129.44)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": 1.3054517947300646}]  
```  
  
####  <a name="bk_ceiling"></a> CEILING  
 Возвращает наименьшее целочисленное значение, которое больше или равно указанному числовому выражению.  
  
 **Синтаксис**  
  
```  
CEILING (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже показаны положительные числовые, отрицательные и нулевые значения функции CEILING.  
  
```  
SELECT CEILING(123.45), CEILING(-123.45), CEILING(0.0)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 124, $2: -123, $3: 0}]  
```  
  
####  <a name="bk_cos"></a> COS  
 Возвращает тригонометрический косинус указанного угла в радианах в указанном выражении.  
  
 **Синтаксис**  
  
```  
COS(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже вычисляется COS указанного угла.  
  
```  
SELECT COS(14.78)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": -0.59946542619465426}]  
```  
  
####  <a name="bk_cot"></a> COT  
 Возвращает тригонометрический котангенс указанного угла в радианах в указанном числовом выражении.  
  
 **Синтаксис**  
  
```  
COT(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже вычисляется COT указанного угла.  
  
```  
SELECT COT(124.1332)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": -0.040311998371148884}]  
```  
  
####  <a name="bk_degrees"></a> DEGREES  
 Возвращает соответствующее значение угла в градусах для угла, указанного в радианах.  
  
 **Синтаксис**  
  
```  
DEGREES (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Следующий пример возвращает число градусов в угле, равном PI/2 радиан.  
  
```  
SELECT DEGREES(PI()/2)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": 90}]  
```  
  
####  <a name="bk_floor"></a> FLOOR  
 Возвращает наибольшее целочисленное значение, которое меньше или равно указанному числовому выражению.  
  
 **Синтаксис**  
  
```  
FLOOR (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже показаны положительные числовые, отрицательные и нулевые значения функции FLOOR.  
  
```  
SELECT FLOOR(123.45), FLOOR(-123.45), FLOOR(0.0)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 123, $2: -124, $3: 0}]  
```  
  
####  <a name="bk_exp"></a> EXP  
 Возвращает значение экспоненты для указанного числового выражения.  
  
 **Синтаксис**  
  
```  
EXP (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примечания**  
  
 Константа **e** (2,718281…) является основанием натуральных логарифмов.  
  
 Экспонента числа — это константа **e** степени числа. Например, EXP(1.0) = e^1.0 = 2,71828182845905 и EXP(10) = e^10 = 22026,4657948067.  
  
 Экспонента натурального логарифма числа — это само число. Например, EXP (LOG (n)) = n. Натуральный логарифм экспоненты числа также является числом. Например, LOG (EXP (n)) = n.  
  
 **Примеры**  
  
 В примере ниже объявляется переменная и возвращается значение экспоненты указанной переменной (10).  
  
```  
SELECT EXP(10)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 22026.465794806718}]  
```  
  
 Пример ниже возвращает значение экспоненты от натурального логарифма 20 и натуральный логарифм экспоненты 20. Так как эти функции обратные, в обоих случаях возвращается значение 20 (после округления до плавающей запятой).  
  
```  
SELECT EXP(LOG(20)), LOG(EXP(20))  
```  
  
 Результирующий набор:  
  
```  
[{$1: 19.999999999999996, $2: 20}]  
```  
  
####  <a name="bk_log"></a> LOG  
 Возвращает натуральный логарифм от указанного числового выражения.  
  
 **Синтаксис**  
  
```  
LOG (<numeric_expression> [, <base>])  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
-   `base`  
  
     Дополнительный числовой аргумент, который задает основание логарифма.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примечания**  
  
 По умолчанию функция LOG() возвращает натуральный логарифм. Основание логарифма можно изменить с помощью дополнительного параметра основания.  
  
 Натуральный логарифм — это логарифм с основанием **e**, где **e** — это иррациональная константа приблизительно равная 2,718281828.  
  
 Натуральный логарифм экспоненты числа — это само число. Например, LOG( EXP( n ) ) = n. И экспонента натурального логарифма числа также является самым числом. Например, EXP( LOG( n ) ) = n.  
  
 **Примеры**  
  
 В примере ниже объявляется переменная и возвращается значение логарифма указанной переменной (10).  
  
```  
SELECT LOG(10)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 2.3025850929940459}]  
```  
  
 В примере ниже вычисляется логарифм экспоненты числа.  
  
```  
SELECT EXP(LOG(10))  
```  
  
 Результирующий набор:  
  
```  
[{$1: 10.000000000000002}]  
```  
  
####  <a name="bk_log10"></a> LOG10  
 Возвращает десятичный логарифм от указанного числового выражения.  
  
 **Синтаксис**  
  
```  
LOG10 (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примечания**  
  
 Функции LOG10 и POWER обратно связаны друг с другом. Например, 10 ^ LOG10(n) = n.  
  
 **Примеры**  
  
 В примере ниже объявляется переменная и возвращается значение LOG10 указанной переменной (100).  
  
```  
SELECT LOG10(100)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 2}]  
```  
  
####  <a name="bk_pi"></a> PI  
 Возвращает значение константы "пи".  
  
 **Синтаксис**  
  
```  
PI ()  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает значение PI.  
  
```  
SELECT PI()  
```  
  
 Результирующий набор:  
  
```  
[{"$1": 3.1415926535897931}]  
```  
  
####  <a name="bk_power"></a> POWER  
 Возвращает результат возведения указанного числового выражения в заданную степень.  
  
 **Синтаксис**  
  
```  
POWER (<numeric_expression>, <y>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
-   `y`  
  
     Степень для возведения аргумента `numeric_expression`.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В следующем примере показано возведение числа в третью степень (куб числа).  
  
```  
SELECT POWER(2, 3), POWER(2.5, 3)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 8, $2: 15.625}]  
```  
  
####  <a name="bk_radians"></a> RADIANS  
 Возвращает значение угла в радианах для числового значения, указанного в градусах.  
  
 **Синтаксис**  
  
```  
RADIANS (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже берется несколько углов в качестве входных данных и возвращаются их соответствующие значения в радианах.  
  
```  
SELECT RADIANS(-45.01), RADIANS(-181.01), RADIANS(0), RADIANS(0.1472738), RADIANS(197.1099392)  
```  
  
 Результирующий набор:  
  
```  
[{  
       "$1": -0.7855726963226477,  
       "$2": -3.1592204790349356,  
       "$3": 0,  
       "$4": 0.0025704127119236249,  
       "$5": 3.4402174274458375  
   }]  
```  
  
####  <a name="bk_round"></a> ROUND  
 Возвращает числовое значение, округленное до ближайшего целого значения в большую сторону.  
  
 **Синтаксис**  
  
```  
ROUND(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже положительные и отрицательные числа округляются до ближайшего целого.  
  
```  
SELECT ROUND(2.4), ROUND(2.6), ROUND(2.5), ROUND(-2.4), ROUND(-2.6)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 2, $2: 3, $3: 3, $4: -2, $5: -3}]  
```  
  
####  <a name="bk_sign"></a> SIGN  
 Возвращает знак указанного числового выражения (+1 для положительных чисел, 0 для нуля или -1 для отрицательных).  
  
 **Синтаксис**  
  
```  
SIGN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает значения SIGN для чисел от –2 до 2.  
  
```  
SELECT SIGN(-2), SIGN(-1), SIGN(0), SIGN(1), SIGN(2)  
```  
  
 Результирующий набор:  
  
```  
[{$1: -1, $2: -1, $3: 0, $4: 1, $5: 1}]  
```  
  
####  <a name="bk_sin"></a> SIN  
 Возвращает тригонометрический синус заданного угла в радианах для указанного выражения.  
  
 **Синтаксис**  
  
```  
SIN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже вычисляется синус указанного угла.  
  
```  
SELECT SIN(45.175643)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": 0.929607286611012}]  
```  
  
####  <a name="bk_sqrt"></a> SQRT  
 Возвращает квадратный корень из указанного числового значения.  
  
 **Синтаксис**  
  
```  
SQRT(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает квадратный корень для чисел 1–3.  
  
```  
SELECT SQRT(1), SQRT(2.0), SQRT(3)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 1, $2: 1.4142135623730952, $3: 1.7320508075688772}]  
```  
  
####  <a name="bk_square"></a> SQUARE  
 Возвращает квадратный корень из указанного числового значения.  
  
 **Синтаксис**  
  
```  
SQUARE(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает квадраты для чисел 1–3.  
  
```  
SELECT SQUARE(1), SQUARE(2.0), SQUARE(3)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 1, $2: 4, $3: 9}]  
```  
  
####  <a name="bk_tan"></a> TAN  
 Возвращает тангенс заданного угла в радианах для указанного выражения.  
  
 **Синтаксис**  
  
```  
TAN (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Пример ниже вычисляет тангенс от PI()/2.  
  
```  
SELECT TAN(PI()/2);  
```  
  
 Результирующий набор:  
  
```  
[{"$1": 16331239353195370 }]  
```  
  
####  <a name="bk_trunc"></a> TRUNC  
 Возвращает числовое значение, округленное до ближайшего целого значения в меньшую сторону.  
  
 **Синтаксис**  
  
```  
TRUNC(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже положительные и отрицательные числа усекаются до ближайшего целого значения.  
  
```  
SELECT TRUNC(2.4), TRUNC(2.6), TRUNC(2.5), TRUNC(-2.4), TRUNC(-2.6)  
```  
  
 Результирующий набор:  
  
```  
[{$1: 2, $2: 2, $3: 2, $4: -2, $5: -2}]  
```  
  
###  <a name="bk_type_checking_functions"></a> Функции проверки типа  
 Следующие функции поддерживают проверку типа входных значений и возвращают логическое значение.  
  
||||  
|-|-|-|  
|[IS_ARRAY](#bk_is_array)|[IS_BOOL](#bk_is_bool)|[IS_DEFINED](#bk_is_defined)|  
|[IS_NULL](#bk_is_null)|[IS_NUMBER](#bk_is_number)|[IS_OBJECT](#bk_is_object)|  
|[IS_PRIMITIVE](#bk_is_primitive)|[IS_STRING](#bk_is_string)||  
  
####  <a name="bk_is_array"></a> IS_ARRAY  
 Возвращает логическое значение, указывающее, является ли указанное выражение массивом.  
  
 **Синтаксис**  
  
```  
IS_ARRAY(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 В примере ниже с помощью функции IS_ARRAY проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
 IS_ARRAY(true),   
 IS_ARRAY(1),  
 IS_ARRAY("value"),  
 IS_ARRAY(null),  
 IS_ARRAY({prop: "value"}),   
 IS_ARRAY([1, 2, 3]),  
 IS_ARRAY({prop: "value"}.prop2)  
```  
  
 Результирующий набор:  
  
```  
[{$1: false, $2: false, $3: false, $4: false, $5: false, $6: true}]  
```  
  
####  <a name="bk_is_bool"></a> IS_BOOL  
 Возвращает логическое значение, указывающее, является ли указанное выражение логическим значением.  
  
 **Синтаксис**  
  
```  
IS_BOOL(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 В примере ниже с помощью функции IS_BOOL проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
    IS_BOOL(true),   
    IS_BOOL(1),  
    IS_BOOL("value"),   
    IS_BOOL(null),  
    IS_BOOL({prop: "value"}),   
    IS_BOOL([1, 2, 3]),  
    IS_BOOL({prop: "value"}.prop2)  
```  
  
 Результирующий набор:  
  
```  
[{$1: true, $2: false, $3: false, $4: false, $5: false, $6: false}]  
```  
  
####  <a name="bk_is_defined"></a> IS_DEFINED  
 Возвращает логическое значение, указывающее, назначено ли свойству значение.  
  
 **Синтаксис**  
  
```  
IS_DEFINED(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 В примере ниже проверяется наличие свойства в указанном документе JSON. Первый пример возвращает значение true, так как присутствует значение "a", но второй возвращает значение false, так как значение "b" отсутствует.  
  
```  
SELECT IS_DEFINED({ "a" : 5 }.a), IS_DEFINED({ "a" : 5 }.b)  
```  
  
 Результирующий набор:  
  
```  
[{  
       "$1": true,    
       "$2": false   
   }]  
```  
  
####  <a name="bk_is_null"></a> IS_NULL  
 Возвращает логическое значение, указывающее, является ли указанное выражение значением Null.  
  
 **Синтаксис**  
  
```  
IS_NULL(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 В примере ниже с помощью функции IS_NULL проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
    IS_NULL(true),   
    IS_NULL(1),  
    IS_NULL("value"),   
    IS_NULL(null),  
    IS_NULL({prop: "value"}),   
    IS_NULL([1, 2, 3]),  
    IS_NULL({prop: "value"}.prop2)  
```  
  
 Результирующий набор:  
  
```  
[{$1: false, $2: false, $3: false, $4: true, $5: false, $6: false}]  
```  
  
####  <a name="bk_is_number"></a> IS_NUMBER  
 Возвращает логическое значение, указывающее, является ли указанное выражение числовым значением.  
  
 **Синтаксис**  
  
```  
IS_NUMBER(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 В примере ниже с помощью функции IS_NULL проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
    IS_NUMBER(true),   
    IS_NUMBER(1),  
    IS_NUMBER("value"),   
    IS_NUMBER(null),  
    IS_NUMBER({prop: "value"}),   
    IS_NUMBER([1, 2, 3]),  
    IS_NUMBER({prop: "value"}.prop2)  
```  
  
 Результирующий набор:  
  
```  
[{$1: false, $2: true, $3: false, $4: false, $5: false, $6: false}]  
```  
  
####  <a name="bk_is_object"></a> IS_OBJECT  
 Возвращает логическое значение, указывающее, является ли указанное выражение объектом JSON.  
  
 **Синтаксис**  
  
```  
IS_OBJECT(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 В примере ниже с помощью функции IS_OBJECT проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
    IS_OBJECT(true),   
    IS_OBJECT(1),  
    IS_OBJECT("value"),   
    IS_OBJECT(null),  
    IS_OBJECT({prop: "value"}),   
    IS_OBJECT([1, 2, 3]),  
    IS_OBJECT({prop: "value"}.prop2)  
```  
  
 Результирующий набор:  
  
```  
[{$1: false, $2: false, $3: false, $4: false, $5: true, $6: false}]  
```  
  
####  <a name="bk_is_primitive"></a> IS_PRIMITIVE  
 Возвращает логическое значение, указывающее, является ли указанное выражение примитивом (строкой, логическим значением, числовым значением или значением Null).  
  
 **Синтаксис**  
  
```  
IS_PRIMITIVE(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 В примере ниже с помощью функции IS_PRIMITIVE проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
           IS_PRIMITIVE(true),   
           IS_PRIMITIVE(1),  
           IS_PRIMITIVE("value"),   
           IS_PRIMITIVE(null),  
           IS_PRIMITIVE({prop: "value"}),   
           IS_PRIMITIVE([1, 2, 3]),  
           IS_PRIMITIVE({prop: "value"}.prop2)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": true, "$2": true, "$3": true, "$4": true, "$5": false, "$6": false, "$7": false}]  
```  
  
####  <a name="bk_is_string"></a> IS_STRING  
 Возвращает логическое значение, указывающее, является ли указанное выражение строковым значением.  
  
 **Синтаксис**  
  
```  
IS_STRING(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 В примере ниже с помощью функции IS_STRING проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
       IS_STRING(true),   
       IS_STRING(1),  
       IS_STRING("value"),   
       IS_STRING(null),  
       IS_STRING({prop: "value"}),   
       IS_STRING([1, 2, 3]),  
       IS_STRING({prop: "value"}.prop2)  
```  
  
 Результирующий набор:  
  
```  
[{$1: false, $2: false, $3: true, $4: false, $5: false, $6: false}]  
```  
  
###  <a name="bk_string_functions"></a> Строковые функции  
 Следующие скалярные функции выполняют операцию над входным строковым значением и возвращают строковое, числовое или логическое значение.  
  
||||  
|-|-|-|  
|[CONCAT](#bk_concat)|[CONTAINS](#bk_contains)|[ENDSWITH](#bk_endswith)|  
|[INDEX_OF](#bk_index_of)|[LEFT](#bk_left)|[LENGTH](#bk_length)|  
|[LOWER](#bk_lower)|[LTRIM](#bk_ltrim)|[REPLACE](#bk_replace)|  
|[REPLICATE](#bk_replicate)|[REVERSE](#bk_reverse)|[RIGHT](#bk_right)|  
|[RTRIM](#bk_rtrim)|[STARTSWITH](#bk_startswith)|[SUBSTRING](#bk_substring)|  
|[UPPER](#bk_upper)|||  
  
####  <a name="bk_concat"></a> CONCAT  
 Возвращает строку, являющуюся результатом объединения двух или более строковых значений.  
  
 **Синтаксис**  
  
```  
CONCAT(<str_expr>, <str_expr> [, <str_expr>])  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает объединенную строку указанных значений.  
  
```  
SELECT CONCAT("abc", "def")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "abcdef"}  
```  
  
####  <a name="bk_contains"></a> CONTAINS  
 Возвращает значение логического типа, указывающее, содержит ли первое строковое выражение второе.  
  
 **Синтаксис**  
  
```  
CONTAINS(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Пример ниже проверяет, содержит ли строка "abc"вхождения "ab" и "d".  
  
```  
SELECT CONTAINS("abc", "ab"), CONTAINS("abc", "d")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": true, "$2": false}]  
```  
  
####  <a name="bk_endswith"></a> ENDSWITH  
 Возвращает значение логического типа, указывающее, заканчивается ли первое строковое выражение вторым.  
  
 **Синтаксис**  
  
```  
ENDSWITH(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает строки "abc", в конце которых есть "b" и "bc".  
  
```  
SELECT ENDSWITH("abc", "b"), ENDSWITH("abc", "bc")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": false, "$2": true}]  
```  
  
####  <a name="bk_index_of"></a> INDEX_OF  
 Возвращает начальную позицию первого вхождения второго строкового выражения в первое указанное строковое выражение или –1, если строка не найдена.  
  
 **Синтаксис**  
  
```  
INDEX_OF(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает индекс различных подстрок в строке "abc".  
  
```  
SELECT INDEX_OF("abc", "ab"), INDEX_OF("abc", "b"), INDEX_OF("abc", "c")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": 0, "$2": 1, "$3": -1}]  
```  
  
####  <a name="bk_left"></a> LEFT  
 Возвращает левую часть строки с указанным количеством символов.  
  
 **Синтаксис**  
  
```  
LEFT(<str_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает левую часть строки "abc" для значений различной длины.  
  
```  
SELECT LEFT("abc", 1), LEFT("abc", 2)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "a", "$2": "ab"}]  
```  
  
####  <a name="bk_length"></a> LENGTH  
 Возвращает число символов указанного строкового выражения.  
  
 **Синтаксис**  
  
```  
LENGTH(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает длину строки.  
  
```  
SELECT LENGTH("abc")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": 3}]  
```  
  
####  <a name="bk_lower"></a> LOWER  
 Возвращает строковое выражение после преобразования символов верхнего регистра в нижний.  
  
 **Синтаксис**  
  
```  
LOWER(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Ниже представлен пример использования функции LOWER в запросе.  
  
```  
SELECT LOWER("Abc")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "abc"}]  
  
```  
  
####  <a name="bk_ltrim"></a> LTRIM  
 Возвращает строковое выражение после удаления начальных пробелов.  
  
 **Синтаксис**  
  
```  
LTRIM(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Ниже представлен пример использования функции LTRIM в запросе.  
  
```  
SELECT LTRIM("  abc"), LTRIM("abc"), LTRIM("abc   ")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "abc", "$2": "abc", "$3": "abc   "}]  
```  
  
####  <a name="bk_replace"></a> REPLACE  
 Заменяет все вхождения указанного строкового значения другим строковым значением.  
  
 **Синтаксис**  
  
```  
REPLACE(<str_expr>, <str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Ниже представлен пример использования функции REPLACE в запросе.  
  
```  
SELECT REPLACE("This is a Test", "Test", "desk")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "This is a desk"}]  
```  
  
####  <a name="bk_replicate"></a> REPLICATE  
 Повторяет строковое значение указанное число раз.  
  
 **Синтаксис**  
  
```  
REPLICATE(<str_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Ниже представлен пример использования функции REPLICATE в запросе.  
  
```  
SELECT REPLICATE("a", 3)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "aaa"}]  
```  
  
####  <a name="bk_reverse"></a> REVERSE  
 Возвращает обратный порядок строкового значения.  
  
 **Синтаксис**  
  
```  
REVERSE(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Ниже представлен пример использования функции REVERSE в запросе.  
  
```  
SELECT REVERSE("Abc")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "cbA"}]  
```  
  
####  <a name="bk_right"></a> RIGHT  
 Возвращает правую часть строки с указанным количеством символов.  
  
 **Синтаксис**  
  
```  
RIGHT(<str_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает правую часть строки "abc" для значений различной длины.  
  
```  
SELECT RIGHT("abc", 1), RIGHT("abc", 2)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "c", "$2": "bc"}]  
```  
  
####  <a name="bk_rtrim"></a> RTRIM  
 Возвращает строковое выражение после удаления конечных пробелов.  
  
 **Синтаксис**  
  
```  
RTRIM(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Ниже представлен пример использования функции RTRIM в запросе.  
  
```  
SELECT RTRIM("  abc"), RTRIM("abc"), RTRIM("abc   ")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "   abc", "$2": "abc", "$3": "abc"}]  
```  
  
####  <a name="bk_startswith"></a> STARTSWITH  
 Возвращает значение логического типа, указывающее, начинается ли первое строковое выражение вторым.  
  
 **Синтаксис**  
  
```  
STARTSWITH(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Пример ниже проверяет, начинается ли строка "abc" с "b" и "a".  
  
```  
SELECT STARTSWITH("abc", "b"), STARTSWITH("abc", "a")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": false, "$2": true}]  
```  
  
####  <a name="bk_substring"></a> SUBSTRING  
 Возвращает часть строкового выражения, начиная с указанной позиции (отсчет начинается с нуля) и до достижения указанной длины (или до конца строки).  
  
 **Синтаксис**  
  
```  
SUBSTRING(<str_expr>, <num_expr> [, <num_expr>])  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Пример ниже возвращает подстроку "abc", которая начинается с 1 и имеет длину в 1 знак.  
  
```  
SELECT SUBSTRING("abc", 1, 1)  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "b"}]  
```  
  
####  <a name="bk_upper"></a> UPPER  
 Возвращает строковое выражение после преобразования символов нижнего регистра в верхний.  
  
 **Синтаксис**  
  
```  
UPPER(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Ниже представлен пример использования функции UPPER в запросе.  
  
```  
SELECT UPPER("Abc")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": "ABC"}]  
```  
  
###  <a name="bk_array_functions"></a> Функции массивов  
 Следующие скалярные функции выполняют операцию над входным массивом и возвращают числовое или логическое значение, либо массив.  
  
||||  
|-|-|-|  
|[ARRAY_CONCAT](#bk_array_concat)|[ARRAY_CONTAINS](#bk_array_contains)|[ARRAY_LENGTH](#bk_array_length)|  
|[ARRAY_SLICE](#bk_array_slice)|||  
  
####  <a name="bk_array_concat"></a> ARRAY_CONCAT  
 Возвращает массив, который является результатом объединения значений двух или более массивов.  
  
 **Синтаксис**  
  
```  
ARRAY_CONCAT (<arr_expr>, <arr_expr> [, <arr_expr>])  
```  
  
 **Аргументы**  
  
-   `arr_expr`  
  
     Любое допустимое выражение массива.  
  
 **Типы возвращаемого значения**  
  
 Возвращает выражение массива.  
  
 **Примеры**  
  
 В примере ниже показано, как объединить два массива.  
  
```  
SELECT ARRAY_CONCAT(["apples", "strawberries"], ["bananas"])  
```  
  
 Результирующий набор:  
  
```  
[{"$1": ["apples", "strawberries", "bananas"]}]  
```  
  
####  <a name="bk_array_contains"></a> ARRAY_CONTAINS  
Возвращает логическое значение, указывающее, содержит ли массив указанное значение. Можно указать, будет ли сопоставление полным или частичным. 

 **Синтаксис**  
  
```  
ARRAY_CONTAINS (<arr_expr>, <expr> [, bool_expr])  
```  
  
 **Аргументы**  
  
-   `arr_expr`  
  
     Любое допустимое выражение массива.  
  
-   `expr`  
  
     Любое допустимое выражение.  

-   `bool_expr`  
  
     Любое логическое выражение.       
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое значение.  
  
 **Примеры**  
  
 В примере ниже показано, как проверить членство в массиве с помощью функции ARRAY_CONTAINS.  
  
```  
SELECT   
           ARRAY_CONTAINS(["apples", "strawberries", "bananas"], "apples"),  
           ARRAY_CONTAINS(["apples", "strawberries", "bananas"], "mangoes")  
```  
  
 Результирующий набор:  
  
```  
[{"$1": true, "$2": false}]  
```  

 В примере ниже показано, как проверить частичное совпадение JSON в массиве с помощью функции ARRAY_CONTAINS.  
  
```  
SELECT  
    ARRAY_CONTAINS([{"name": "apples", "fresh": true}, {"name": "strawberries", "fresh": true}], {"name": "apples"}, true), 
    ARRAY_CONTAINS([{"name": "apples", "fresh": true}, {"name": "strawberries", "fresh": true}], {"name": "apples"}),
    ARRAY_CONTAINS([{"name": "apples", "fresh": true}, {"name": "strawberries", "fresh": true}], {"name": "mangoes"}, true) 
```  
  
 Результирующий набор:  
  
```  
[{
  "$1": true,
  "$2": false,
  "$3": false
}] 
```  
  
####  <a name="bk_array_length"></a> ARRAY_LENGTH  
 Возвращает число элементов массива, указанного в выражении.  
  
 **Синтаксис**  
  
```  
ARRAY_LENGTH(<arr_expr>)  
```  
  
 **Аргументы**  
  
-   `arr_expr`  
  
     Любое допустимое выражение массива.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 В примере ниже показано, как получить длину массива с помощью функции ARRAY_LENGTH.  
  
```  
SELECT ARRAY_LENGTH(["apples", "strawberries", "bananas"])  
```  
  
 Результирующий набор:  
  
```  
[{"$1": 3}]  
```  
  
####  <a name="bk_array_slice"></a> ARRAY_SLICE  
 Возвращает часть выражения массива.
  
 **Синтаксис**  
  
```  
ARRAY_SLICE (<arr_expr>, <num_expr> [, <num_expr>])  
```  
  
 **Аргументы**  
  
-   `arr_expr`  
  
     Любое допустимое выражение массива.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое значение.  
  
 **Примеры**  
  
 В примере ниже показано, как получить часть массива с помощью функции ARRAY_SLICE.  
  
```  
SELECT   
           ARRAY_SLICE(["apples", "strawberries", "bananas"], 1),  
           ARRAY_SLICE(["apples", "strawberries", "bananas"], 1, 1)  
```  
  
 Результирующий набор:  
  
```  
[{  
           "$1": ["strawberries", "bananas"],   
           "$2": ["strawberries"]  
       }]  
```  
  
###  <a name="bk_spatial_functions"></a> Пространственные функции  
 Скалярные функции выполняют операцию над входным пространственным объектом и возвращают числовое или логическое значение.  
  
||||  
|-|-|-|  
|[ST_DISTANCE](#bk_st_distance)|[ST_WITHIN](#bk_st_within)|[ST_INTERSECTS](#bk_st_intersects)|[ST_ISVALID](#bk_st_isvalid)|  
|[ST_ISVALIDDETAILED](#bk_st_isvaliddetailed)|||  
  
####  <a name="bk_st_distance"></a> ST_DISTANCE  
 Возвращает расстояние между двумя выражениями точек GeoJSON, многоугольников или объектов LineString.  
  
 **Синтаксис**  
  
```  
ST_DISTANCE (<spatial_expr>, <spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение, указывающее расстояние. При использовании эталонной системы по умолчанию это значение указывается в метрах.  
  
 **Примеры**  
  
 В примере ниже показано, как вернуть все документы семейств, которые находятся в пределах 30 км от заданного расположения, с помощью встроенной функции ST_DISTANCE. .  
  
```  
SELECT f.id   
FROM Families f   
WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000  
```  
  
 Результирующий набор:  
  
```  
[{  
  "id": "WakefieldFamily"  
}]  
```  
  
####  <a name="bk_st_within"></a> ST_WITHIN  
 Возвращает логическое выражение, указывающее, располагается ли объект GeoJSON (точка, многоугольник или LineString), указанный в первом аргументе, внутри второго объекта GeoJSON (точка, многоугольник или LineString).  
  
 **Синтаксис**  
  
```  
ST_WITHIN (<spatial_expr>, <spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
 
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое значение.  
  
 **Примеры**  
  
 В следующем примере показано, как найти все документы семейства внутри многоугольника с помощью функции ST_WITHIN.  
  
```  
SELECT f.id   
FROM Families f   
WHERE ST_WITHIN(f.location, {  
    'type':'Polygon',   
    'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]  
})  
```  
  
 Результирующий набор:  
  
```  
[{ "id": "WakefieldFamily" }]  
```  

####  <a name="bk_st_intersects"></a> ST_INTERSECTS  
 Возвращает логическое выражение, указывающее, пересекается ли объект GeoJSON (точка, многоугольник или LineString), указанный в первом аргументе, со вторым объектом GeoJSON (точка, многоугольник или LineString).  
  
 **Синтаксис**  
  
```  
ST_INTERSECTS (<spatial_expr>, <spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
 
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое значение.  
  
 **Примеры**  
  
 В примере ниже показано, как найти все области, пересекающиеся с заданным многоугольником.  
  
```  
SELECT a.id   
FROM Areas a   
WHERE ST_INTERSECTS(a.location, {  
    'type':'Polygon',   
    'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]  
})  
```  
  
 Результирующий набор:  
  
```  
[{ "id": "IntersectingPolygon" }]  
```  
  
####  <a name="bk_st_isvalid"></a> ST_ISVALID  
 Возвращает логическое значение, указывающее, является ли действительным выражение GeoJSON (точка, многоугольник или LineString).  
  
 **Синтаксис**  
  
```  
ST_ISVALID(<spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение GeoJSON (точка, многоугольник или LineString).  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 В примере ниже показано, как проверить допустимость точки с помощью функции ST_VALID.  
  
 Например, эта точка может иметь значение широты, которое не входит в допустимый диапазон значений (от –90 до 90), из-за чего запрос возвращает значение false.  
  
 По спецификации GeoJSON для многоугольника последняя пара координат должна совпадать с первой, чтобы фигура стала замкнутой. Точки внутри многоугольника должны указываться в порядке против часовой стрелки. Если точки указаны в порядке по часовой стрелке, то многоугольник представляет регион, расположенный снаружи от него.  
  
```  
SELECT ST_ISVALID({ "type": "Point", "coordinates": [31.9, -132.8] })  
```  
  
 Результирующий набор:  
  
```  
[{ "$1": false }]  
```  
  
####  <a name="bk_st_isvaliddetailed"></a> ST_ISVALIDDETAILED  
 Возвращает значение JSON, содержащее логическое значение, указывающее, является ли выражение GeoJSON (точка, многоугольник или LineString) действительным. Если оно является недействительным, то возвращаемое значение также содержит строку с описанием причины.  
  
 **Синтаксис**  
  
```  
ST_ISVALID(<spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение точки или многоугольника GeoJSON.  
  
 **Типы возвращаемого значения**  
  
 Возвращает значение JSON, содержащее логическое значение, указывающее, является ли выражение точки или многоугольника GeoJSON действительным. Если оно является недействительным, возвращаемое значение также содержит строку с описанием причины.  
  
 **Примеры**  
  
 В примере ниже показано, как проверить допустимость (с подробными сведениями) с помощью функции ST_ISVALIDDETAILED.  
  
```  
SELECT ST_ISVALIDDETAILED({   
  "type": "Polygon",   
  "coordinates": [[ [ 31.8, -5 ], [ 31.8, -4.7 ], [ 32, -4.7 ], [ 32, -5 ] ]]  
})  
```  
  
 Результирующий набор:  
  
```  
[{  
  "$1": {   
    "valid": false,   
    "reason": "The Polygon input is not valid because the start and end points of the ring number 1 are not the same. Each ring of a polygon must have the same start and end points."   
  }  
}]  
```  
  
## <a name="next-steps"></a>Дополнительная информация  
 [SQL-запросы и синтаксис SQL в Azure Cosmos DB](sql-api-sql-query.md)   
 [Документация по базе данных Azure Cosmos](https://docs.microsoft.com/azure/cosmos-db/)  
  
  
