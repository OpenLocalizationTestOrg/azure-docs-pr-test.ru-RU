---
title: "Уникальные ключи в Azure Cosmos DB | Документация Майкрософт"
description: "Узнайте, как использовать уникальные ключи в базе данных Azure Cosmos DB."
services: cosmos-db
keywords: "ограничение уникального ключа, нарушение ограничения уникального ключа"
author: rafats
manager: jhubbard
editor: monicar
documentationcenter: 
ms.assetid: b15d5041-22dd-491e-a8d5-a3d18fa6517d
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 11/27/2017
ms.author: rafats
ms.openlocfilehash: c530b34edf9bfa0651b7b114dcf7e8add0d906ed
ms.sourcegitcommit: 0e4491b7fdd9ca4408d5f2d41be42a09164db775
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/14/2017
---
# <a name="unique-keys-in-azure-cosmos-db"></a>Уникальные ключи в Azure Cosmos DB

Уникальные ключи предоставляют разработчикам возможность добавить слой целостности данных в базу данных. Создавая политику уникальных ключей при создании контейнера, вы гарантируете уникальность одного или нескольких значений [ключа секции](partition-data.md). После создания контейнера с политикой уникальных ключей он предотвращает создание любых новых или обновленных элементов со значениями, которые дублируют значения, заданные с помощью уникального ограничения ключа.   

> [!NOTE]
> Последние версии поддерживаемых уникальных ключей [.NET](sql-api-sdk-dotnet.md) и [.NET Core](sql-api-sdk-dotnet-core.md) SDK SQL и [MongoDB API](mongodb-feature-support.md#unique-indexes). API таблицы и API Graph в текущее время не поддерживают уникальные ключи. 
> 
>

## <a name="use-case"></a>Вариант использования 

Например, рассмотрим как пользовательская база данных, связанная с приложением [социальных сетей](use-cases.md#web-and-mobile-applications), может получить преимущества от политики уникальных ключей для адресов электронной почты. Сделав адрес электронной почты пользователя уникальным ключом, убедитесь, что каждая запись имеет уникальный адрес электронной почты и что невозможно создать запись с дублирующимся адресом электронной почты. 

Если нужно, чтобы пользователи могли для создавать нескольких записей с одним адресом электронной почты, но не с тем же именем, фамилией и адресом электронной почты, можно добавить другие пути для политики уникальных ключей. Поэтому вместо создания уникального ключа, который просто основан на адресе электронной почты, можно создать уникальный ключ, который представляет собой комбинацию имени, фамилии и электронной почты. В этом случае каждая уникальная комбинация из трех путей разрешена, поэтому база данных может содержать элементы, которые имеют следующие значения пути. Каждая из этих записей передала бы политику уникальных ключей.  

**Допустимые значения для уникального ключа столбцов firstName, lastName и адрес электронной почты**

|Имя|Фамилия|Адрес электронной почты|
|---|---|---|
|Гэби|Дюперре|gaby@contoso.com |
|Гэби|Дюперре|gaby@fabrikam.com|
|Иван|Дюперре|gaby@fabrikam.com|
|    |Дюперре|gaby@fabrikam.com|
|    |       |gaby@fabraikam.com|

При попытке вставить другую запись с любым сочетанием, которые перечислены в приведенной выше таблице, вы получите сообщение об ошибке, указывающее, что ограничение уникального ключа не выполнено. Azure Cosmos DB возвращается ошибку "Ресурс с указанными идентификатором или именем уже существует" или "Ресурс с определенным идентификатором, именем или уникальным индексом уже существует". 

## <a name="using-unique-keys"></a>Использование уникальных ключей

Уникальные ключи должны быть определены при создании контейнера, а уникальный ключ привязан к ключу секции. Чтобы использовать предыдущий пример, если секция основана на почтовом индексе, можно получить записи из таблицы, которые дублируются в каждой секции.

Имеющиеся контейнеры нельзя обновить для использования уникальных ключей.

После создания контейнера с политикой уникальных ключей политику можно изменить только при повторном создании контейнера. При наличии данных, в которых нужно реализовать уникальные ключи, создайте контейнер и используйте соответствующее средство миграции данных, чтобы перенести данные в новый контейнер. Контейнеры SQL используйте [средство переноса данных](import-data.md). Для контейнеров MongoDB используйте [mongoimport.exe или mongorestore.exe](mongodb-migrate.md).

В каждый уникальный ключ можно включить до 16 значений путей (например, /firstName, /lastName, /address/zipCode и т. д.) 

Каждая политика уникальных ключей может иметь не более 10 ограничений уникальных ключей или сочетаний. Таким образом пример выше, который использует имя, фамилию и адрес электронной почты, является только одним ограничением и использует три из 16 возможных путей. 

Затраты единиц запросов для создания, обновления и удаления элемента значительно выше при наличии в контейнере политики уникальных ключей. 

Разреженные уникальные ключи не поддерживаются. Если значения для некоторых уникальных путей отсутствуют, они рассматриваются как имеющие специальное значение null, которое принимает участие в ограничении уникальности.

## <a name="sql-api-sample"></a>Образец API-интерфейса SQL

В следующем образце кода показано, как создать новый контейнер SQL с двумя ограничения уникального ключа. Первое ограничение — это ограничение по firstName, lastName, адресу электронной почты, описанное в примере выше. Второе ограничение — это адрес или почтовый индекс пользователей. Пример файла JSON, который использует пути в этой политике уникальных ключей, следует примеру кода. 

```csharp
// Create a collection with two separate UniqueKeys, one compound key for /firstName, /lastName,
// and /email, and another for /address/zipCode.
private static async Task CreateCollectionIfNotExistsAsync(string dataBase, string collection)
{
    try
    {
        await client.ReadDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri(dataBase, collection));
    }
    catch (DocumentClientException e)
    {
        if (e.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
            DocumentCollection myCollection = new DocumentCollection();
            myCollection.Id = collection;
            myCollection.PartitionKey.Paths.Add("/pk");
            myCollection.UniqueKeyPolicy = new UniqueKeyPolicy
            {
                UniqueKeys =
                new Collection<UniqueKey>
                {
                    new UniqueKey { Paths = new Collection<string> { "/firstName" , "/lastName" , "/email" }}
                    new UniqueKey { Paths = new Collection<string> { "/address/zipCode" } },

                }
            };
            await client.CreateDocumentCollectionAsync(
                UriFactory.CreateDatabaseUri(dataBase),
                myCollection,
                new RequestOptions { OfferThroughput = 2500 });
        }
        else
        {
            throw;
        }
    }
```

Пример документа JSON.

```json
{
    "id": "1",
    "firstName": "Gaby",
    "lastName": "Duperre",
    "email": "gaby@contoso.com",
    "address": [
        {            
            "line1": "100 Some Street",
            "line2": "Unit 1",
            "city": "Seattle",
            "state": "WA",
            "zipCode": 98012
        }
    ],
}
```
## <a name="mongodb-api-sample"></a>Пример API MongoDB

В следующем примере команды показано, как создать уникальный индекс для полей firstName, lastName и электронной почты коллекции пользователей для MongoDB API. Это гарантирует уникальность комбинации во всех трех полях во всех документах в коллекции. Для коллекций API MongoDB уникальный индекс создается после создания коллекции, но перед ее заполнением.

```
db.users.createIndex( { firstName: 1, lastName: 1, email: 1 }, { unique: true } )
```

## <a name="next-steps"></a>Дальнейшие действия

В этой статье вы узнали, как создавать уникальные ключи для элементов в базе данных. При создании контейнера в первый раз ознакомьтесь со статьей о [секционировании данных в Azure Cosmos DB](partition-data.md), чтобы узнать, как уникальные ключи и ключи секций зависят друг от друга. 


