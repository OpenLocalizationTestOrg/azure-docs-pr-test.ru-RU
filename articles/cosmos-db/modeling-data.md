---
title: "данные документа aaaModeling базы данных NoSQL | Документы Microsoft"
description: "Подробно о моделировании данных для баз данных NoSQL"
keywords: "моделирование данных"
services: cosmos-db
author: arramac
manager: jhubbard
editor: mimig1
documentationcenter: 
ms.assetid: 69521eb9-590b-403c-9b36-98253a4c88b5
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/29/2016
ms.author: arramac
ms.openlocfilehash: 2e388c833f204287896dfa8e6f79c88073731b6b
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="modeling-document-data-for-nosql-databases"></a>Моделирование данных документов для базы данных NoSQL
Пока без схемы базах данных, таких как Azure Cosmos DB, легко super tooembrace изменения tooyour используемой модели данных по-прежнему необходимо потратить некоторое время думать о данных. 

Как происходит toobe хранимых данных? Как обеспечивается непрерывная tooretrieve и запроса данных приложения? Ориентировано ли ваше приложение на запись или на чтение? 

После считывания в этой статье, можно будет tooanswer hello следующие вопросы:

* Как следует представлять документ в базе данных?
* Что такое моделирование данных и почему оно так важно? 
* Как обеспечивается моделирования данных документа базы данных другой tooa реляционной базы данных?
* Как выразить связи данных в нереляционной базе данных?
* При внедрении данных и если связать toodata?

## <a name="embedding-data"></a>Внедрение данных
При запуске моделирования данных в хранилище документа, например Azure Cosmos DB, попробуйте tootreat объекты в виде **самодостаточным документы** представлены в формате JSON.

Прежде чем углубляться в подробности, давайте вернемся немного назад и рассмотрим, как можно смоделировать что-либо в реляционной базе данных, ведь многим из нас уже знакома эта тема. Hello следующем примере показано, как пользователь может сохранить в реляционной базе данных. 

![Модель реляционной базы данных](./media/documentdb-modeling-data/relational-data-model.png)

При работе с реляционными базами данных, мы были при изучении для toonormalize лет нормализации, нормализации.

Нормализация данных обычно подразумевает создание сущности, такие как лицо и распределением в toodiscrete части данных. В приведенном выше примере hello пользователь может иметь несколько записей контактной информации, а также несколько записей адресов. Мы пойдем еще дальше и разобьем сведения о контактах, извлекая общие поля, такие как тип. Аналогично и для адреса — здесь каждая запись имеет тип, такой как *Home* или *Business*. 

Привет, руководствуясь локальных при нормализации данных слишком**избежать хранения избыточных данных** на каждой записи и вместо ссылки toodata. В этом примере tooread обладающий все контактные сведения и адреса, необходимо toouse СОЕДИНЕНИЯ tooeffectively статистических данных во время выполнения.

    SELECT p.FirstName, p.LastName, a.City, cd.Detail
    FROM Person p
    JOIN ContactDetail cd ON cd.PersonId = p.Id
    JOIN ContactDetailType on cdt ON cdt.Id = cd.TypeId
    JOIN Address a ON a.PersonId = p.Id

Чтобы обновить сведения о контактах и адреса для отдельного человека, требуется выполнить операции записи для множества отдельных таблиц. 

Теперь давайте же Здравствуйте, взгляните на том, как мы модели данных как автономная сущность в базе данных документа.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "addresses": [
            {            
                "line1": "100 Some Street",
                "line2": "Unit 1",
                "city": "Seattle",
                "state": "WA",
                "zip": 98012
            }
        ],
        "contactDetails": [
            {"email: "thomas@andersen.com"},
            {"phone": "+1 555 555-5555", "extension": 5555}
        ] 
    }

Использование hello выше у нас есть теперь **денормализованные** hello записи лица где мы **внедренные** Здравствуйте, все сведения, касающиеся toothis пользователями, например свои контактные сведения и адреса, в одном tooa Документ JSON.
Кроме того так как мы не будете ограничены tooa фиксированную схему, мы hello гибкость toodo таких вещей, как полностью наличие контактные сведения различные формы. 

Получение записи полный человек из базы данных hello теперь является отдельной операции в одной коллекции, а для одного документа чтения. Обновление сведений о контактах и адресов в записи человека также обеспечивается одной операцией записи, выполняемой для одного документа.

По Денормализация данных, приложение должно tooissue меньшее число запросов и обновлений toocomplete распространенных операций. 

### <a name="when-tooembed"></a>Когда tooembed
В общем случае модели внедренных данных следует использовать в следующих ситуациях:

* между сущностями существуют связи **contains** ;
* между сущностями существуют связи **один к нескольким** ;
* имеются внедренные данные, которые **редко изменяются**;
* имеются внедренные данные, которые не разрастаются **неограниченно**;
* Внедренные данные, **целый** toodata в документе.

> [!NOTE]
> Обычно модели денормализованных данных обеспечивают повышенную производительность при **чтении** .
> 
> 

### <a name="when-not-tooembed"></a>Если не tooembed
Хотя hello правило в базе данных документа является toodenormalize все, что и внедрить все данные в одном документе tooa, это может привести toosome ситуациях, в которых следует избегать.

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "name": "What's new in hello coolest Cloud",
        "summary": "A blog post by someone real famous",
        "comments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from hello interwebs"},
            …
            {"id": 100001, "author": "jane", "comment": "and on we go ..."},
            …
            {"id": 1000000001, "author": "angry", "comment": "blah angry blah angry"},
            …
            {"id": ∞ + 1, "author": "bored", "comment": "oh man, will this ever end?"},
        ]
    }

Так могла бы выглядеть сущность публикации с внедренными комментариями, если бы мы моделировали обычный блог или систему CMS. Hello проблема с этим примером является, hello комментарии массив **unbounded**, это означает, что отсутствует номер toohello (практического) ограничения комментариев, может иметь любую одну публикацию. Станет проблемы как размер hello hello документа может значительно расти.

Как размер hello hello документа увеличивается hello возможность tootransmit hello данных по линии связи hello, а также чтение и обновление hello в документе шкалы, будут затронуты.

В этом случае было бы лучше hello tooconsider модели.

    Post document:
    {
        "id": "1",
        "name": "What's new in hello coolest Cloud",
        "summary": "A blog post by someone real famous",
        "recentComments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from hello interwebs"},
            {"id": 3, "author": "jane", "comment": "....."}
        ]
    }

    Comment documents:
    {
        "postId": "1"
        "comments": [
            {"id": 4, "author": "anon", "comment": "more goodness"},
            {"id": 5, "author": "bob", "comment": "tails from hello field"},
            ...
            {"id": 99, "author": "angry", "comment": "blah angry blah angry"}
        ]
    },
    {
        "postId": "1"
        "comments": [
            {"id": 100, "author": "anon", "comment": "yet more"},
            ...
            {"id": 199, "author": "bored", "comment": "will this ever end?"}
        ]
    }

Эта модель имеет hello трех последних комментарии на hello учет себя, который является массивом с фиксированной границей времени. Hello других комментариев группируются в toobatches 100 комментариев и хранятся в виде отдельных документов. Hello размер пакета hello был выбран как 100, потому что наши вымышленные приложения позволяет hello комментарии 100 tooload пользователей одновременно.  

Другой случай, когда внедренные данные не рекомендуется при hello внедренных данных часто используются в документах и часто изменяются. 

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            {
                "numberHeld": 100,
                "stock": { "symbol": "zaza", "open": 1, "high": 2, "low": 0.5 }
            },
            {
                "numberHeld": 50,
                "stock": { "symbol": "xcxc", "open": 89, "high": 93.24, "low": 88.87 }
            }
        ]
    }

Этот код может представлять биржевой портфель человека. Мы выбрали tooembed hello биржевых данных в документе tooeach портфеля. В среде, где связанные данные изменяется часто, как биржевая, торговых приложения внедрение часто изменяемых данных будет toomean, что каждый раз был продан stock постоянно обновляется каждый документ портфеля.

В течение дня акции *zaza* могут покупать и продавать сотни раз, и *zaza* могут входить в портфели тысяч пользователей. С моделью данных, таких как hello выше мы бы tooupdate нескольких тысяч документов портфеля много раз каждый день ведущая tooa, не очень хорошо масштабируются. 

## <a id="Refer"></a>Использование ссылок на данные
Таким образом, внедрение данных отлично подходит для многих ситуаций, однако совершенно ясно, что существуют сценарии, в которых денормализация данных вызовет больше проблем, чем поможет решить. Что же нам делать теперь? 

Реляционные базы данных не являются hello единственное место, где можно создавать связи между сущностями. В базе данных документов могут иметь сведения в одном документе, который фактически связывает toodata в других документах. Теперь я хочу не рекомендуют даже одну минуту мы создаем системы, которые были бы лучше подходит tooa или реляционную базу данных в базе данных Azure Cosmos любая другая база данных документа, но простые отношения допустимы и может быть очень полезно. 

В hello JSON ниже мы выбрали пример hello toouse портфеля акций из ранее но в этот раз мы называем элемент склада toohello по портфелю hello вместо его внедрения. Таким образом, элемент склада hello часто изменяются на протяжении hello день hello только документ, который требуется обновить toobe при биржевых однооконный hello. 

    Person document:
    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            { "numberHeld":  100, "stockId": 1},
            { "numberHeld":  50, "stockId": 2}
        ]
    }

    Stock documents:
    {
        "id": "1",
        "symbol": "zaza",
        "open": 1,
        "high": 2,
        "low": 0.5,
        "vol": 11970000,
        "mkt-cap": 42000000,
        "pe": 5.89
    },
    {
        "id": "2",
        "symbol": "xcxc",
        "open": 89,
        "high": 93.24,
        "low": 88.87,
        "vol": 2970200,
        "mkt-cap": 1005000,
        "pe": 75.82
    }


Подход toothis немедленно недостаток хотя является ли приложение tooshow необходимые сведения о каждой из них, который проводится при отображении портфолио человека; в этом случае потребуется toomake несколько приема-передачи toohello tooload hello сведения о базе данных для каждого документа акций. Здесь мы сделали решение tooimprove hello эффективность операций записи, которые происходить часто в hello дня, но в свою очередь компрометации на hello операций чтения, потенциально оказывает меньшее влияние на производительность hello этой конкретной системы.

> [!NOTE]
> Нормализованных моделей данных **может потребоваться несколько циклов приема-передачи** toohello сервера.
> 
> 

### <a name="what-about-foreign-keys"></a>Сведения о внешнем ключе
Так как в настоящее время не используется понятие ограничения, внешнего ключа или в противном случае — все связи между документов, имеющих в документах фактически являются «слабой ссылки» и не будут проверены по самой базы данных hello. Если требуется, чтобы tooensure, hello данных, который ссылается документ tooactually существует, то потребуется toodo в приложении, или с помощью hello серверных триггеров или хранимых процедур в базе данных Azure Cosmos.

### <a name="when-tooreference"></a>Когда tooreference
В общем случае модели нормализованных данных следует использовать в следующих ситуациях:

* Осуществляется представление связей **один ко многим** .
* Осуществляется представление связей **многие ко многим** .
* Связанные данные **часто изменяются**.
* Данные, на которые указывает ссылка, могут быть **неограниченными**.

> [!NOTE]
> Обычно нормализация обеспечивает повышенную производительность при **записи** .
> 
> 

### <a name="where-do-i-put-hello-relationship"></a>Места размещения hello связи?
рост Hello отношения «hello» поможет определить, в которых документ toostore hello.

Если взглянуть на hello JSON ниже, моделирующее издателей и книг.

    Publisher document:
    {
        "id": "mspress",
        "name": "Microsoft Press",
        "books": [ 1, 2, 3, ..., 100, ..., 1000]
    }

    Book documents:
    {"id": "1", "name": "Azure Cosmos DB 101" }
    {"id": "2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "3", "name": "Taking over hello world one JSON doc at a time" }
    ...
    {"id": "100", "name": "Learn about Azure Cosmos DB" }
    ...
    {"id": "1000", "name": "Deep Dive in tooAzure Cosmos DB" }

При небольших с ограниченной роста hello количество книг hello по издателю последующее сохранение ссылки книги hello внутри документа hello издателя может пригодиться. Однако если unbounded hello количество книг по издателю, эта модель данных приведет toomutable, растет массивы как документе издателю hello пример выше. 

Переключение предметы немного бы результат в модели, но теперь hello и те же данные по-прежнему представляет позволяет избежать эти большие изменяемой коллекции.

    Publisher document: 
    {
        "id": "mspress",
        "name": "Microsoft Press"
    }

    Book documents: 
    {"id": "1","name": "Azure Cosmos DB 101", "pub-id": "mspress"}
    {"id": "2","name": "Azure Cosmos DB for RDBMS Users", "pub-id": "mspress"}
    {"id": "3","name": "Taking over hello world one JSON doc at a time"}
    ...
    {"id": "100","name": "Learn about Azure Cosmos DB", "pub-id": "mspress"}
    ...
    {"id": "1000","name": "Deep Dive in tooAzure Cosmos DB", "pub-id": "mspress"}

В приведенном выше примере hello, мы удалили hello unbounded коллекции hello издателя документа. Вместо этого мы просто у издателя toohello ссылку на каждом документе книги.

### <a name="how-do-i-model-manymany-relationships"></a>Как моделировать связи "многие ко многим"
В реляционной базе данных связи *многие ко многим* часто моделируются с помощью таблиц JOIN, которые просто соединяют вместе записи из других таблиц. 

![Объединенные таблицы](./media/documentdb-modeling-data/join-table.png)

Может быть удобным средством tooreplicate hello же результата с помощью документов и создания модели данных, которая выглядит примерно следующие toohello.

    Author documents: 
    {"id": "a1", "name": "Thomas Andersen" }
    {"id": "a2", "name": "William Wakefield" }

    Book documents:
    {"id": "b1", "name": "Azure Cosmos DB 101" }
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "b3", "name": "Taking over hello world one JSON doc at a time" }
    {"id": "b4", "name": "Learn about Azure Cosmos DB" }
    {"id": "b5", "name": "Deep Dive in tooAzure Cosmos DB" }

    Joining documents: 
    {"authorId": "a1", "bookId": "b1" }
    {"authorId": "a2", "bookId": "b1" }
    {"authorId": "a1", "bookId": "b2" }
    {"authorId": "a1", "bookId": "b3" }

Такой подход будет работать. Тем не менее загрузка автора с их книг или Загрузка книги с его автор всегда потребуется по меньшей мере два дополнительных запросов к hello базы данных. Объединение документов и еще один запрос toofetch hello непосредственно документа присоединяемых toohello один запрос. 

Если эта таблица JOIN всего лишь соединяет два элемента данных, почему бы просто не отказаться от нее?
Рассмотрим следующие hello.

    Author documents:
    {"id": "a1", "name": "Thomas Andersen", "books": ["b1, "b2", "b3"]}
    {"id": "a2", "name": "William Wakefield", "books": ["b1", "b4"]}

    Book documents: 
    {"id": "b1", "name": "Azure Cosmos DB 101", "authors": ["a1", "a2"]}
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users", "authors": ["a1"]}
    {"id": "b3", "name": "Learn about Azure Cosmos DB", "authors": ["a1"]}
    {"id": "b4", "name": "Deep Dive in tooAzure Cosmos DB", "authors": ["a2"]}

Теперь если у меня автора, немедленно узнать, какие книги был разработан и и наоборот, если у меня возникли загруженного документа книги я знаю hello идентификаторы авторов hello. Это экономит, промежуточный запрос к hello соединяемой таблице уменьшение числа hello server циклов приема-передачи приложение имеет toomake. 

## <a id="WrapUp"></a>Гибридные модели данных
Мы рассмотрели внедрение данных (или денормализацию) и использование ссылок на данные (или нормализацию), а также преимущества и недостатки этих подходов. 

Он не всегда имеют toobe либо или, не быть сущности Испуганные toomix копирование немного. 

На основе определенных шаблонов использования и рабочих нагрузок, которые могут быть случаи, где смешивание внедренные приложения и ссылочных данных имеет смысл удалось логику приложения toosimpler интереса с сервером меньшее число циклов приема-передачи отказываясь высокого уровня производительности .

Рассмотрим следующий JSON hello. 

    Author documents: 
    {
        "id": "a1",
        "firstName": "Thomas",
        "lastName": "Andersen",        
        "countOfBooks": 3,
         "books": ["b1", "b2", "b3"],
        "images": [
            {"thumbnail": "http://....png"}
            {"profile": "http://....png"}
            {"large": "http://....png"}
        ]
    },
    {
        "id": "a2",
        "firstName": "William",
        "lastName": "Wakefield",
        "countOfBooks": 1,
        "books": ["b1"],
        "images": [
            {"thumbnail": "http://....png"}
        ]
    }

    Book documents:
    {
        "id": "b1",
        "name": "Azure Cosmos DB 101",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "http://....png"},
            {"id": "a2", "name": "William Wakefield", "thumbnailUrl": "http://....png"}
        ]
    },
    {
        "id": "b2",
        "name": "Azure Cosmos DB for RDBMS Users",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "http://....png"},
        ]
    }

Здесь мы (обычно) выполнили hello внедренную модель, где внедренные данные из других сущностей в hello верхнего уровня документа, но упоминается других данных. 

Если взглянуть на документе книги hello, мы видим, несколько интересных поля при рассмотрении массива hello авторов. Отсутствует *идентификатор* поле, являющееся поле hello, мы используем toorefer задней tooan автор документа, стандартные рекомендации по Нормализованная модель, а затем мы также имеют *имя* и *thumbnailUrl*. Мы может просто использовали *идентификатор* левого tooget приложения hello дополнительную информацию, помогающую его из соответствующих автор документа hello, с помощью hello «связи», но, поскольку наше приложение отображает имя автора hello и a эскиз рисунка с каждой книги отображается мы можно сохранить сервере toohello кругового пути на книги в списке, денормализации **некоторые** данные автора hello.

Убедитесь, что, если изменено имя автора hello или было tooupdate их фотография будет toogo обновление всех книг они никогда не опубликована, но для нашего приложения, исходя из предположения hello авторы не изменяют очень часто, их имена это допустимого конструктора решение.  

В примере hello **предварительно вычисляемых агрегатов** значения toosave ресурсов обработки на операции чтения. В примере hello некоторые из данных hello, внедренных в hello автор документа является данных, вычисляемых во время выполнения. Создается каждый раз при публикации новой книги документа книги **и** hello countOfBooks задано значение tooa вычисляется на основании hello число документов в книге, существующих для определенной автора. Эта оптимизация бы хорошо чтения больших систем, где может позволить вычислений toodo при записи в порядке toooptimize чтений.

Здравствуйте, toohave возможности модели с предварительно вычисляемыми полями стало возможным, так как Azure Cosmos DB поддерживает **транзакции с несколькими документами**. Многих хранилищ NoSQL нельзя выполнить транзакции для документов и поэтому представление проектные решения, такие как «всегда встраивать все», из-за ограничений toothis. В Azure Cosmos DB вы можете использовать триггеры на стороне сервера или хранимые процедуры, которые вставляют книги и обновляют авторов в рамках транзакции ACID. Теперь вы не **имеют** tooembed tooone все содержимое документа просто toobe в том, что данные остаются неизменными.

## <a name="NextSteps"></a>Дальнейшие действия
Hello крупнейших общие выводы из этой статьи — toounderstand, что в мире без схемы моделирования данных будет столь же важно как никогда. 

Так же, как есть не единый способ toorepresent фрагмента данных на экране, нет не единый способ toomodel данных. Требуется toounderstand приложения и каким образом будут получены, получать и обрабатывать данные hello. Затем применяя некоторые hello рекомендации, описанные ниже, вы можно задать о создании модели, учитывающие hello немедленным потребностям приложения. Приложения должны toochange, позволяет эффективно использовать гибкость hello tooembrace без схемы базы данных, изменение и легко развить модели данных. 

toolearn Дополнительные сведения о базе данных Azure Cosmos, см. Служба toohello [документации](https://azure.microsoft.com/documentation/services/cosmos-db/) страницы. 

toounderstand как tooshard данные по нескольким секциям, см. слишком[секционирование данных в базе данных Azure Cosmos](documentdb-partition-data.md). 
