---
title: "Моделирование данных документов для базы данных NoSQL | Документы Майкрософт"
description: "Подробно о моделировании данных для баз данных NoSQL"
keywords: "моделирование данных"
services: cosmos-db
author: arramac
manager: jhubbard
editor: mimig1
documentationcenter: 
ms.assetid: 69521eb9-590b-403c-9b36-98253a4c88b5
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/29/2016
ms.author: arramac
ms.openlocfilehash: 16c387fe574243544cf54cf283c7713ddcaa1942
ms.sourcegitcommit: 6699c77dcbd5f8a1a2f21fba3d0a0005ac9ed6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2017
---
# <a name="modeling-document-data-for-nosql-databases"></a>Моделирование данных документов для базы данных NoSQL
Хотя базы данных без схем, такие как Azure Cosmos DB, существенно упрощают внесение изменений в модель данных, вам все равно следует уделить время анализу ситуации с данными. 

Как данные будут храниться? Как приложение будет получать данные и выполнять запросы по ним? Ориентировано ли ваше приложение на запись или на чтение? 

После прочтения этой статьи вы сможете ответить на следующие вопросы:

* Как следует представлять документ в базе данных?
* Что такое моделирование данных и почему оно так важно? 
* Чем различается моделирование данных в базе данных документов и в реляционной базе данных?
* Как выразить связи данных в нереляционной базе данных?
* Когда следует внедрять данные, а когда — связывать?

## <a name="embedding-data"></a>Внедрение данных
Когда вы начинаете моделировать данные в хранилище документов, таком как Azure Cosmos DB, попробуйте обрабатывать свои сущности как **самодостаточные документы**, представленные в формате JSON.

Прежде чем углубляться в подробности, давайте вернемся немного назад и рассмотрим, как можно смоделировать что-либо в реляционной базе данных, ведь многим из нас уже знакома эта тема. В следующем примере показано, как можно сохранить в реляционной базе данных человека. 

![Модель реляционной базы данных](./media/documentdb-modeling-data/relational-data-model.png)

При работе с реляционными базами данных мы в течение многих лет учимся одному — нормализовать, нормализовать, нормализовать.

Нормализация данных обычно заключается в том, чтобы взять сущность, например человека, и разбить ее на отдельные элементы данных. В приведенном выше примере человек может иметь несколько записей со сведениями о контактах, а также несколько записей с адресом. Мы пойдем еще дальше и разобьем сведения о контактах, извлекая общие поля, такие как тип. Аналогично и для адреса — здесь каждая запись имеет тип, такой как *Home* или *Business*. 

Руководящий принцип при нормализации данных заключается в том, чтобы **избегать хранения избыточных данных** в каждой записи и использовать только ссылки на эти данные. Чтобы в данном примере считать данные о человеке со всеми его сведениями контактах и адресами, необходимо использовать операторы JOIN для эффективной агрегации данных во время выполнения.

    SELECT p.FirstName, p.LastName, a.City, cd.Detail
    FROM Person p
    JOIN ContactDetail cd ON cd.PersonId = p.Id
    JOIN ContactDetailType on cdt ON cdt.Id = cd.TypeId
    JOIN Address a ON a.PersonId = p.Id

Чтобы обновить сведения о контактах и адреса для отдельного человека, требуется выполнить операции записи для множества отдельных таблиц. 

А сейчас давайте рассмотрим, как смоделировать аналогичные данные в виде самодостаточной сущности в базе данных документов.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "addresses": [
            {            
                "line1": "100 Some Street",
                "line2": "Unit 1",
                "city": "Seattle",
                "state": "WA",
                "zip": 98012
            }
        ],
        "contactDetails": [
            {"email: "thomas@andersen.com"},
            {"phone": "+1 555 555-5555", "extension": 5555}
        ] 
    }

Согласно описанному выше подходу, мы выполнили **денормализацию** записи человека, куда была **внедрена** такая информация, как сведения о контактах и адреса, получив отдельный документ JSON.
Кроме того, отсутствие привязки к фиксированной схеме повышает гибкость работы, например, мы можем использовать сведения о контактах в самых разных формах. 

Получение всей записи человека из базы данных теперь обеспечивается одной операцией чтения, выполняемой для одной коллекции и отдельного документа. Обновление сведений о контактах и адресов в записи человека также обеспечивается одной операцией записи, выполняемой для одного документа.

Благодаря денормализации данных ваше приложение может использовать меньше запросов и обновлений для выполнения распространенных операций. 

### <a name="when-to-embed"></a>Когда следует использовать внедрение
В общем случае модели внедренных данных следует использовать в следующих ситуациях:

* между сущностями существуют связи **contains** ;
* между сущностями существуют связи **один к нескольким** ;
* имеются внедренные данные, которые **редко изменяются**;
* имеются внедренные данные, которые не разрастаются **неограниченно**;
* имеются внедренные данные, которые составляют **целое** с данными в документе.

> [!NOTE]
> Обычно модели денормализованных данных обеспечивают повышенную производительность при **чтении** .
> 
> 

### <a name="when-not-to-embed"></a>Когда внедрение использовать не следует
Хотя основной подход для базы данных документов заключается в том, чтобы выполнить денормализацию всех элементов и внедрить все данные в один документ, это может привести к некоторым нежелательным ситуациям.

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "name": "What's new in the coolest Cloud",
        "summary": "A blog post by someone real famous",
        "comments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
            …
            {"id": 100001, "author": "jane", "comment": "and on we go ..."},
            …
            {"id": 1000000001, "author": "angry", "comment": "blah angry blah angry"},
            …
            {"id": ∞ + 1, "author": "bored", "comment": "oh man, will this ever end?"},
        ]
    }

Так могла бы выглядеть сущность публикации с внедренными комментариями, если бы мы моделировали обычный блог или систему CMS. Проблема с данным примером заключается в том, что массив комментариев является **неограниченным**, то есть не существует (фактического) предела для количества комментариев, которое может иметь отдельная публикация. Это станет источником проблем, так как размер документа может значительно вырасти.

По мере роста размера документа пропорционально ухудшается возможность передачи данных, а также чтения и обновления документа.

В этом случае лучше рассмотреть следующую модель.

    Post document:
    {
        "id": "1",
        "name": "What's new in the coolest Cloud",
        "summary": "A blog post by someone real famous",
        "recentComments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
            {"id": 3, "author": "jane", "comment": "....."}
        ]
    }

    Comment documents:
    {
        "postId": "1"
        "comments": [
            {"id": 4, "author": "anon", "comment": "more goodness"},
            {"id": 5, "author": "bob", "comment": "tails from the field"},
            ...
            {"id": 99, "author": "angry", "comment": "blah angry blah angry"}
        ]
    },
    {
        "postId": "1"
        "comments": [
            {"id": 100, "author": "anon", "comment": "yet more"},
            ...
            {"id": 199, "author": "bored", "comment": "will this ever end?"}
        ]
    }

В этом модели три последних комментария внедрены в саму публикацию, которая здесь представлена массивом фиксированного размера. Другие комментарии сгруппированы в пакеты по 100 штук и сохранены в отдельных документах. Размер пакета был выбран равным 100, поскольку наше условное приложение позволяет пользователю отправить 100 комментариев за один раз.  

Кроме того внедрение данных нельзя назвать удачным решением там, где эти данные часто используются в разных документах и постоянно изменяются. 

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            {
                "numberHeld": 100,
                "stock": { "symbol": "zaza", "open": 1, "high": 2, "low": 0.5 }
            },
            {
                "numberHeld": 50,
                "stock": { "symbol": "xcxc", "open": 89, "high": 93.24, "low": 88.87 }
            }
        ]
    }

Этот код может представлять биржевой портфель человека. Мы решили внедрить информацию об акциях в каждый документ портфеля. В среде, где связанные данные регулярно изменяются, например, в приложении биржевых торгов, внедрение часто изменяемых данных означает, что вы постоянно обновляете каждый документ портфеля при выполнении торговой операции с каждой акцией.

В течение дня акции *zaza* могут покупать и продавать сотни раз, и *zaza* могут входить в портфели тысяч пользователей. В случае использования описанной выше модели данных нам пришлось бы обновлять многие тысячи документов портфелей каждый день, что затруднило бы масштабирование системы. 

## <a id="Refer"></a>Использование ссылок на данные
Таким образом, внедрение данных отлично подходит для многих ситуаций, однако совершенно ясно, что существуют сценарии, в которых денормализация данных вызовет больше проблем, чем поможет решить. Что же нам делать теперь? 

Связи между сущностями можно задавать не только в реляционных базах данных. В базе данных документов можно поместить в один документ сведения, которые ссылаются на данные в других документах. Я не спорю, что мы создаем системы, которые лучше подходят для реляционной базы данных в Azure Cosmos DB или любой другой базы данных документов, однако простые связи легко реализуются и могут оказаться очень удобны в работе. 

В приведенном ниже коде JSON мы решили использовать использованный ранее пример биржевого портфеля, однако здесь мы не внедряем элемент акции в портфеле, а ссылаемся на него. Если элемент акции часто изменяется в течение дня, то обновлять требуется единственный документ акции. 

    Person document:
    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            { "numberHeld":  100, "stockId": 1},
            { "numberHeld":  50, "stockId": 2}
        ]
    }

    Stock documents:
    {
        "id": "1",
        "symbol": "zaza",
        "open": 1,
        "high": 2,
        "low": 0.5,
        "vol": 11970000,
        "mkt-cap": 42000000,
        "pe": 5.89
    },
    {
        "id": "2",
        "symbol": "xcxc",
        "open": 89,
        "high": 93.24,
        "low": 88.87,
        "vol": 2970200,
        "mkt-cap": 1005000,
        "pe": 75.82
    }


Недостаток такого подхода проявляется, когда приложению нужно отобразить информацию о каждой имеющейся акции в портфеле человека; в этом случае потребуется выполнить множество обращений к базе данных, чтобы загрузить информацию для каждого документа акции. Здесь мы приняли решение повысить эффективность операций записи, которые часто выполняются в течение дня, однако это затруднило выполнение операций чтения, которые оказывают меньшее влияние на производительность всей данной системы.

> [!NOTE]
> Модели нормализованных данных **могут потребовать больше круговых путей** к серверу.
> 
> 

### <a name="what-about-foreign-keys"></a>Сведения о внешнем ключе
Поскольку в настоящий момент концепция ограничения, основанная на внешнем ключе или чем-либо другом, отсутствует, все связи между документами представляют собой "слабые звенья" и не проверяются базой данных. Если вы хотите убедиться, что данные, на которые ссылается документ, действительно существуют, это нужно сделать в приложении либо с помощью триггеров на стороне сервера или хранимых процедур в Azure Cosmos DB.

### <a name="when-to-reference"></a>Когда следует использовать ссылки
В общем случае модели нормализованных данных следует использовать в следующих ситуациях:

* Осуществляется представление связей **один ко многим** .
* Осуществляется представление связей **многие ко многим** .
* Связанные данные **часто изменяются**.
* Данные, на которые указывает ссылка, могут быть **неограниченными**.

> [!NOTE]
> Обычно нормализация обеспечивает повышенную производительность при **записи** .
> 
> 

### <a name="where-do-i-put-the-relationship"></a>Куда следует поместить связь
Рост связи поможет определить, в каком документе следует сохранить ссылку.

Давайте рассмотрим следующий код JSON, моделирующий издателей и книги.

    Publisher document:
    {
        "id": "mspress",
        "name": "Microsoft Press",
        "books": [ 1, 2, 3, ..., 100, ..., 1000]
    }

    Book documents:
    {"id": "1", "name": "Azure Cosmos DB 101" }
    {"id": "2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "3", "name": "Taking over the world one JSON doc at a time" }
    ...
    {"id": "100", "name": "Learn about Azure Cosmos DB" }
    ...
    {"id": "1000", "name": "Deep Dive in to Azure Cosmos DB" }

Если на издателя приходится небольшое число книг, а рост ограничен, то может оказаться удобным хранить ссылку на книгу в документе издателя. Однако если число книг на издателя не имеет ограничений, эта модель данных приведет к изменяемым и разрастающимся массивам, как в приведенном выше примере с документом издателя. 

Небольшая доработка помогает получить модель, которая все еще представляет те же данные, однако избавляется от крупных изменяемых коллекций.

    Publisher document: 
    {
        "id": "mspress",
        "name": "Microsoft Press"
    }

    Book documents: 
    {"id": "1","name": "Azure Cosmos DB 101", "pub-id": "mspress"}
    {"id": "2","name": "Azure Cosmos DB for RDBMS Users", "pub-id": "mspress"}
    {"id": "3","name": "Taking over the world one JSON doc at a time"}
    ...
    {"id": "100","name": "Learn about Azure Cosmos DB", "pub-id": "mspress"}
    ...
    {"id": "1000","name": "Deep Dive in to Azure Cosmos DB", "pub-id": "mspress"}

В приведенном выше примере мы помещали неограниченную коллекцию в документ издателя. Вместо этого мы просто воспользуемся ссылкой на издателя в каждом документе книги.

### <a name="how-do-i-model-manymany-relationships"></a>Как моделировать связи "многие ко многим"
В реляционной базе данных связи *многие ко многим* часто моделируются с помощью таблиц JOIN, которые просто соединяют вместе записи из других таблиц. 

![Объединенные таблицы](./media/documentdb-modeling-data/join-table.png)

У вас может возникнуть желание реплицировать это с помощью документов и создать модель данных, аналогичную приведенной ниже.

    Author documents: 
    {"id": "a1", "name": "Thomas Andersen" }
    {"id": "a2", "name": "William Wakefield" }

    Book documents:
    {"id": "b1", "name": "Azure Cosmos DB 101" }
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "b3", "name": "Taking over the world one JSON doc at a time" }
    {"id": "b4", "name": "Learn about Azure Cosmos DB" }
    {"id": "b5", "name": "Deep Dive in to Azure Cosmos DB" }

    Joining documents: 
    {"authorId": "a1", "bookId": "b1" }
    {"authorId": "a2", "bookId": "b1" }
    {"authorId": "a1", "bookId": "b2" }
    {"authorId": "a1", "bookId": "b3" }

Такой подход будет работать. Однако при загрузке автора вместе с его книгами или книги вместе с ее автором всегда потребуется отправлять два дополнительных запроса в базу данных. Один запрос отправляется в документ присоединения, а другой — для получения самого присоединяемого документа. 

Если эта таблица JOIN всего лишь соединяет два элемента данных, почему бы просто не отказаться от нее?
Давайте рассмотрим следующее.

    Author documents:
    {"id": "a1", "name": "Thomas Andersen", "books": ["b1, "b2", "b3"]}
    {"id": "a2", "name": "William Wakefield", "books": ["b1", "b4"]}

    Book documents: 
    {"id": "b1", "name": "Azure Cosmos DB 101", "authors": ["a1", "a2"]}
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users", "authors": ["a1"]}
    {"id": "b3", "name": "Learn about Azure Cosmos DB", "authors": ["a1"]}
    {"id": "b4", "name": "Deep Dive in to Azure Cosmos DB", "authors": ["a2"]}

Если у меня есть автор, я сразу же узнаю, какие книги он написал, и наоборот, если у меня загружен документ книги, я получу сведения об авторе. Это позволяет отказаться от промежуточного запроса к таблице JOIN и сократить количество круговых путей для вашего приложения. 

## <a id="WrapUp"></a>Гибридные модели данных
Мы рассмотрели внедрение данных (или денормализацию) и использование ссылок на данные (или нормализацию), а также преимущества и недостатки этих подходов. 

Однако далеко не всегда следует придерживаться лишь одного из подходов, можно попробовать совместить их. 

Учитывая применяемые в приложении схемы использования и рабочие нагрузки, в некоторых случаях совмещение внедрения и ссылок может иметь смысл и позволяет упростить логическую схему приложения, сократить число круговых путей к серверу и при этом сохранить высокий уровень производительности.

Давайте рассмотрим следующий код JSON. 

    Author documents: 
    {
        "id": "a1",
        "firstName": "Thomas",
        "lastName": "Andersen",        
        "countOfBooks": 3,
         "books": ["b1", "b2", "b3"],
        "images": [
            {"thumbnail": "http://....png"}
            {"profile": "http://....png"}
            {"large": "http://....png"}
        ]
    },
    {
        "id": "a2",
        "firstName": "William",
        "lastName": "Wakefield",
        "countOfBooks": 1,
        "books": ["b1"],
        "images": [
            {"thumbnail": "http://....png"}
        ]
    }

    Book documents:
    {
        "id": "b1",
        "name": "Azure Cosmos DB 101",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "http://....png"},
            {"id": "a2", "name": "William Wakefield", "thumbnailUrl": "http://....png"}
        ]
    },
    {
        "id": "b2",
        "name": "Azure Cosmos DB for RDBMS Users",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "http://....png"},
        ]
    }

Здесь мы в большей степени придерживались модели внедрения, где данные из других сущностей внедряются в документ верхнего уровня, однако для остальных данных используются ссылки. 

Если взглянуть на документ книги, можно заметить несколько интересных полей в массиве авторов. Существует поле *id*, которое используется для обратной ссылки на документ автора, что является стандартным решением в модели нормализации, однако также присутствуют поля *name* и *thumbnailUrl*. Мы могли бы ограничиться полем *id* и заставить приложение получать всю необходимую информацию из соответствующего документа автора с использованием "ссылки", но поскольку наше приложение выводит имя автора и эскиз для каждой отображаемой книги, мы можем сэкономить по одному круговому пути к серверу на каждую книгу в списке, выполнив денормализацию **некоторых** данных об авторе.

Естественно, в случае изменения имени автора или обновления его фотографии нам пришлось бы обновить каждую опубликованную им книгу, однако в нашем приложении такое решение вполне уместно, поскольку авторы довольно редко меняют свои имена.  

В примере используются значения **предварительно вычисленных статистических выражений** , чтобы сэкономить вычислительные ресурсы на операции чтения. В данном примере некоторые данные, внедренные в документ автора, вычисляются во время выполнения. Каждый раз при публикации новой книги создается документ книги, **и** для поля countOfBooks задается вычисленное значение, зависящее от числа существующих для данного автора документов книги. Такая оптимизация хорошо подходит для систем с большим количеством операций чтения, где можно выполнять вычисления в операциях записи для повышения производительности операций чтения.

Использование модели с предварительно вычисленными значениями в полях стало возможным благодаря тому, что Azure Cosmos DB поддерживает **транзакции с несколькими документами**. Многие хранилища NoSQL не позволяют выполнять транзакции между документами, что вынуждает слепо следовать правилу "всегда внедряйте все, что можно". В Azure Cosmos DB вы можете использовать триггеры на стороне сервера или хранимые процедуры, которые вставляют книги и обновляют авторов в рамках транзакции ACID. Теперь вам не **обязательно** внедрять все в один документ просто для того, чтобы обеспечить согласованность данных.

## <a name="NextSteps"></a>Дальнейшие действия
Основная идея этой статьи заключается в том, что моделирование данных без фиксированных схем не теряет своей актуальности. 

Как не существует единственного способа представить элемент данных на экране, нет такого способа и для моделирования данных. Необходимо разобраться в принципах работы приложения, его механизмах формирования, использования и обработки данных. После этого с помощью представленных здесь рекомендаций вы можете приступить к созданию модели, которая оптимально соответствует основным потребностям вашего приложения. Благодаря отсутствию схемы в базе данных вы можете оперативно вносить изменения в приложения и легко корректировать модель данных соответствующим образом. 

Дополнительные сведения об Azure Cosmos DB см. на странице [документации](https://azure.microsoft.com/documentation/services/cosmos-db/) по этой службе. 

Чтобы понять, как сегментировать данные по нескольким разделам, ознакомьтесь со статьей [Секционирование, ключи секции и масштабирование в DocumentDB](documentdb-partition-data.md). 
