---
title: "Секционирование и горизонтальное масштабирование в базе данных Azure Cosmos DB"
description: "Сведения о работе секционирования в базе данных Azure Cosmos DB, настройке секционирования и ключей секций, а также о выборе подходящего ключа секции для вашего приложения."
services: cosmos-db
author: arramac
manager: jhubbard
editor: monicar
documentationcenter: 
ms.assetid: cac9a8cd-b5a3-4827-8505-d40bb61b2416
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/10/2017
ms.author: arramac
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: e2d2847276e553d7511241ff323c3e00aad8e5c9
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/03/2017
---
# <a name="how-to-partition-and-scale-in-azure-cosmos-db"></a>Секционирование и масштабирование в базе данных Azure Cosmos DB

[База данных Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) — это глобально распределенная, многомодельная служба базы данных, созданная для обеспечения высокой производительности и прогнозируемости, а также легкой масштабируемости по мере расширения вашего приложения. В этой статье рассматривается, как работает секционирование для всех моделей данных в базе данных Azure Cosmos DB, и описывается, как настроить контейнеры базы данных Azure Cosmos DB для эффективного масштабирования ваших приложений.

Секционирование и ключи секций также рассматриваются в этом видео из цикла "Azure, пятница" от Скотта Хансельмана (Scott Hanselman) и главного технического руководителя базы данных Azure Cosmos DB, Ширеша Тоты (Shireesh Thota).

> [!VIDEO https://channel9.msdn.com/Shows/Azure-Friday/Azure-DocumentDB-Elastic-Scale-Partitioning/player]
> 

## <a name="partitioning-in-azure-cosmos-db"></a>Секционирование в базе данных Azure Cosmos DB
В базе данных Azure Cosmos DB можно хранить данные без схемы и запрашивать их, получая ответ за миллисекунды вне зависимости от масштаба. База данных Cosmos DB предоставляет контейнеры для хранения данных, которые называются **коллекциями (для документов), графами или таблицами**. Контейнеры — это логические ресурсы, они могут включать в себя одну или несколько физических секций или серверов. Число секций определяется базой данных Azure Cosmos DB по размеру хранилища и пропускной способности, выделенных для контейнера. С каждой секцией в базе данных Azure Cosmos DB связано фиксированное количество хранилищ на основе SSD, которое реплицируется для обеспечения высокого уровня доступности. Управление секциями полностью осуществляется базой данных Azure Cosmos DB, и нет необходимости создавать сложный код или управлять секциями. Контейнеры базы данных Azure Cosmos DB не ограничены в плане хранения и пропускной способности. 

![horizontal](./media/introduction/azure-cosmos-db-partitioning.png) 

Секционирование прозрачно для вашего приложения. База данных Cosmos DB поддерживает высокую скорость чтения и записи, запросы, логику транзакции, уровни согласованности и точное управление доступом с помощью методов и API для одного ресурса контейнера. Служба обрабатывает распределение данных в секциях и направляет запросы в нужную секцию. 

Как работает секционирование Каждый элемент должен иметь ключ секции и ключ строки, которые однозначно идентифицируют его. Ключ секции выступает в качестве логической секции для ваших данных и предоставляет базе данных Cosmos DB естественную границу для распределения данных между секциями. Вот как работает секционирование в базе данных Azure Cosmos DB:

* Вы подготавливаете контейнер базы данных Cosmos DB с пропускной способностью `T` запросов в секунду.
* В это время база данных Cosmos DB подготавливает необходимое число секций для обслуживания `T` запросов. Если `T` больше, чем максимальная пропуская способность на секцию `t`, тогда база данных Cosmos DB подготавливает такое количество секций: `N` = `T/t`.
* База данных Cosmos DB распределяет пространство хэшей ключей секций равномерно по `N` секциям. Таким образом, каждая секция (физическая секция) содержит значения ключа секции 1-N (логические секции).
* Когда физическая секция `p` достигает предельного размера хранилища, база данных Cosmos DB разделяет `p` на две новые секции (`p1` и `p2`) и распределяет значения, соответствующие примерно половине ключей, в каждую из секций. Эта операция разделения незаметна для вашего приложения.
* Аналогичным образом, когда вы обеспечиваете пропускную способность выше пропускной способности `t*N`, база данных Cosmos DB разбивает одну или несколько секций для поддержки более высокой пропускной способности.

Семантика для ключей секций несколько отличается, чтобы соответствовать семантике каждого API, как показано в следующей таблице.

| API | Ключ раздела | Ключ строки |
| --- | --- | --- |
| DocumentDB | пользовательский путь к ключу секции | фиксированное значение `id` | 
| MongoDB | пользовательский ключ сегмента  | фиксированное значение `_id` | 
| График | свойство пользовательского ключа секции | фиксированное значение `id` | 
| Таблица | фиксированное значение `PartitionKey` | фиксированное значение `RowKey` | 

База данных Cosmos DB использует секционирование на основе хэша. При написании элемента база данных Cosmos DB хэширует значение ключа секции и использует хэшированный результат, чтобы определить, в какой секции сохранить элемент. База данных Cosmos DB сохраняет все элементы с помощью одного ключа в одной физической секции. Выбор ключа секции — важное решение, которое придется принять на этапе проектирования. Необходимо выбрать имя свойства, которое имеет широкий диапазон значений и шаблоны доступа.

> [!NOTE]
> Мы советуем иметь ключ секции с большим количеством уникальных значений (как минимум сотней и тысячей).
>

Контейнеры базы данных Azure Cosmos DB могут быть созданы как фиксированные или неограниченные. Контейнеры фиксированного размера имеют максимальный размер в 10 ГБ и пропускную способность в 10 000 ЕЗ в секунду. Некоторые API позволяют исключить ключ секции для контейнеров фиксированного размера. Чтобы создать контейнер неограниченного размера, необходимо указать минимальную пропускную способность в 2500 ЕЗ в секунду.

## <a name="partitioning-and-provisioned-throughput"></a>Секционирование и подготовленная пропускная способность
База данных Cosmos DB предназначена для обеспечения прогнозируемой производительности. При создании контейнера вы резервируете пропускную способность в виде **[единиц запроса](request-units.md) (ЕЗ) в секунду с потенциальной надстройкой для ЕЗ в минуту**. На каждый запрос расходуется определенное число единиц запроса, пропорциональное объему системных ресурсов, например ЦП, память, и операций ввода-вывода, потребляемых операцией. Чтение документа размером 1 КБ с согласованностью сеанса потребляет 1 единицу запроса. На операцию чтения требуется 1 единица запроса вне зависимости от числа хранящихся элементов или количества параллельных запросов, выполняемых одновременно. Элементы большего размера требуют больше единиц запроса. Если вы знаете размер сущностей и количество операций чтения, необходимых для работы вашего приложения, то можете подготовить точную величину пропускной способности, необходимую приложению для операций чтения. 

> [!NOTE]
> Чтобы достичь полной пропускной способности контейнера, необходимо выбрать ключ секции, который позволяет равномерно распределять запросы по нескольким разным значениям ключа секции.
> 
> 

<a name="designing-for-partitioning"></a>
## <a name="working-with-the-azure-cosmos-db-apis"></a>Работа с API базы данных Azure Cosmos DB
Вы можете использовать портал Azure или Azure CLI для создания контейнеров и их масштабирования в любое время. В этом разделе показано, как создать контейнеры и указать пропускную способность и определение ключа секции в каждом из поддерживаемых API.

### <a name="documentdb-api"></a>API DocumentDB
В следующем примере показано, как создать контейнер (коллекцию) с помощью API DocumentDB. Дополнительные сведения см. в статье [Секционирование, ключи секции и масштабирование в DocumentDB](partition-data.md).

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

Вы можете считать элемент (документ) с помощью метода `GET` в REST API или `ReadDocumentAsync` в одном из пакетов SDK.

```csharp
// Read document. Needs the partition key and the ID to be specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

### <a name="mongodb-api"></a>API MongoDB
С помощью API MongoDB вы можете создать сегментированную коллекцию, используя предпочитаемый инструмент, драйвер или пакет SDK. В этом примере для создания коллекции мы используем оболочку Mongo.

В оболочке Mongo:

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
Результат:

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a>API таблицы

С помощью API таблицы вы можете указать пропускную способность для таблиц в конфигурации appSettings для своего приложения:

```xml
<configuration>
    <appSettings>
      <!--Table creation options -->
      <add key="TableThroughput" value="700"/>
    </appSettings>
</configuration>
```

Затем вы создаете таблицу с использованием пакета SDK для хранилища таблиц Azure. Ключ секции неявно создается как значение `PartitionKey`. 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists();
```

Следующий фрагмент кода позволяет извлечь одну сущность:

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute the retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
Дополнительные сведения см. в статье [Azure Cosmos DB: Develop with the Table API in .NET](tutorial-develop-table-dotnet.md) (База данных Azure Cosmos. Разработка с помощью API таблиц в .NET).

### <a name="graph-api"></a>API Graph

С API Graph для создания контейнеров вам необходимо использовать портал Azure или CLI. Кроме того, так как база данных Azure Cosmos DB многомодельна, можно выбрать другую ее модель для создания и масштабирования контейнера графов.

Вы можете прочитать любую вершину или ребро, используя ключ секции и идентификатор в Gremlin. Например, для графа с регионом США в качестве ключа секции и Сиетлом в качестве ключа строки вы можете найти вершину, используя следующий синтаксис:

```
g.V(['USA', 'Seattle'])
```

Аналогично и с ребрами — вы можете ссылаться на ребро с помощью ключа секции и строки.

```
g.E(['USA', 'I5'])
```

Дополнительные сведения см. в статье [Azure Cosmos DB Gremlin graph support](gremlin-support.md) (Поддержка графа Gremlin для базы данных Azure Cosmos DB).


<a name="designing-for-partitioning"></a>
## <a name="designing-for-partitioning"></a>Проектирование секционирования
Для эффективного масштабирования базы данных Azure Cosmos DB при создании контейнера необходимо выбрать подходящий ключ секции. Существует две основные рекомендации по выбору ключа секции.

* **Ограничение для запросов и транзакций**: выбранный ключ секции должен сбалансировать необходимость использования транзакций и требование к распределению сущностей по нескольким ключам секции для реализации масштабируемого решения. С одной стороны, можно задать один ключ секции для всех элементов, но это может ограничить масштабируемость решения. С другой стороны, можно назначить уникальный ключ секции каждому элементу, что обеспечит высокую масштабируемость, но не позволит использовать транзакции между документами с помощью хранимых процедур и триггеров. Идеальный ключ секции позволяет применять эффективные запросы и обеспечивает достаточную кратность, чтобы гарантировать масштабируемость решения. 
* **Нет узких мест для хранения и производительности**: важно выбрать свойство, которое обеспечивает распределение записей между различными уникальными значениями. Запросы по одному и тому же ключу секции не могут превышать пропускную способность одной секции и регулируются. Поэтому важно выбрать ключ секции, который не создает "горячие точки" в вашем приложении. Так как все данные для ключа отдельной секции должны храниться в пределах секции, рекомендуется также избегать использования ключей секций с большими объемами данных для одного значения. 

Давайте рассмотрим несколько реальных сценариев и подходящие ключи секции для каждого:
* Если вы реализуете серверную часть профиля пользователя, то в качестве ключа секции удобно выбрать идентификатор пользователя.
* Если вы храните данные Интернета вещей, например состояние устройства, то в качестве ключа секции удобно выбрать идентификатор устройства.
* Если вы используете Azure Cosmos DB для ведения журнала данных временных рядов, то в качестве ключа секции удобно выбрать имя узла или идентификатор процесса.
* Если вы используете мультитенантную архитектуру, то в качестве ключа секции удобно выбрать идентификатор клиента.

В некоторых случаях использования (например, Интернет вещей и профили пользователей) ключ секции может быть таким же, как и ваш идентификатор (ключ документа). В других случаях, например для данных временных рядов, может потребоваться ключ секции, который отличается от этого идентификатора.

### <a name="partitioning-and-loggingtime-series-data"></a>Секционирование и ведение журнала (данные временных рядов)
Одним из распространенных вариантов использования базы данных Cosmos DB является ведение журналов и телеметрия. Важно выбрать подходящий ключ секции, поскольку может понадобиться считывать или записывать огромные объемы данных. Выбор зависит от количества операций чтения и записи, а также типов запросов, которые предполагается выполнять. Ниже приведены некоторые советы по выбору подходящего ключа секции.

* Если ваш вариант использования подразумевает небольшое количество операций записи, накапливаемых в течение длительного срока, а также необходимость запроса по диапазонам меток времени и другим фильтрам, то в качестве ключа секции будет уместно использовать свертку метки времени, например дату. Это позволяет выполнять запросы по всем данным для даты из одной секции. 
* Если, как это чаще бывает, рабочая нагрузка подразумевает большое число операций записи, следует использовать ключ секции, который не зависит от метки времени, чтобы база данных Cosmos DB могла выполнять равномерную запись в несколько секций. В этом случае хорошим выбором станет имя узла, идентификатор процесса, идентификатор действия или другое свойство с большим количеством элементов. 
* Третий подход является гибридным. В нем предусмотрено несколько контейнеров — по одному на каждый день и месяц, а ключ секции является фрагментарным свойством, таким как имя узла. Преимущество такого подхода в том, что вы можете задать разные уровни пропускной способности в зависимости от периода. Например, контейнер для текущего месяца подготавливается с более высокой пропускной способностью, так как он обслуживает операции как чтения, так и записи, при этом контейнеры за предыдущие месяцы имеют сниженную пропускную способность, так как обслуживают только чтение.

### <a name="partitioning-and-multi-tenancy"></a>Секционирование и мультитенантность
При реализации мультитенантного приложения с помощью базы данных Cosmos DB существует два популярных шаблона — один ключ секции на клиент и один контейнер на клиент. Ниже приведены преимущества и недостатки каждого из методов.

* Один ключ секции на клиент: в этой модели клиенты совместно размещены в одном контейнере. Однако запросы и операции вставки для элементов в рамках одного клиента можно выполнить с одной секцией. Кроме того, можно реализовать логику транзакций для всех элементов в пределах клиента. Так как несколько клиентов совместно используют один контейнер, можно сократить затраты на хранилище и пропускную способность, организовав пул ресурсов для клиентов в пределах одного контейнера, а не подготавливая дополнительный запас для каждого клиента. Недостатком является отсутствие изоляции производительности каждого клиента. Повышение производительности или пропускной способности действует для всех контейнеров, а не для выбранных клиентов.
* Один контейнер на клиент: каждый клиент имеет собственный контейнер. В этой модели можно резервировать производительность для каждого клиента. Благодаря новой модели ценообразования на основе резервирования для базы данных Cosmos DB, эта модель является более экономичной для мультитенантных приложений с небольшим числом клиентов.

Можно использовать также комбинированный или многоуровневый подход, при котором маленькие клиенты размещаются совместно, а большие переносятся в свои собственные контейнеры.

## <a name="next-steps"></a>Дальнейшие действия
В этой статье мы предоставили обзор концепций и рекомендации для секционирования с использованием любого API базы данных Azure Cosmos DB. 

* Дополнительные сведения о подготовленной пропускной способности в базе данных Azure Cosmos DB см. в [этой статье](request-units.md).
* Узнайте больше о [глобальном распределении в базе данных Azure Cosmos DB](distribute-data-globally.md).



