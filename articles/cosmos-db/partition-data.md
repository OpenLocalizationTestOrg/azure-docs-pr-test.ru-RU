---
title: "Секционирование и горизонтальное масштабирование в базе данных Azure Cosmos DB"
description: "Сведения о работе секционирования в базе данных Azure Cosmos DB, настройке секционирования и ключей секций, а также о выборе подходящего ключа секции для вашего приложения."
services: cosmos-db
author: arramac
manager: jhubbard
editor: monicar
documentationcenter: 
ms.assetid: cac9a8cd-b5a3-4827-8505-d40bb61b2416
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/10/2017
ms.author: arramac
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: e2d2847276e553d7511241ff323c3e00aad8e5c9
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/03/2017
---
# <a name="how-to-partition-and-scale-in-azure-cosmos-db"></a><span data-ttu-id="1a667-103">Секционирование и масштабирование в базе данных Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="1a667-103">How to partition and scale in Azure Cosmos DB</span></span>

<span data-ttu-id="1a667-104">[База данных Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) — это глобально распределенная, многомодельная служба базы данных, созданная для обеспечения высокой производительности и прогнозируемости, а также легкой масштабируемости по мере расширения вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="1a667-104">[Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a global distributed, multi-model database service designed to help you achieve fast, predictable performance and scale seamlessly along with your application as it grows.</span></span> <span data-ttu-id="1a667-105">В этой статье рассматривается, как работает секционирование для всех моделей данных в базе данных Azure Cosmos DB, и описывается, как настроить контейнеры базы данных Azure Cosmos DB для эффективного масштабирования ваших приложений.</span><span class="sxs-lookup"><span data-stu-id="1a667-105">This article provides an overview of how partitioning works for all the data models in Azure Cosmos DB, and describes how you can configure Azure Cosmos DB containers to effectively scale your applications.</span></span>

<span data-ttu-id="1a667-106">Секционирование и ключи секций также рассматриваются в этом видео из цикла "Azure, пятница" от Скотта Хансельмана (Scott Hanselman) и главного технического руководителя базы данных Azure Cosmos DB, Ширеша Тоты (Shireesh Thota).</span><span class="sxs-lookup"><span data-stu-id="1a667-106">Partitioning and partition keys are also covered in this Azure Friday video with Scott Hanselman and Azure Cosmos DB Principal Engineering Manager, Shireesh Thota.</span></span>

> [!VIDEO https://channel9.msdn.com/Shows/Azure-Friday/Azure-DocumentDB-Elastic-Scale-Partitioning/player]
> 

## <a name="partitioning-in-azure-cosmos-db"></a><span data-ttu-id="1a667-107">Секционирование в базе данных Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="1a667-107">Partitioning in Azure Cosmos DB</span></span>
<span data-ttu-id="1a667-108">В базе данных Azure Cosmos DB можно хранить данные без схемы и запрашивать их, получая ответ за миллисекунды вне зависимости от масштаба.</span><span class="sxs-lookup"><span data-stu-id="1a667-108">In Azure Cosmos DB, you can store and query schema-less data with order-of-millisecond response times at any scale.</span></span> <span data-ttu-id="1a667-109">База данных Cosmos DB предоставляет контейнеры для хранения данных, которые называются **коллекциями (для документов), графами или таблицами**.</span><span class="sxs-lookup"><span data-stu-id="1a667-109">Cosmos DB provides containers for storing data called **collections (for document), graphs, or tables**.</span></span> <span data-ttu-id="1a667-110">Контейнеры — это логические ресурсы, они могут включать в себя одну или несколько физических секций или серверов.</span><span class="sxs-lookup"><span data-stu-id="1a667-110">Containers are logical resources and can span one or more physical partitions or servers.</span></span> <span data-ttu-id="1a667-111">Число секций определяется базой данных Azure Cosmos DB по размеру хранилища и пропускной способности, выделенных для контейнера.</span><span class="sxs-lookup"><span data-stu-id="1a667-111">The number of partitions is determined by Cosmos DB based on the storage size and the provisioned throughput of the container.</span></span> <span data-ttu-id="1a667-112">С каждой секцией в базе данных Azure Cosmos DB связано фиксированное количество хранилищ на основе SSD, которое реплицируется для обеспечения высокого уровня доступности.</span><span class="sxs-lookup"><span data-stu-id="1a667-112">Every partition in Cosmos DB has a fixed amount of SSD-backed storage associated with it, and is replicated for high availability.</span></span> <span data-ttu-id="1a667-113">Управление секциями полностью осуществляется базой данных Azure Cosmos DB, и нет необходимости создавать сложный код или управлять секциями.</span><span class="sxs-lookup"><span data-stu-id="1a667-113">Partition management is fully managed by Azure Cosmos DB, and you do not have to write complex code or manage your partitions.</span></span> <span data-ttu-id="1a667-114">Контейнеры базы данных Azure Cosmos DB не ограничены в плане хранения и пропускной способности.</span><span class="sxs-lookup"><span data-stu-id="1a667-114">Cosmos DB containers are unlimited in terms of storage and throughput.</span></span> 

![horizontal](./media/introduction/azure-cosmos-db-partitioning.png) 

<span data-ttu-id="1a667-116">Секционирование прозрачно для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="1a667-116">Partitioning is transparent to your application.</span></span> <span data-ttu-id="1a667-117">База данных Cosmos DB поддерживает высокую скорость чтения и записи, запросы, логику транзакции, уровни согласованности и точное управление доступом с помощью методов и API для одного ресурса контейнера.</span><span class="sxs-lookup"><span data-stu-id="1a667-117">Cosmos DB supports fast reads and writes, queries, transactional logic, consistency levels, and fine-grained access control via methods/APIs to a single container resource.</span></span> <span data-ttu-id="1a667-118">Служба обрабатывает распределение данных в секциях и направляет запросы в нужную секцию.</span><span class="sxs-lookup"><span data-stu-id="1a667-118">The service handles distributing data across partitions and routing query requests to the right partition.</span></span> 

<span data-ttu-id="1a667-119">Как работает секционирование</span><span class="sxs-lookup"><span data-stu-id="1a667-119">How does partitioning work?</span></span> <span data-ttu-id="1a667-120">Каждый элемент должен иметь ключ секции и ключ строки, которые однозначно идентифицируют его.</span><span class="sxs-lookup"><span data-stu-id="1a667-120">Each item must have a partition key and a row key, which uniquely identify it.</span></span> <span data-ttu-id="1a667-121">Ключ секции выступает в качестве логической секции для ваших данных и предоставляет базе данных Cosmos DB естественную границу для распределения данных между секциями.</span><span class="sxs-lookup"><span data-stu-id="1a667-121">Your partition key acts as a logical partition for your data, and provides Cosmos DB with a natural boundary for distributing data across partitions.</span></span> <span data-ttu-id="1a667-122">Вот как работает секционирование в базе данных Azure Cosmos DB:</span><span class="sxs-lookup"><span data-stu-id="1a667-122">In brief, here is how partitioning works in Azure Cosmos DB:</span></span>

* <span data-ttu-id="1a667-123">Вы подготавливаете контейнер базы данных Cosmos DB с пропускной способностью `T` запросов в секунду.</span><span class="sxs-lookup"><span data-stu-id="1a667-123">You provision a Cosmos DB container with `T` requests/s throughput</span></span>
* <span data-ttu-id="1a667-124">В это время база данных Cosmos DB подготавливает необходимое число секций для обслуживания `T` запросов.</span><span class="sxs-lookup"><span data-stu-id="1a667-124">Behind the scenes, Cosmos DB provisions partitions needed to serve `T` requests/s.</span></span> <span data-ttu-id="1a667-125">Если `T` больше, чем максимальная пропуская способность на секцию `t`, тогда база данных Cosmos DB подготавливает такое количество секций: `N` = `T/t`.</span><span class="sxs-lookup"><span data-stu-id="1a667-125">If `T` is higher than the maximum throughput per partition `t`, then Cosmos DB provisions `N` = `T/t` partitions</span></span>
* <span data-ttu-id="1a667-126">База данных Cosmos DB распределяет пространство хэшей ключей секций равномерно по `N` секциям.</span><span class="sxs-lookup"><span data-stu-id="1a667-126">Cosmos DB allocates the key space of partition key hashes evenly across the `N` partitions.</span></span> <span data-ttu-id="1a667-127">Таким образом, каждая секция (физическая секция) содержит значения ключа секции 1-N (логические секции).</span><span class="sxs-lookup"><span data-stu-id="1a667-127">So, each partition (physical partition) hosts 1-N partition key values (logical partitions)</span></span>
* <span data-ttu-id="1a667-128">Когда физическая секция `p` достигает предельного размера хранилища, база данных Cosmos DB разделяет `p` на две новые секции (`p1` и `p2`) и распределяет значения, соответствующие примерно половине ключей, в каждую из секций.</span><span class="sxs-lookup"><span data-stu-id="1a667-128">When a physical partition `p` reaches its storage limit, Cosmos DB seamlessly splits `p` into two new partitions `p1` and `p2` and distributes values corresponding to roughly half the keys to each of the partitions.</span></span> <span data-ttu-id="1a667-129">Эта операция разделения незаметна для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="1a667-129">This split operation is invisible to your application.</span></span>
* <span data-ttu-id="1a667-130">Аналогичным образом, когда вы обеспечиваете пропускную способность выше пропускной способности `t*N`, база данных Cosmos DB разбивает одну или несколько секций для поддержки более высокой пропускной способности.</span><span class="sxs-lookup"><span data-stu-id="1a667-130">Similarly, when you provision throughput higher than `t*N` throughput, Cosmos DB splits one or more of your partitions to support the higher throughput</span></span>

<span data-ttu-id="1a667-131">Семантика для ключей секций несколько отличается, чтобы соответствовать семантике каждого API, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="1a667-131">The semantics for partition keys are slightly different to match the semantics of each API, as shown in the following table:</span></span>

| <span data-ttu-id="1a667-132">API</span><span class="sxs-lookup"><span data-stu-id="1a667-132">API</span></span> | <span data-ttu-id="1a667-133">Ключ раздела</span><span class="sxs-lookup"><span data-stu-id="1a667-133">Partition Key</span></span> | <span data-ttu-id="1a667-134">Ключ строки</span><span class="sxs-lookup"><span data-stu-id="1a667-134">Row Key</span></span> |
| --- | --- | --- |
| <span data-ttu-id="1a667-135">DocumentDB</span><span class="sxs-lookup"><span data-stu-id="1a667-135">DocumentDB</span></span> | <span data-ttu-id="1a667-136">пользовательский путь к ключу секции</span><span class="sxs-lookup"><span data-stu-id="1a667-136">custom partition key path</span></span> | <span data-ttu-id="1a667-137">фиксированное значение `id`</span><span class="sxs-lookup"><span data-stu-id="1a667-137">fixed `id`</span></span> | 
| <span data-ttu-id="1a667-138">MongoDB</span><span class="sxs-lookup"><span data-stu-id="1a667-138">MongoDB</span></span> | <span data-ttu-id="1a667-139">пользовательский ключ сегмента</span><span class="sxs-lookup"><span data-stu-id="1a667-139">custom shard key</span></span>  | <span data-ttu-id="1a667-140">фиксированное значение `_id`</span><span class="sxs-lookup"><span data-stu-id="1a667-140">fixed `_id`</span></span> | 
| <span data-ttu-id="1a667-141">График</span><span class="sxs-lookup"><span data-stu-id="1a667-141">Graph</span></span> | <span data-ttu-id="1a667-142">свойство пользовательского ключа секции</span><span class="sxs-lookup"><span data-stu-id="1a667-142">custom partition key property</span></span> | <span data-ttu-id="1a667-143">фиксированное значение `id`</span><span class="sxs-lookup"><span data-stu-id="1a667-143">fixed `id`</span></span> | 
| <span data-ttu-id="1a667-144">Таблица</span><span class="sxs-lookup"><span data-stu-id="1a667-144">Table</span></span> | <span data-ttu-id="1a667-145">фиксированное значение `PartitionKey`</span><span class="sxs-lookup"><span data-stu-id="1a667-145">fixed `PartitionKey`</span></span> | <span data-ttu-id="1a667-146">фиксированное значение `RowKey`</span><span class="sxs-lookup"><span data-stu-id="1a667-146">fixed `RowKey`</span></span> | 

<span data-ttu-id="1a667-147">База данных Cosmos DB использует секционирование на основе хэша.</span><span class="sxs-lookup"><span data-stu-id="1a667-147">Cosmos DB uses hash-based partitioning.</span></span> <span data-ttu-id="1a667-148">При написании элемента база данных Cosmos DB хэширует значение ключа секции и использует хэшированный результат, чтобы определить, в какой секции сохранить элемент.</span><span class="sxs-lookup"><span data-stu-id="1a667-148">When you write an item, Cosmos DB hashes the partition key value and use the hashed result to determine which partition to store the item in.</span></span> <span data-ttu-id="1a667-149">База данных Cosmos DB сохраняет все элементы с помощью одного ключа в одной физической секции.</span><span class="sxs-lookup"><span data-stu-id="1a667-149">Cosmos DB stores all items with the same partition key in the same physical partition.</span></span> <span data-ttu-id="1a667-150">Выбор ключа секции — важное решение, которое придется принять на этапе проектирования.</span><span class="sxs-lookup"><span data-stu-id="1a667-150">The choice of the partition key is an important decision that you have to make at design time.</span></span> <span data-ttu-id="1a667-151">Необходимо выбрать имя свойства, которое имеет широкий диапазон значений и шаблоны доступа.</span><span class="sxs-lookup"><span data-stu-id="1a667-151">You must pick a property name that has a wide range of values and has even access patterns.</span></span>

> [!NOTE]
> <span data-ttu-id="1a667-152">Мы советуем иметь ключ секции с большим количеством уникальных значений (как минимум сотней и тысячей).</span><span class="sxs-lookup"><span data-stu-id="1a667-152">It is a best practice to have a partition key with many distinct values (100s-1000s at a minimum).</span></span>
>

<span data-ttu-id="1a667-153">Контейнеры базы данных Azure Cosmos DB могут быть созданы как фиксированные или неограниченные.</span><span class="sxs-lookup"><span data-stu-id="1a667-153">Azure Cosmos DB containers can be created as "fixed" or "unlimited."</span></span> <span data-ttu-id="1a667-154">Контейнеры фиксированного размера имеют максимальный размер в 10 ГБ и пропускную способность в 10 000 ЕЗ в секунду.</span><span class="sxs-lookup"><span data-stu-id="1a667-154">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="1a667-155">Некоторые API позволяют исключить ключ секции для контейнеров фиксированного размера.</span><span class="sxs-lookup"><span data-stu-id="1a667-155">Some APIs allow the partition key to be omitted for fixed-size containers.</span></span> <span data-ttu-id="1a667-156">Чтобы создать контейнер неограниченного размера, необходимо указать минимальную пропускную способность в 2500 ЕЗ в секунду.</span><span class="sxs-lookup"><span data-stu-id="1a667-156">To create a container as unlimited, you must specify a minimum throughput of 2500 RU/s.</span></span>

## <a name="partitioning-and-provisioned-throughput"></a><span data-ttu-id="1a667-157">Секционирование и подготовленная пропускная способность</span><span class="sxs-lookup"><span data-stu-id="1a667-157">Partitioning and provisioned throughput</span></span>
<span data-ttu-id="1a667-158">База данных Cosmos DB предназначена для обеспечения прогнозируемой производительности.</span><span class="sxs-lookup"><span data-stu-id="1a667-158">Cosmos DB is designed for predictable performance.</span></span> <span data-ttu-id="1a667-159">При создании контейнера вы резервируете пропускную способность в виде **[единиц запроса](request-units.md) (ЕЗ) в секунду с потенциальной надстройкой для ЕЗ в минуту**.</span><span class="sxs-lookup"><span data-stu-id="1a667-159">When you create a container, you reserve throughput in terms of **[request units](request-units.md) (RU) per second with a potential add-on for RU per minute**.</span></span> <span data-ttu-id="1a667-160">На каждый запрос расходуется определенное число единиц запроса, пропорциональное объему системных ресурсов, например ЦП, память, и операций ввода-вывода, потребляемых операцией.</span><span class="sxs-lookup"><span data-stu-id="1a667-160">Each request is assigned a request unit charge that is proportionate to the amount of system resources like CPU, Memory, and IO consumed by the operation.</span></span> <span data-ttu-id="1a667-161">Чтение документа размером 1 КБ с согласованностью сеанса потребляет 1 единицу запроса.</span><span class="sxs-lookup"><span data-stu-id="1a667-161">A read of a 1-KB document with Session consistency consumes one request unit.</span></span> <span data-ttu-id="1a667-162">На операцию чтения требуется 1 единица запроса вне зависимости от числа хранящихся элементов или количества параллельных запросов, выполняемых одновременно.</span><span class="sxs-lookup"><span data-stu-id="1a667-162">A read is 1 RU regardless of the number of items stored or the number of concurrent requests running at the same time.</span></span> <span data-ttu-id="1a667-163">Элементы большего размера требуют больше единиц запроса.</span><span class="sxs-lookup"><span data-stu-id="1a667-163">Larger items require higher request units depending on the size.</span></span> <span data-ttu-id="1a667-164">Если вы знаете размер сущностей и количество операций чтения, необходимых для работы вашего приложения, то можете подготовить точную величину пропускной способности, необходимую приложению для операций чтения.</span><span class="sxs-lookup"><span data-stu-id="1a667-164">If you know the size of your entities and the number of reads you need to support for your application, you can provision the exact amount of throughput required for your application's read needs.</span></span> 

> [!NOTE]
> <span data-ttu-id="1a667-165">Чтобы достичь полной пропускной способности контейнера, необходимо выбрать ключ секции, который позволяет равномерно распределять запросы по нескольким разным значениям ключа секции.</span><span class="sxs-lookup"><span data-stu-id="1a667-165">To achieve the full throughput of the container, you must choose a partition key that allows you to evenly distribute requests among some distinct partition key values.</span></span>
> 
> 

<a name="designing-for-partitioning"></a>
## <a name="working-with-the-azure-cosmos-db-apis"></a><span data-ttu-id="1a667-166">Работа с API базы данных Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="1a667-166">Working with the Azure Cosmos DB APIs</span></span>
<span data-ttu-id="1a667-167">Вы можете использовать портал Azure или Azure CLI для создания контейнеров и их масштабирования в любое время.</span><span class="sxs-lookup"><span data-stu-id="1a667-167">You can use the Azure portal or Azure CLI to create containers and scale them at any time.</span></span> <span data-ttu-id="1a667-168">В этом разделе показано, как создать контейнеры и указать пропускную способность и определение ключа секции в каждом из поддерживаемых API.</span><span class="sxs-lookup"><span data-stu-id="1a667-168">This section shows how to create containers and specify the throughput and partition key definition in each of the supported APIs.</span></span>

### <a name="documentdb-api"></a><span data-ttu-id="1a667-169">API DocumentDB</span><span class="sxs-lookup"><span data-stu-id="1a667-169">DocumentDB API</span></span>
<span data-ttu-id="1a667-170">В следующем примере показано, как создать контейнер (коллекцию) с помощью API DocumentDB.</span><span class="sxs-lookup"><span data-stu-id="1a667-170">The following sample shows how to create a container (collection) using the DocumentDB API.</span></span> <span data-ttu-id="1a667-171">Дополнительные сведения см. в статье [Секционирование, ключи секции и масштабирование в DocumentDB](partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="1a667-171">You can find more details in [Partitioning with DocumentDB API](partition-data.md).</span></span>

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

<span data-ttu-id="1a667-172">Вы можете считать элемент (документ) с помощью метода `GET` в REST API или `ReadDocumentAsync` в одном из пакетов SDK.</span><span class="sxs-lookup"><span data-stu-id="1a667-172">You can read an item (document) using the `GET` method in the REST API or using `ReadDocumentAsync` in one of the SDKs.</span></span>

```csharp
// Read document. Needs the partition key and the ID to be specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

### <a name="mongodb-api"></a><span data-ttu-id="1a667-173">API MongoDB</span><span class="sxs-lookup"><span data-stu-id="1a667-173">MongoDB API</span></span>
<span data-ttu-id="1a667-174">С помощью API MongoDB вы можете создать сегментированную коллекцию, используя предпочитаемый инструмент, драйвер или пакет SDK.</span><span class="sxs-lookup"><span data-stu-id="1a667-174">With the MongoDB API, you can create a sharded collection through your favorite tool, driver, or SDK.</span></span> <span data-ttu-id="1a667-175">В этом примере для создания коллекции мы используем оболочку Mongo.</span><span class="sxs-lookup"><span data-stu-id="1a667-175">In this example, we use the Mongo Shell for the collection creation.</span></span>

<span data-ttu-id="1a667-176">В оболочке Mongo:</span><span class="sxs-lookup"><span data-stu-id="1a667-176">In the Mongo Shell:</span></span>

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
<span data-ttu-id="1a667-177">Результат:</span><span class="sxs-lookup"><span data-stu-id="1a667-177">Results:</span></span>

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a><span data-ttu-id="1a667-178">API таблицы</span><span class="sxs-lookup"><span data-stu-id="1a667-178">Table API</span></span>

<span data-ttu-id="1a667-179">С помощью API таблицы вы можете указать пропускную способность для таблиц в конфигурации appSettings для своего приложения:</span><span class="sxs-lookup"><span data-stu-id="1a667-179">With the Table API, you specify the throughput for tables in the appSettings configuration for your application:</span></span>

```xml
<configuration>
    <appSettings>
      <!--Table creation options -->
      <add key="TableThroughput" value="700"/>
    </appSettings>
</configuration>
```

<span data-ttu-id="1a667-180">Затем вы создаете таблицу с использованием пакета SDK для хранилища таблиц Azure.</span><span class="sxs-lookup"><span data-stu-id="1a667-180">Then you create a table using the Azure Table storage SDK.</span></span> <span data-ttu-id="1a667-181">Ключ секции неявно создается как значение `PartitionKey`.</span><span class="sxs-lookup"><span data-stu-id="1a667-181">The partition key is implicitly created as the `PartitionKey` value.</span></span> 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists();
```

<span data-ttu-id="1a667-182">Следующий фрагмент кода позволяет извлечь одну сущность:</span><span class="sxs-lookup"><span data-stu-id="1a667-182">You can retrieve a single entity using the following snippet:</span></span>

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute the retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
<span data-ttu-id="1a667-183">Дополнительные сведения см. в статье [Azure Cosmos DB: Develop with the Table API in .NET](tutorial-develop-table-dotnet.md) (База данных Azure Cosmos. Разработка с помощью API таблиц в .NET).</span><span class="sxs-lookup"><span data-stu-id="1a667-183">See [Developing with the Table API](tutorial-develop-table-dotnet.md) for more details.</span></span>

### <a name="graph-api"></a><span data-ttu-id="1a667-184">API Graph</span><span class="sxs-lookup"><span data-stu-id="1a667-184">Graph API</span></span>

<span data-ttu-id="1a667-185">С API Graph для создания контейнеров вам необходимо использовать портал Azure или CLI.</span><span class="sxs-lookup"><span data-stu-id="1a667-185">With the Graph API, you must use the Azure portal or CLI to create containers.</span></span> <span data-ttu-id="1a667-186">Кроме того, так как база данных Azure Cosmos DB многомодельна, можно выбрать другую ее модель для создания и масштабирования контейнера графов.</span><span class="sxs-lookup"><span data-stu-id="1a667-186">Alternatively, since Azure Cosmos DB is multi-model, you can use one of the other models to create and scale your graph container.</span></span>

<span data-ttu-id="1a667-187">Вы можете прочитать любую вершину или ребро, используя ключ секции и идентификатор в Gremlin.</span><span class="sxs-lookup"><span data-stu-id="1a667-187">You can read any vertex or edge using the partition key and id in Gremlin.</span></span> <span data-ttu-id="1a667-188">Например, для графа с регионом США в качестве ключа секции и Сиетлом в качестве ключа строки вы можете найти вершину, используя следующий синтаксис:</span><span class="sxs-lookup"><span data-stu-id="1a667-188">For example, for a graph with region ("USA") as the partition key, and "Seattle" as the row key, you can find a vertex using the following syntax:</span></span>

```
g.V(['USA', 'Seattle'])
```

<span data-ttu-id="1a667-189">Аналогично и с ребрами — вы можете ссылаться на ребро с помощью ключа секции и строки.</span><span class="sxs-lookup"><span data-stu-id="1a667-189">Same with edges, you can reference an edge using the partition key and row key.</span></span>

```
g.E(['USA', 'I5'])
```

<span data-ttu-id="1a667-190">Дополнительные сведения см. в статье [Azure Cosmos DB Gremlin graph support](gremlin-support.md) (Поддержка графа Gremlin для базы данных Azure Cosmos DB).</span><span class="sxs-lookup"><span data-stu-id="1a667-190">See [Gremlin support for Cosmos DB](gremlin-support.md) for more details.</span></span>


<a name="designing-for-partitioning"></a>
## <a name="designing-for-partitioning"></a><span data-ttu-id="1a667-191">Проектирование секционирования</span><span class="sxs-lookup"><span data-stu-id="1a667-191">Designing for partitioning</span></span>
<span data-ttu-id="1a667-192">Для эффективного масштабирования базы данных Azure Cosmos DB при создании контейнера необходимо выбрать подходящий ключ секции.</span><span class="sxs-lookup"><span data-stu-id="1a667-192">To scale effectively with Azure Cosmos DB, you need to pick a good partition key when you create your container.</span></span> <span data-ttu-id="1a667-193">Существует две основные рекомендации по выбору ключа секции.</span><span class="sxs-lookup"><span data-stu-id="1a667-193">There are two key considerations for choosing a partition key:</span></span>

* <span data-ttu-id="1a667-194">**Ограничение для запросов и транзакций**: выбранный ключ секции должен сбалансировать необходимость использования транзакций и требование к распределению сущностей по нескольким ключам секции для реализации масштабируемого решения.</span><span class="sxs-lookup"><span data-stu-id="1a667-194">**Boundary for query and transactions**: Your choice of partition key should balance the need to enable the use of transactions against the requirement to distribute your entities across multiple partition keys to ensure a scalable solution.</span></span> <span data-ttu-id="1a667-195">С одной стороны, можно задать один ключ секции для всех элементов, но это может ограничить масштабируемость решения.</span><span class="sxs-lookup"><span data-stu-id="1a667-195">At one extreme, you could set the same partition key for all your items, but this may limit the scalability of your solution.</span></span> <span data-ttu-id="1a667-196">С другой стороны, можно назначить уникальный ключ секции каждому элементу, что обеспечит высокую масштабируемость, но не позволит использовать транзакции между документами с помощью хранимых процедур и триггеров.</span><span class="sxs-lookup"><span data-stu-id="1a667-196">At the other extreme, you could assign a unique partition key for each item, which would be highly scalable but would prevent you from using cross document transactions via stored procedures and triggers.</span></span> <span data-ttu-id="1a667-197">Идеальный ключ секции позволяет применять эффективные запросы и обеспечивает достаточную кратность, чтобы гарантировать масштабируемость решения.</span><span class="sxs-lookup"><span data-stu-id="1a667-197">An ideal partition key is one that enables you to use efficient queries and that has sufficient cardinality to ensure your solution is scalable.</span></span> 
* <span data-ttu-id="1a667-198">**Нет узких мест для хранения и производительности**: важно выбрать свойство, которое обеспечивает распределение записей между различными уникальными значениями.</span><span class="sxs-lookup"><span data-stu-id="1a667-198">**No storage and performance bottlenecks**: It is important to pick a property that allows writes to be distributed across various distinct values.</span></span> <span data-ttu-id="1a667-199">Запросы по одному и тому же ключу секции не могут превышать пропускную способность одной секции и регулируются.</span><span class="sxs-lookup"><span data-stu-id="1a667-199">Requests to the same partition key cannot exceed the throughput of a single partition, and are throttled.</span></span> <span data-ttu-id="1a667-200">Поэтому важно выбрать ключ секции, который не создает "горячие точки" в вашем приложении.</span><span class="sxs-lookup"><span data-stu-id="1a667-200">So it is important to pick a partition key that does not result in "hot spots" within your application.</span></span> <span data-ttu-id="1a667-201">Так как все данные для ключа отдельной секции должны храниться в пределах секции, рекомендуется также избегать использования ключей секций с большими объемами данных для одного значения.</span><span class="sxs-lookup"><span data-stu-id="1a667-201">Since all the data for a single partition key must be stored within a partition, it is also recommended to avoid partition keys that have high volumes of data for the same value.</span></span> 

<span data-ttu-id="1a667-202">Давайте рассмотрим несколько реальных сценариев и подходящие ключи секции для каждого:</span><span class="sxs-lookup"><span data-stu-id="1a667-202">Let's look at a few real-world scenarios, and good partition keys for each:</span></span>
* <span data-ttu-id="1a667-203">Если вы реализуете серверную часть профиля пользователя, то в качестве ключа секции удобно выбрать идентификатор пользователя.</span><span class="sxs-lookup"><span data-stu-id="1a667-203">If you’re implementing a user profile backend, then the user ID is a good choice for partition key.</span></span>
* <span data-ttu-id="1a667-204">Если вы храните данные Интернета вещей, например состояние устройства, то в качестве ключа секции удобно выбрать идентификатор устройства.</span><span class="sxs-lookup"><span data-stu-id="1a667-204">If you’re storing IoT data for example, device state, a device ID is a good choice for partition key.</span></span>
* <span data-ttu-id="1a667-205">Если вы используете Azure Cosmos DB для ведения журнала данных временных рядов, то в качестве ключа секции удобно выбрать имя узла или идентификатор процесса.</span><span class="sxs-lookup"><span data-stu-id="1a667-205">If you’re using Azure Cosmos DB for logging time-series data, then the hostname or process ID is a good choice for partition key.</span></span>
* <span data-ttu-id="1a667-206">Если вы используете мультитенантную архитектуру, то в качестве ключа секции удобно выбрать идентификатор клиента.</span><span class="sxs-lookup"><span data-stu-id="1a667-206">If you have a multi-tenant architecture, the tenant ID is a good choice for partition key.</span></span>

<span data-ttu-id="1a667-207">В некоторых случаях использования (например, Интернет вещей и профили пользователей) ключ секции может быть таким же, как и ваш идентификатор (ключ документа).</span><span class="sxs-lookup"><span data-stu-id="1a667-207">In some use cases like IoT and user profiles, the partition key might be the same as your id (document key).</span></span> <span data-ttu-id="1a667-208">В других случаях, например для данных временных рядов, может потребоваться ключ секции, который отличается от этого идентификатора.</span><span class="sxs-lookup"><span data-stu-id="1a667-208">In others like the time series data, you might have a partition key that’s different than the id.</span></span>

### <a name="partitioning-and-loggingtime-series-data"></a><span data-ttu-id="1a667-209">Секционирование и ведение журнала (данные временных рядов)</span><span class="sxs-lookup"><span data-stu-id="1a667-209">Partitioning and logging/time-series data</span></span>
<span data-ttu-id="1a667-210">Одним из распространенных вариантов использования базы данных Cosmos DB является ведение журналов и телеметрия.</span><span class="sxs-lookup"><span data-stu-id="1a667-210">One of the common use cases of Cosmos DB is for logging and telemetry.</span></span> <span data-ttu-id="1a667-211">Важно выбрать подходящий ключ секции, поскольку может понадобиться считывать или записывать огромные объемы данных.</span><span class="sxs-lookup"><span data-stu-id="1a667-211">It is important to pick a good partition key since you might need to read/write vast volumes of data.</span></span> <span data-ttu-id="1a667-212">Выбор зависит от количества операций чтения и записи, а также типов запросов, которые предполагается выполнять.</span><span class="sxs-lookup"><span data-stu-id="1a667-212">The choice depends on your read and write rates and kinds of queries you expect to run.</span></span> <span data-ttu-id="1a667-213">Ниже приведены некоторые советы по выбору подходящего ключа секции.</span><span class="sxs-lookup"><span data-stu-id="1a667-213">Here are some tips on how to choose a good partition key.</span></span>

* <span data-ttu-id="1a667-214">Если ваш вариант использования подразумевает небольшое количество операций записи, накапливаемых в течение длительного срока, а также необходимость запроса по диапазонам меток времени и другим фильтрам, то в качестве ключа секции будет уместно использовать свертку метки времени, например дату.</span><span class="sxs-lookup"><span data-stu-id="1a667-214">If your use case involves a small rate of writes accumulating over a long period of time, and need to query by ranges of timestamps and other filters, then using a rollup of the timestamp, for example,  date as a partition key is a good approach.</span></span> <span data-ttu-id="1a667-215">Это позволяет выполнять запросы по всем данным для даты из одной секции.</span><span class="sxs-lookup"><span data-stu-id="1a667-215">This allows you to query over all the data for a date from a single partition.</span></span> 
* <span data-ttu-id="1a667-216">Если, как это чаще бывает, рабочая нагрузка подразумевает большое число операций записи, следует использовать ключ секции, который не зависит от метки времени, чтобы база данных Cosmos DB могла выполнять равномерную запись в несколько секций.</span><span class="sxs-lookup"><span data-stu-id="1a667-216">If your workload is written heavy, which is more common, you should use a partition key that’s not based on timestamp so that Cosmos DB can distribute writes evenly across various partitions.</span></span> <span data-ttu-id="1a667-217">В этом случае хорошим выбором станет имя узла, идентификатор процесса, идентификатор действия или другое свойство с большим количеством элементов.</span><span class="sxs-lookup"><span data-stu-id="1a667-217">Here a hostname, process ID, activity ID, or another property with high cardinality is a good choice.</span></span> 
* <span data-ttu-id="1a667-218">Третий подход является гибридным. В нем предусмотрено несколько контейнеров — по одному на каждый день и месяц, а ключ секции является фрагментарным свойством, таким как имя узла.</span><span class="sxs-lookup"><span data-stu-id="1a667-218">A third approach is a hybrid one where you have multiple containers, one for each day/month and the partition key is a granular property like hostname.</span></span> <span data-ttu-id="1a667-219">Преимущество такого подхода в том, что вы можете задать разные уровни пропускной способности в зависимости от периода. Например, контейнер для текущего месяца подготавливается с более высокой пропускной способностью, так как он обслуживает операции как чтения, так и записи, при этом контейнеры за предыдущие месяцы имеют сниженную пропускную способность, так как обслуживают только чтение.</span><span class="sxs-lookup"><span data-stu-id="1a667-219">This has the benefit that you can set different throughput based on the time window, for example, the container for the current month is provisioned with higher throughput since it serves reads and writes, whereas previous months with lower throughput since they only serve reads.</span></span>

### <a name="partitioning-and-multi-tenancy"></a><span data-ttu-id="1a667-220">Секционирование и мультитенантность</span><span class="sxs-lookup"><span data-stu-id="1a667-220">Partitioning and multi-tenancy</span></span>
<span data-ttu-id="1a667-221">При реализации мультитенантного приложения с помощью базы данных Cosmos DB существует два популярных шаблона — один ключ секции на клиент и один контейнер на клиент.</span><span class="sxs-lookup"><span data-stu-id="1a667-221">If you are implementing a multi-tenant application using Cosmos DB, there are two popular patterns – one partition key per tenant, and one container per tenant.</span></span> <span data-ttu-id="1a667-222">Ниже приведены преимущества и недостатки каждого из методов.</span><span class="sxs-lookup"><span data-stu-id="1a667-222">Here are the pros and cons for each:</span></span>

* <span data-ttu-id="1a667-223">Один ключ секции на клиент: в этой модели клиенты совместно размещены в одном контейнере.</span><span class="sxs-lookup"><span data-stu-id="1a667-223">One Partition Key per tenant: In this model, tenants are collocated within a single container.</span></span> <span data-ttu-id="1a667-224">Однако запросы и операции вставки для элементов в рамках одного клиента можно выполнить с одной секцией.</span><span class="sxs-lookup"><span data-stu-id="1a667-224">But queries and inserts for items within a single tenant can be performed against a single partition.</span></span> <span data-ttu-id="1a667-225">Кроме того, можно реализовать логику транзакций для всех элементов в пределах клиента.</span><span class="sxs-lookup"><span data-stu-id="1a667-225">You can also implement transactional logic across all items within a tenant.</span></span> <span data-ttu-id="1a667-226">Так как несколько клиентов совместно используют один контейнер, можно сократить затраты на хранилище и пропускную способность, организовав пул ресурсов для клиентов в пределах одного контейнера, а не подготавливая дополнительный запас для каждого клиента.</span><span class="sxs-lookup"><span data-stu-id="1a667-226">Since multiple tenants share a container, you can save storage and throughput costs by pooling resources for tenants within a single container rather than provisioning extra headroom for each tenant.</span></span> <span data-ttu-id="1a667-227">Недостатком является отсутствие изоляции производительности каждого клиента.</span><span class="sxs-lookup"><span data-stu-id="1a667-227">The drawback is that you do not have performance isolation per tenant.</span></span> <span data-ttu-id="1a667-228">Повышение производительности или пропускной способности действует для всех контейнеров, а не для выбранных клиентов.</span><span class="sxs-lookup"><span data-stu-id="1a667-228">Performance/throughput increases apply to the entire container vs targeted increases for tenants.</span></span>
* <span data-ttu-id="1a667-229">Один контейнер на клиент: каждый клиент имеет собственный контейнер.</span><span class="sxs-lookup"><span data-stu-id="1a667-229">One Container per tenant: Each tenant has its own container.</span></span> <span data-ttu-id="1a667-230">В этой модели можно резервировать производительность для каждого клиента.</span><span class="sxs-lookup"><span data-stu-id="1a667-230">In this model, you can reserve performance per tenant.</span></span> <span data-ttu-id="1a667-231">Благодаря новой модели ценообразования на основе резервирования для базы данных Cosmos DB, эта модель является более экономичной для мультитенантных приложений с небольшим числом клиентов.</span><span class="sxs-lookup"><span data-stu-id="1a667-231">With Cosmos DB's new provisioning pricing model, this model is more cost-effective for multi-tenant applications with a few tenants.</span></span>

<span data-ttu-id="1a667-232">Можно использовать также комбинированный или многоуровневый подход, при котором маленькие клиенты размещаются совместно, а большие переносятся в свои собственные контейнеры.</span><span class="sxs-lookup"><span data-stu-id="1a667-232">You can also use a combination/tiered approach that collocates small tenants and migrates larger tenants to their own container.</span></span>

## <a name="next-steps"></a><span data-ttu-id="1a667-233">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="1a667-233">Next steps</span></span>
<span data-ttu-id="1a667-234">В этой статье мы предоставили обзор концепций и рекомендации для секционирования с использованием любого API базы данных Azure Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="1a667-234">In this article, we provided an overview for an overview of concepts and best practices for partitioning with any Azure Cosmos DB API.</span></span> 

* <span data-ttu-id="1a667-235">Дополнительные сведения о подготовленной пропускной способности в базе данных Azure Cosmos DB см. в [этой статье](request-units.md).</span><span class="sxs-lookup"><span data-stu-id="1a667-235">Learn about [provisioned throughput in Azure Cosmos DB](request-units.md)</span></span>
* <span data-ttu-id="1a667-236">Узнайте больше о [глобальном распределении в базе данных Azure Cosmos DB](distribute-data-globally.md).</span><span class="sxs-lookup"><span data-stu-id="1a667-236">Learn about [global distribution in Azure Cosmos DB](distribute-data-globally.md)</span></span>



