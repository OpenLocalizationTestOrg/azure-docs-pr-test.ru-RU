---
title: "aaaAzure руководство по созданию таблицы хранилища | Документы Microsoft"
description: "Разработка масштабируемых и высокопроизводительных таблиц в табличном хранилище Azure"
services: cosmos-db
documentationcenter: na
author: mimig1
manager: tadb
editor: tysonn
ms.assetid: 8e228b0c-2998-4462-8101-9f16517393ca
ms.service: cosmos-db
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: storage
ms.date: 02/28/2017
ms.author: mimig
ms.openlocfilehash: 059f05a1d20e4d9537034b7ca133c5334bbefa04
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a>Руководство по разработке табличных хранилищ Azure: разработка масштабируемых и высокопроизводительных таблиц
[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

toodesign масштабируемых и высокопроизводительных таблиц необходимо учитывать ряд факторов, таких как производительности, масштабируемости и затрат. Ранее разработанный схемы для реляционных баз данных, эти вопросы будут знакомы tooyou, но существуют некоторые сходства между модель хранения службы таблиц Azure hello и реляционные модели, существуют также многие важные различия. Обычно эти отличия приводят toovery различными вариантами, может выглядеть counter-intuitive или неправильный toosomeone, знакомый с реляционными базами данных, но что следует делать хорошее представление при разработке для хранилища ключей и значений NoSQL например hello службы таблиц Azure. Число различия в разработке будут отражать hello факт, что служба таблиц hello спроектированный toosupport масштабе облака приложений, которые могут содержать миллиарды сущностей (строк в терминах реляционных баз данных), данных или наборов данных должен поддерживать очень высокий объем транзакций: таким образом, требуется toothink по-разному о том, как хранить данные и понять, как работает hello службы таблиц. Хорошо спроектированные хранилище данных NoSQL можно включить вашего решения tooscale дальше (и при более низких затратах) чем решения, использующего реляционной базы данных. Данное руководство поможет решить эти задачи.  

## <a name="about-hello-azure-table-service"></a>О hello службы таблиц Azure
В этом разделе описываются некоторые функции hello ключа hello службы таблиц, особенно применимо toodesigning производительности и масштабируемости. Если новый tooAzure хранилища и hello службы таблиц, сначала прочтите [tooMicrosoft введение хранилища Azure](../storage/common/storage-introduction.md) и [приступить к работе с хранилищем таблиц Azure, с помощью .NET](table-storage-how-to-use-dotnet.md) перед чтением hello оставшейся части данной статья. Несмотря на то, что hello в этом руководстве нацелено на hello службы таблиц, сюда входят некоторые обсуждение приветствия очереди Azure и службы больших двоичных объектов, и как их можно использовать вместе с hello службы таблиц в решении.  

Что такое служба hello таблицы? Как и следует ожидать от имени hello, hello служба таблиц использует данных toostore табличном формате. В стандартных терминах hello каждой строки таблицы hello представляет сущность и хранилища столбцов hello hello различные свойства этого объекта. Каждая сущность имеет пару ключей toouniquely идентифицировать его и столбец типа timestamp, Здравствуйте, служба таблиц использует tootrack время последнего обновления сущности hello (это происходит автоматически и вручную перезаписать hello timestamp с произвольным значением). Hello служба таблиц использует оптимистический параллелизм toomanage это отметка времени последнего изменения (LMT).  

> [!NOTE]
> операции REST API службы таблиц Hello также возвращают **ETag** значение, он является производным от последнего изменения отметок времени hello (LMT). В этом документе мы будем использовать hello термины ETag и LMT взаимозаменяемо, так как они ссылаются toohello же базовым данным.  
> 
> 

Hello пример toostore разработки простую таблицу employee и department и сущности. Многие примеры hello, приведенные далее в этом руководстве, основаны на такой простой подход.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td>Marketing</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Jun</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>Department</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Marketing</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Sales</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


Таким образом, это выглядит аналогично tooa таблицы реляционной базы данных с hello ключевые различия hello обязательные столбцы, и hello возможность toostore нескольких сущностей типов в hello одной таблицы. Кроме того, каждый из hello определяемые пользователем свойства, такие как **FirstName** или **возраст** имеет тип данных, такие как integer или string, точно так же, как и столбец в реляционной базе данных. Несмотря на то, что в отличие от реляционной базы данных, без схемы характер hello hello таблицы службы означает, что свойство не обязаны иметь hello же тип данных для каждой сущности. toostore сложных типов данных в одном свойстве, необходимо использовать сериализованный формат, например JSON или XML. Дополнительные сведения о типы данных службе, такие как поддерживаемой hello таблицы, диапазоны дат, поддерживаемые, правила именования и ограничения на размер см. в разделе [hello основные сведения о модели данных службы таблиц](http://msdn.microsoft.com/library/azure/dd179338.aspx).

Как видите, выбор **PartitionKey** и **RowKey** — основные toogood конструктора таблиц. Каждая сущность, хранящаяся в таблице, должна иметь уникальное сочетание значений **PartitionKey** и **RowKey**. Как и в случае с ключами в таблице реляционной базы данных hello **PartitionKey** и **RowKey** значения: индексированные toocreate кластеризованный индекс, который обеспечивает быстрый поиск; Однако hello служба таблиц не создаются вторичные индексы, поэтому эти hello только два индексированных свойств, (некоторые шаблоны hello, описанным ниже показывают, как обойти это ограничение явной).  

Таблица состоит из одной или нескольких секций и как можно будет увидеть, многие hello разработки решения, принимаемые будет вокруг Выбор подходящего **PartitionKey** и **RowKey** toooptimize решения. В решение может входить только одна таблица, в которой все сущности упорядочены по разделам. Однако обычно решение будет состоять из нескольких таблиц. Таблицы помогают toologically организация сущностей, помогут управлять доступом toohello данных с помощью управления доступом и ее можно удалить с помощью одна операция сохранения всей таблицы.  

### <a name="table-partitions"></a>Разделы таблицы
Имя учетной записи Hello, имя таблицы и **PartitionKey** вместе определяют hello секции в службе хранилища hello, где служба таблиц hello хранит hello сущности. А также не входит в состав hello, схема для сущностей адресации, секции определения области транзакции (см. [транзакции группы сущностей](#entity-group-transactions) ниже) и как служба таблиц hello масштабирует основу hello формы. Дополнительные сведения о разделах см. в статье [Целевые показатели масштабируемости и производительности службы хранилища Azure](../storage/common/storage-scalability-targets.md).  

В hello службы таблиц, отдельный узел службы или более завершения секций и hello службы шкал, динамически балансировки нагрузки секций между узлами. Если узел находится под нагрузкой, служба таблиц hello можно *разбиение* hello диапазона секций, обслуживаемых этого узла на разных узлах; при интенсивности трафика, hello службы можно *слияния* hello секции в диапазоне от Скрытый узлы обратно на одном узле.  

Дополнительные сведения о hello служба таблиц внутренние сведения о hello и в частности способы hello служба управляет секций см бумаги hello [хранилища Microsoft Azure: высокой доступных облачная служба хранилища строгих согласованности](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).  

### <a name="entity-group-transactions"></a>Транзакции группы сущностей
В hello службы таблиц транзакции группы сущностей (EGTs) являются hello только встроенный механизм для выполнения атомарных обновлений для нескольких сущностей. EGTs также, который ссылается tooas *пакетной операции* некоторые документы. EGTs может работать только с сущностей, хранящихся в hello одной секции (общую папку hello одинаковым ключом секции в данной таблице), поэтому каждый раз, когда требуется atomic поведение транзакций для нескольких сущностей необходимо, эти сущности находятся в hello tooensure одной секции. Это часто причина для хранения нескольких типов сущностей в hello же таблицы (и секции) и не использует несколько таблиц для различных типов сущностей. Одна транзакция группы сущностей может работать с максимум 100 сущностей.  При передаче нескольких параллельных EGTs для его обработки является важным tooensure этих EGTs работают на сущности, которые являются общими между EGTs, как в противном случае обработка может быть отложено.

EGTs риск потенциальной компромисс для tooevaluate при проектировании: использование нескольких секций улучшает масштабируемость приложения hello, так как Azure имеет больше возможностей для балансировки нагрузки запросов между узлами, но это может ограничить hello возможность атомарные транзакции tooperform приложения и поддержания строгого согласованности данных. Кроме того, существуют целевые показатели масштабируемости, определенных на уровне секции, которая может ограничить пропускную способность транзакций, можно ожидать для одного узла hello hello: Дополнительные сведения о hello целевые показатели масштабируемости для учетных записей хранилища Azure и hello таблицы службы см. в разделе [целевые показатели производительности и масштабируемости хранилища Azure](../storage/common/storage-scalability-targets.md). В последующих подразделах в этом руководстве рассматриваются различные разработки стратегии, которые помогают управлять компромиссы подобные, а также рассматриваются как лучше toochoose ключа секции на основе hello конкретных требований клиентского приложения.  

### <a name="capacity-considerations"></a>Рекомендации по емкости
Hello следующей таблице перечислены некоторые toobe значения ключа hello учитывать при разработке решения службы таблиц.  

| Общая емкость учетной записи хранения Azure | 500 TБ |
| --- | --- |
| Количество таблиц в учетной записи хранения Azure |Ограничивается только емкостью hello hello учетной записи хранения |
| Количество разделов в таблице |Ограничивается только емкостью hello hello учетной записи хранения |
| Количество сущностей в разделе |Ограничивается только емкостью hello hello учетной записи хранения |
| Размер отдельной сущности |До too1 МБ с не более 255 свойств (включая hello **PartitionKey**, **RowKey**, и **Timestamp**) |
| Размер hello **PartitionKey** |Строка вверх too1 КБ |
| Размер hello **RowKey** |Строка вверх too1 КБ |
| Размер транзакции группы сущностей |Транзакция может включать не более 100 сущностей и hello полезных данных должно быть меньше 4 МБ. Транзакция группы сущностей может обновлять сущность только один раз. |

Дополнительные сведения см. в разделе [hello основные сведения о модели данных службы таблиц](http://msdn.microsoft.com/library/azure/dd179338.aspx).  

### <a name="cost-considerations"></a>Рекомендации по стоимости
Относительно недорогая система хранения данных таблицы, однако следует включить оценки затрат для обоих емкости использования и hello количество транзакций в процессе знакомства с любого решения, которое использует службу hello таблицы. Однако во многих сценариях хранение денормализованные или повторяющиеся данные в порядке tooimprove hello производительность или масштабируемость решения является tootake допустимый подход. Дополнительные сведения о ценах см. на странице [Цены на хранилища Azure](https://azure.microsoft.com/pricing/details/storage/).  

## <a name="guidelines-for-table-design"></a>Рекомендации по разработке таблиц
Эти списки обобщения некоторые ключевые рекомендации hello, которых следует помнить при проектировании таблиц, и в этом руководстве, поможет решить их все более подробно далее. Эти рекомендации очень отличаются от hello рекомендации, которые обычно нужно выполнить для структуры реляционной базы данных.  

Проектирование вашей таблице службы решения toobe *чтения* эффективно:

* ***Разрабатывайте решения с учетом выполнения запросов в приложениях с большим количеством операций чтения.*** При проектировании таблиц подумать о запросах hello (особенно hello задержка важных), которые будут выполняться, прежде чем вы думаете о как обновит сущностей. Это позволит создать эффективное и высокопроизводительное решение.  
* ***Указывайте свойства PartitionKey и RowKey в запросах.*** *Выберите запросы* , таких как эти hello наиболее эффективный запросов к службе таблиц.  
* ***Рассмотрите возможность хранения повторяющихся копий сущностей.*** Хранилище таблиц не требует больших затрат поэтому рассмотрите возможность хранения hello одной сущности несколько раз (с разными ключами) tooenable более эффективные запросы.  
* ***Рассмотрите возможность денормализации данных.*** Хранилище таблиц не требует больших затрат поэтому рассмотрите возможность денормализации данных. Например можно хранить сводки сущности, чтобы запросы для статистической обработки данных необходим только tooaccess одной сущности.  
* ***Используйте значения составного ключа.*** Hello только ключи, у вас есть являются **PartitionKey** и **RowKey**. Например используйте tooentities пути альтернативного доступа с ключом tooenable значений составных ключей.  
* ***Используйте проекции в запросах.*** Можно уменьшить hello объем данных, передачи по сети hello с помощью запросов выберите только что hello поля.  

Проектирование вашей таблице службы решения toobe *записи* эффективно:  

* ***Не создавайте разделы с высокой нагрузкой.*** Нажмите сочетание клавиш, позволяющие toospread запросов по нескольким секциям в любой момент времени.  
* ***Избегайте пиковых нагрузок по трафику.*** Сглаживание hello трафика за разумный период времени и исключить всплески нагрузки трафика.
* ***Для каждого типа сущности не требуется создавать отдельную таблицу.*** Если требуются атомарные транзакции между типами сущностей, можно сохранить эти несколько типов сущностей в hello же секции в hello одной таблицы.
* ***Рассмотрите возможность hello максимальной пропускной способности, которые необходимо получить.*** Необходимо иметь в виду hello целевые показатели масштабируемости для hello службы таблиц и убедитесь, что проект не приведет tooexceed их.  

При чтении данного руководства вы увидите примеры, которые демонстрируют практическую реализацию всех этих принципов.  

## <a name="design-for-querying"></a>Разработка для запросов
Может считывать решений обслуживания таблицы, интенсивно использующих, интенсивно использующих записи или сочетание двух hello. Этот раздел посвящен toobear вещей hello в виду при разработке службы toosupport вашей таблице, эффективно операции чтения. Как правило, схема, поддерживающая операции чтения, также эффективна для операций записи. Однако существуют дополнительные вопросы toobear в виду при разработке toosupport операций записи, описанные в следующем разделе hello, [разработки для изменения данных](#design-for-data-modification).

Хорошей отправной точкой для разработки вашей tooenable решения службы таблицы данных tooread эффективно является tooask «какие запросы будут данные моего приложения требуется tooexecute tooretrieve hello hello службы таблиц необходимое?»  

> [!NOTE]
> С hello службы таблиц, очень важно заранее hello правильный разработки так как он является сложной и затратными toochange tooget его позже. Например, в реляционной базе данных, часто бывает tooaddress возможных проблем с производительностью, добавив индексирует tooan существующей базы данных: это не параметр с hello службы таблиц.  
> 
> 

Этот раздел посвящен hello основных проблем, которые необходимо учитывать при проектировании таблиц для выполнения запросов. Hello, описанные в этом разделе приведен список разделов:

* [Влияние выбора свойств PartitionKey и RowKey на производительность запросов](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [Выбор соответствующего свойства PartitionKey](#choosing-an-appropriate-partitionkey)
* [Оптимизация запросов для hello службы таблиц](#optimizing-queries-for-the-table-service)
* [Сортировка данных в hello службы таблиц](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a>Влияние выбора свойств PartitionKey и RowKey на производительность запросов
Hello следующих примерах предполагается hello службы таблиц сохранение сущности employee с следующая структура hello (Большинство примеров hello опустить hello **Timestamp** свойство для ясности):  

| *Имя столбца* | *Тип данных* |
| --- | --- |
| **PartitionKey** (Название отдела) |Строка |
| **RowKey** (ИД сотрудника) |Строка |
| **FirstName** |Строка |
| **LastName** |Строка |
| **Age** |Число |
| **EmailAddress** |Строка |

Здравствуйте, ранее [Общие сведения о службе таблиц Azure](#overview) описываются некоторые hello основные возможности hello службы таблиц Azure, которые имеют прямое влияние на проектирование для запроса. Эти привести hello следующие общие рекомендации по созданию запросов к службе таблиц. Обратите внимание, что синтаксис фильтра hello, используемых в следующих примерах hello из REST API службы таблиц hello дополнительная информация [запросы к сущностям](http://msdn.microsoft.com/library/azure/dd179421.aspx).  

* Объект ***запроса точки*** является наиболее эффективный поиск toouse hello и рекомендуется toobe используются для уточняющих запросов большого объема и уточняющие запросы, требующие минимальной задержке. Такой запрос можно использовать индексы hello toolocate отдельной сущности очень эффективно, указав оба hello **PartitionKey** и **RowKey** значения. Например: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')  
* Во-вторых, важнее ***запрос по диапазону*** , использующий hello **PartitionKey** и фильтры в диапазон **RowKey** значения tooreturn более одной сущности. Hello **PartitionKey** значение идентифицирует определенный раздел и hello **RowKey** значения определите подмножество hello сущностей в этой секции. Например: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'  
* Третий лучшее — ***сканирования секции*** , использующий hello **PartitionKey** и фильтры для другого неключевые свойства, которые могут возвращать более одной сущности. Hello **PartitionKey** значение идентифицирует определенный раздел, и значения свойств hello, выберите для подмножества hello сущностей в этой секции. Например: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'  
* Объект ***Table Scan*** не включает hello **PartitionKey** и оно очень неэффективно, так как он выполняет все секции hello, составляющих таблицу в свою очередь для любой из соответствующих сущностей. Он будет выполнять сканирование таблицы независимо от того, используется ли фильтр использует hello **RowKey**. Например: $filter=LastName eq 'Jones'  
* Запросы, возвращающие несколько сущностей, возвращают их отсортированными по свойствам **PartitionKey** и **RowKey**. Выберите tooavoid обращения hello сущностей в клиенте hello **RowKey** , определяющий порядок сортировки наиболее распространенные hello.  

Обратите внимание, что использование "**или**» на основе фильтра toospecify **RowKey** значения результатов для проверки секции и не обрабатывается как запрос диапазона. Поэтому следует избегать запросов, использующих следующие фильтры: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322').  

Примеры кода на стороне клиента, использующих hello клиентской библиотеки хранилища tooexecute эффективные запросы см.:  

* [Выполнение запроса точки с помощью клиентской библиотеки хранилища hello](#executing-a-point-query-using-the-storage-client-library)
* [Извлечение нескольких сущностей с помощью LINQ](#retrieving-multiple-entities-using-linq)
* [Проекция на стороне сервера](#server-side-projection)  

Примеры кода на стороне клиента, который может обрабатывать несколько сущностей типов хранятся в hello же таблицы см. в разделе:  

* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a>Выбор соответствующего свойства PartitionKey
Выбор **PartitionKey** следует учитывать необходимость hello tooenables использование hello EGTs (целостность tooensure) от toodistribute требование hello сущностей по нескольким секциям (tooensure масштабируемое решение).  

С одной стороны можно сохранить все сущности в одной секции, но это может ограничить масштабируемость hello решения и могли бы помешать hello служба таблиц не могут tooload балансировать нагрузку по запросам. В hello другой стороны, можно хранить одну сущность на секцию, которой будет высокомасштабируемых позволяющее обслуживания tooload баланс hello таблицы запросов, но которой не удастся транзакции группы сущностей с помощью.  

Идеальной **PartitionKey** то, которое позволяет toouse эффективные запросы и имеет достаточно секций tooensure решения является масштабируемым. Вы поймете, что сущности имеют соответствующее свойство, которое распределяет их по необходимому количеству разделов.

> [!NOTE]
> Например, в системе, где хранятся сведения о пользователях или сотрудниках, идентификатор пользователя (UserID) может быть выражен подходящим значением PartitionKey. Вы можете иметь несколько сущностей, использующих в качестве ключа секции hello данного пользователя. Все сущности, в которых хранятся данные о пользователе, группируются в один раздел. В результате все операции с этими сущностями выполняются через транзакции группы сущностей, но масштабируемость остается высокой.
> 
> 

Существуют дополнительные рекомендации по своему выбору **PartitionKey** , которые связывают toohow будет вставки, обновления и удаления сущностей: hello в разделе [разработки для изменения данных](#design-for-data-modification) ниже.  

### <a name="optimizing-queries-for-hello-table-service"></a>Оптимизация запросов для hello службы таблиц
Hello службы таблиц автоматически индексирует сущностей с помощью hello **PartitionKey** и **RowKey** значений в один кластеризованный индекс, поэтому hello причине что точечными запросами hello наиболее эффективный toouse . Тем не менее, есть индексов не hello кластеризованный индекс для hello отличный от того, **PartitionKey** и **RowKey**.

Во многих проектах должен удовлетворять требованиям tooenable подстановки сущностей на основе нескольких критериев. Например, поиск сущностей сотрудников на основе адреса электронной почты, ИД сотрудника или фамилии. Здравствуйте, следующие шаблоны в разделе "hello" [шаблоны проектирования таблицы](#table-design-patterns) устранить эти типы требований и описывают способы обходу hello фактов, что служба таблиц hello не предоставляет вторичных индексов:  

* [Шаблон внутри секции вторичный индекс](#intra-partition-secondary-index-pattern) -хранение нескольких копий каждой сущности, используя различные **RowKey** значения (в hello одной секции) tooenable быстрого и эффективного поиска и сортировки альтернативный заказы с помощью различные **RowKey** значения.  
* [Вторичный индекс между шаблон](#inter-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности, с помощью разными значениями RowKey в разные разделы или в отдельных таблицах tooenable быстрого и эффективного поиска и сортировки альтернативный заказы с помощью различных **RowKey** значения.  
* [Шаблон сущностей индекс](#index-entities-pattern) -обслуживание индекса сущностей tooenable эффективного поиска, возвращающих списки сущностей.  

### <a name="sorting-data-in-hello-table-service"></a>Сортировка данных в hello службы таблиц
Hello служба таблиц возвращает сущности в возрастающем порядке, основанном на **PartitionKey** , а затем по **RowKey**. Эти разделы находятся значения строк и tooensure, числовые значения сортировки правильно, необходимо преобразовать их tooa фиксированной длины и выполнить их заполнение нулями. Например, если hello значение идентификатора сотрудника служит hello **RowKey** — это целочисленное значение, необходимо преобразовать идентификатор сотрудника **123** слишком**00000123**.  

Многие приложения имеют требования toouse данные отсортированы в разном порядке: например, сортировка сотрудников по имени или присоединив даты. Здравствуйте, следующие шаблоны в разделе "hello" [шаблоны проектирования таблицы](#table-design-patterns) адресов, как порядок сортировки tooalternate для сущностей:  

* [Шаблон внутри секции вторичный индекс](#intra-partition-secondary-index-pattern) -хранение нескольких копий каждой сущности, с помощью разными значениями RowKey (в hello одной секции) tooenable быстрого и эффективного поиска и сортировки альтернативный заказы с помощью разными значениями RowKey.  
* [Вторичный индекс между шаблон](#inter-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности, с помощью разными значениями RowKey в разные разделы в отдельных таблицах tooenable быстрого и эффективного поиска и сортировки альтернативный заказы с помощью разных RowKey значения.
* [Шаблон заключительный фрагмент журнала](#log-tail-pattern) -получение hello  *n*  сущностей недавно добавленную секцию tooa с помощью **RowKey** значение, которое сортирует в обратную даты и времени заказа.  

## <a name="design-for-data-modification"></a>Разработка для изменения данных
В этом разделе основное внимание уделяется hello вопросы проектирования для оптимизации операций вставки, обновления и удаления. В некоторых случаях потребуется tooevaluate hello компромисс между вариантами, оптимизировать запросы по оптимизации для изменения данных так же, как в модели для реляционных баз данных (несмотря на то, что hello, обеспечивающих управление hello конструктора схем преимущества и недостатки отличаются в реляционной базе данных). Здравствуйте, раздел [шаблоны проектирования таблицы](#table-design-patterns) описывает некоторые шаблоны проектирования подробные для hello службы таблиц и кратко описаны преимущества и недостатки. На практике вы увидите, что многие модели, оптимизированные для выполнения запросов к сущностям, также хорошо подходят для изменения сущностей.  

### <a name="optimizing-hello-performance-of-insert-update-and-delete-operations"></a>Оптимизация производительности hello вставки, обновления и удаления операций
tooupdate или удалить сущность, должен быть доступ tooidentify его с помощью hello **PartitionKey** и **RowKey** значения. В этом отношении Выбор **PartitionKey** и **RowKey** указывают для изменения сущности должны следовать аналогичные toosupport выбора tooyour критериев запросы, поскольку требуется tooidentify сущности как эффективным способом. Не следует toouse неэффективным секцию или таблицу сканирования toolocate сущности в порядке toodiscover hello **PartitionKey** и **RowKey** значения требуется tooupdate или удалите его.  

Здравствуйте, следующие шаблоны в разделе "hello" [шаблоны проектирования таблицы](#table-design-patterns) адреса оптимизация производительности hello или вашей insert, update, а операции удаления:  

* [Шаблон удаления большого объема](#high-volume-delete-pattern) -удаление hello Enable слишком большое количество сущностей, сохраняя все сущности hello для одновременного удаления в своих собственных отдельную таблицу; можно удалить сущности hello путем удаления таблицы hello.  
* [Шаблон рядов данных](#data-series-pattern) -хранилище полные данные ряда в одной сущности toominimize hello ряд запросов, можно сделать.  
* [Шаблон широкий сущностей](#wide-entities-pattern) -использовать несколько сущностей логической toostore физические объекты с более чем 252 свойств.  
* [Шаблон больших сущностей](#large-entities-pattern) -использование больших двоичных объектов хранилища toostore свойство больших значений.  

### <a name="ensuring-consistency-in-your-stored-entities"></a>Обеспечение согласованности хранимых сущностей
Здравствуйте, другие влияет выбор ключей для оптимизации изменения данных является ключевым фактором как tooensure согласованности с помощью атомарные транзакции. Toooperate EGT можно использовать только на объекты, хранящиеся в hello одной секции.  

Здравствуйте, следующие шаблоны в разделе "hello" [шаблоны проектирования таблицы](#table-design-patterns) заботиться о согласовании адрес:  

* [Шаблон внутри секции вторичный индекс](#intra-partition-secondary-index-pattern) -хранение нескольких копий каждой сущности, используя различные **RowKey** значения (в hello одной секции) tooenable быстрого и эффективного поиска и сортировки альтернативный заказы с помощью различные **RowKey** значения.  
* [Вторичный индекс между шаблон](#inter-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности, с помощью разными значениями RowKey в разные разделы или в отдельных таблицах tooenable быстрого и эффективного поиска и сортировки альтернативный заказы с помощью различных **RowKey** значения.  
* [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern) — обеспечение согласованного поведения в рамках границ раздела или границ системы хранения с помощью запросов Azure.
* [Шаблон сущностей индекс](#index-entities-pattern) -обслуживание индекса сущностей tooenable эффективного поиска, возвращающих списки сущностей.  
* [Денормализация шаблон](#denormalization-pattern) -объединить данные, относящиеся к вместе в одной сущности tooenable tooretrieve все hello необходимо с помощью запроса одной точки данных.  
* [Шаблон рядов данных](#data-series-pattern) -хранилище полные данные ряда в одной сущности toominimize hello ряд запросов, можно сделать.  

Сведения о транзакции группы сущностей, в разделе hello [транзакции группы сущностей](#entity-group-transactions).  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>Использование эффективных запросов в разработке для эффективных изменений
Во многих случаях конструктора для эффективного результатов запросов в эффективный изменения, но всегда следует оценить, выполнен ли ситуация hello для конкретного сценария. Некоторые шаблоны hello в разделе "hello" [шаблоны проектирования таблицы](#table-design-patterns) явно оценки компромиссы между направление запросов и изменение сущностей и всегда следует проявлять в учетной записи hello количество каждого типа операции.  

Здравствуйте, следующие шаблоны в разделе "hello" [шаблоны проектирования таблицы](#table-design-patterns) компромиссы между проектированием для обеспечения эффективного поиска и проектирование для изменения данных для эффективного устранения:  

* [Шаблон составного ключа](#compound-key-pattern) -использование составного **RowKey** tooenable значения toolookup клиента связанные данные с помощью запроса одной точки.  
* [Шаблон заключительный фрагмент журнала](#log-tail-pattern) -получение hello  *n*  сущностей недавно добавленную секцию tooa с помощью **RowKey** значение, которое сортирует в обратную даты и времени заказа.  

## <a name="encrypting-table-data"></a>Шифрование данных таблицы
Здравствуйте, клиентская библиотека хранилища Azure .NET поддерживает шифрование свойств сущности строки для вставки операций и замены. Hello зашифрованные строки хранятся в службе hello как двоичные свойства и их преобразование задней toostrings после расшифровки.    

Для таблиц Кроме toohello политики шифрования, пользователи должны указать toobe свойства hello зашифрованы. Это можно сделать путем указания атрибута [PropertyAttribute] \(для сущностей POCO, которые являются производными от TableEntity) или с помощью сопоставителя шифрования в параметрах запроса. Сопоставитель шифрования — это делегат, который получает ключ секции, ключ строки и имя свойства, а затем возвращает логическое значение, которое указывает, следует ли это свойство шифровать. Во время шифрования hello клиентской библиотеки будет использовать этот toodecide сведения ли свойства должны быть зашифрованы при записи toohello сети. Делегат Hello также предоставляет возможность hello логики вокруг как свойства шифруются. (Например, если значение равно X, то шифровать свойство А; в противном случае шифровать свойства А и В.) Обратите внимание, что он является не обязательным tooprovide эти сведения при чтении или выполнения запросов к сущностям.

Обратите внимание, что слияние в настоящее время не поддерживается. Так как подмножество свойств может зашифрованные ранее с помощью другой ключ, просто слияние новых свойств hello и обновление метаданных hello приведет к потере данных. Слияние либо требует внесения дополнительных службы вызывает tooread hello существующих сущностей из службы hello, либо с помощью нового ключа каждого свойства, которые не подходят для повышения производительности.     

Дополнительные сведения о шифровании данных таблицы см. в статье [Шифрование на стороне клиента для службы хранилища Microsoft Azure](../storage/common/storage-client-side-encryption.md).  

## <a name="modelling-relationships"></a>Моделирование отношений
Построение моделей домена является ключевым моментом в hello проектирования сложных систем. Как правило использовать hello моделирования процесса tooidentify сущностей и hello связи между ними как toounderstand способом hello бизнес-среды и уведомить hello Дизайн системы. Этот раздел посвящен как преобразовать некоторые hello в toodesigns модели домена для службы таблиц hello распространенные типы отношений. Hello процесса сопоставления из логической модели данных tooa физического NoSQL на основе модели данных очень отличается от используемого при разработке реляционной базы данных. Структура реляционных баз данных обычно предполагает процесса нормализации данных, оптимизированными для минимизации избыточность — и декларативных запросов возможность, которая краткие описания как hello реализация принципов работы hello базы данных.  

### <a name="one-to-many-relationships"></a>Отношения «один-ко-многим»
Отношения «один-ко-многим» между бизнес-объектами являются практически самыми распространенными. Например, в одном отделе работает много сотрудников. Имеется несколько способов tooimplement один ко многим связи на hello службы таблиц каждого с преимущества и недостатки, которые могут быть применимо toohello определенного сценария.  

Рассмотрим пример hello глобальной экономике крупного предприятия с десятками тысяч подразделений и сущности employee, где каждый отдел имеет многие сотрудники и каждого сотрудника как связанную с одного конкретного подразделения. Одним из подходов является отдельной отдел toostore и сущности employee такие:  

![][1]

В этом примере показано явную связь между hello типы на основании hello один ко многим **PartitionKey** значение. В каждом отделе может работать много сотрудников.  

В этом примере также показано сущность department и его связанные сотрудника сущности в hello одной секции. Можно выбрать различные секции toouse, таблицы или даже учетные записи хранения для hello различных типов сущностей.  

Альтернативный подход — toodenormalize только сотрудника сущностей данных и хранилище с данными денормализованные отдела, как показано в следующий пример hello. В данном конкретном случае этот денормализованные подход может оказаться наиболее hello при наличии подробности требования toobe может toochange hello диспетчера отдела, так как toodo это необходимо tooupdate каждого служащего в отделе hello.  

![][2]

Дополнительные сведения см. в разделе hello [шаблон денормализации](#denormalization-pattern) далее в этом руководстве.  

Hello следующей таблице приведена сводка hello преимуществ и недостатков каждого из подходов hello, описанные выше, для хранения сотрудника и отдел сущностей, которые имеют связь «один ко многим». Следует также учитывать, насколько часто ожидается tooperform различные операции: он может быть приемлемым toohave схема, которая включает в себя ресурсоемкой операцией, если эта операция происходит редко.  

<table>
<tr>
<th>Подход</th>
<th>Преимущества</th>
<th>Недостатки</th>
</tr>
<tr>
<td>Отдельные типы сущностей, один раздел, одна таблица</td>
<td>
<ul>
<li>Сущность отдела можно обновить с помощью одной операции.</li>
<li>Согласованность toomaintain EGT можно использовать при наличии toomodify требование сущность department всякий раз, когда вы обновление, вставка или удаление сущности employee. Например, в случае поддержки осведомленности о количестве сотрудников в каждом отделе.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий, клиент может потребоваться tooretrieve сотрудник и сущность department.</li>
<li>Выполняются операции хранилища в hello же секции. При значительных объемах транзакций это может привести к формированию активной области.</li>
<li>Не удается переместить сотрудника tooa новое подразделение с помощью EGT.</li>
</ul>
</td>
</tr>
<tr>
<td>Отдельные типы сущностей, разные разделы или таблицы, или учетные записи хранилища</td>
<td>
<ul>
<li>Сущность отдела или сущность сотрудника можно обновить с помощью одной операции.</li>
<li>В значительными объемами транзакций, это может помочь разворота нагрузки hello в нескольких секциях.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий, клиент может потребоваться tooretrieve сотрудник и сущность department.</li>
<li>Нельзя использовать EGTs toomaintain согласованности при вы обновление, вставка или удаление сотрудника и обновление отдел. Например, для обновления количества сотрудников в сущности отдела.</li>
<li>Не удается переместить сотрудника tooa новое подразделение с помощью EGT.</li>
</ul>
</td>
</tr>
<tr>
<td>Денормализация в один тип сущности</td>
<td>
<ul>
<li>Можно получить все сведения о hello, с помощью одного запроса.</li>
</ul>
</td>
<td>
<ul>
<li>Если вам нужна информация отдел tooupdate (для этого может потребоваться вы tooupdate все hello сотрудниками в отделе) может дорогих toomaintain согласованности.</li>
</ul>
</td>
</tr>
</table>

Как выбрать эти параметры и какие преимущества hello и недостатки наиболее важны, зависит от вашей определенные сценарии приложений. Например как часто изменять отдел сущности; нужны ли все запросы сотрудника hello дополнительной информации отдела; насколько близко вы toohello ограничения масштабирования на секции или вашей учетной записи хранилища?  

### <a name="one-to-one-relationships"></a>Отношения «один-к-одному»
В модель предметной области могут входить отношения между сущностями «один-к-одному». Если вам требуется tooimplement отношение в hello службы таблиц, необходимо выбрать как toolink hello двух связанных объектов, при необходимости tooretrieve их обоих. Эта ссылка может указывать, в зависимости от соглашения в значениях ключа hello, явную или неявную, сохраняя ссылку в форме hello **PartitionKey** и **RowKey** значения в каждой сущности tooits связанные сущности. Следует ли хранить hello обсуждение связанные сущности в одной секции hello, см. раздел hello [один ко многим связи](#one-to-many-relationships).  

Обратите внимание, что существуют также вопросах реализации, которые могут привести отношения один к одному tooimplement в службе таблиц hello.  

* Обработка сущностей большого размера (дополнительные сведения см. в статье [Шаблон для сущностей больших размеров](#large-entities-pattern)).  
* Внедрение средств управления доступом (см. раздел [Управление доступом с помощью подписанных URL-адресов](#controlling-access-with-shared-access-signatures)).  

### <a name="join-in-hello-client"></a>Примите участие в приветствия клиента
Несмотря на то, что существуют способы toomodel связи в hello службы таблиц, не следует забывать, масштабируемость и производительность hello два основной причины использования hello службы таблиц. Если обнаружится, что моделирования много связей, которые представляют угрозу hello производительности и масштабируемости решения, необходимо обратиться самостоятельно при необходимости toobuild все hello отношения между данными в макет таблицы. Может быть разработки может toosimplify hello и улучшения hello масштабируемости и производительности для вашего решения, если предоставляется возможность выполнить любое соединение клиентского приложения.  

Например при наличии небольших таблиц, содержащих данные, которые не очень часто изменяются, затем можно получить эти данные один раз и кэшировать его на приветствия клиента. Это может предотвратить повторных передач tooretrieve hello и тех же данных. В примерах hello, были также рассмотрены в данном руководстве hello отделов в небольшой организации это скорее всего toobe небольшие и редко становится хорошим кандидатом для данных, клиентское приложение можно загрузить один раз и кэш так же для поиска данных изменений.  

### <a name="inheritance-relationships"></a>Отношения наследования
Если клиентское приложение использует набор классов, которые являются частью бизнес-сущности toorepresent отношение наследования, можно легко сохранить этих сущностей в hello службы таблиц. Например, может потребоваться hello следующий набор классов, определенных в клиентском приложении где **лицо** класс является абстрактным.

![][3]

Можно хранить экземпляры двух конкретных классов hello в hello службы таблиц с помощью одной таблицы Person, с помощью сущностей в этом выглядят следующим образом:  

![][4]

Дополнительные сведения о работе с несколькими типами сущностей в hello же таблицу в клиентском коде в разделе hello [работа с типами сущностей разнородных](#working-with-heterogeneous-entity-types) далее в этом руководстве. Это примеры как toorecognize hello типа сущности в клиентском коде.  

## <a name="table-design-patterns"></a>Шаблоны для разработки таблиц
В предыдущих разделах вы уже узнали подробные обсуждения как toooptimize таблицы обоих получение данных сущности, с помощью запросов и разработки для вставки, обновления и удаления данных сущности. В этом разделе приводится описание некоторых шаблонов, которые подходят для использования с решениями для службы таблиц. Кроме того вы увидите, как вы можно практически устранить некоторые проблемы hello и преимущества и недостатки возникает ранее в этом руководстве. Hello следующей диаграмме показаны hello связи между hello различных шаблонов:  

![][5]

карты шаблон Hello выше представлены некоторые связи между шаблонов (синий) и антишаблоны (оранжевый), описанные в данном руководстве. Безусловно, существует множество других стоящих внимания шаблонов. Например, один из основных сценариев hello для службы таблиц — toouse hello [материализованные представления шаблон](https://msdn.microsoft.com/library/azure/dn589782.aspx) из hello [разделение ответственности команды запросов (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) шаблон.  

### <a name="intra-partition-secondary-index-pattern"></a>Шаблон вторичного индекса внутри раздела
Хранение нескольких копий каждой сущности, используя различные **RowKey** значения (в hello одной секции) tooenable быстрого и эффективного поиска и сортировки альтернативный заказы с помощью различных **RowKey** значения. Транзакции группы сущностей обеспечивают согласованность обновлений копий.  

#### <a name="context-and-problem"></a>Контекст и проблема
Hello службы таблиц автоматически индексирует сущностей с помощью hello **PartitionKey** и **RowKey** значения. Это позволяет tooretrieve клиентского приложения эффективно с использованием этих значений сущности. Например, с помощью структуры таблицы hello, показано ниже, клиентское приложение может использовать tooretrieve запроса точки отдельного сотрудника сущности с помощью название отдела hello и идентификатор сотрудника hello (hello **PartitionKey** и  **RowKey** значения). Клиент также может извлекать сущности, отсортированные по ИД сотрудника в каждом отделе.

![][6]

Если также требуется toobe может toofind сущности employee на основе hello значения другого свойства, такие как адрес электронной почты, необходимо использовать менее эффективный toofind сканирования секции совпадения. Это так, как служба таблиц hello не поддерживает вторичные индексы. Кроме того, имеется не toorequest параметр список сотрудников, отсортированных в порядке, отличном от **RowKey** заказа.  

#### <a name="solution"></a>Решение
toowork вокруг hello отсутствие вторичные индексы можно хранить несколько копий каждой сущности для каждой копии с другой **RowKey** значение. Если сохранить сущность со структурами hello, показано ниже, получать сущности employee на основе идентификатора сотрудниках и адрес электронной почты. Здравствуйте, префиксные значения для hello **RowKey**, «empid_» и «email_» позволяют tooquery для одного сотрудника или диапазон сотрудников с помощью диапазона адресов электронной почты или идентификаторов.  

![][7]

Hello следующих двух условий фильтра (один поиске идентификатор сотрудника и один поиск по адресу электронной почты) и укажите точечными запросами:  

* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

При выполнении запроса для диапазона сущности employee, можно указать диапазон, отсортированных в порядке идентификатор сотрудника или диапазон, отсортированных в порядке адрес электронной почты с помощью запроса для сущностей с hello соответствующий префикс в hello **RowKey**.  

* использовать все hello сотрудникам отдела продаж hello идентификатор сотрудника в диапазоне 000100 too000199 hello toofind: $filter = (eq PartitionKey «Продажи») и (ge RowKey «empid_000100») и (le RowKey «empid_000199»)  
* все hello сотрудники отдела продаж hello с адресом электронной почты, начиная с hello toofind буква «' use: $filter = (eq PartitionKey «Продажи») и (ge RowKey «email_a») и (lt RowKey «email_b»)  
  
  Обратите внимание, что используется в примерах hello выше синтаксис фильтра hello из REST API службы таблиц hello дополнительная информация [запросы к сущностям](http://msdn.microsoft.com/library/azure/dd179421.aspx).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Хранилище таблиц является toouse относительно требует больших затрат, поэтому hello затрат на хранение повторяющихся данных не должно быть предметом первостепенной важности. Тем не менее следует всегда возвращают hello затрат на основе требований предполагаемого хранения проекта и добавлять повторяющиеся объекты toosupport hello запросы, которые клиентское приложение будет выполнять только.  
* Поскольку hello вторичный индекс сущности сохраняются в hello же секции как hello исходной сущности, вы должны убедиться, не превышает hello целевые показатели масштабируемости отдельной секции.  
* Повторяющиеся сущностей можно сохранить согласованность друг с другом с помощью двух копий EGTs tooupdate hello объекта hello единым блоком. Это означает, что следует хранить все копии сущности в hello одной секции. Дополнительные сведения см в разделе hello [с помощью транзакции группы сущностей](#entity-group-transactions).  
* Здравствуйте, значение, используемое для hello **RowKey** должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Заполнение числовые значения в hello **RowKey** (например, идентификатор сотрудника hello 000223) позволяет исправить сортировки и фильтрации на основе верхней и нижней границ.  
* Вы не обязательно tooduplicate все hello свойства сущности. Например, если hello запросов, уточняющие сущности hello hello с помощью электронной почты адрес в hello **RowKey** не требуется значение возраста сотрудников hello, эти сущности может иметь hello следующие структуры:

![][8]

* Это обычно лучше toostore повторяющиеся данные и убедитесь, что все данные hello, необходимые в рамках одного запроса можно получить, чем один запрос toolocate toouse сущностью и другой hello toolookup необходимых данных.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Эта схема используется в том случае, когда приложению клиента, tooretrieve сущностей, используя разнообразные разных ключей, когда клиент должен tooretrieve сущностей в различными порядками сортировки и там, где можно определить каждую сущность, с помощью различных уникальных значений. Однако должны быть убедитесь, что при выполнении сущности уточняющих запросов, с помощью различных hello не превышает ограничения масштабируемости секции hello **RowKey** значения.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Шаблон вторичного индекса в разных разделах;](#inter-partition-secondary-index-pattern)
* [Шаблон составного ключа;](#compound-key-pattern)
* [Транзакции группы сущностей;](#entity-group-transactions)
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>Шаблон вторичного индекса в разных разделах
Хранение нескольких копий каждой сущности, используя различные **RowKey** значения в отдельной секции или в отдельных таблицах tooenable уточняющие запросы быстрые и эффективные и альтернативный порядок сортировки с помощью различных **RowKey**значения.  

#### <a name="context-and-problem"></a>Контекст и проблема
Hello службы таблиц автоматически индексирует сущностей с помощью hello **PartitionKey** и **RowKey** значения. Это позволяет tooretrieve клиентского приложения эффективно с использованием этих значений сущности. Например, с помощью структуры таблицы hello, показано ниже, клиентское приложение может использовать tooretrieve запроса точки отдельного сотрудника сущности с помощью название отдела hello и идентификатор сотрудника hello (hello **PartitionKey** и  **RowKey** значения). Клиент также может извлекать сущности, отсортированные по ИД сотрудника в каждом отделе.  

![][9]

Если также требуется toobe может toofind сущности employee на основе hello значения другого свойства, такие как адрес электронной почты, необходимо использовать менее эффективный toofind сканирования секции совпадения. Это так, как служба таблиц hello не поддерживает вторичные индексы. Кроме того, имеется не toorequest параметр список сотрудников, отсортированных в порядке, отличном от **RowKey** заказа.  

Планирование очень большой объем транзакций на эти сущности и требуется toominimize риск hello hello регулирования клиента службы таблиц.  

#### <a name="solution"></a>Решение
toowork вокруг hello отсутствие вторичные индексы хранение нескольких копий каждой сущности с каждой копии с помощью различных **PartitionKey** и **RowKey** значения. Если сохранить сущность со структурами hello, показано ниже, получать сущности employee на основе идентификатора сотрудниках и адрес электронной почты. Здравствуйте, префиксные значения для hello **PartitionKey**, «empid_» и «email_» позволяет tooidentify вы индекс, который хотите toouse для запроса.  

![][10]

Hello следующих двух условий фильтра (один поиске идентификатор сотрудника и один поиск по адресу электронной почты) и укажите точечными запросами:  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

При выполнении запроса для диапазона сущности employee, можно указать диапазон, отсортированных в порядке идентификатор сотрудника или диапазон, отсортированных в порядке адрес электронной почты с помощью запроса для сущностей с hello соответствующий префикс в hello **RowKey**.  

* все hello сотрудников в toofind hello отдела продаж с идентификаторами в диапазоне hello **000100** слишком**000199** сортировки используется порядок идентификатор сотрудника: $filter = (PartitionKey eq ' empid_Sales') и (RowKey ge " 000100') и (le RowKey "000199")  
* toofind порядок использования адреса электронной почты всех hello сотрудников отдела продаж hello с адресом электронной почты, который начинается с «» в: $filter = (PartitionKey eq ' email_Sales') и (RowKey ge 'a') и (lt RowKey 'b')  

Обратите внимание, что используется в примерах hello выше синтаксис фильтра hello из REST API службы таблиц hello дополнительная информация [запросы к сущностям](http://msdn.microsoft.com/library/azure/dd179421.aspx).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Можно сохранить повторяющиеся сущностей согласованным друг с другом с помощью hello [шаблон согласованным транзакции](#eventually-consistent-transactions-pattern) toomaintain hello первичного и вторичного индекса сущности.  
* Хранилище таблиц является toouse относительно требует больших затрат, поэтому hello затрат на хранение повторяющихся данных не должно быть предметом первостепенной важности. Тем не менее следует всегда возвращают hello затрат на основе требований предполагаемого хранения проекта и добавлять повторяющиеся объекты toosupport hello запросы, которые клиентское приложение будет выполнять только.  
* Здравствуйте, значение, используемое для hello **RowKey** должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Заполнение числовые значения в hello **RowKey** (например, идентификатор сотрудника hello 000223) позволяет исправить сортировки и фильтрации на основе верхней и нижней границ.  
* Вы не обязательно tooduplicate все hello свойства сущности. Например, если hello запросов, уточняющие сущности hello hello с помощью электронной почты адрес в hello **RowKey** не требуется значение возраста сотрудников hello, эти сущности может иметь hello следующие структуры:
  
  ![][11]
* Это обычно лучше toostore повторяющиеся данные и убедитесь, что можно получить все hello необходимых данных в рамках одного запроса не toolocate один запрос toouse сущности, используя hello вторичного индекса, и другой toolookup hello необходимых данных в первичном индексе hello.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Эта схема используется в том случае, когда приложению клиента, tooretrieve сущностей, используя разнообразные разных ключей, когда клиент должен tooretrieve сущностей в различными порядками сортировки и там, где можно определить каждую сущность, с помощью различных уникальных значений. Использовать этот шаблон при необходимости tooavoid превышение hello секции масштабируемости при выполнении сущности уточняющих запросов, с помощью различных hello **RowKey** значения.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Шаблон вторичного индекса внутри раздела;](#intra-partition-secondary-index-pattern)  
* [Шаблон составного ключа;](#compound-key-pattern)  
* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>Шаблон для согласованных транзакций
Обеспечьте согласованное поведение в рамках границ раздела или границ системы хранения с помощью запросов Azure.  

#### <a name="context-and-problem"></a>Контекст и проблема
EGTs включить атомарные транзакции через несколько сущностей, которые совместно используют hello же ключ секционирования. Для производительности и масштабируемости, вы можете toostore сущностей с требованиями к согласованности в отдельной секции или в системе хранить: в этом случае нельзя использовать EGTs toomaintain согласованности. Например может потребоваться toomaintain требование, итоговая согласованность между:  

* Записи, которые хранятся в двух разных секциях в hello же таблицу, в различных таблицах в в разных учетных записей хранения.  
* Сущность, хранящихся в hello службы таблиц и больших двоичных объектов, хранящихся в hello службы BLOB-объектов.  
* Сущность, хранящиеся в службе таблиц hello и файл в файловой системе.  
* Сущность хранения в hello службы таблиц еще индексированы hello службы поиска Azure.  

#### <a name="solution"></a>Решение
Используя очереди Azure, можно реализовать решение, обеспечивающее согласованность между двумя и более разделами или системами хранения.
tooillustrate это подход, предположим, имеется требование toobe может tooarchive старого сущности employee. К старым сущностям сотрудников редко выполняются запросы, поэтому они должны быть исключены из любых действий, связанных с текущими сотрудниками. tooimplement это требование, сохранении активных сотрудников в hello **текущей** таблицы и старой сотрудников в hello **архив** таблицы. Архивация сотрудник требует toodelete hello сущности из hello **текущей** и добавить сущность toohello hello **архив** таблицы, но не может использовать tooperform EGT эти две операции. риск hello tooavoid, сбой приводит tooappear сущности, оба или ни одна из таблиц, операция сохранения hello должен быть согласованным. Hello следующей схеме описаны шаги hello в этой операции. Дополнительные сведения приведены для исключения пути в следующий текст hello.  

![][12]

Клиент инициирует операцию архив hello, размещая сообщения в очереди Azure, в этом примере tooarchive сотрудника #456. Рабочая роль опрашивает очередь hello для новых сообщений; При обнаружении он считывает сообщение hello и оставляет скрытые копии очереди hello. Hello рабочей роли Далее извлекает копию hello сущности из hello **текущей** таблицы, вставка в hello **архив** таблицы, а затем удаляет hello исходного из hello **текущей**таблицы. И, наконец в случае ошибки из предыдущих шагов hello не hello рабочей роли удаляет hello скрытого сообщения из очереди hello.  

В этом примере шаг 4 вставляет hello сотрудника в hello **архив** таблицы. Его добавить hello сотрудника tooa blob в hello службы BLOB-объектов или файл в файловой системе.  

#### <a name="recovering-from-failures"></a>Восстановление после сбоев
Очень важно, hello операций в шагах **4** и **5** должно быть *идемпотентными* в случае, если операции архивирования hello toorestart должен hello рабочей роли. При использовании службы таблиц hello, для шага **4** следует использовать операцию «Вставка или замена»; для шага **5** следует использовать «удалить, если существует» операции в клиентской библиотеке hello, вы используете. Если используется другая система хранения данных, необходимо выполнить соответствующую идемпотентную операцию.  

Если рабочая роль hello никогда не завершается шаг **6**, затем после превышения времени ожидания hello снова появится на hello очереди, готовые к hello рабочей роли tootry tooreprocess его. Hello рабочей роли можно проверить, сколько раз прочтения сообщения в очереди hello и при необходимости это «подозрительных» сообщений для изучения путем отправки их tooa флаг разделения очереди. Дополнительные сведения о чтении очереди сообщений и проверки hello количество вывода из очереди см. в разделе [получение сообщений](https://msdn.microsoft.com/library/azure/dd179474.aspx).  

Некоторые ошибки из служб таблиц и очередей hello являются временных ошибок и клиентское приложение должно включать toohandle логику повторных попыток подходящий их.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Это решение не поддерживает изоляцию транзакций. Например, клиент может прочитать hello **текущей** и **архив** таблиц при hello рабочей роли между шагами **4** и **5**и в разделе несогласованное представление данных hello. Следует заметить, что данные hello согласованные со временем.  
* Необходимо убедиться, что шаги 4 и 5 идемпотентными в окончательной согласованности tooensure заказа.  
* Можно масштабировать hello решения с помощью нескольких очередей и экземпляры рабочих ролей.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Используйте этот шаблон при необходимости tooguarantee окончательной согласованности между сущностями, которая существует в другой секции или таблицы. Можно расширить этот шаблон tooensure окончательной согласованности для операций на hello службы таблиц и BLOB-объектов hello и других источников данных хранилища Azure, например базы данных или hello файловой системы.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Объединение или замена.](#merge-or-replace)  

> [!NOTE]
> Если уровень изоляции транзакции — tooyour важные решения, должны рассмотрите возможность повторной разработки вашей tooenable таблиц вы toouse EGTs.  
> 
> 

### <a name="index-entities-pattern"></a>Шаблон сущностей индекса
Обслуживание индекса сущностей tooenable эффективного поиска, возвращающих списки сущностей.  

#### <a name="context-and-problem"></a>Контекст и проблема
Hello службы таблиц автоматически индексирует сущностей с помощью hello **PartitionKey** и **RowKey** значения. Это позволяет tooretrieve приложения клиента эффективно с использованием запроса точки сущности. Например, с помощью структуры таблицы hello, показано ниже, клиентское приложение получать отдельного сотрудника сущности с помощью название отдела hello и идентификатор сотрудника hello (hello **PartitionKey** и **RowKey** ).  

![][13]

Если также требуется доступ tooretrieve toobe список сущности employee на основе hello значения другого свойства не являются уникальными, например фамилии, должен использовать менее эффективный раздел сканирования toofind совпадения, а не с помощью индекса toolook их непосредственно вверх. Это так, как служба таблиц hello не поддерживает вторичные индексы.  

#### <a name="solution"></a>Решение
Просмотр tooenable по фамилии со структурой сущности hello, показанном выше, необходимо поддерживать списки идентификаторов. Если требуется, чтобы сущности employee hello tooretrieve с определенной фамилией, например Джонс, сначала найдите hello список идентификаторов для сотрудников с Джонс как фамилии и затем извлечь эти сущности employee. Существует три основных варианта для хранения hello списки идентификаторов:  

* Использование хранилища больших двоичных объектов.  
* Создание индекса сущностей в hello же секции как сущности employee hello.  
* Создание сущностей индексов в отдельном разделе или таблице.  

<u>Вариант № 1. Использование хранилища больших двоичных объектов</u>  

Для первого параметра hello, создании большого двоичного объекта для каждого уникальный фамилии и в каждом хранилище больших двоичных объектов список hello **PartitionKey** (отдел) и **RowKey** (идентификатор сотрудника) значений для сотрудников, имеющих то последнего имя. При добавлении или удалении сотрудник следует убедиться, что hello содержимое hello соответствующие большого двоичного объекта является согласованным с сущности employee hello.  

<u>Параметр #2:</u> Здравствуйте, создание индекса сущностей в одной секции  

Второй параметр hello при помощи индекса сущностей, хранящих hello следующие данные:  

![][14]

Hello **EmployeeIDs** свойство содержит список идентификаторов для сотрудников с фамилией hello хранятся в hello **RowKey**.  

Hello ниже описывается процесс hello, которые необходимо выполнить при добавлении нового сотрудника при использовании hello второй вариант. В этом примере мы добавляем сотрудника с идентификатором 000152 и фамилию Джонс отдела продаж hello:  

1. Получить сущность hello индекса с **PartitionKey** значение «Sales» и hello **RowKey** значение «Иванов». Сохраните hello ETag toouse этой сущности на шаге 2.  
2. Создание транзакции группы сущностей (то есть пакетной операции), вставляет новую сущность employee hello (**PartitionKey** значение «Sales» и **RowKey** значение «000152»), и индекс сущности (helloобновлений **PartitionKey** значение «Sales» и **RowKey** значение «Иванов»), добавив hello нового сотрудника идентификатор toohello списка в поле EmployeeIDs hello. Сведения о транзакциях группы сущностей см. в разделе [Транзакции группы сущностей](#entity-group-transactions).  
3. Если транзакция группы сущностей hello завершается ошибкой из-за ошибки оптимистичного параллелизма (только что другой пользователь изменил hello индекс сущности), затем понадобятся toostart через на шаге 1.  

При использовании hello второй вариант, можно использовать аналогичные toodeleting подход сотрудника. Изменение последнего имени сотрудника немного сложнее, поскольку его нужно будет tooexecute транзакция группы сущностей, который обновляет три сущности: hello сущности employee hello индекс сущности для старого фамилии hello и сущность hello индекса для hello фамилию. Каждая сущность должна получать перед внесением любых изменений в порядке значений ETag hello tooretrieve, можно затем использовать обновления tooperform hello, опираясь на оптимистичный параллелизм.  

Hello ниже описывается процесс hello, которые необходимо выполнить при необходимости toolook копирование всех сотрудников hello с заданной фамилией отдела при использовании hello второй вариант. В этом примере осуществляется поиск всех сотрудников hello Фамилия Джонс отдела продаж hello:  

1. Получить сущность hello индекса с **PartitionKey** значение «Sales» и hello **RowKey** значение «Иванов».  
2. Синтаксический анализ списка hello коды в поле EmployeeIDs hello сотрудников.  
3. Если требуются дополнительные сведения о каждом из этих сотрудников (например, адреса электронной почты), извлекать каждой сущности employee hello с помощью **PartitionKey** значение «Sales» и **RowKey** значения из Hello список сотрудников, полученный на шаге 2.  

<u>Вариант 3.</u> Создание сущностей индексов в отдельном разделе или таблице  

Третий вариант hello при помощи индекса сущностей, хранящих hello следующие данные:  

![][15]

Hello **EmployeeIDs** свойство содержит список идентификаторов для сотрудников с фамилией hello хранятся в hello **RowKey**.  

Третий параметр hello нельзя использовать EGTs toomaintain согласованности, поскольку hello индекс сущности находятся в отдельной секции из сущности employee hello. Следует убедиться, что hello индекс сущности являются согласованным с сущности employee hello.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Это решение требует по крайней мере два запроса tooretrieve сопоставления сущностей: один tooquery hello индекс сущности tooobtain hello список **RowKey** значения, а затем отправляется запрос tooretrieve каждой сущности в списке hello.  
* Учитывая, что отдельной сущности не может превышать 1 МБ, параметр #2, и параметр #3 в решении hello предполагается hello список идентификаторов для данной фамилии больше никогда не превышает 1 МБ. Если список идентификаторов hello скорее всего, toobe больше 1 МБ, используйте параметр #1 и хранения данных индекса hello в хранилище больших двоичных объектов.  
* Если используется параметр #2 (с помощью toohandle EGTs Добавление и удаление сотрудников и изменение последнего имени сотрудника), необходимо определить Если hello объема транзакций будет достигнута ограничения масштабируемости hello в данной секции. Если это так hello, следует рассмотреть согласованным решения (параметр #1 или параметр #3), которые используют обновление hello toohandle очередей запросов и позволяет вам toostore индекс сущностей в отдельной секции из сущности employee hello.  
* Параметр #2, в этом решении предполагается требуется toolook по фамилиям в отделе: например, вы хотите tooretrieve список сотрудников с фамилией Джонс hello отдела продаж. Возможности toolook toobe копирование всех hello сотрудников с фамилией Джонс hello всей организации, используйте параметр #1 или параметр #3.
* Можно реализовать решение на основе очереди, обеспечивающая окончательной согласованности (hello в разделе [шаблон согласованным транзакции](#eventually-consistent-transactions-pattern) Дополнительные сведения).  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Используйте этот шаблон при необходимости toolookup набора сущностей, что все используют общее значение свойства, например всех сотрудников с фамилией hello Джонс.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>Шаблон денормализации
Объединение взаимосвязанные данные вместе в одной сущности tooenable tooretrieve все hello необходимо с помощью запроса одной точки данных.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе данных обычно нормализовать tooremove дублирования данных, что приводит к запросы, получающие данные из нескольких таблиц. Если вы нормализовать данные в таблицах Azure, необходимо несколько циклов приема-передачи из hello клиента toohello сервера tooretrieve связанные данные. Например, с табличной структурой hello, приведенные ниже, то требуется два округления приема-передачи tooretrieve hello подробные сведения об отделе: один toofetch hello отдел сущность, которая содержит идентификатор менеджера hello и еще один запрос toofetch hello manager сведения в сотрудника сущность.  

![][16]

#### <a name="solution"></a>Решение
Вместо сохранения данных hello в двумя отдельными сущностями, денормализации hello данных и хранить копию сведения диспетчера hello в сущность department hello. Например:  

![][17]

С сущностями отдела, хранимые с этими свойствами теперь можно получить все hello сведения, необходимые о отдела, с использованием запроса точки.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Двойное хранение некоторых данных связано с определенными издержками. Hello производительность (полученный из службы хранилища toohello меньшее число запросов) обычно перевешивает hello граничной увеличение затрат на хранение (и затрат частично смещение по снижению hello количество транзакций требуются сведения toofetch hello отдела).  
* Необходимо поддерживать согласованность hello две сущности, которые хранят сведения о диспетчерах hello. Можно обработать hello проблемы согласованности с помощью EGTs tooupdate несколько сущностей в одной атомарной транзакции: в этом случае сущность department hello и сущности employee hello для отдела hello хранятся в hello одной секции.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Используйте этот шаблон, если необходимо часто toolook связанные сведения. Этот шаблон уменьшает количество запросов к клиенту необходимо выполнять tooretrieve hello данные, которые требуются в hello.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>Шаблон составного ключа
Использование составного **RowKey** tooenable значения toolookup клиента связанные данные с помощью запроса одной точки.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе данных, это вполне естественным toouse соединения в запросах tooreturn связанные фрагменты данных toohello клиента в одном запросе. Например можно использовать toolook идентификатор сотрудника hello список связанных сущностей, которые содержат производительности и просмотреть данные для этого сотрудника.  

Предположим, что сущности employee хранятся в службе таблиц hello через hello следующая структура:  

![][18]

Необходимо также toostore исторические данные, связанные с tooreviews и производительности для каждого сотрудника hello года работал для вашей организации и может tooaccess toobe эти сведения понадобятся по годам. Один из вариантов является toocreate другую таблицу для хранения сущностей с hello следующие структуры:  

![][19]

Обратите внимание, что с этим подход, вы можете решить tooduplicate некоторые сведения (такие как имя и фамилия) в новый сущности tooenable hello вы tooretrieve данных с помощью одного запроса. Тем не менее не может поддерживать строгая согласованность, так как нельзя использовать tooupdate EGT hello две сущности атомарным образом.  

#### <a name="solution"></a>Решение
Сохранить новый тип сущности в исходной таблице с помощью сущностей с hello следующие структуры:  

![][20]

Обратите внимание, каким образом hello **RowKey** теперь используется составной ключ состоит из идентификатор сотрудника hello и год hello hello проверку данных, позволяющая tooretrieve hello производительности сотрудника и просматривать данные с помощью одного запроса для одной сущности.  

Следующий пример Hello описаны как можно получить все данные для проверки hello для конкретного сотрудника (например, сотрудник 000123 hello отдела продаж).  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Следует использовать подходящий разделитель, который позволяет легко tooparse hello **RowKey** значение: например, **000123_2012**.  
* Также сохранении этой сущности в секции таким же как другие сущности, содержащие соответствующие данные для hello hello же сотрудника, то есть можно использовать EGTs toomaintain строгая согласованность.
* Следует учитывать, как часто будет запрашивать данные toodetermine hello целесообразность этот шаблон.  Например если вы получите доступ к редко hello данные для проверки и hello основные данные о сотрудниках часто следует сохранять их как отдельные сущности.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Эта схема используется в том случае, когда требуется toostore одного или нескольких связанных сущностей запросе часто.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)  
* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>Шаблон для заключительного фрагмента журнала
Получить hello  *n*  сущностей недавно добавленную секцию tooa с помощью **RowKey** значение, которое сортирует в обратную даты и времени заказа.  

#### <a name="context-and-problem"></a>Контекст и проблема
Распространенным требованием является быть может tooretrieve hello последний созданный сущностей, например hello 10 последних заявки на компенсацию расходов переданный сотрудником. Таблица запросов, поддерживающих **$top** сначала запросить hello tooreturn операции  *n*  сущностей из набора: нет эквивалентный запрос операции tooreturn hello последние n сущностей в наборе.  

#### <a name="solution"></a>Решение
Хранилище hello сущностей с помощью **RowKey** , естественным образом Сортировка в обратном направлении даты и времени заказа с помощью так hello самую последнюю запись всегда hello первый в таблице hello.  

Например может tooretrieve toobe Здравствуйте 10 последних заявки на компенсацию расходов переданный сотрудником, можно использовать значение обратного тактов, производным от hello текущую дату и время. Hello следующий код C# показывает один из способов toocreate подходящее значение «инвертированный тактов» для **RowKey** , сортирует от последней toohello hello старой:  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

Вы можете вернуться toohello значение даты и времени с помощью hello, следующий код:  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

Таблица Hello запрос выглядит следующим образом:  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Необходимо заполнить значение обратного тактов hello в начале нулями сортирует tooensure hello строковое значение.  
* Следует иметь в виду hello целей масштабируемость на уровне hello секции. Не создайте разделы с высокой нагрузкой.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Используйте этот шаблон при необходимости tooaccess сущностей в порядке, обратном даты и времени, а также при необходимости tooaccess hello недавно добавлено сущностей.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Анти-шаблон, предусматривающий добавление в начало или конец;](#prepend-append-anti-pattern)  
* [Извлечение сущностей.](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a>Шаблон для удаления больших объемов сущностей
Включить удаление hello слишком большое количество сущностей, сохраняя все сущности hello для одновременного удаления в своих собственных отдельную таблицу; Удалить сущности hello, удалив таблицы hello.  

#### <a name="context-and-problem"></a>Контекст и проблема
Во многих приложениях удалить старые данные, которые больше не нужна toobe доступных tooa клиентское приложение или приложение hello архивации tooanother носитель. Обычно необходимо указать такие данные по дате: например, имеется требование записи toodelete все запросы на вход, не более 60 дней.  

Один из возможных является toouse hello даты и времени запроса входа hello в hello **RowKey**:  

![][21]

Такой подход позволяет избежать гиперобъекты секции, так как приложение hello можно вставки и удаления сущностей имя входа для каждого пользователя в отдельной секции. Однако этот подход может быть дорогостоящей и много времени при наличии большого числа сущностей, поскольку сначала его нужно tooperform просмотра таблиц в порядке tooidentify все toodelete сущностей hello и удалите каждый старая сущность. Обратите внимание, что можно уменьшить hello количество циклов приема-передачи toohello сервере требуется toodelete hello старого сущностей, пакетное выполнение нескольких запросов на удаление в EGTs.  

#### <a name="solution"></a>Решение
Используйте отдельную таблицу для каждого дня, когда предпринимаются попытки входа с систему. Конструктора сущностей hello выше tooavoid точки беспроводного доступа можно использовать при вставке сущности и удаление старого сущностей теперь является просто вопрос удаления одну таблицу каждый день (одна операция сохранения) вместо поиск и удаление сотен и тысяч сущности отдельного имени входа каждый день.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Проект поддерживает другие возможности, приложение будет использовать данные hello, например поиск определенных сущностей, связывание с другими данными или создания статистические данные?  
* Ваш проект предотвращает формирование активных областей в случае вставки новых сущностей?  
* Ожидается, что задержка, если требуется, чтобы tooreuse hello таким же именем таблицы после его удаления. Это лучше tooalways используйте уникальными именами таблиц.  
* Ожидается, что некоторые регулирование во время первого использования новой таблицы при hello службы таблиц узнает шаблоны доступа к hello и распределяет секции hello по узлам. Рассмотрите, как часто требуется toocreate новых таблиц.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Используйте этот шаблон, если выполняется большое количество сущностей, которые необходимо удалить в hello то же время.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Транзакции группы сущностей;](#entity-group-transactions)
* [Изменение сущностей.](#modifying-entities)  

### <a name="data-series-pattern"></a>Шаблон для рядов данных
Хранилище полные данные ряда в нескольких запросов к одной сущности toominimize hello.  

#### <a name="context-and-problem"></a>Контекст и проблема
Типичный сценарий предназначен для приложения toostore ряд данных, что обычно требуется tooretrieve за один раз. Например приложение может записи сколько Мгновенных сообщений, каждый час отправляет каждого сотрудника и затем использовать этот tooplot сведения, сколько сообщений, передаваемых каждого пользователя hello предыдущим 24 часам. Один конструктор может быть toostore 24 сущностей для каждого сотрудника.  

![][22]

Такой подход можно легко найти и обновить tooupdate hello сущности для каждого сотрудника, всякий раз, когда значение счетчика сообщение hello tooupdate необходимые приложения hello. Тем не менее tooretrieve Здравствуйте сведения tooplot диаграмму активности hello для hello, последние 24 часа, необходимо получить 24 сущности.  

#### <a name="solution"></a>Решение
Используйте следующие конструктора с числом сообщение hello toostore отдельные свойства для каждого часа hello.  

![][23]

Такой подход можно использовать сообщения число tooupdate hello слияния операций для сотрудника для определенное время. Теперь можно получить все сведения hello необходимы tooplot hello диаграммы с помощью запроса одной сущности.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Если ряды полные данные не помещаются в одну сущность (сущность может иметь свойства too252), используйте в альтернативном хранилище данных как большого двоичного объекта.  
* Если у вас есть несколько клиентов одновременно обновление сущности, вам потребуется toouse hello **ETag** tooimplement оптимистичного параллелизма. Большое количество клиентов может привести к высокому уровню конкуренции.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Эта схема используется в том случае, когда необходима tooupdate и получить ряд данных, связанных с отдельной сущности.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Шаблон для сущностей больших размеров](#large-entities-pattern)  
* [Объединение или замена.](#merge-or-replace)  
* [Шаблон согласованным транзакции](#eventually-consistent-transactions-pattern) (при сохранении hello ряда данных в большой двоичный объект)  

### <a name="wide-entities-pattern"></a>Шаблон для масштабных сущностей
Используете несколько сущностей логической toostore физические объекты с более чем 252 свойств.  

#### <a name="context-and-problem"></a>Контекст и проблема
Отдельные сущности может иметь не более чем 252 свойств (за исключением hello обязательные системные свойства) и не может хранить более 1 МБ данных в целом. В реляционной базе данных обычно получаемому round любые ограничения на размер строки hello, добавив новую таблицу и обеспечения 1 к 1 взаимосвязи между ними.  

#### <a name="solution"></a>Решение
С помощью службы таблиц hello, можно хранить несколько сущностей toorepresent объект одного крупного бизнеса с более чем 252 свойств. Например если вы хотите toostore число hello количество Мгновенных сообщений, отправляемых для каждого сотрудника для hello последние 365 дней, можно использовать hello следующая структура, использующая две сущности с разными схемами:  

![][24]

Если вам требуется toomake изменения, требующие обновления обоих tookeep сущностей, их синхронизировано друг с другом, можно использовать EGT. В противном случае сообщение число tooupdate hello одного объединения операций можно использовать для определенного дня. все hello данные для отдельного сотрудника, необходимо получить обе сущности, но это можно сделать с двумя эффективный запросами, которые используются оба tooretrieve **PartitionKey** и **RowKey** значение.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Извлечение полного логическая сущность состоит по крайней мере два транзакции с хранилищем: один tooretrieve физической сущности.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Используйте этот шаблон при необходимости toostore сущностей, размер или число свойств превышает пределы hello для отдельной сущности hello служба таблиц.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Транзакции группы сущностей;](#entity-group-transactions)
* [Объединение или замена.](#merge-or-replace)

### <a name="large-entities-pattern"></a>Шаблон для сущностей больших размеров
Используйте значения больших свойств toostore хранилища больших двоичных объектов.  

#### <a name="context-and-problem"></a>Контекст и проблема
В отдельной сущности нельзя сохранить данные, общий объем которых превышает 1 МБ. Если одно или несколько свойств хранения значений, которые приводят это значение hello общий размер вашей tooexceed сущности, нельзя хранить hello всей сущности в hello службы таблиц.  

#### <a name="solution"></a>Решение
Если сущности превышает 1 МБ, так как одно или несколько свойств содержат большой объем данных, можно сохранить данные в hello службы BLOB-объектов и затем сохранить адрес hello hello большого двоичного объекта в свойстве в сущности hello. Например, можно хранить hello фотография сотрудника в хранилище больших двоичных объектов и хранить фотографию toohello ссылку в hello **фото** свойство сущности employee:  

![][25]

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* toomaintain окончательной согласованности между сущностью hello в hello службы таблиц и данных hello в hello BLOB-объектов, используйте hello [шаблон согласованным транзакции](#eventually-consistent-transactions-pattern) toomaintain сущностей.
* Получение в завершенную сущность состоит по крайней мере два транзакции с хранилищем: одна сущность tooretrieve hello и один tooretrieve hello данные большого двоичного объекта.  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Используйте этот шаблон, когда нужна toostore сущностей, размер которого превышает ограничения hello для отдельной сущности в службе таблиц hello.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Шаблон для масштабных сущностей.](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>Анти-шаблон, предусматривающий добавление в начало или конец
Повышения масштабируемости, при наличии большой объем вставок, распределяя вставок hello по нескольким секциям.  

#### <a name="context-and-problem"></a>Контекст и проблема
Добавляя или добавлении сущности tooyour хранимых сущностей обычно приводит к предварительного добавления новых сущностей toohello приложения hello или последней секции последовательность секций. В этом случае все вставки hello в любой момент времени происходило в hello вставляет одного раздела, Создание активной области, который предотвращает hello таблицы службы балансировки нагрузки между несколькими узлами и возможно вызывает масштабируемость hello toohit вашего приложения целевые объекты для секции. Например если у вас есть приложение, доступ к сети журналы и ресурсов для сотрудников, то в итоге структуру сущности, как показано ниже hello текущий час секции становится активной области, если hello объема транзакций достигает hello цель масштабируемости для отдельные секции:  

![][26]

#### <a name="solution"></a>Решение
Hello следующая структура альтернативных сущности позволяет избежать появления гиперобъекта на любой определенной секции как события журналы приложения hello.  

![][27]

Обратите внимание, в данном примере как оба hello **PartitionKey** и **RowKey** являются составными. Hello **PartitionKey** использует отдел hello и ведения журнала для hello toodistribute идентификатор сотрудника по нескольким секциям.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующие точки, при определении hello как tooimplement этот шаблон:  

* Делает клиентское приложение выполняет hello альтернативных ключевой структуры, можно избежать создания горячей секций при операции вставки эффективно hello поддерживают запросы?  
* Означает ли ваш предполагаемого объема транзакций, скорее всего, tooreach hello целевые показатели масштабируемости отдельной секции и регулирование службой хранения hello?  

#### <a name="when-toouse-this-pattern"></a>Если toouse этот шаблон
Избегайте антишаблон началу append hello при тома транзакций является вероятностью tooresult регулирования службой хранения hello при доступе к горячей секции.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
Hello следующие шаблоны и рекомендации могут также быть актуальна при реализации данного шаблона:  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для заключительного фрагмента журнала;](#log-tail-pattern)  
* [Изменение сущностей.](#modifying-entities)  

### <a name="log-data-anti-pattern"></a>Анти-шаблон для данных журнала
Как правило следует использовать hello службы больших двоичных объектов вместо hello данные журнала toostore службы таблицы.  

#### <a name="context-and-problem"></a>Контекст и проблема
Обычное Сфера применения данных журнала — tooretrieve выбора записей журнала для определенной даты или диапазона: например, можно toofind все hello и критических сообщений об ошибках, зарегистрированные приложения между 15:04 и 15:06 на конкретную дату. Требуется toouse hello даты и времени hello журнала сообщений toodetermine hello секции Сохранение записей журнала в: что результаты в активном секции так, как в любой момент времени будут совместно использовать все сущности журнала hello hello же **PartitionKey** значение (в разделе hello [начале/Добавление антишаблон](#prepend-append-anti-pattern)). Например hello, следующая схема сущности сообщение журнала приводит горячей секции, так как приложение hello записывает все сообщения журнала toohello секции для hello текущей даты и времени:  

![][28]

В этом примере hello **RowKey** включает hello Дата и время tooensure сообщение hello журнала, что сообщения журнала хранятся в порядке даты и времени и включает идентификатор сообщения в случае, если несколько сообщений журнала совместно использовать hello же даты и времени.  

Другой подход заключается в toouse **PartitionKey** , гарантирующий, что приложение hello записывает сообщения для диапазона секций. Например если hello источник сообщения журнала hello предоставляет toodistribute способом сообщений по нескольким секциям, можно использовать следующие схемы сущности hello:  

![][29]

Hello проблему с этой схемы то, что tooretrieve все hello сообщений журнала для определенный промежуток времени, необходимо найти каждой секции в таблице hello.

#### <a name="solution"></a>Решение
Hello предыдущего раздела выделенный hello ситуации, стараясь toouse hello записей журналов toostore службы таблиц и предлагаемые два неудовлетворительными, схем. Одно из решений руководством tooa горячей секции с hello риск снижения производительности на запись сообщений журнала; Hello другим решением привела к низкой производительности запросов из-за требований tooscan hello каждой секции в таблице hello tooretrieve сообщениях журнала определенный промежуток времени. Хранилище BLOB-объектов предлагает лучшим решением для такого сценария и не собирает данные hello журнала Azure аналитики хранилища хранилищ.  

В этом разделе описаны как аналитика хранилища сохраняет данные журнала в хранилище BLOB-объектов как иллюстрация подход toostoring данных, которые обычно выполняются запросы по диапазону.  

Служба аналитики хранилища сохраняет сообщения журнала в формате с разделителями в нескольких больших двоичных объектах. в формате с разделителями Hello упрощает для клиента данных hello tooparse приложения в журнал сообщение hello.  

Аналитика хранилища используется соглашение об именовании для больших двоичных объектов, которые позволяет toolocate hello большого двоичного объекта (или большие двоичные объекты), содержащими сообщения журнала hello, поиск которых выполняется. Например большой двоичный объект с именем «queue/2014/07/31/1800/000001.log» содержит сообщения журнала, связанные службы очередей toohello hello час, начиная с 18:00, 31 июля 2014 г. Hello «000001» указывает, что это hello первый файл журнала за этот период. Аналитика хранилища также сначала записывает отметки времени hello hello и последний журнала сообщения, хранящиеся в файле hello как часть метаданных hello большого двоичного объекта. Hello API для больших двоичных объектов хранилища позволяет обнаружить большие двоичные объекты в контейнере на основе префикса имени: toolocate все hello большие двоичные объекты, содержащие очереди данных журналов для hello час, начиная с 18:00, можно использовать hello префикс «очереди/2014/07/31/1800.»  

Аналитики хранилища внутренне буферов сообщений журнала и периодически обновлять соответствующие hello BLOB-объект или создает новый файл с последнего пакета hello записей журнала. Это сокращает число hello записи необходимо выполнить toohello BLOB-объектов.  

При реализации аналогичное решение в приложении, необходимо учитывать, как toomanage hello компромисса между надежность (записи каждого хранилища tooblob запись журнала, как это происходит), стоимости и масштабируемости (буферизации обновлений в приложении и их записи tooblob хранилища в пакетах).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Примите во внимание при выборе влияние toostore журнала данных следующие точки hello.  

* При создании схемы таблицы без потенциальных разделов с высокой нагрузкой может оказаться, что доступ к данным журнала осуществляется неэффективно.  
* tooprocess ведения журнала данных, часто клиент должен tooload много записей.  
* Несмотря на то, что данные журнала часто носят структурированный характер, наилучшим решением может быть хранилище больших двоичных объектов.  

### <a name="implementation-considerations"></a>Рекомендации по реализации
В этом разделе рассматриваются некоторые из toobear вопросы hello учитывать при реализации шаблонов hello, описанное в предыдущем разделе hello. Большая часть этого раздела используются примеры написаны на C#, в которых используется hello клиентской библиотеки хранилища (версия 4.3.0 на момент написания статьи hello).  

### <a name="retrieving-entities"></a>Извлечение сущностей.
Как описано в разделе "hello" [конструктора для выполнения запросов к](#design-for-querying), hello наиболее эффективный это запрос точки. Однако в некоторых сценариях может потребоваться tooretrieve нескольких сущностей. В этом разделе описываются некоторые общие сущности tooretrieving подходы, с помощью клиентской библиотеки хранилища hello.  

#### <a name="executing-a-point-query-using-hello-storage-client-library"></a>Выполнение запроса точки с помощью клиентской библиотеки хранилища hello
tooexecute простым способом Hello запроса точки — toouse hello **получить** табличную операцию, как показано в hello, следующий фрагмент кода C#, который извлекает сущность с **PartitionKey** значение «Sales» и  **RowKey** значения «212»:  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

Обратите внимание на то, как в этом примере ожидает hello объекта он извлекает toobe типа **EmployeeEntity**.  

#### <a name="retrieving-multiple-entities-using-linq"></a>Извлечение нескольких сущностей с помощью LINQ
Для извлечения нескольких сущностей можно использовать LINQ с клиентской библиотекой хранилища, указав при этом запрос с предложением **where** . tooavoid Просмотр таблицы, следует всегда включать hello **PartitionKey** значение в hello где предложения и по возможности hello **RowKey** значение tooavoid просмотров таблиц и разделов. Hello служба таблиц поддерживает ограниченный набор операторов сравнения (больше, больше или равно, меньше чем», «меньше или равно, равно и не равно) toouse в hello где предложения. Hello следующий фрагмент кода C# выполняет поиск всех сотрудников hello которого последнее имя начинается с «B» (при условии, что hello **RowKey** хранилищ hello Фамилия) в отдел продаж hello (при условии, что hello **PartitionKey** хранит имя hello отдела):  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

Обратите внимание на то, как запрос hello указывает оба **RowKey** и **PartitionKey** tooensure более высокую производительность.  

Hello следующий образец кода демонстрирует эквивалентную функциональность, с помощью плавного API hello (Дополнительные сведения о fluent API-интерфейсы в целом. в разделе [практические рекомендации по разработке Fluent API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> Hello образец создает вложенные несколько **CombineFilters** tooinclude методы hello три условия фильтрации.  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a>Извлечение большого количества сущностей из запроса
Оптимальный запрос возвращает отдельные сущности на основе значений **PartitionKey** и **RowKey**. Однако в некоторых случаях возможно tooreturn требование множество сущностей из hello же секции, или даже от большого числа секций.  

Следует всегда полностью проверить производительность приложения hello в таких сценариях.  

Запрос к службе таблиц hello может возвращать не более 1000 сущностей одновременно и может выполняться не более 5 секунд. Если hello результирующий набор содержит более 1000 сущностей, если hello запрос не завершен в течение 5 секунд, или если hello запрос пересекает границу секции hello, hello служба таблиц возвращает tooenable токен продолжения hello hello toorequest клиентского приложения Следующий набор сущностей. Дополнительные сведения о принципе действия маркеров продолжения см. в статье [Query Timeout and Pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx) (Время ожидания запроса и разбивка на страницы).  

При использовании клиентской библиотеки хранилища hello, он может автоматически обработки токенов продолжения автоматически при возвращении сущностей из службы таблиц hello. Hello следующий пример кода C# с помощью клиентской библиотеки хранилища hello автоматически обрабатывает маркеры продолжения hello служба таблиц возвращает их в ответе:  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

Следующий код C# Hello обрабатывает маркеры продолжения явным образом:  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

С помощью токенов продолжения явным образом, можно управлять при получении hello следующего сегмента данных. Например если клиентское приложение позволяет пользователям toopage через hello сущностей, хранящихся в таблице, пользователь может решить не toopage через все сущности hello, полученные запросом hello, поэтому приложение будет использовать только типа hello tooretrieve токен продолжения рядом сегмент при hello пользователя был завершен постраничный просмотр всех сущностей hello в текущем сегменте hello. Такой подход имеет несколько преимуществ.  

* Благодаря этому можно toolimit hello объем tooretrieve данные из службы таблиц hello и переносить по сети hello.  
* Она позволяет вам tooperform асинхронные операции ввода-ВЫВОДА в .NET.  
* Благодаря этому можно tooserialize hello продолжение токена toopersistent хранилища, чтобы продолжить hello для события сбоя приложения.  

> [!NOTE]
> Маркер продолжения обычно возвращает сегмент, содержащий 1000 сущностей и меньше. Это также относится hello ограничить hello количество записей, которые возвращает запрос, используя **принимать** tooreturn hello первый n сущностей, которые соответствуют условию поиска: hello таблицы служба может возвратить сегмент, содержащий менее n сущностей вдоль с tooenable токен продолжения вы tooretrieve hello оставшиеся объекты.  
> 
> 

Hello следующий код C# показывает, как количество сущностей hello toomodify возвращаются внутри сегмента:  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>Проекция на стороне сервера
Одной сущности можно иметь свойства too255 и развертывать too1 МБ. При запросе таблицы hello и получения сущностей, могут потребоваться не все свойства hello и можно избежать, без необходимости передачи данных (toohelp сократить задержку и уменьшить стоимость). Можно использовать свойства просто hello tootransfer проекции на стороне сервера, необходимые. Hello следующий пример — извлекает только hello **электронной почты** свойства (вместе с **PartitionKey**, **RowKey**, **Timestamp**и  **ETag**) из сущностей hello, выбранные запросом hello.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

Обратите внимание, каким образом hello **RowKey** значение доступно, даже если он не был включен в список свойств tooretrieve hello.  

### <a name="modifying-entities"></a>Изменение сущностей.
Hello клиентская библиотека хранилища позволяет toomodify сущностей, хранящиеся в службе таблиц hello, вставка, удаление и обновление сущностей. EGTs toobatch можно использовать несколько операций вставки, обновления и delete вместе tooreduce hello количество циклов приема-передачи требуется и повысить производительность hello решения.  

Учтите, что исключения, когда hello клиентской библиотеки хранилища обычно выполняет EGT включают индекс hello hello сущность, которая вызвала toofail пакета hello. Это может оказаться полезным при отладке кода, использующего транзакции группы сущностей.  

Следует также учитывать влияние разработки на то, каким образом клиентское приложение обрабатывает операций параллелизма и обновления.  

#### <a name="managing-concurrency"></a>Управление параллелизмом
По умолчанию, служба таблиц hello реализует оптимистичного параллелизма проверка на уровне hello отдельных сущностей для **вставить**, **слияния**, и **удалить** операций, Хотя допускается для типа hello tooforce клиента таблицы toobypass службы этих проверок. Дополнительные сведения об управлении параллелизмом hello службы таблиц см. в разделе [управление параллелизмом в хранилище Microsoft Azure](../storage/common/storage-concurrency.md).  

#### <a name="merge-or-replace"></a>Объединение или замена.
Hello **заменить** метод hello **TableOperation** класса всегда заменяет hello завершенную сущность в hello службы таблиц. Если не включено свойство в запросе hello, свойство существует в сущности хранимых hello, запрос hello удаляет хранение свойство из hello сущности. Если не требуется tooremove свойства явным образом из хранится каждое свойство, необходимо включить в запрос hello.  

Можно использовать hello **слияния** метод hello **TableOperation** класса tooreduce hello объем данных, следует отправить службе таблиц toohello при необходимости tooupdate сущности. Hello **слияния** метод заменяет все свойства в сущности hello хранимые значения свойства из сущности hello, включенных в запрос hello, но оставляет без изменений в любые свойства в hello хранится сущности, которые не включены в запрос hello. Это полезно в том случае, если большие объекты и достаточно tooupdate небольшое количество свойств в запросе.  

> [!NOTE]
> Hello **заменить** и **слияния** способы завершаются ошибкой, если hello сущность не существует. В качестве альтернативы можно использовать hello **InsertOrReplace** и **InsertOrMerge** методы, создать новую сущность, если он не существует.  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a>Работа с разными типами сущностей
Hello службы таблиц — *без схемы* хранилища таблиц, значит, что одной таблицы может содержать объекты различных типов, обеспечивая большую гибкость при разработке. Hello следующий пример иллюстрирует таблица сотрудников и отдел сущностей:  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Обратите внимание, что каждая сущность должна иметь значения **PartitionKey**, **RowKey** и **Timestamp** и при этом может содержать любой набор свойств. Кроме того что нет tooindicate hello введите сущности, если вы не выбрали toostore где-нибудь эту информацию. Для идентификации типа сущности hello двумя способами:  

* Добавить toohello тип сущности hello **RowKey** (или возможно hello **PartitionKey**). Например, **EMPLOYEE_000123** или **DEPARTMENT_SALES** в качестве значений **RowKey**.  
* Используйте отдельные свойства toorecord hello тип сущности как показано в следующей таблице hello.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Department</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Первый вариант Hello, добавляя hello объекта типа toohello **RowKey**, полезно, если есть вероятность, что две сущности различных типов могут появиться hello же значение ключа. Он также группирует сущности hello в секции hello того же типа, друг с другом.  

Hello способов, приведенных в этом разделе, обсуждение которых относится toohello [отношения наследования](#inheritance-relationships) ранее в данном руководстве в разделе "hello" [моделирования связей](#modelling-relationships).  

> [!NOTE]
> Следует рассмотрите возможность включения номер версии в hello типа значение tooenable клиентских приложений tooevolve POCO объектов сущностей и работать с различными версиями.  
> 
> 

Hello остальной части этого раздела описываются некоторые функции hello в hello клиентской библиотеки хранилища, предназначенных для упрощения работы с несколькими типами сущностей в hello же таблицы.  

#### <a name="retrieving-heterogeneous-entity-types"></a>Извлечение разных типов сущностей
При использовании клиентской библиотеки хранилища hello имеется три параметра для работы с несколькими типами сущностей.  

Если вы знаете тип hello hello объектов с определенным **RowKey** и **PartitionKey** значения, то можно указать тип сущности hello при извлечении hello сущности, как показано в примерах hello предыдущие два получать сущностей типа **EmployeeEntity**: [выполнение запроса точки с помощью клиентской библиотеки хранилища hello](#executing-a-point-query-using-the-storage-client-library) и [извлечения нескольких сущностей с помощью LINQ](#retrieving-multiple-entities-using-linq).  

второй вариант Hello — toouse hello **DynamicTableEntity** типа (контейнер свойств) вместо конкретный тип сущности POCO (этот параметр может также повысить производительность, поскольку нет необходимости tooserialize и десериализации hello сущности слишком. Типы по сети). Следующий код C# потенциально Hello получает несколько сущностей различных типов из таблицы hello, но возвращает все сущности как **DynamicTableEntity** экземпляров. Затем он использует hello **EntityType** тип hello toodetermine свойства каждой сущности:  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

Обратите внимание, что tooretrieve другие свойства, необходимо использовать hello **TryGetValue** метод hello **свойства** свойство hello **DynamicTableEntity** класса.  

Третий вариант — использование hello toocombine **DynamicTableEntity** типа и **EntityResolver** экземпляра. Это позволяет типами POCO toomultiple tooresolve в hello того же запроса. В этом примере hello **EntityResolver** делегат использует hello **EntityType** toodistinguish свойство между типами hello две сущности, запрос возвращает hello. Hello **Разрешить** метод использует hello **Сопоставитель** делегировать tooresolve **DynamicTableEntity** экземпляров слишком**TableEntity** экземпляров.  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a>Изменение разных типов сущностей
Тип сущности toodelete tooknow hello не обязательно, а всегда известен тип hello сущности при вставке его. Тем не менее, можно использовать **DynamicTableEntity** введите tooupdate сущности, не зная его типа и без использования класса сущности POCO. Hello следующий образец кода возвращает одну сущность и проверяет hello **EmployeeCount** существует свойство перед его обновлением.  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a>Управление доступом с помощью подписей общего доступа
Можно использовать подпись общего доступа (SAS) токены tooenable клиентских приложений toomodify (и запрос) сущностей таблицы напрямую без tooauthenticate необходимость hello непосредственно с hello службы таблиц. Как правило существует три основных преимущества toousing SAS в приложении:  

* Нет необходимости toodistribute хранилища учетной записи ключа tooan небезопасных платформы (например, мобильных устройств) в порядке tooallow tooaccess этого устройства и изменения объектов в hello службы таблиц.  
* Вы можете разгрузить часть работы hello веб- и рабочих ролей выполнять в управлении устройствами tooclient сущности как компьютеры конечных пользователей и мобильных устройств.  
* Можно назначить ограниченного и время ограниченный набор разрешений tooa клиента (например, разрешение доступа только для чтения toospecific ресурсы).  

Дополнительные сведения об использовании токенов SAS с hello службы таблиц см. в разделе [с помощью общего доступа подписи (SAS)](../storage/common/storage-dotnet-shared-access-signature-part-1.md).  

Однако по-прежнему необходимо создать токены SAS hello, предоставляющими клиент toohello объекты приложения в службе таблиц hello: это необходимо в среде, которая имеет защищенный доступ tooyour ключи учетной записи хранения. Как правило используется веб- или рабочей роли toogenerate hello SAS маркеры и их toohello клиентские приложения, которые требуется получить доступ к tooyour сущностей. Поскольку по-прежнему издержки участвующие в создании и доставке tooclients маркеры SAS, рассмотрите возможность оптимальных tooreduce эту нагрузку, особенно в крупномасштабных системах.  

Это возможно toogenerate маркер SAS, который обеспечивает доступ tooa подмножество hello сущностей в таблице. По умолчанию создает маркер SAS для всей таблицы, но это также возможно toospecify этой tooeither hello SAS предоставление маркера доступа диапазон **PartitionKey** значений или диапазон **PartitionKey** и  **RowKey** значения. Можно выбрать toogenerate маркеры SAS для отдельных пользователей системы таким образом, что маркер SAS для каждого пользователя предоставляет им доступ только служба таблиц tootheir собственные сущностей в hello.  

### <a name="asynchronous-and-parallel-operations"></a>Асинхронные и параллельные операции
Чтобы улучшить производительность и время отклика клиента в случае распределения запросов по нескольким разделам, рекомендуется обратить внимание на асинхронные и параллельные запросы.
Например, в вашем распоряжении может быть два или несколько экземпляров рабочих ролей с параллельным доступом к таблицам. Может иметь отдельные рабочие роли, ответственный за отдельные наборы разделов или просто иметь несколько экземпляров рабочей роли, каждый может tooaccess все hello секций в таблице.  

Повысить производительность в экземпляре клиента можно путем асинхронного выполнения операций хранения. Hello клиентская библиотека хранилища позволяет легко toowrite асинхронные запросы и изменения. Например можно начать с hello синхронный метод, который извлекает все сущности hello в секции, как показано в hello, следующий код C#:  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

Этот код можно легко изменить, поэтому этот запрос hello выполняется асинхронно, как показано ниже:  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

В этом примере асинхронного видно hello следующие изменения из hello синхронной версии:  

* Сигнатура метода Hello теперь включает hello **async** модификатор и возвращает **задачи** экземпляра.  
* Вместо вызова hello **ExecuteSegmented** tooretrieve результаты метода, теперь вызовы hello метод hello **ExecuteSegmentedAsync** метод и использует hello **await** модификатор tooretrieve приводит асинхронно.  

клиентское приложение Hello этот метод можно вызывать несколько раз (с разными значениями hello **отдел** параметра), и каждый запрос будет выполняться в отдельном потоке.  

Обратите внимание, что нет асинхронную версию hello **Execute** метод в hello **TableQuery** класса, так как hello **IEnumerable** интерфейс не поддерживает асинхронные перечисление.  

Можно вставлять, обновлять и удалять сущности в асинхронном режиме. Следующий пример на C# Hello показывает tooinsert простой, синхронный метод или замены сущности employee:  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

Этот код можно легко изменить, чтобы обновление hello выполняется асинхронно, как показано ниже:  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

В этом примере асинхронного видно hello следующие изменения из hello синхронной версии:  

* Сигнатура метода Hello теперь включает hello **async** модификатор и возвращает **задачи** экземпляра.  
* Вместо вызова hello **Execute** метод tooupdate hello сущность, теперь вызовы hello метод hello **ExecuteAsync** метод и использует hello **await** tooretrieve модификатор результаты асинхронно.  

Hello клиентское приложение может вызывать несколько асинхронных методов такого рода, и каждый вызов метода будет выполняться в отдельном потоке.  

### <a name="credits"></a>Баллы
Мы хотели бы hello toothank следующие члены hello команды Azure их достижениями: Dominic Betts, Джейсон Хогг, Жан Ghanem, Джей Харидас, Джефф Ирвин, Vamshidhar Kommineni, Vinay Козлов и Serdar Ozler а также (Tom Hollander) из Microsoft DX. 

Мы также предлагаем hello toothank следующего Microsoft MVP по их мнение во время проверки циклов: Игорь Papirov и Эдвард Bakker.

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

