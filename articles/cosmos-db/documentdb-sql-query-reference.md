---
Заголовок: aaa» Azure Cosmos DB DocumentDB API: синтаксис SQL | Документы Microsoft» Описание: справочную документацию по классу hello язык запросов SQL Azure Cosmos базы данных DocumentDB API.
службы: cosmos db Автор: диспетчер mimig1: jhubbard редактора: mimig documentationcenter: ''

MS.AssetId: ms.service: ms.workload cosmos db: ms.tgt_pltfrm службы данных: ms.devlang н/д: н/д ms.topic: ссылки ms.date: ms.author 06/13/2017 г.: mimig

---

# <a name="azure-cosmos-db-documentdb-api-sql-syntax-reference"></a>Справочник по синтаксису SQL-запросов API DocumentDB в Azure Cosmos DB

Hello Azure Cosmos DB DocumentDB API поддерживает запросов документы с помощью знакомого языка SQL (языка структурированных запросов) как грамматики иерархическим документам JSON, не требуя явной схемы или создания вторичных индексов. Этот раздел содержит справочную документацию по hello язык запросов DocumentDB API SQL.

Пошаговое hello язык запросов DocumentDB API SQL см. в разделе [SQL-запросов для Azure Cosmos DB DocumentDB API](documentdb-sql-query.md).  
  
Мы также приглашаем вас toovisit hello [площадку запросов](http://www.documentdb.com/sql/demo) где попробуйте Azure Cosmos DB и выполнение запросов SQL, используя наш набор данных.  
  
## <a name="select-query"></a>Запрос SELECT  
Получает документы JSON из базы данных hello. Он поддерживает вычисление выражений, проектирование, фильтрацию и соединение.  Hello обозначения, используемые для описания инструкций SELECT hello, приведены в разделе соглашения о синтаксисе hello.  
  
**Синтаксис**  
  
```
<select_query> ::=  
SELECT <select_specification>   
    [ FROM <from_specification>]   
    [ WHERE <filter_condition> ]  
    [ ORDER BY <sort_specification> ]  
```  
  
 **Примечания**  
  
 Сведения о каждом из этих предложений см. в следующих разделах:  
  
-   [Предложение SELECT](#bk_select_query)  
  
-   [Предложение FROM](#bk_from_clause)  
  
-   [Предложение WHERE](#bk_where_clause)  
  
-   [Предложение ORDER BY](#bk_orderby_clause)  
  
Hello предложения в инструкции SELECT hello должны быть упорядочены, как показано выше. Любое из необязательных предложений hello может быть опущено. Но если необязательные предложения используются, они должны следовать в правильном порядке hello.  
  
**Логический порядок обработки инструкции SELECT hello**  
  
— Hello порядок, в котором обрабатываются предложения:  

1.  [Предложение FROM](#bk_from_clause)  
2.  [Предложение WHERE](#bk_where_clause)  
3.  [Предложение ORDER BY](#bk_orderby_clause)  
4.  [Предложение SELECT](#bk_select_query)  

Обратите внимание, что это отличается от порядка hello, в котором они появляются в синтаксис hello. Hello упорядочение выполняется таким образом, что все новые символы, представленные обработанным предложением видны и могут использоваться в предложениях, обрабатываемых позднее. Например, псевдонимы, объявленные в предложении FROM, доступны в предложениях WHERE и SELECT.  

**Пробелы и комментарии**  

Все символы пробелов, которые не являются частью строку в кавычках или заключенный в кавычки идентификатор не являются частью грамматики языка hello и учитываются во время синтаксического анализа.  

Hello язык запросов поддерживает комментарии в стиле T-SQL  

-   Инструкция SQL `-- comment text [newline]`  

Пробелы и комментарии не имеют значения в грамматике hello, они должны быть используется tooseparate маркеры. Например, `-1e5` представляет лексему с одним номером, а `: – 1 e5` — лексему "минус" (–), за которой следует номер 1 и идентификатор e5.  

##  <a name="bk_select_query"></a>Предложение SELECT  
Hello предложения в инструкции SELECT hello должны быть упорядочены, как показано выше. Любое из необязательных предложений hello может быть опущено. Но если необязательные предложения используются, они должны следовать в правильном порядке hello.  

**Синтаксис**  
```  
SELECT <select_specification>  

<select_specification> ::=   
      '*'   
      | <object_property_list>   
      | VALUE <scalar_expression> [[ AS ] value_alias]  
  
<object_property_list> ::=   
{ <scalar_expression> [ [ AS ] property_alias ] } [ ,...n ]  
  
```  
  
 **Аргументы**  
  
 `<select_specification>`  
  
 Свойства или значение toobe, выбранных для hello результирующего набора.  
  
 `'*'`  
  
Указывает, что значение hello должно быть получено без внесения изменений. В частности в том случае, если значение hello обработки является объектом, будет получен все свойства.  
  
 `<object_property_list>`  
  
Указывает список свойств toobe получить hello. Каждое возвращаемое значение будет свой объект с указанных свойств hello.  
  
`VALUE`  
  
Указывает, что вместо hello полного объекта JSON должно быть получено значение JSON hello. Это, в отличие от `<property_list>` не переносится hello предполагаемое значение в объекте.  
  
`<scalar_expression>`  
  
Вычислить выражение, представляющее значение toobe hello. Дополнительные сведения см. в разделе [Скалярные выражения](#bk_scalar_expressions).  
  
**Примечания**  
  
Hello `SELECT *` синтаксис допустим, только если предложение FROM объявило ровно один псевдоним. Синтаксис `SELECT *` обеспечивает проекцию удостоверения, что может пригодиться, если проекция не требуется. Кроме того, это единственный действительный синтаксис, если в предложении FROM указан один источник входных данных.  
  
Обратите внимание, что `SELECT <select_list>` и `SELECT *` — это "синтаксический сахар". При необходимости их можно выразить с помощью простых инструкций SELECT, как показано ниже.  
  
1.  `SELECT * FROM ... AS from_alias ...`  
  
     эквивалентно правилу  
  
     `SELECT from_alias FROM ... AS from_alias ...`  
  
2.  `SELECT <expr1> AS p1, <expr2> AS p2,..., <exprN> AS pN [other clauses...]`  
  
     эквивалентно правилу  
  
     `SELECT VALUE { p1: <expr1>, p2: <expr2>, ..., pN: <exprN> }[other clauses...]`  
  
**См. также**  
  
[Скалярные выражения](#bk_scalar_expressions)  
[Предложение SELECT](#bk_select_query)  
  
##  <a name="bk_from_clause"></a>Предложение FROM  
Указывает источник hello или присоединенных источников. Hello from является необязательным. Даже без него другие приложения по-прежнему выполнятся.  
  
**Синтаксис**  
  
```  
FROM <from_specification>  
  
<from_specification> ::=   
        <from_source> {[ JOIN <from_source>][,...n]}  
  
<from_source> ::=   
          <collection_expression> [[AS] input_alias]  
        | input_alias IN <collection_expression>  
  
<collection_expression> ::=   
        ROOT   
     | collection_name  
     | input_alias  
     | <collection_expression> '.' property_name  
     | <collection_expression> '[' "property_name" | array_index ']'  
```  
  
**Аргументы**  
  
`<from_source>`  
  
Указывает источник данных с псевдонимом или без него. Если псевдоним не указан, он будет выведен из hello `<collection_expression>` с помощью следующих правил:  
  
-   Если выражение hello представляет собой collection_name, collection_name будет использоваться в качестве псевдонима.  
  
-   Если выражение hello `<collection_expression>`, property_name, а затем property_name будет использоваться в качестве псевдонима. Если выражение hello представляет собой collection_name, collection_name будет использоваться в качестве псевдонима.  
  
AS `input_alias`  
  
Указывает, что hello `input_alias` — это набор значений, возвращаемых базовым выражением коллекции hello.  
 
`input_alias` IN  
  
Указывает, что hello `input_alias` должен представлять набор значений, полученных путем итерации всех элементов массива каждого массиве, возвращенном базовым выражением коллекции hello hello. Значения, возвращенные базовым выражением коллекции, которые не являются массивом, игнорируются.  
  
`<collection_expression>`  
  
Указывает выражение toobe hello коллекции документов tooretrieve hello.  
  
`ROOT`  
  
Указывает, что документ должен быть получен от значения по умолчанию hello, текущей подключенной коллекции.  
  
`collection_name`  
  
Указывает, что документ должен быть получен из коллекции указанный hello. Имя Hello hello коллекции должно соответствовать имя hello коллекции hello, подключенного в настоящее время.  
  
`input_alias`  
  
Указывает, что документ должен быть получен из hello другого источника, определенного по псевдониму предоставленный hello.  
  
`<collection_expression> '.' property_`  
  
Указывает, что документ должен быть получен путем обращения к hello `property_name` свойства или элементу массива array_index для всех документов, полученных с указанного выражения коллекции.  
  
`<collection_expression> '[' "property_name" | array_index ']'`  
  
Указывает, что документ должен быть получен путем обращения к hello `property_name` свойства или элементу массива array_index для всех документов, полученных с указанного выражения коллекции.  
  
**Примечания**  
  
Все псевдонимы, предоставленные или выведенные в hello `<from_source>(`s) должно быть уникальным. Hello синтаксис `<collection_expression>.`property_name Здравствуйте, таким же, как `<collection_expression>' ['"property_name"']'`. Однако hello такой синтаксис можно использовать, если имя свойства содержит недопустимые символы.  
  
**Обработка отсутствующих свойств, элементов массива и неопределенных значений**  
  
Если выражение коллекции обращается к свойствам или элементам массива и необходимое значение отсутствует, это значение игнорируется и не проходит дальнейшую обработку.  
  
**Определение области контекста выражения коллекции**  
  
Выражение коллекции может указываться на уровне коллекции или документа:  
  
-   Выражение имеет уровень коллекции, если hello базовым источником выражения коллекции hello является либо ROOT или `collection_name`. Такое выражение представляет набор документов, полученных непосредственно из коллекции hello и не зависит от hello обработки других выражений коллекции.  
  
-   Выражение имеет уровень документа, если hello является базовым источником выражения коллекции hello `input_alias` представленные ранее в запросе hello. Такое выражение представляет набор документов, полученный в результате вычисления выражения коллекции hello в области hello каждого документа, принадлежащего toohello набор, связанный с коллекцией псевдонима hello.  Hello результирующий набор будет объединением наборов, полученных при вычислении выражения коллекции hello для каждого из документов hello в базовый набор hello.  
  
**Соединения**  
  
В текущем выпуске hello Azure Cosmos DB поддерживает внутренние соединения. Дополнительные возможности соединения будут добавлены позже.

Задает результат внутренние соединения в полное перекрестное произведение hello, участвующих в соединении hello. Hello результатом N-стороннего соединения является набор N-элементных кортежей, где каждое значение в кортеж hello связанный с набором, участвующим в соединении hello псевдоним hello и может осуществляться с помощью ссылки на этот псевдоним в других предложениях.  
  
Вычисление Hello hello соединения зависит от hello области контекста участвующих наборов hello:  
  
-  Результатом соединения набора элементов набора A и набора Б уровня коллекции является векторное произведение всех элементов в наборе А и Б.
  
-   Соединение набора A и набора Б уровня документа приводит к объединению всех наборов, полученных при оценке набора Б уровня документа для каждого документа из набора А.  
  
 В текущем выпуске hello обработчиком запросов hello поддерживается более одного выражения уровня коллекции.  
  
**Примеры соединений**  
  
Рассмотрим следующую из предложения hello.`<from_source1> JOIN <from_source2> JOIN ... JOIN <from_sourceN>`  
  
 Разрешите каждому источнику определить `input_alias1, input_alias2, …, input_aliasN`. Это предложение FROM возвращает набор N-кортежей (кортежей, у которых число значений равно N). Каждый кортеж будет иметь значения, полученные путем итерации всех псевдонимов коллекции среди их наборов.  
  
*Пример соединения 1 с 2 источниками:*  
  
- Определите аргумент `<from_source1>` на уровне коллекции. Он должен представлять набор {A, B, C}.  
  
- Определите аргумент `<from_source2>` на уровне документа и добавьте ссылку на input_alias1. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- Здравствуйте, предложение FROM `<from_source1> JOIN <from_source2>` приведет к hello следующих кортежей:  
  
    (`input_alias1, input_alias2`):  
  
    `(A, 1), (A, 2), (B, 3), (C, 4), (C, 5)`  
  
*Пример соединения 2 с 3 источниками:*  
  
- Определите аргумент `<from_source1>` на уровне коллекции. Он должен представлять набор {A, B, C}.  
  
- Определите аргумент `<from_source2>` на уровне документа и добавьте ссылку на `input_alias1`. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- Определите аргумент `<from_source3>` на уровне документа и добавьте ссылку на `input_alias2`. Он должен представлять следующие наборы:  
  
    {100, 200} для `input_alias2 = 1,`;  
  
    {300} для `input_alias2 = 3,`.  
  
- Здравствуйте, предложение FROM `<from_source1> JOIN <from_source2> JOIN <from_source3>` приведет к hello следующих кортежей:  
  
    (input_alias1, input_alias2, input_alias3):  
  
    (A, 1, 100), (A, 1, 200), (B, 3, 300)  
  
> [!NOTE]
> Отсутствие кортежей для других значений `input_alias1`, `input_alias2`, для которых hello `<from_source3>` не вернул все значения.  
  
*Пример соединения 3 с 3 источниками:*  
  
- Определите аргумент <from_source1> на уровне коллекции. Он должен представлять набор {A, B, C}.  
  
- Определите аргумент `<from_source1>` на уровне коллекции. Он должен представлять набор {A, B, C}.  
  
- Определите аргумент <from_source2> на уровне документа и добавьте ссылку на input_alias1. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- Разрешить `<from_source3>` объединить слишком`input_alias1` и представлять наборы:  
  
    {100, 200} для `input_alias2 = A,`;  
  
    {300} для `input_alias2 = C,`.  
  
- Здравствуйте, предложение FROM `<from_source1> JOIN <from_source2> JOIN <from_source3>` приведет к hello следующих кортежей:  
  
    (`input_alias1, input_alias2, input_alias3`):  
  
    (A, 1, 100), (A, 1, 200), (A, 2, 100), (A, 2, 200),  (C, 4, 300) ,  (C, 5, 300)  
  
> [!NOTE]
> Это привело к перекрестному произведению между `<from_source2>` и `<from_source3>` , так как оба эти области toohello же `<from_source1>`.  Это привело к созданию 4 (2 x 2) кортежей со значением A, 0 кортежей (1 x 0) со значением B и 2 (2x1) кортежей со значением C.  
  
**См. также**  
  
 [Предложение SELECT](#bk_select_query)  
  
##  <a name="bk_where_clause"></a>Предложение WHERE  
 Указывает условие поиска hello hello документами, возвращенными запросом hello.  
  
 **Синтаксис**  
  
```  
WHERE <filter_condition>  
<filter_condition> ::= <scalar_expression>  
  
```  
  
 **Аргументы**  
  
-   `<filter_condition>`  
  
     Указывает о toobe документы hello вернул toobe условие hello.  
  
-   `<scalar_expression>`  
  
     Вычислить выражение, представляющее значение toobe hello. В разделе hello [скалярные выражения](#bk_scalar_expressions) подробные сведения см.  
  
 **Примечания**  
  
 Чтобы hello toobe документа возвращается выражение, указанное как условие фильтра должно возвращать tootrue. Только логическое значение true будет удовлетворять условию hello, любое другое значение: undefined, null, значение равно false, число, массив или объект будет удовлетворяет условию hello.  
  
##  <a name="bk_orderby_clause"></a>Предложение ORDER BY  
 Указывает порядок для результатов, возвращаемых запросом hello сортировки hello.  
  
 **Синтаксис**  
  
```  
ORDER BY <sort_specification>  
<sort_specification> ::= <sort_expression> [, <sort_expression>]  
<sort_expression> ::= <scalar_expression> [ASC | DESC]  
  
```  
  
 **Аргументы**  
  
-   `<sort_specification>`  
  
     Задает свойство или выражение, на котором toosort hello результирующий набор запроса. Столбец сортировки можно указать в качестве имени или псевдонима.  
  
     Вы можете указать несколько столбцов сортировки. Имена столбцов должны быть уникальными. последовательность Hello hello столбцов сортировки в предложении ORDER BY hello определяет организации hello hello сортировки результирующего набора. То есть hello результирующий набор сортируется по первым свойством hello и затем упорядоченный список сортируется по второму свойству hello и т. д.  
  
     Hello имена столбцов, на которые ссылается предложение ORDER BY hello должно соответствовать tooeither списка или tooa столбца, определенного в таблице, указанной в предложении FROM hello без неопределенность выберите столбец в hello.  
  
-   `<sort_expression>`  
  
     Указывает одно свойство или выражение, на какие результирующего набора запроса hello toosort.  
  
-   `<scalar_expression>`  
  
     В разделе hello [скалярные выражения](#bk_scalar_expressions) подробные сведения см.  
  
-   `ASC | DESC`  
  
     Указывает, что значения hello в указанном столбце hello должны сортироваться в порядке возрастания или убывания. Значение ASC сортирует от hello наименьшее значение toohighest значение. Значение DESC сортирует от наибольшее значение toolowest значение. Порядок сортировки по умолчанию hello — ASC. Значения NULL рассматриваются как минимально возможные значения hello.  
  
 **Примечания**  
  
 Хотя Грамматика hello запросов поддерживает несколько порядок по свойствам, hello Azure Cosmos DB запроса времени выполнения поддерживает сортировки только для одного свойства и только имена свойств, т. е. не для вычисляемых свойств. Сортировка также требует hello, что политика индексирования включает индекс диапазона для свойства hello и hello указан тип с наибольшей точностью hello. См. в документации для получения дополнительных сведений по политике индексации toohello.  
  
##  <a name="bk_scalar_expressions"></a>Скалярные выражения  
 Скалярное выражение представляет собой сочетание символов и операторов, которые могут быть вычисляется tooobtain одно значение. К простым выражениям можно отнести константы, ссылки на свойства, ссылки на элементы массива, ссылки на псевдонимы или вызовы функций. C помощью операторов простые выражения можно объединить в сложные.  
  
 Дополнительные сведения о значениях скалярных выражений см. в разделе [Константы](#bk_constants).  
  
 **Синтаксис**  
  
```  
<scalar_expression> ::=  
       <constant>   
     | input_alias   
     | parameter_name  
     | <scalar_expression>.property_name  
     | <scalar_expression>'['"property_name"|array_index']'  
     | unary_operator <scalar_expression>  
     | <scalar_expression> binary_operator <scalar_expression>    
     | <scalar_expression> ? <scalar_expression> : <scalar_expression>  
     | <scalar_function_expression>  
     | <create_object_expression>   
     | <create_array_expression>  
     | (<scalar_expression>)   
  
<scalar_function_expression> ::=  
        'udf.' Udf_scalar_function([<scalar_expression>][,…n])  
        | builtin_scalar_function([<scalar_expression>][,…n])  
  
<create_object_expression> ::=  
   '{' [{property_name | "property_name"} : <scalar_expression>][,…n] '}'  
  
<create_array_expression> ::=  
   '[' [<scalar_expression>][,…n] ']'  
  
```  
  
 **Аргументы**  
  
-   `<constant>`  
  
     Представляет значение константы. Дополнительные сведения см. в разделе [Константы](#bk_constants).  
  
-   `input_alias`  
  
     Представляет значение, определяемое hello `input_alias` появился в hello `FROM` предложения.  
    Это значение гарантированно toonot быть **не определено** —**не определено** значения во входном файле hello, пропускаются.  
  
-   `<scalar_expression>.property_name`  
  
     Представляет значение свойства hello объекта. Если свойство hello не существует или ссылка на свойство в значение, которое не является объектом, то выражение hello принимает слишком**не определено** значение.  
  
-   `<scalar_expression>'['"property_name"|array_index']'`  
  
     Представляет значение hello свойство с именем `property_name` или элементу массива с индексом `array_index` из объекта или массива. Если индекс свойства или массива hello не существует или на значение, которое не является объектом или массивом указана ссылка на индекс свойства или массива hello, hello выражение вычисляет значение tooundefined.  
  
-   `unary_operator <scalar_expression>`  
  
     Представляет оператор, который будет применен tooa одно значение. Дополнительные сведения см. в разделе [Операторы](#bk_operators).  
  
-   `<scalar_expression> binary_operator <scalar_expression>`  
  
     Представляет оператор, который будет применен tootwo значения. Дополнительные сведения см. в разделе [Операторы](#bk_operators).  
  
-   `<scalar_function_expression>`  
  
     Представляет значение, определяемое результатом вызова функции.  
  
-   `udf_scalar_function`  
  
     Имя пользователя hello определяемой скалярной функции.  
  
-   `builtin_scalar_function`  
  
     Имя встроенной скалярной функции hello.  
  
-   `<create_object_expression>`  
  
     Представляет значение, полученное в процессе создания объекта с заданными свойствами и их значениями.  
  
-   `<create_array_expression>`  
  
     Представляет значение, полученное в процессе создания массива с заданными значениями в качестве элементов.  
  
-   `parameter_name`  
  
     Представляет значение hello указанное имя параметра. Имена параметров должны быть одиночный символ @ как первый символ hello.  
  
 **Примечания**  
  
 При вызове встроенной или определяемой пользователем скалярной функции необходимо определить все аргументы. Если любой из аргументов hello не определен, не будет вызвана функция hello и hello результат будет неопределенным.  
  
 При создании объекта, любое свойство, которому назначено значение undefined будет пропущена и не включается в созданном объекте hello.  
  
 При создании массива любое значение элемента, который назначается **не определено** значение будет пропускаться и не включенных в объект создан hello. Это приведет к tootake hello рядом определенный элемент вместо него таким образом, этот массив hello создан не будет пропущенных индексов.  
  
##  <a name="bk_operators"></a>Операторы  
 В этом разделе описаны операторы hello поддерживается. Каждый оператор может быть назначенных tooexactly одной категории.  
  
 В таблице **Категории операторов** ниже приведены сведения об обработке значений **undefined**, требованиях к типу входных значений и обработке значений несоответствующего типа.  
  
 **Категории операторов**  
  
|**Категория**|**Дополнительные сведения**|  
|-|-|  
|**Арифметические**|Оператор ожидает, что входными данными toobe номера. выходные данные — числа. Если какие-либо из входных данных hello **не определено** , или тип, отличный от номера, а затем hello результат **не определено**.|  
|**Битовые**|Оператор ожидает, что входными данными toobe 32-разрядное целое число со знаком номера. выходные данные — 32-разрядные целые числа со знаками.<br /><br /> Все нецелочисленные значения округляются. Положительные значения округляются в меньшую сторону, а отрицательные — в большую.<br /><br /> Любое значение, выходящее за пределы диапазона 32-разрядное целое число hello будут преобразованы, выполнив последние 32 бита его дополнительном коде.<br /><br /> Если какие-либо из входных данных hello **не определено** или тип, отличный от числового, результатом hello является **не определено**.<br /><br /> **Примечание:** hello выше поведение совместимо с поведением побитового оператора JavaScript.|  
|**Логические**|Оператор ожидает, что входными данными toobe логические значения. выходные данные — логические значения.<br />Если какие-либо из входных данных hello **не определено** или тип, отличный от логического, результатом hello будет **не определено**.|  
|**Сравнение**|Оператор ожидает, что входными данными hello toohave же типа и не быть неопределенным. Выходные данные — логические значения.<br /><br /> Если какие-либо из входных данных hello **не определено** или hello входные данные имеют разные типы, а затем результат hello **не определено**.<br /><br /> Сведения об упорядочении значений см. в таблице **Упорядочение сравниваемых значений**.|  
|**string**|Оператор ожидает, что входными данными toobe строки. выходные данные — строки.<br />Если какие-либо из входных данных hello **не определено** , или тип, отличный от строки, а затем hello результат **не определено**.|  
  
 **Унарные операторы**  
  
|**Имя**|**Оператор**|**Дополнительные сведения**|  
|-|-|-|  
|**Арифметические**|+<br /><br /> -|Возвращает значение числа "hello".<br /><br /> Выполняет побитовую операцию. Возвращает отрицательное числовое значение.|  
|**Битовые**|~|Дополнение. Возвращает дополнение числового значения.|  
|**Логические**|**NOT**|Отрицание. Возвращает отрицательное логическое значение.|  
  
 **Бинарные операторы**  
  
|**Имя**|**Оператор**|**Дополнительные сведения**|  
|-|-|-|  
|**Арифметические**|+<br /><br /> -<br /><br /> *<br /><br /> /<br /><br /> %|Сложение.<br /><br /> Вычитание.<br /><br /> Умножение.<br /><br /> Деление.<br /><br /> Модуляция.|  
|**Битовые**|&#124;<br /><br /> &<br /><br /> ^<br /><br /> <<<br /><br /> >><br /><br /> >>>|Битовый OR.<br /><br /> Битовый AND.<br /><br /> Битовый XOR.<br /><br /> Сдвиг влево.<br /><br /> Сдвиг вправо.<br /><br /> Сдвиг вправо с заполнением нулями.|  
|**Логические**|**AND**<br /><br /> **OR**|Логическое умножение. Возвращает значение **true**, если оба аргумента имеют значение **true**. В противном случае возвращает **false**.<br /><br /> Логическое умножение. Возвращает значение **true**, если оба аргумента имеют значение **true**. В противном случае возвращает **false**.|  
|**Сравнение**|**=**<br /><br /> **!=, <>**<br /><br /> **>**<br /><br /> **>=**<br /><br /> **<**<br /><br /> **<=**<br /><br /> **??**|Равно. Возвращает значение **true**, если оба аргумента равны. В противном случае возвращает **false**.<br /><br /> Не равно. Возвращает значение **true**, если оба аргумента не равны. В противном случае возвращает **false**.<br /><br /> Больше. Возвращает **true** Если первый аргумент больше, чем hello второй, возвращают **false** в противном случае.<br /><br /> Больше или равно. Возвращает **true** Если первого аргумента больше или равно toohello второй, возвращают **false** в противном случае.<br /><br /> Меньше. Возвращает **true** Если первый аргумент меньше, чем второй hello, возвращают **false** в противном случае.<br /><br /> Меньше или равно. Возвращает **true** Если первого аргумента меньше или равно toohello второй одно возвращаемое **false** в противном случае.<br /><br /> Слияние. Возвращает hello второй аргумент, если первый аргумент hello **не определено** значение.|  
|**Строка**|**&#124;&#124;**|Объединение. Возвращает объединение обоих аргументов.|  
  
 **Тернарные операторы**  
  
|Тернарный оператор|?|Возвращает hello второй аргумент, если первый аргумент hello принимает слишком**true**; в противном случае возвращает третий аргумент hello.|  
|-|-|-|  
  
 **Упорядочение сравниваемых значений**  
  
|**Тип**|**Порядок значений**|  
|-|-|  
|**Неопределенное**|Невозможно сравнить.|  
|**Null**|Доступное значение: **Null**|  
|**Число**|Натуральное вещественное число.<br /><br /> Отрицательное значение бесконечности меньше любого другого числового значения.<br /><br /> Положительное значение бесконечности больше любого другого числового значения. Значение **NaN** невозможно сравнить. При сравнение с **NaN** возвращается значение **undefined**.|  
|**Строка**|Лексикографический порядок.|  
|**Массив**|Не поддерживает упорядочивание, но равнозначные.|  
|**Объект**|Не поддерживает упорядочивание, но равнозначные.|  
  
 **Примечания**  
  
 В базе данных Azure Cosmos hello типы значений часто неизвестны до их фактического извлечения из базы данных hello. В порядке toosupport эффективное выполнение запросов большинство hello операторов имеют строгие требования к типам. Кроме того, операторы сами по себе не выполняют неявное преобразование.  
  
 Это означает, что запрос, такие как: ВЫБЕРИТЕ * FROM ROOT r WHERE r.Age = 21 вернет только документы со свойством Age toohello равно числу 21. Документы с строки равно toohello свойства Age «21» или hello строке «0021», не соответствуют, как выражение hello «21» = 21 оценивает tooundefined. Это позволяет лучше использовать индексы, так как Уточняющий запрос hello определенного значения (т. е. числа 21) выполняется быстрее, чем поиск неопределенного количества возможных совпадений, (т. е. числа 21 или строк «21», «021», «21,0»...). Это отличается от способа вычисления операторов в значениях различных типов на языке JavaScript.  
  
 **Равенство и сравнение массивов и объектов**  
  
 При сравнении значений массивов или объектов с использованием операторов диапазона (>, >=, <, <=) возвращается значение undefined, так как порядок этих значений не определен. Но выполнить структурное сравнение можно с помощью операторов равенства и неравенства (=, !=, <>).  
  
 Два массива считаются равными, если они имеют одинаковое число элементов и сопоставляемые элементы также равны. Если сравнение пары элементов приводит к undefined, результатом сравнения массива hello не определен.  
  
 Два объекта считаются равными, если они имеют одинаковые свойства и сопоставляемые свойства также равны. Если сравнение пары значений свойств приводит к undefined, результатом сравнения объектов hello не определен.  
  
##  <a name="bk_constants"></a>Константы  
 Константа (также известная как литерал или скаляр) — это символ, представляющий определенное значение данных. Hello формат константы зависит от типа данных hello hello значения, которое он представляет.  
  
 **Поддерживаемые скалярные типы данных**  
  
|**Тип**|**Порядок значений**|  
|-|-|  
|**Неопределенное**|Доступное значение: **undefined**|  
|**Null**|Доступное значение: **Null**|  
|**Логический**|Доступные значения: **false**, **true**|  
|**Число**|Число с плавающей запятой двойной точности, стандарт IEEE 754.|  
|**Строка**|Последовательности из нуля или более знаков Юникода. Строки необходимо заключить в одинарные или двойные кавычки.|  
|**Массив**|Последовательность из нуля или более элементов. Каждый элемент может иметь значение любого скалярного типа данных (за исключением типа "Неопределенное").|  
|**Объект**|Неупорядоченный набор из нуля или более пар "имя — значение". Имя является строкой Юникода. Значение может иметь любой скалярный тип данных (за исключением типа **Неопределенное**).|  
  
 **Синтаксис**  
  
```  
<constant> ::=  
   <undefined_constant>  
     | <null_constant>   
     | <boolean_constant>   
     | <number_constant>   
     | <string_constant>   
     | <array_constant>   
     | <object_constant>   
  
<undefined_constant> ::= undefined  
  
<null_constant> ::= null  
  
<boolean_constant> ::= false | true  
  
<number_constant> ::= decimal_literal | hexadecimal_literal  
  
<string_constant> ::= string_literal  
  
<array_constant> ::=  
    '[' [<constant>][,...n] ']'  
  
<object_constant> ::=   
   '{' [{property_name | "property_name"} : <constant>][,...n] '}'  
  
```  
  
 **Аргументы**  
  
1.  `<undefined_constant>; undefined`  
  
     Представляет неопределенное значение типа "Неопределенное".  
  
2.  `<null_constant>; null`  
  
     Представляет значение **Null** типа **Null**.  
  
3.  `<boolean_constant>`  
  
     Представляет константу типа "Логический".  
  
4.  `false`  
  
     Представляет значение **false** типа "Логический".  
  
5.  `true`  
  
     Представляет значение **true** типа "Логический".  
  
6.  `<number_constant>`  
  
     Представляет константу.  
  
7.  `decimal_literal`  
  
     Десятичные литералы — это числа, представленные в десятичном или экспоненциальном представлении.  
  
8.  `hexadecimal_literal`  
  
     Шестнадцатеричные литералы — это числа, представленные с помощью префикса 0x, за которым следуют одна или несколько шестнадцатеричных цифр.  
  
9. `<string_constant>`  
  
     Представляет константу типа "Строка".  
  
10. `string _literal`  
  
     Строковые литералы — это строки Юникода, представленные в виде последовательности из нуля или более знаков Юникода или escape-последовательностей. Строковые литералы заключаются в одинарные кавычки (апостроф — ') или двойные кавычки (кавычки — ").  
  
 Допускаются следующие escape-последовательности:  
  
|**escape-последовательность**|**Описание**|**Символ Юникода**|  
|-|-|-|  
|\\'|Апостроф (')|U+0027|  
|\\"|Кавычки (")|U+0022|  
|\\\|Обратная косая черта (\\)|U+005C|  
|\\/|Косая черта (/)|U+002F|  
|\b|BACKSPACE|U+0008|  
|\f|Смена страницы|U+000C|  
|\n|Перевод строки|U+000A|  
|\r|Возврат каретки|U+000D|  
|\t|TAB|U+0009|  
|\uXXXX|Символ Юникода, определяемый 4 шестнадцатеричными цифрами.|U+XXXX|  
  
##  <a name="bk_query_perf_guidelines"></a> Рекомендации по повышению производительности запросов  
 Чтобы запрос toobe, эффективного выполнения больших коллекции следует использовать фильтры, которые могут обслуживаться одним или несколькими индексами.  
  
 для поиска по индексу будут считаться Hello следующие фильтры:  
  
-   Используйте оператор равенства (=) с выражением пути к документу и константой.  
  
-   Используйте операторы диапазона (<, \<=, >, >=) с выражением пути к документу и числовыми константами.  
  
-   Выражение пути к документу означает любое выражение, которое определяет постоянный путь в документах hello из коллекции hello ссылки на базы данных.  
  
 **Выражение пути к документу**  
  
 Выражения пути к документу — это выражения, которые оценивают путь свойства или индексатор массива в документе из коллекции баз данных. Этот путь может быть расположение используемых tooidentify hello, упоминаемых в фильтре непосредственно в hello документов в коллекции баз данных hello.  
  
 Для toobe выражение считается выражением пути к документу следует:  
  
1.  Справочник по hello коллекции корень напрямую.  
  
2.  Ссылаться на свойство или индексатор массива констант любого выражения пути к документу.  
  
3.  Ссылаться на псевдоним, который представляет выражение пути к документу.  
  
     **Соглашения о синтаксисе**  
  
     Hello в следующей таблице описывается синтаксис toodescribe hello соглашения, используемые в справочнике по языку запроса DocumentDB API hello.  
  
    |**Соглашение**|**Область использования**|  
    |-|-|    
    |Прописные буквы|Ключевые слова, не учитывающие регистр.|  
    |Нижний регистр|Ключевые слова, учитывающие регистр.|  
    |\<Нетерминальный символ>|Нетерминальный символ, определяется отдельно.|  
    |\<Нетерминальный символ> ::=|Определение синтаксиса нетерминального символа hello.|  
    |Другие терминальные символы|Терминальный символ (лексема) подробно описывается в словах.|  
    |Идентификатор|Идентификатор. Поддерживает только следующие знаки: a–z, A–Z, 0–9. Первый знак не может быть цифрой.|  
    |Строка|Строка в кавычках. Разрешает любые допустимые строки. См. описание аргумента string_literal.|  
    |Символ|Литеральный символ, который является частью синтаксиса hello.|  
    |&#124; (вертикальная линия)|Варианты элементов синтаксиса. Можно использовать только один из указанных элементов hello.|  
    |[ ] /(квадратные скобки)|В квадратных скобках указывается один или несколько дополнительных элементов.|  
    |[ ,…n ]|Указывает, что предшествующий элемент hello может быть повторяющихся n — количество раз. Hello отдельные вхождения элемента разделяются запятыми.|  
    |[ …n ]|Указывает, что предшествующий элемент hello может быть повторяющихся n — количество раз. Hello вхождения разделяются пробелами.|  
  
##  <a name="bk_built_in_functions"></a>Встроенные функции  
 Azure Cosmos DB предоставляет множество встроенных функций SQL. Ниже перечислены категории встроенных функций Hello.  
  
|Функция|Описание|  
|--------------|-----------------|  
|[Математические функции](#bk_mathematical_functions)|Hello математические функции производят вычисления, чаще всего основываясь на входящих значениях, заданных в качестве аргументов и возвращают числовые значения.|  
|[Функции проверки типа](#bk_type_checking_functions)|функции проверки типа Hello разрешить toocheck hello тип выражения в запросах SQL.|  
|[Строковые функции](#bk_string_functions)|Hello строковые функции выполняют операцию над входным строковым значением и возвращают строковое, числовое или логическое значение.|  
|[Функции массивов](#bk_array_functions)|функции массивов Hello выполняют операции с входным значением массива и возвращают числовое, логическое значение или значение массива.|  
|[Пространственные функции](#bk_spatial_functions)|Hello Пространственные функции выполняют операцию над пространственного объекта входного значения и возвращают числовое или логическое значение.|  
  
###  <a name="bk_mathematical_functions"></a>Математические функции  
 Hello следующие функции выполняют вычисление, обычно на основании входных значений, заданных в качестве аргументов и возвращают числовое значение.  
  
||||  
|-|-|-|  
|[ABS](#bk_abs)|[ACOS](#bk_acos)|[ASIN](#bk_asin)|  
|[ATAN](#bk_atan)|[ATN2](#bk_atn2)|[CEILING](#bk_ceiling)|  
|[COS](#bk_cos)|[COT](#bk_cot)|[DEGREES](#bk_degrees)|  
|[EXP](#bk_exp)|[FLOOR](#bk_floor)|[LOG](#bk_log)|  
|[LOG10](#bk_log10)|[PI](#bk_pi)|[POWER](#bk_power)|  
|[RADIANS](#bk_radians)|[ROUND](#bk_round)|[SIN](#bk_sin)|  
|[SQRT](#bk_sqrt)|[SQUARE](#bk_square)|[SIGN](#bk_sign)|  
|[TAN](#bk_tan)|[TRUNC](#bk_trunc)||  
  
####  <a name="bk_abs"></a> ABS  
 Возвращает hello абсолютное (положительное) значение hello указанного числового выражения.  
  
 **Синтаксис**  
  
```  
ABS (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello пример hello результатов с помощью функции hello ABS к трем различным числам.  
  
```  
SELECT ABS(-1), ABS(0), ABS(1)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 1, $2: 0, $3: 1}]  
```  
  
####  <a name="bk_acos"></a> ACOS  
 Возвращает hello угол в радианах, косинус которого является hello указанного числового выражения; также называется арккосинусом.  
  
 **Синтаксис**  
  
```  
ACOS(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello ACOS-1.  
  
```  
SELECT ACOS(-1)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": 3.1415926535897931}]  
```  
  
####  <a name="bk_asin"></a> ASIN  
 Hello Возвращает угол в радианах, синус которого равен hello указано числовое выражение. Также называется арксинусом.  
  
 **Синтаксис**  
  
```  
ASIN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello ASIN-1.  
  
```  
SELECT ASIN(-1)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": -1.5707963267948966}]  
```  
  
####  <a name="bk_atan"></a> ATAN  
 Hello Возвращает угол в радианах, тангенс которого равен hello указано числовое выражение. Также называется арктангенсом.  
  
 **Синтаксис**  
  
```  
ATAN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Следующий пример, что возвращает hello ATAN hello Hello заданное значение.  
  
```  
SELECT ATAN(-45.01)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": -1.5485826962062663}]  
```  
  
####  <a name="bk_atn2"></a> ATN2  
 Возвращает главное значение hello hello арктангенса y / x, выраженное в радианах.  
  
 **Синтаксис**  
  
```  
ATN2(<numeric_expression>, <numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующий пример вычисляет hello ATN2 для hello указан x и y компонентов.  
  
```  
SELECT ATN2(35.175643, 129.44)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": 1.3054517947300646}]  
```  
  
####  <a name="bk_ceiling"></a> CEILING  
 Возвращает hello наименьшее целочисленное значение больше или равно, hello указанного числового выражения.  
  
 **Синтаксис**  
  
```  
CEILING (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello в следующем примере показаны положительные числовые, отрицательные, и функция CEILING hello нулевые значения.  
  
```  
SELECT CEILING(123.45), CEILING(-123.45), CEILING(0.0)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 124, $2: -123, $3: 0}]  
```  
  
####  <a name="bk_cos"></a> COS  
 Возвращает hello hello в тригонометрический косинус указанного угла в радианах, в hello указанного выражения.  
  
 **Синтаксис**  
  
```  
COS(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Следующий пример Hello вычисляет hello COS hello, который задан угол.  
  
```  
SELECT COS(14.78)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": -0.59946542619465426}]  
```  
  
####  <a name="bk_cot"></a> COT  
 Возвращает hello hello в тригонометрический котангенс указанного угла в радианах, в hello указанного числового выражения.  
  
 **Синтаксис**  
  
```  
COT(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Следующий пример Hello вычисляет hello COT заданного угла hello.  
  
```  
SELECT COT(124.1332)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": -0.040311998371148884}]  
```  
  
####  <a name="bk_degrees"></a> DEGREES  
 Возвращает hello соответствующее значение угла в градусах для значения угла в радианах.  
  
 **Синтаксис**  
  
```  
DEGREES (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello число градусов в угле, равном PI/2 радиан.  
  
```  
SELECT DEGREES(PI()/2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": 90}]  
```  
  
####  <a name="bk_floor"></a> FLOOR  
 Возвращает наибольшее целое число hello меньше или равно toohello указанного числового выражения.  
  
 **Синтаксис**  
  
```  
FLOOR (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello в следующем примере показаны положительные числовые, отрицательные, и функция FLOOR hello нулевые значения.  
  
```  
SELECT FLOOR(123.45), FLOOR(-123.45), FLOOR(0.0)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 123, $2: -124, $3: 0}]  
```  
  
####  <a name="bk_exp"></a> EXP  
 Возвращает значение экспоненты hello объекта hello указанного числового выражения.  
  
 **Синтаксис**  
  
```  
EXP (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примечания**  
  
 Константа Hello **e** (2,718281...) является hello базовый натуральных логарифмов.  
  
 Hello экспоненты числа является константой hello **e** возникает toohello степень числа hello. Например, EXP(1.0) = e^1.0 = 2,71828182845905 и EXP(10) = e^10 = 22026,4657948067.  
  
 Экспонента натурального логарифма hello числа Hello — номер hello, сам: EXP (LOG (n)) = n. А hello натуральный логарифм экспоненты числа hello — номер hello, сам: LOG (EXP (n)) = n.  
  
 **Примеры**  
  
 Hello в примере объявляется переменная и возвращает значение экспоненты hello hello указанной переменной (10).  
  
```  
SELECT EXP(10)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 22026.465794806718}]  
```  
  
 Hello следующий пример возвращает значение экспоненты hello hello натурального логарифма 20 и натуральный логарифм hello hello экспоненты 20. Поскольку эти функции являются обратными друг от друга, возвращаемому значению hello округления чисел с плавающей запятой, что в обоих случаях — 20.  
  
```  
SELECT EXP(LOG(20)), LOG(EXP(20))  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 19.999999999999996, $2: 20}]  
```  
  
####  <a name="bk_log"></a> LOG  
 Возвращает hello натуральный логарифм hello указанного числового выражения.  
  
 **Синтаксис**  
  
```  
LOG (<numeric_expression> [, <base>])  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
-   `base`  
  
     Дополнительный числовой аргумент, который задает hello базовой логарифм hello.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примечания**  
  
 По умолчанию LOG() возвращает натуральный логарифм hello. Hello основание системы счисления hello логарифм tooanother значения можно изменить с помощью дополнительного параметра основания hello.  
  
 Hello натуральный логарифм — базовый toohello логарифм hello **e**, где **e** является иррациональная константа приблизительно равно too2.718281828.  
  
 Номер hello сам является Hello натуральный логарифм экспоненты числа hello: LOG (EXP (n)) = n. А hello экспоненту hello натуральный логарифм числа — номер hello, сам: EXP (LOG (n)) = n.  
  
 **Примеры**  
  
 Hello в примере объявляется переменная и возвращает значение логарифма hello hello указанной переменной (10).  
  
```  
SELECT LOG(10)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 2.3025850929940459}]  
```  
  
 Hello следующий пример вычисляет hello ЖУРНАЛА для hello экспоненты числа.  
  
```  
SELECT EXP(LOG(10))  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 10.000000000000002}]  
```  
  
####  <a name="bk_log10"></a> LOG10  
 Возвращает логарифм по основанию 10 hello hello указанного числового выражения.  
  
 **Синтаксис**  
  
```  
LOG10 (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примечания**  
  
 Hello LOG10 и POWER функции являются обратно связанные tooone другой. Например, 10 ^ LOG10(n) = n.  
  
 **Примеры**  
  
 Hello в примере объявляется переменная и возвращает значение LOG10 hello hello указанной переменной (100).  
  
```  
SELECT LOG10(100)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 2}]  
```  
  
####  <a name="bk_pi"></a> PI  
 Возвращает hello константное значение PI.  
  
 **Синтаксис**  
  
```  
PI ()  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello число пи.  
  
```  
SELECT PI()  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": 3.1415926535897931}]  
```  
  
####  <a name="bk_power"></a> POWER  
 Здравствуйте, возвращает значение указанного hello toohello выражения указанная степень.  
  
 **Синтаксис**  
  
```  
POWER (<numeric_expression>, <y>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
-   `y`  
  
     — Hello power toowhich tooraise `numeric_expression`.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Следующий пример Hello показано возведение числа toohello степень 3 (куб hello hello числа).  
  
```  
SELECT POWER(2, 3), POWER(2.5, 3)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 8, $2: 15.625}]  
```  
  
####  <a name="bk_radians"></a> RADIANS  
 Возвращает значение угла в радианах для числового значения, указанного в градусах.  
  
 **Синтаксис**  
  
```  
RADIANS (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello в примере берется несколько углов в качестве входных данных и возвращает их соответствующие значения в радианах.  
  
```  
SELECT RADIANS(-45.01), RADIANS(-181.01), RADIANS(0), RADIANS(0.1472738), RADIANS(197.1099392)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{  
       "$1": -0.7855726963226477,  
       "$2": -3.1592204790349356,  
       "$3": 0,  
       "$4": 0.0025704127119236249,  
       "$5": 3.4402174274458375  
   }]  
```  
  
####  <a name="bk_round"></a> ROUND  
 Возвращает числовое значение, округленное toohello ближайшего целого значения.  
  
 **Синтаксис**  
  
```  
ROUND(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello примере округляет hello следующие положительные и отрицательные числа toohello ближайшего целого.  
  
```  
SELECT ROUND(2.4), ROUND(2.6), ROUND(2.5), ROUND(-2.4), ROUND(-2.6)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 2, $2: 3, $3: 3, $4: -2, $5: -3}]  
```  
  
####  <a name="bk_sign"></a> SIGN  
 Здравствуйте, возвращает положительное (+ 1), ноль (0) или отрицательный знак (-1) hello указанного числового выражения.  
  
 **Синтаксис**  
  
```  
SIGN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello значения знака для чисел от-2 too2.  
  
```  
SELECT SIGN(-2), SIGN(-1), SIGN(0), SIGN(1), SIGN(2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: -1, $2: -1, $3: 0, $4: 1, $5: 1}]  
```  
  
####  <a name="bk_sin"></a> SIN  
 Возвращает hello hello в Тригонометрический синус указанного угла в радианах, в hello указанное выражение.  
  
 **Синтаксис**  
  
```  
SIN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Следующий пример Hello вычисляет hello SIN указанного угла hello.  
  
```  
SELECT SIN(45.175643)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": 0.929607286611012}]  
```  
  
####  <a name="bk_sqrt"></a> SQRT  
 Возвращает hello квадратный корень из hello указано числовое значение.  
  
 **Синтаксис**  
  
```  
SQRT(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello квадратные корни чисел 1 – 3.  
  
```  
SELECT SQRT(1), SQRT(2.0), SQRT(3)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 1, $2: 1.4142135623730952, $3: 1.7320508075688772}]  
```  
  
####  <a name="bk_square"></a> SQUARE  
 Квадратный из hello hello возвращает указанное числовое значение.  
  
 **Синтаксис**  
  
```  
SQUARE(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello квадратов чисел 1 – 3.  
  
```  
SELECT SQUARE(1), SQUARE(2.0), SQUARE(3)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 1, $2: 4, $3: 9}]  
```  
  
####  <a name="bk_tan"></a> TAN  
 Возвращает тангенс hello hello указанного угла в радианах, в hello определенных выражением.  
  
 **Синтаксис**  
  
```  
TAN (<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующем примере вычисляется тангенс hello PI () / 2.  
  
```  
SELECT TAN(PI()/2);  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": 16331239353195370 }]  
```  
  
####  <a name="bk_trunc"></a> TRUNC  
 Возвращает числовое значение, усеченное toohello ближайшего целого значения.  
  
 **Синтаксис**  
  
```  
TRUNC(<numeric_expression>)  
```  
  
 **Аргументы**  
  
-   `numeric_expression`  
  
     Числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Следующий пример Hello усекает hello следующие положительные и отрицательные числа toohello ближайшее целое значение.  
  
```  
SELECT TRUNC(2.4), TRUNC(2.6), TRUNC(2.5), TRUNC(-2.4), TRUNC(-2.6)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: 2, $2: 2, $3: 2, $4: -2, $5: -2}]  
```  
  
###  <a name="bk_type_checking_functions"></a> Функции проверки типа  
 Hello следующие функции поддерживают проверку типа входных значений, и каждая возвращает логическое значение.  
  
||||  
|-|-|-|  
|[IS_ARRAY](#bk_is_array)|[IS_BOOL](#bk_is_bool)|[IS_DEFINED](#bk_is_defined)|  
|[IS_NULL](#bk_is_null)|[IS_NUMBER](#bk_is_number)|[IS_OBJECT](#bk_is_object)|  
|[IS_PRIMITIVE](#bk_is_primitive)|[IS_STRING](#bk_is_string)||  
  
####  <a name="bk_is_array"></a> IS_ARRAY  
 Возвращает логическое значение, указывающее, если тип hello hello задать выражение является массивом.  
  
 **Синтаксис**  
  
```  
IS_ARRAY(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример проверяет объекты JSON Boolean, number, string, значение null, объект, массив и неопределенных типов, с помощью функции IS_ARRAY hello.  
  
```  
SELECT   
 IS_ARRAY(true),   
 IS_ARRAY(1),  
 IS_ARRAY("value"),  
 IS_ARRAY(null),  
 IS_ARRAY({prop: "value"}),   
 IS_ARRAY([1, 2, 3]),  
 IS_ARRAY({prop: "value"}.prop2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: false, $2: false, $3: false, $4: false, $5: false, $6: true}]  
```  
  
####  <a name="bk_is_bool"></a> IS_BOOL  
 Возвращает логическое значение, указывающее, если тип hello hello задать выражение является логическим.  
  
 **Синтаксис**  
  
```  
IS_BOOL(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример проверяет объекты JSON Boolean, number, string, значение null, объект, массив и неопределенных типов, с помощью функции IS_BOOL hello.  
  
```  
SELECT   
    IS_BOOL(true),   
    IS_BOOL(1),  
    IS_BOOL("value"),   
    IS_BOOL(null),  
    IS_BOOL({prop: "value"}),   
    IS_BOOL([1, 2, 3]),  
    IS_BOOL({prop: "value"}.prop2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: true, $2: false, $3: false, $4: false, $5: false, $6: false}]  
```  
  
####  <a name="bk_is_defined"></a> IS_DEFINED  
 Возвращает логическое значение, указывающее, если свойство hello назначено значение.  
  
 **Синтаксис**  
  
```  
IS_DEFINED(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Следующий пример проверяет наличие hello свойство в пределах hello Hello указан документ JSON. Hello сначала возвращает значение true, так как «» присутствует, но hello второй возвращает значение false, так как отсутствует «b».  
  
```  
SELECT IS_DEFINED({ "a" : 5 }.a), IS_DEFINED({ "a" : 5 }.b)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{  
       "$1": true,    
       "$2": false   
   }]  
```  
  
####  <a name="bk_is_null"></a> IS_NULL  
 Возвращает логическое значение, указывающее, если тип hello hello задать выражение имеет значение null.  
  
 **Синтаксис**  
  
```  
IS_NULL(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример проверяет объекты JSON Boolean, number, string, значение null, объект, массив и неопределенных типов, с помощью функции IS_NULL hello.  
  
```  
SELECT   
    IS_NULL(true),   
    IS_NULL(1),  
    IS_NULL("value"),   
    IS_NULL(null),  
    IS_NULL({prop: "value"}),   
    IS_NULL([1, 2, 3]),  
    IS_NULL({prop: "value"}.prop2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: false, $2: false, $3: false, $4: true, $5: false, $6: false}]  
```  
  
####  <a name="bk_is_number"></a> IS_NUMBER  
 Возвращает логическое значение, указывающее, если тип hello hello задать выражение является числом.  
  
 **Синтаксис**  
  
```  
IS_NUMBER(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример проверяет объекты JSON Boolean, number, string, значение null, объект, массив и неопределенных типов, с помощью функции IS_NULL hello.  
  
```  
SELECT   
    IS_NUMBER(true),   
    IS_NUMBER(1),  
    IS_NUMBER("value"),   
    IS_NUMBER(null),  
    IS_NUMBER({prop: "value"}),   
    IS_NUMBER([1, 2, 3]),  
    IS_NUMBER({prop: "value"}.prop2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: false, $2: true, $3: false, $4: false, $5: false, $6: false}]  
```  
  
####  <a name="bk_is_object"></a> IS_OBJECT  
 Возвращает логическое значение, указывающее, если тип hello hello задать выражение, объект JSON.  
  
 **Синтаксис**  
  
```  
IS_OBJECT(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример проверяет объекты JSON Boolean, number, string, значение null, объект, массив и неопределенных типов, с помощью функции IS_OBJECT hello.  
  
```  
SELECT   
    IS_OBJECT(true),   
    IS_OBJECT(1),  
    IS_OBJECT("value"),   
    IS_OBJECT(null),  
    IS_OBJECT({prop: "value"}),   
    IS_OBJECT([1, 2, 3]),  
    IS_OBJECT({prop: "value"}.prop2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: false, $2: false, $3: false, $4: false, $5: true, $6: false}]  
```  
  
####  <a name="bk_is_primitive"></a> IS_PRIMITIVE  
 Возвращает логическое значение, указывающее, если тип hello hello задать выражение является примитивом (строка, логическое значение, числовое значение или null).  
  
 **Синтаксис**  
  
```  
IS_PRIMITIVE(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример проверяет объекты JSON Boolean, number, string, значение null, объект, массив и неопределенных типов, с помощью функции IS_PRIMITIVE hello.  
  
```  
SELECT   
           IS_PRIMITIVE(true),   
           IS_PRIMITIVE(1),  
           IS_PRIMITIVE("value"),   
           IS_PRIMITIVE(null),  
           IS_PRIMITIVE({prop: "value"}),   
           IS_PRIMITIVE([1, 2, 3]),  
           IS_PRIMITIVE({prop: "value"}.prop2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": true, "$2": true, "$3": true, "$4": true, "$5": false, "$6": false, "$7": false}]  
```  
  
####  <a name="bk_is_string"></a> IS_STRING  
 Возвращает логическое значение, указывающее, если тип hello hello выражения является строка.  
  
 **Синтаксис**  
  
```  
IS_STRING(<expression>)  
```  
  
 **Аргументы**  
  
-   `expression`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример проверяет объекты JSON Boolean, number, string, значение null, объект, массив и неопределенных типов, с помощью функции IS_STRING hello.  
  
```  
SELECT   
       IS_STRING(true),   
       IS_STRING(1),  
       IS_STRING("value"),   
       IS_STRING(null),  
       IS_STRING({prop: "value"}),   
       IS_STRING([1, 2, 3]),  
       IS_STRING({prop: "value"}.prop2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{$1: false, $2: false, $3: true, $4: false, $5: false, $6: false}]  
```  
  
###  <a name="bk_string_functions"></a> Строковые функции  
 Hello следующие скалярные функции выполняют операцию над входным строковым значением и возвращают строковое, числовое или логическое значение.  
  
||||  
|-|-|-|  
|[CONCAT](#bk_concat)|[CONTAINS](#bk_contains)|[ENDSWITH](#bk_endswith)|  
|[INDEX_OF](#bk_index_of)|[LEFT](#bk_left)|[LENGTH](#bk_length)|  
|[LOWER](#bk_lower)|[LTRIM](#bk_ltrim)|[REPLACE](#bk_replace)|  
|[REPLICATE](#bk_replicate)|[REVERSE](#bk_reverse)|[RIGHT](#bk_right)|  
|[RTRIM](#bk_rtrim)|[STARTSWITH](#bk_startswith)|[SUBSTRING](#bk_substring)|  
|[UPPER](#bk_upper)|||  
  
####  <a name="bk_concat"></a> CONCAT  
 Возвращает строку, являющуюся результатом объединения двух или более строковых значений hello.  
  
 **Синтаксис**  
  
```  
CONCAT(<str_expr>, <str_expr> [, <str_expr>])  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Следующий пример возвращает строку hello объединенные hello Hello указанные значения.  
  
```  
SELECT CONCAT("abc", "def")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "abcdef"}  
```  
  
####  <a name="bk_contains"></a> CONTAINS  
 Возвращает логическое значение, указывающее, является ли hello первое строковое выражение содержит hello второй.  
  
 **Синтаксис**  
  
```  
CONTAINS(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример проверяет «abc» содержит «ab» и содержит «d».  
  
```  
SELECT CONTAINS("abc", "ab"), CONTAINS("abc", "d")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": true, "$2": false}]  
```  
  
####  <a name="bk_endswith"></a> ENDSWITH  
 Возвращает логическое значение, указывающее, было ли первое строковое выражение hello заканчивается hello второй.  
  
 **Синтаксис**  
  
```  
ENDSWITH(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello, «abc» заканчивается «b» и «bc».  
  
```  
SELECT ENDSWITH("abc", "b"), ENDSWITH("abc", "bc")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": false, "$2": true}]  
```  
  
####  <a name="bk_index_of"></a> INDEX_OF  
 Возвращает hello, начальная позиция первого вхождения hello hello второго строкового выражения внутри первого указанного строкового выражения hello, или значение -1, если строка hello не найдена.  
  
 **Синтаксис**  
  
```  
INDEX_OF(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Hello следующем примере возвращается индекс различных подстрок внутри «abc» hello.  
  
```  
SELECT INDEX_OF("abc", "ab"), INDEX_OF("abc", "b"), INDEX_OF("abc", "c")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": 0, "$2": 1, "$3": -1}]  
```  
  
####  <a name="bk_left"></a> LEFT  
 Возвращает hello левую часть строки с hello указанное число символов.  
  
 **Синтаксис**  
  
```  
LEFT(<str_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello в левом верхнем углу «abc» для различных значений длины.  
  
```  
SELECT LEFT("abc", 1), LEFT("abc", 2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "ab", "$2": "ab"}]  
```  
  
####  <a name="bk_length"></a> LENGTH  
 Количество символов для hello hello возвращает указанного строкового выражения.  
  
 **Синтаксис**  
  
```  
LENGTH(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает длину строки hello.  
  
```  
SELECT LENGTH("abc")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": 3}]  
```  
  
####  <a name="bk_lower"></a> LOWER  
 Возвращает строковое выражение после преобразования данных toolowercase символ верхнего регистра.  
  
 **Синтаксис**  
  
```  
LOWER(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Следующий пример показывает как Hello toouse НИЖНЕГО в запросе.  
  
```  
SELECT LOWER("Abc")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "abc"}]  
  
```  
  
####  <a name="bk_ltrim"></a> LTRIM  
 Возвращает строковое выражение после удаления начальных пробелов.  
  
 **Синтаксис**  
  
```  
LTRIM(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Следующий пример показывает как Hello toouse LTRIM внутри запроса.  
  
```  
SELECT LTRIM("  abc"), LTRIM("abc"), LTRIM("abc   ")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "abc", "$2": "abc", "$3": "abc   "}]  
```  
  
####  <a name="bk_replace"></a> REPLACE  
 Заменяет все вхождения указанного строкового значения другим строковым значением.  
  
 **Синтаксис**  
  
```  
REPLACE(<str_expr>, <str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Hello в следующем примере показано, как toouse ЗАМЕНИТЕ в запросе.  
  
```  
SELECT REPLACE("This is a Test", "Test", "desk")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "This is a desk"}]  
```  
  
####  <a name="bk_replicate"></a> REPLICATE  
 Повторяет строковое значение указанное число раз.  
  
 **Синтаксис**  
  
```  
REPLICATE(<str_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Hello в следующем примере показано, как РЕПЛИЦИРОВАТЬ toouse в запросе.  
  
```  
SELECT REPLICATE("a", 3)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "aaa"}]  
```  
  
####  <a name="bk_reverse"></a> REVERSE  
 Возвращает hello строковое значение в обратном порядке.  
  
 **Синтаксис**  
  
```  
REVERSE(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Hello, следующий пример показывает, как ОТМЕНИТЬ toouse в запросе.  
  
```  
SELECT REVERSE("Abc")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "cbA"}]  
```  
  
####  <a name="bk_right"></a> RIGHT  
 Возвращает hello правой части строки с hello указанное число символов.  
  
 **Синтаксис**  
  
```  
RIGHT(<str_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello правую часть «abc» для различных значений длины.  
  
```  
SELECT RIGHT("abc", 1), RIGHT("abc", 2)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "c", "$2": "bc"}]  
```  
  
####  <a name="bk_rtrim"></a> RTRIM  
 Возвращает строковое выражение после удаления конечных пробелов.  
  
 **Синтаксис**  
  
```  
RTRIM(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Следующий пример показывает как Hello toouse RTRIM внутри запроса.  
  
```  
SELECT RTRIM("  abc"), RTRIM("abc"), RTRIM("abc   ")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "   abc", "$2": "abc", "$3": "abc"}]  
```  
  
####  <a name="bk_startswith"></a> STARTSWITH  
 Возвращает логическое значение, указывающее, является ли первое строковое выражение hello начинается с hello во-вторых.  
  
 **Синтаксис**  
  
```  
STARTSWITH(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Hello следующий пример проверяет hello строка «abc» начинается с «b» и «».  
  
```  
SELECT STARTSWITH("abc", "b"), STARTSWITH("abc", "a")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": false, "$2": true}]  
```  
  
####  <a name="bk_substring"></a> SUBSTRING  
 Возвращает часть строкового выражения, начиная с hello указан символ Отсчитываемая от нуля позиция и продолжает toohello указывается длина или toohello конца строки hello.  
  
 **Синтаксис**  
  
```  
SUBSTRING(<str_expr>, <num_expr> [, <num_expr>])  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Hello следующий пример возвращает hello подстрока «abc» начиная с 1 и длиной 1 символ.  
  
```  
SELECT SUBSTRING("abc", 1, 1)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "b"}]  
```  
  
####  <a name="bk_upper"></a> UPPER  
 Возвращает строковое выражение после преобразования данных toouppercase строчные буквы.  
  
 **Синтаксис**  
  
```  
UPPER(<str_expr>)  
```  
  
 **Аргументы**  
  
-   `str_expr`  
  
     Любое допустимое строковое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает строковое выражение.  
  
 **Примеры**  
  
 Следующий пример показывает как Hello toouse ВЕРХНЕМ в запросе  
  
```  
SELECT UPPER("Abc")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": "ABC"}]  
```  
  
###  <a name="bk_array_functions"></a> Функции массивов  
 Hello следующие скалярные функции выполняют операцию над входным значением массива и возвращают числовое, логическое значение или значение массива  
  
||||  
|-|-|-|  
|[ARRAY_CONCAT](#bk_array_concat)|[ARRAY_CONTAINS](#bk_array_contains)|[ARRAY_LENGTH](#bk_array_length)|  
|[ARRAY_SLICE](#bk_array_slice)|||  
  
####  <a name="bk_array_concat"></a> ARRAY_CONCAT  
 Возвращает массив, который является результатом объединения двух или более значений массивов hello.  
  
 **Синтаксис**  
  
```  
ARRAY_CONCAT (<arr_expr>, <arr_expr> [, <arr_expr>])  
```  
  
 **Аргументы**  
  
-   `arr_expr`  
  
     Любое допустимое выражение массива.  
  
 **Типы возвращаемого значения**  
  
 Возвращает выражение массива.  
  
 **Примеры**  
  
 Hello в следующем примере как tooconcatenate двух массивов.  
  
```  
SELECT ARRAY_CONCAT(["apples", "strawberries"], ["bananas"])  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": ["apples", "strawberries", "bananas"]}]  
```  
  
####  <a name="bk_array_contains"></a> ARRAY_CONTAINS  
 Возвращает логическое значение, указывающее, содержит ли массив hello hello заданного значения.  
  
 **Синтаксис**  
  
```  
ARRAY_CONTAINS (<arr_expr>, <expr>)  
```  
  
 **Аргументы**  
  
-   `arr_expr`  
  
     Любое допустимое выражение массива.  
  
-   `expr`  
  
     Любое допустимое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое значение.  
  
 **Примеры**  
  
 Следующий пример как Hello toocheck членства в массив с помощью ARRAY_CONTAINS.  
  
```  
SELECT   
           ARRAY_CONTAINS(["apples", "strawberries", "bananas"], "apples"),  
           ARRAY_CONTAINS(["apples", "strawberries", "bananas"], "mangoes")  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": true, "$2": false}]  
```  
  
####  <a name="bk_array_length"></a> ARRAY_LENGTH  
 Возвращает число hello элементов hello указано выражение массива.  
  
 **Синтаксис**  
  
```  
ARRAY_LENGTH(<arr_expr>)  
```  
  
 **Аргументы**  
  
-   `arr_expr`  
  
     Любое допустимое выражение массива.  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение.  
  
 **Примеры**  
  
 Следующий пример Hello как tooget hello длину массива с помощью ARRAY_LENGTH.  
  
```  
SELECT ARRAY_LENGTH(["apples", "strawberries", "bananas"])  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{"$1": 3}]  
```  
  
####  <a name="bk_array_slice"></a> ARRAY_SLICE  
 Возвращает часть выражения массива.
  
 **Синтаксис**  
  
```  
ARRAY_SLICE (<arr_expr>, <num_expr> [, <num_expr>])  
```  
  
 **Аргументы**  
  
-   `arr_expr`  
  
     Любое допустимое выражение массива.  
  
-   `num_expr`  
  
     Любое допустимое числовое выражение.  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое значение.  
  
 **Примеры**  
  
 Следующий пример как Hello tooget часть массива с помощью ARRAY_SLICE.  
  
```  
SELECT   
           ARRAY_SLICE(["apples", "strawberries", "bananas"], 1),  
           ARRAY_SLICE(["apples", "strawberries", "bananas"], 1, 1)  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{  
           "$1": ["strawberries", "bananas"],   
           "$2": ["strawberries"]  
       }]  
```  
  
###  <a name="bk_spatial_functions"></a> Пространственные функции  
 Hello следующие скалярные функции выполняют операции над входным значением пространственного объекта и возвращают числовое или логическое значение.  
  
||||  
|-|-|-|  
|[ST_DISTANCE](#bk_st_distance)|[ST_WITHIN](#bk_st_within)|[ST_INTERSECTS](#bk_st_intersects)|[ST_ISVALID](#bk_st_isvalid)|  
|[ST_ISVALIDDETAILED](#bk_st_isvaliddetailed)|||  
  
####  <a name="bk_st_distance"></a> ST_DISTANCE  
 Возвращает hello расстояние между выражениями hello две точки GeoJSON Polygon и LineString.  
  
 **Синтаксис**  
  
```  
ST_DISTANCE (<spatial_expr>, <spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
  
 **Типы возвращаемого значения**  
  
 Возвращает числовое выражение, содержащее hello расстояние. Это выражается в метрах для эталонной системы по умолчанию hello.  
  
 **Примеры**  
  
 Следующий пример показывает как Hello tooreturn семейства все документы, которые находятся в пределах 30 км hello определенное место, с помощью встроенной функции ST_DISTANCE hello. .  
  
```  
SELECT f.id   
FROM Families f   
WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{  
  "id": "WakefieldFamily"  
}]  
```  
  
####  <a name="bk_st_within"></a> ST_WITHIN  
 Возвращает логическое выражение, указывающее, является ли объект GeoJSON на hello (точка Polygon и LineString), указанный в первый аргумент hello в hello GeoJSON (точка Polygon и LineString) в hello второго аргумента.  
  
 **Синтаксис**  
  
```  
ST_WITHIN (<spatial_expr>, <spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
 
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое значение.  
  
 **Примеры**  
  
 Hello в следующем примере показано, как toofind все семейство документы внутри многоугольника с помощью ST_WITHIN.  
  
```  
SELECT f.id   
FROM Families f   
WHERE ST_WITHIN(f.location, {  
    'type':'Polygon',   
    'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]  
})  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{ "id": "WakefieldFamily" }]  
```  

####  <a name="bk_st_intersects"></a> ST_INTERSECTS  
 Возвращает логическое выражение, указывающее, пересекается ли объект GeoJSON на hello (точка Polygon и LineString), указанный в первый аргумент hello hello GeoJSON (точка Polygon и LineString) в hello второго аргумента.  
  
 **Синтаксис**  
  
```  
ST_INTERSECTS (<spatial_expr>, <spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
 
-   `spatial_expr`  
  
     Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое значение.  
  
 **Примеры**  
  
 Следующий пример показывает как Hello toofind hello все области, которые пересекается с заданной многоугольника.  
  
```  
SELECT a.id   
FROM Areas a   
WHERE ST_INTERSECTS(a.location, {  
    'type':'Polygon',   
    'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]  
})  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{ "id": "IntersectingPolygon" }]  
```  
  
####  <a name="bk_st_isvalid"></a> ST_ISVALID  
 Возвращает логическое значение, указывающее, является ли hello точки GeoJSON Polygon и LineString выражение допустимо.  
  
 **Синтаксис**  
  
```  
ST_ISVALID(<spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение GeoJSON (точка, многоугольник или LineString).  
  
 **Типы возвращаемого значения**  
  
 Возвращает логическое выражение.  
  
 **Примеры**  
  
 Следующий пример показывает как Hello toocheck, если точка может быть использована с помощью ST_VALID.  
  
 Например, эта точка имеет значение широты, которая не находится в допустимый диапазон значений [-90, 90] hello, поэтому Здравствуйте, запрос возвращает значение false.  
  
 Для многоугольников hello GeoJSON спецификация требует, должно быть hello последней парой координат предоставленный hello таким же как первого, toocreate hello замкнутую фигуру. Точки внутри многоугольника должны указываться в порядке против часовой стрелки. Многоугольник, указанным в заказе по часовой стрелке представляет обратное hello hello области внутри него.  
  
```  
SELECT ST_ISVALID({ "type": "Point", "coordinates": [31.9, -132.8] })  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{ "$1": false }]  
```  
  
####  <a name="bk_st_isvaliddetailed"></a> ST_ISVALIDDETAILED  
 Возвращает значение JSON, содержащий логическое значение, указываемое hello точки GeoJSON Polygon и LineString выражение является допустимым и если недействительной, кроме того hello причина как строковое значение.  
  
 **Синтаксис**  
  
```  
ST_ISVALID(<spatial_expr>)  
```  
  
 **Аргументы**  
  
-   `spatial_expr`  
  
     Любое допустимое выражение точки или многоугольника GeoJSON.  
  
 **Типы возвращаемого значения**  
  
 Возвращает значение JSON, содержащий логическое значение, если hello указания момента GeoJSON или Многоугольник выражение является допустимым и если недействительной, кроме того hello причина как строковое значение.  
  
 **Примеры**  
  
 Следующий пример как Hello toocheck срок действия (с сведения о) с помощью ST_ISVALIDDETAILED.  
  
```  
SELECT ST_ISVALIDDETAILED({   
  "type": "Polygon",   
  "coordinates": [[ [ 31.8, -5 ], [ 31.8, -4.7 ], [ 32, -4.7 ], [ 32, -5 ] ]]  
})  
```  
  
 Ниже приведен результирующий набор hello.  
  
```  
[{  
  "$1": {   
    "valid": false,   
    "reason": "hello Polygon input is not valid because hello start and end points of hello ring number 1 are not hello same. Each ring of a polygon must have hello same start and end points."   
  }  
}]  
```  
  
## <a name="next-steps"></a>Дальнейшие действия  
 [SQL-запросы и синтаксис SQL в Azure Cosmos DB](documentdb-sql-query.md)   
 [Документация по базе данных Azure Cosmos](https://docs.microsoft.com/en-us/azure/cosmos-db/)  
  
  
