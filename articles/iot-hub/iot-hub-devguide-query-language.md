---
title: "Общие сведения о языке запросов Центра Интернета вещей Azure | Документация Майкрософт"
description: "Руководство разработчика. Описание похожего на SQL языка запросов Центра Интернета вещей, используемого для получения сведений о двойниках устройств и заданиях из Центра Интернета вещей."
services: iot-hub
documentationcenter: .net
author: fsautomata
manager: timlt
editor: 
ms.assetid: 851a9ed3-b69e-422e-8a5d-1d79f91ddf15
ms.service: iot-hub
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 10/24/2017
ms.author: elioda
ms.openlocfilehash: 450f2d38f7b641bcf6b8be061969404a1b582b4c
ms.sourcegitcommit: 7d4b3cf1fc9883c945a63270d3af1f86e3bfb22a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2018
---
# <a name="iot-hub-query-language-for-device-twins-jobs-and-message-routing"></a>Язык запросов Центра Интернета вещей для двойников устройств, заданий и маршрутизации сообщений

Центр Интернета вещей предоставляет эффективный язык запросов, похожий на SQL, для получения сведений о [двойниках устройств][lnk-twins], [заданиях][lnk-jobs] и [маршрутизации сообщений][lnk-devguide-messaging-routes]. В этой статье представлены:

* общие сведения об основных возможностях языка запросов Центра Интернета вещей;
* подробное описание языка.

## <a name="device-twin-queries"></a>Запросы двойника устройства
[Двойники устройств][lnk-twins] могут содержать произвольные объекты JSON в качестве тегов и свойств. Центр Интернета вещей позволяет выполнять запросы к двойникам устройств как к одному документу JSON, содержащему все сведения о двойниках устройств.
Например, предположим, что двойники устройств Центра Интернета вещей имеют следующую структуру:

```json
{
    "deviceId": "myDeviceId",
    "etag": "AAAAAAAAAAc=",
    "status": "enabled",
    "statusUpdateTime": "0001-01-01T00:00:00",    
    "connectionState": "Disconnected",    
    "lastActivityTime": "0001-01-01T00:00:00",
    "cloudToDeviceMessageCount": 0,
    "authenticationType": "sas",    
    "x509Thumbprint": {    
        "primaryThumbprint": null,
        "secondaryThumbprint": null
    },
    "version": 2,
    "tags": {
        "location": {
            "region": "US",
            "plant": "Redmond43"
        }
    },
    "properties": {
        "desired": {
            "telemetryConfig": {
                "configId": "db00ebf5-eeeb-42be-86a1-458cccb69e57",
                "sendFrequencyInSecs": 300
            },
            "$metadata": {
            ...
            },
            "$version": 4
        },
        "reported": {
            "connectivity": {
                "type": "cellular"
            },
            "telemetryConfig": {
                "configId": "db00ebf5-eeeb-42be-86a1-458cccb69e57",
                "sendFrequencyInSecs": 300,
                "status": "Success"
            },
            "$metadata": {
            ...
            },
            "$version": 7
        }
    }
}
```

Центр Интернета вещей предоставляет двойники устройства как коллекцию документов с именем **devices**.
Следующий запрос получает весь набор двойников устройства:

```sql
SELECT * FROM devices
```

> [!NOTE]
> [Пакеты SDK для Azure IoT][lnk-hub-sdks] поддерживают разбивку на страницы объемных результатов.

Центр Интернета вещей позволяет получить двойники устройств, отфильтрованные по произвольным условиям. Например, для получения двойников устройств, где тег **location.region** имеет значение **US**, используйте следующий запрос:

```sql
SELECT * FROM devices
WHERE tags.location.region = 'US'
```

Кроме того, поддерживаются логические операторы и арифметические сравнения. Например, для получения двойников устройств, которые находятся в США и настроены для отправки телеметрии не чаще раза в минуту, используйте следующий запрос:

```sql
SELECT * FROM devices
WHERE tags.location.region = 'US'
    AND properties.reported.telemetryConfig.sendFrequencyInSecs >= 60
```

Для удобства можно также использовать константы массива с операторами **IN** ("входит") и **NIN** ("не входит"). Например, для получения двойников устройств, сообщающих о подключении по Wi-Fi или проводной сети, используйте следующий запрос:

```sql
SELECT * FROM devices
WHERE properties.reported.connectivity IN ['wired', 'wifi']
```

Часто требуется определить все двойники устройств, содержащие определенное свойство. Для этой цели Центр Интернета вещей поддерживает функцию `is_defined()`. Например, для получения двойников устройств, которые определяют свойство `connectivity`, используется следующий запрос:

```SQL
SELECT * FROM devices
WHERE is_defined(properties.reported.connectivity)
```

Полное описание возможностей фильтрации см. в разделе [Предложение WHERE][lnk-query-where].

Кроме того, поддерживаются группирование и агрегаты. Например, чтобы найти количество устройств в каждом состоянии конфигурации телеметрии, используйте следующий запрос:

```sql
SELECT properties.reported.telemetryConfig.status AS status,
    COUNT() AS numberOfDevices
FROM devices
GROUP BY properties.reported.telemetryConfig.status
```

Этот запрос группировки вернет результат, как в следующем примере. Здесь три устройства сообщают об успешной конфигурации, два все еще применяют конфигурацию и одно сообщило об ошибке. 

```json
[
    {
        "numberOfDevices": 3,
        "status": "Success"
    },
    {
        "numberOfDevices": 2,
        "status": "Pending"
    },
    {
        "numberOfDevices": 1,
        "status": "Error"
    }
]
```

Запросы проекции позволяют разработчикам настроить возврат только требуемых свойств. Например, чтобы узнать время последнего действия всех отключенных устройств, используйте следующий запрос:

```sql
SELECT LastActivityTime FROM devices WHERE status = 'enabled'
```

### <a name="c-example"></a>Пример C#
Функция обработки запросов предоставляется в [пакете SDK для служб C#][lnk-hub-sdks] в классе **RegistryManager**.
Ниже приведен пример простого запроса:

```csharp
var query = registryManager.CreateQuery("SELECT * FROM devices", 100);
while (query.HasMoreResults)
{
    var page = await query.GetNextAsTwinAsync();
    foreach (var twin in page)
    {
        // do work on twin object
    }
}
```

Обратите внимание, как создается экземпляр объекта **query** с размером страницы (до 100), а затем можно получить несколько страниц, вызвав метод **GetNextAsTwinAsync** несколько раз.
Обратите внимание, что объект query предоставляет несколько вариантов **next*** в зависимости от параметра десериализации, требуемого для запроса. Это могут быть объекты двойников устройств, объекты заданий или простой JSON, который применяется при использовании проекций.

### <a name="nodejs-example"></a>Пример для Node.js
Функция обработки запросов предоставляется в [пакете SDK службы Azure IoT для Node.js][lnk-hub-sdks] в объекте **Registry**.
Ниже приведен пример простого запроса:

```nodejs
var query = registry.createQuery('SELECT * FROM devices', 100);
var onResults = function(err, results) {
    if (err) {
        console.error('Failed to fetch the results: ' + err.message);
    } else {
        // Do something with the results
        results.forEach(function(twin) {
            console.log(twin.deviceId);
        });

        if (query.hasMoreResults) {
            query.nextAsTwin(onResults);
        }
    }
};
query.nextAsTwin(onResults);
```

Обратите внимание, как создается экземпляр объекта **query** с размером страницы (до 100), а затем можно получить несколько страниц, вызвав метод **nextAsTwin** несколько раз.
Обратите внимание, что объект query предоставляет несколько вариантов **next*** в зависимости от параметра десериализации, требуемого для запроса. Это могут быть объекты двойников устройств, объекты заданий или простой JSON, который применяется при использовании проекций.

### <a name="limitations"></a>Ограничения
> [!IMPORTANT]
> Результаты запросов могут поступать с задержкой в несколько минут и не учитывать последние значения в двойниках устройств. При запросе данных отдельных двойников устройств по идентификатору всегда предпочтительнее использовать интерфейс API, который применяется для извлечения таких двойников. Он всегда содержит последние значения и обладает более высокими пределами регулирования.

В настоящее время сравнения поддерживаются только между типами-примитивами (не объектами), например, `... WHERE properties.desired.config = properties.reported.config` поддерживается только в том случае, если эти свойства имеют примитивные значения.

## <a name="get-started-with-jobs-queries"></a>Начало работы с запросами заданий
[Задания][lnk-jobs] позволяют выполнять операции с наборами устройств. Каждый двойник устройства содержит сведения о заданиях, в которых он участвует, в коллекции с именем **jobs**.
Логически получается следующее:

```json
{
    "deviceId": "myDeviceId",
    "etag": "AAAAAAAAAAc=",
    "tags": {
        ...
    },
    "properties": {
        ...
    },
    "jobs": [
        {
            "deviceId": "myDeviceId",
            "jobId": "myJobId",
            "jobType": "scheduleTwinUpdate",
            "status": "completed",
            "startTimeUtc": "2016-09-29T18:18:52.7418462",
            "endTimeUtc": "2016-09-29T18:20:52.7418462",
            "createdDateTimeUtc": "2016-09-29T18:18:56.7787107Z",
            "lastUpdatedDateTimeUtc": "2016-09-29T18:18:56.8894408Z",
            "outcome": {
                "deviceMethodResponse": null
            }
        },
        ...
    ]
}
```

В настоящее время к этой коллекции можно выполнить запрос как к **devices.jobs** на языке запросов Центра Интернета вещей.

> [!IMPORTANT]
> Сейчас свойство jobs никогда не возвращается при запросах двойников устройств (т. е. при запросах, содержащих текст FROM devices). Доступ к нему можно получить только непосредственно с помощью запросов, использующих `FROM devices.jobs`.
>
>

Например, чтобы получить все задания (выполненные и запланированные), влияющие на одно устройство, можно использовать следующий запрос:

```sql
SELECT * FROM devices.jobs
WHERE devices.jobs.deviceId = 'myDeviceId'
```

Обратите внимание, как этот запрос предоставляет сведения о состоянии конкретного устройства (и, возможно, ответ на прямой метод) в каждом возвращенном задании.
Все свойства объектов в коллекции **devices.jobs** можно также отфильтровать с помощью произвольных логических условий.
Например, чтобы получить все завершенные задания по обновлению двойников устройств, созданных после сентября 2016 года для определенного устройства, используйте следующий запрос:

```sql
SELECT * FROM devices.jobs
WHERE devices.jobs.deviceId = 'myDeviceId'
    AND devices.jobs.jobType = 'scheduleTwinUpdate'
    AND devices.jobs.status = 'completed'
    AND devices.jobs.createdTimeUtc > '2016-09-01'
```

Вы также можете получить результаты по одному заданию для каждого устройства.

```sql
SELECT * FROM devices.jobs
WHERE devices.jobs.jobId = 'myJobId'
```

### <a name="limitations"></a>Ограничения
В настоящее время запросы к **devices.jobs** не поддерживают следующие элементы:

* проекции, поэтому можно использовать только `SELECT *`;
* условия, касающиеся двойника устройства, и свойства задания (см. предыдущий раздел);
* выполняемые агрегаты, например count, avg, group by.

## <a name="device-to-cloud-message-routes-query-expressions"></a>Выражения запросов по маршрутам сообщений, отправляемых с устройства в облако

С помощью [маршрутов от устройства в облако][lnk-devguide-messaging-routes] можно сделать так, чтобы Центр Интернета вещей передавал сообщения, отправляемые с устройства в облако, в разные конечные точки на основе условий, вычисляемых для отдельных сообщений.

Используемое в маршруте [условие][lnk-query-expressions] создается на том же языка запросов Центра Интернета вещей, что и условия в запросах двойников и заданий. Условия маршрута вычисляются по заголовкам и тексту сообщения. Выражение запроса маршрутизации может включать только заголовки сообщений, только текст сообщения или заголовки и текст сообщения. Центр Интернета вещей предполагает наличие определенной схемы для заголовков и текста сообщения для маршрутизации сообщений. В следующих разделах описываются необходимые условия правильной маршрутизации Центра Интернета вещей.

### <a name="routing-on-message-headers"></a>Маршрутизация по заголовкам сообщений

Центр Интернета вещей предполагает следующее представление JSON заголовков сообщений для маршрутизации:

```json
{
    "$messageId": "",
    "$enqueuedTime": "",
    "$to": "",
    "$expiryTimeUtc": "",
    "$correlationId": "",
    "$userId": "",
    "$ack": "",
    "$connectionDeviceId": "",
    "$connectionDeviceGenerationId": "",
    "$connectionAuthMethod": "",
    "$content-type": "",
    "$content-encoding": "",

    "userProperty1": "",
    "userProperty2": ""
}
```

Системные свойства сообщений начинаются с символов `'$'`.
Доступ к пользовательским свойствам всегда осуществляется с использованием их имен. Если имя пользовательского свойства совпадает с системным свойством (например, `$to`), такое пользовательское свойство будут извлечено с помощью выражения `$to`.
Вы всегда можете получить доступ к системному свойству с помощью квадратных скобок `{}`: например, можно использовать выражение `{$to}` для доступа к системному свойству `to`. Имена свойств в квадратных скобках всегда позволяют получить соответствующее системное свойство.

Не забывайте, что в именах свойств не учитывается регистр.

> [!NOTE]
> Все свойства сообщения являются строками. Системные свойства сейчас нельзя использовать в запросах (см. [руководство разработчика][lnk-devguide-messaging-format]).
>

Например, если вы используете свойство `messageType`, вы можете направлять все данные телеметрии в одну конечную точку, а все оповещения — в другую. Следующее выражение позволяет перенаправить данные телеметрии:

```sql
messageType = 'telemetry'
```

А это выражение будет перенаправлять текст оповещения:

```sql
messageType = 'alert'
```

Также поддерживаются логические выражения и функции. Например, это позволяет различать сообщения по уровню серьезности:

```sql
messageType = 'alerts' AND as_number(severity) <= 2
```

Полный список поддерживаемых операторов и функций вы найдете в разделе [Выражения и условия][lnk-query-expressions].

### <a name="routing-on-message-bodies"></a>Маршрутизация по тексту сообщений

Центр Интернета вещей поддерживает маршрутизацию на основе содержимого текста сообщения, только если текст сообщения соответствует формату JSON в кодировке UTF-8, UTF-16 или UTF-32. В качестве типа содержимого сообщения необходимо задать `application/json`, а в качестве кодировки содержимого — одну из поддерживаемых кодировок UTF в заголовках сообщения. Если один из заголовков не указан, Центр Интернета вещей не будет пытаться вычислить любое выражение запроса, включающее текст, по сообщению. Если формат сообщения отличается от JSON или сообщение не указывает тип и кодировку содержимого, маршрутизацию сообщений, тем не менее, можно выполнить на основе заголовков сообщения.

Для маршрутизации сообщения можно использовать `$body` в выражении запроса. В выражении запроса можно использовать простую ссылку на текст, ссылку на массив текста или несколько ссылок на текст. В выражении запроса можно также указывать сочетание ссылки на текст со ссылкой на заголовок сообщения. Например, все выражения, приведенные ниже, допустимы:

```sql
$body.message.Weather.Location.State = 'WA'
$body.Weather.HistoricalData[0].Month = 'Feb'
$body.Weather.Temperature = 50 AND $body.message.Weather.IsEnabled
length($body.Weather.Location.State) = 2
$body.Weather.Temperature = 50 AND Status = 'Active'
```

## <a name="basics-of-an-iot-hub-query"></a>Основные сведения о запросе Центра Интернета вещей
Каждый запрос Центра Интернета вещей состоит из предложений SELECT и FROM, а также необязательных предложений WHERE и GROUP BY. Каждый запрос выполняется для коллекции документов JSON, например двойников устройств. Предложение FROM указывает коллекцию документов, по которой будет выполняться итерация (**devices** или **devices.jobs**). Затем применяется фильтр в предложении WHERE. При использовании агрегатов результаты этого шага группируются, как указано в предложении GROUP BY. Для каждой группы создается строка, как указано в предложении SELECT.

```sql
SELECT <select_list>
FROM <from_specification>
[WHERE <filter_condition>]
[GROUP BY <group_specification>]
```

## <a name="from-clause"></a>Предложение FROM
Предложение **FROM <из_спецификации>** может предоставить только два значения: **FROM devices** для запроса двойников устройства или **FROM devices.jobs** для запроса сведений о задании для каждого устройства.

## <a name="where-clause"></a>Предложение WHERE
Предложение **WHERE <условие_фильтрации>** является необязательным. Оно определяет одно или несколько условий, которым должны соответствовать документы JSON в коллекции FROM, чтобы быть включенными в результат. Любой документ JSON должен при вычислении указанных условий возвращать значение true, чтобы быть включенным в результат.

Допустимые условия описаны в разделе [Выражения и условия][lnk-query-expressions].

## <a name="select-clause"></a>Предложение SELECT
Предложение **SELECT <список_для_выбора>** является обязательным. Оно указывает значения, которые будут получены из запроса. Здесь задаются значения JSON, которые используются для создания новых объектов JSON.
На этапе проекции для каждого элемента, отфильтрованного (и при необходимости сгруппированного) подмножества коллекции FROM создается объект JSON, собранный из значений, которые указаны в предложении SELECT.

Далее приводится грамматика предложения SELECT:

```
SELECT [TOP <max number>] <projection list>

<projection_list> ::=
    '*'
    | <projection_element> AS alias [, <projection_element> AS alias]+

<projection_element> :==
    attribute_name
    | <projection_element> '.' attribute_name
    | <aggregate>

<aggregate> :==
    count()
    | avg(<projection_element>)
    | sum(<projection_element>)
    | min(<projection_element>)
    | max(<projection_element>)
```

**Attribute_name** относится к любому свойству документа JSON в коллекции FROM. Некоторые примеры предложений SELECT можно найти в разделе [Начало работы с запросами двойника устройства][lnk-query-getstarted].

В настоящее время предложения для осуществления выбора, отличные от **SELECT***, поддерживаются только в статистических запросах к двойникам устройств.

## <a name="group-by-clause"></a>Предложение GROUP BY
Предложение **GROUP BY <спецификация_группирования>** является необязательным. Оно выполняется после фильтра, указанного в предложении WHERE, и перед проекцией, указанной в предложении SELECT. Оно группирует документы на основе значения атрибута. Эти группы используются для создания статистических значений, как указано в предложении SELECT.

Ниже представлен пример запроса с использованием предложения GROUP BY:

```sql
SELECT properties.reported.telemetryConfig.status AS status,
    COUNT() AS numberOfDevices
FROM devices
GROUP BY properties.reported.telemetryConfig.status
```

Далее указан формальный синтаксис предложения GROUP BY:

```
GROUP BY <group_by_element>
<group_by_element> :==
    attribute_name
    | < group_by_element > '.' attribute_name
```

**Attribute_name** относится к любому свойству документа JSON в коллекции FROM.

В настоящее время предложение GROUP BY поддерживается только при запросе к двойникам устройств.

## <a name="expressions-and-conditions"></a>Выражения и условия
В общем *выражение*:

* возвращает экземпляр типа JSON (например, логическое значение, число, строка, массив или объект);
* определяется обработкой данных, поступающих из документа JSON устройства, и констант с помощью встроенных операторов и функций.

*Условия* — это выражения, результатом вычисления которых является логическое значение. Все константы, значения которых отличаются от логического значения **true**, трактуются как значение **false** (в том числе значения **null**, **undefined**, любые экземпляры объектов или массивов, любые строки и, разумеется, само логическое значение **false**).

Выражения имеют следующий синтаксис:

```
<expression> ::=
    <constant> |
    attribute_name |
    <function_call> |
    <expression> binary_operator <expression> |
    <create_array_expression> |
    '(' <expression> ')'

<function_call> ::=
    <function_name> '(' expression ')'

<constant> ::=
    <undefined_constant>
    | <null_constant>
    | <number_constant>
    | <string_constant>
    | <array_constant>

<undefined_constant> ::= undefined
<null_constant> ::= null
<number_constant> ::= decimal_literal | hexadecimal_literal
<string_constant> ::= string_literal
<array_constant> ::= '[' <constant> [, <constant>]+ ']'
```

Чтобы понять, что означает каждый символ в синтаксисе выражений, ознакомьтесь со следующей таблицей:

| Знак | Определение |
| --- | --- |
| attribute_name | Любое свойство документа JSON в коллекции **FROM**. |
| binary_operator | Любой бинарный оператор, перечисленный в разделе [Операторы](#operators). |
| function_name| Любая функция, перечисленная в разделе [Функции](#functions). |
| decimal_literal |Число с плавающей запятой в десятичном представлении. |
| hexadecimal_literal |Число, представленное строкой 0x, за которой следует строка с шестнадцатеричными цифрами. |
| string_literal |Строковые литералы — это строки Юникода, представленные в виде последовательности из нуля или более знаков Юникода или escape-последовательностей. Строковые литералы заключаются в одинарные или двойные кавычки. В знаках Юникода, определяемых 4 шестнадцатеричными цифрами, разрешено использовать escape-символы `\'`, `\"`, `\\` и `\uXXXX`. |

### <a name="operators"></a>Операторы
Поддерживаются следующие операторы:

| Семейство | Операторы |
| --- | --- |
| Арифметические |+, -, *, /, % |
| Логические |AND, OR, NOT |
| Сравнение |=, !=, <, >, <=, >=, <> |

### <a name="functions"></a>Functions
В запросах двойников и заданий поддерживается только одна функция.

| Функция | ОПИСАНИЕ |
| -------- | ----------- |
| IS_DEFINED(Свойство) | Возвращает логическое значение, указывающее, назначено ли свойству значение (в том числе значение `null`). |

В условиях маршрута поддерживаются следующие математические функции.

| Функция | ОПИСАНИЕ |
| -------- | ----------- |
| ABS(x) | Возвращает модуль (положительное значение) указанного числового выражения. |
| EXP(x) | Возвращает значение экспоненты для указанного числового выражения (e^x). |
| POWER(x,y) | Возвращает результат возведения указанного числового выражения в заданную степень (x^y).|
| SQUARE(x) | Возвращает квадратный корень из указанного числового значения. |
| CEILING(x) | Возвращает наименьшее целочисленное значение, которое больше или равно указанному числовому выражению. |
| FLOOR(x) | Возвращает наибольшее целочисленное значение, которое меньше или равно указанному числовому выражению. |
| SIGN(x) | Возвращает знак указанного числового выражения (+1 для положительных чисел, 0 для нуля или -1 для отрицательных).|
| SQRT(x) | Возвращает квадратный корень из указанного числового значения. |

В условиях маршрута поддерживаются следующие функции проверки и приведения типов.

| Функция | ОПИСАНИЕ |
| -------- | ----------- |
| AS_NUMBER | Преобразует входную строку в число. Возвращает `noop`, если аргумент является числом, или `Undefined`, если строка не представляет число.|
| IS_ARRAY | Возвращает логическое значение, указывающее, является ли указанное выражение массивом. |
| IS_BOOL | Возвращает логическое значение, указывающее, является ли указанное выражение логическим значением. |
| IS_DEFINED | Возвращает логическое значение, указывающее, назначено ли свойству значение. |
| IS_NULL | Возвращает логическое значение, указывающее, является ли указанное выражение значением Null. |
| IS_NUMBER | Возвращает логическое значение, указывающее, является ли указанное выражение числовым значением. |
| IS_OBJECT | Возвращает логическое значение, указывающее, является ли указанное выражение объектом JSON. |
| IS_PRIMITIVE | Возвращает логическое значение, указывающее, является ли указанное выражение примитивом (строкой, логическим значением, числовым значением или `null`). |
| IS_STRING | Возвращает логическое значение, указывающее, является ли указанное выражение строковым значением. |

В условиях маршрутов поддерживаются следующие строковые функции.

| Функция | ОПИСАНИЕ |
| -------- | ----------- |
| CONCAT(x, y, …) | Возвращает строку, являющуюся результатом объединения двух или более строковых значений. |
| LENGTH(x) | Возвращает число символов указанного строкового выражения.|
| LOWER(x) | Возвращает строковое выражение после преобразования символов верхнего регистра в нижний. |
| UPPER(x) | Возвращает строковое выражение после преобразования символов нижнего регистра в верхний. |
| SUBSTRING(строка, начало[, длина]) | Возвращает часть строкового выражения, начиная с указанной позиции (отсчет начинается с нуля) и до достижения указанной длины (или до конца строки). |
| INDEX_OF(строка, фрагмент) | Возвращает начальную позицию первого вхождения второго строкового выражения в первое указанное строковое выражение или –1, если строка не найдена.|
| STARTS_WITH(x, y) | Возвращает значение логического типа, указывающее, начинается ли первое строковое выражение вторым. |
| ENDS_WITH(x, y) | Возвращает значение логического типа, указывающее, заканчивается ли первое строковое выражение вторым. |
| CONTAINS(x,y) | Возвращает значение логического типа, указывающее, содержит ли первое строковое выражение второе. |

## <a name="next-steps"></a>Дополнительная информация
Узнайте, как выполнять запросы в своих приложениях с помощью [пакетов SDK для Azure IoT][lnk-hub-sdks].

[lnk-query-where]: iot-hub-devguide-query-language.md#where-clause
[lnk-query-expressions]: iot-hub-devguide-query-language.md#expressions-and-conditions
[lnk-query-getstarted]: iot-hub-devguide-query-language.md#get-started-with-device-twin-queries

[lnk-twins]: iot-hub-devguide-device-twins.md
[lnk-jobs]: iot-hub-devguide-jobs.md
[lnk-devguide-endpoints]: iot-hub-devguide-endpoints.md
[lnk-devguide-quotas]: iot-hub-devguide-quotas-throttling.md
[lnk-devguide-mqtt]: iot-hub-mqtt-support.md
[lnk-devguide-messaging-routes]: iot-hub-devguide-messages-read-custom.md
[lnk-devguide-messaging-format]: iot-hub-devguide-messages-construct.md
[lnk-devguide-messaging-routes]: ./iot-hub-devguide-messages-read-custom.md

[lnk-hub-sdks]: iot-hub-devguide-sdks.md
