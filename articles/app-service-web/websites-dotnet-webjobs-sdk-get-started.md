---
title: "Создание веб-задания .NET в службе приложений Azure | Документация Майкрософт"
description: "Создание многоуровневого приложения с помощью ASP.NET MVC и Azure. Внешний сервер запускается как веб-приложение в службе приложений Azure, а внутренний сервер — как веб-задание. Приложение использует Entity Framework, базу данных SQL, очереди службы хранилища Azure и большие двоичные объекты."
services: app-service
documentationcenter: .net
author: tdykstra
manager: erikre
editor: mollybos
ms.assetid: 99cb9917-483a-45f8-a98d-07d19c68c753
ms.service: app-service
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 6/14/2017
ms.author: glenga
ms.openlocfilehash: a20b13058caecff75af14957468f20e63a3325c9
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/29/2017
---
# <a name="create-a-net-webjob-in-azure-app-service"></a>Создание веб-задания .NET в службе приложений Azure
В этом руководстве показано, как написать код для простого многоуровневого приложения ASP.NET MVC 5, которое использует пакет [WebJobs SDK](websites-dotnet-webjobs-sdk.md).

[!INCLUDE [app-service-web-webjobs-corenote](../../includes/app-service-web-webjobs-corenote.md)]

Назначение [веб-заданий SDK](websites-webjobs-resources.md) — упрощение кода, с помощью которого веб-задание выполняет такие общие задачи, как обработка изображений, обработка очереди, объединение RSS, обслуживание файлов и отправка сообщений электронной почты. Пакет SDK для веб-заданий имеет встроенные функции для работы с хранилищем Azure и служебной шиной для планирования задач и обработки ошибок, а также других распространенных сценариев. Этот пакет расширяемый; также существует [репозиторий открытого кода для расширений](https://github.com/Azure/azure-webjobs-sdk-extensions/wiki/Binding-Extensions-Overview).

Пример приложения представляет собой рекламную доску объявлений. Пользователи могут загружать изображения для рекламы, а серверный процесс преобразует эти изображения в эскизы. На странице списка рекламных объявлений отображаются эскизы, а на странице подробных рекламных сведений — полноразмерное изображение. Ниже приведен снимок экрана:

![Список рекламы](./media/websites-dotnet-webjobs-sdk-get-started/list.png)

В этом примере приложение работает с [очередями Azure](http://www.asp.net/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern) и [большими двоичными объектами Azure](http://www.asp.net/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/unstructured-blob-storage). В руководстве показано, как развернуть приложение в [службе приложений Azure](http://go.microsoft.com/fwlink/?LinkId=529714) и [Базе данных SQL Azure](http://msdn.microsoft.com/library/azure/ee336279).

## <a id="prerequisites"></a>Предварительные требования
Предполагается, что у вас есть опыт работы с проектами [ASP.NET MVC 5](http://www.asp.net/mvc/tutorials/mvc-5/introduction/getting-started) в Visual Studio.

Это руководство изначально было написано для Visual Studio 2013, но его можно использовать с более поздними версиями Visual Studio. Если вы используете Visual Studio 2015 или 2017, то имейте в виду, что перед запуском приложения в локальной среде необходимо изменить часть `Data Source` строки подключения SQL Server LocalDB в файлах Web.config и App.config с `Data Source=(localdb)\v11.0` на `Data Source=(LocalDb)\MSSQLLocalDB`.

> [!NOTE]
> <a name="note"></a> Для работы с этим руководством требуется учетная запись Azure.
>
> * Вы можете [открыть учетную запись Azure бесплатно](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A261C142F) — вы получаете кредиты, которые можно использовать для опробования платных служб Azure, и даже после израсходования кредитов вы сохраняете учетную запись и возможность использовать бесплатные службы Azure, например веб-сайты. С вашей кредитной карты не будет взиматься плата, если вы явно не измените параметры и не попросите снимать плату.
> * Вы можете [активировать ежемесячные деньги на счете в Azure для подписчиков Visual Studio](https://azure.microsoft.com/pricing/member-offers/msdn-benefits-details/?WT.mc_id=A261C142F). Каждый месяц ваша подписка Visual Studio предоставляет вам кредиты, которые можно использовать для оплаты служб Azure.
>
> Если вы хотите приступить к работе со службой приложений Azure до создания учетной записи Azure, перейдите к разделу [Пробное использование службы приложений](https://azure.microsoft.com/try/app-service/), где вы можете быстро создать кратковременное веб-приложение начального уровня в службе приложений. Никаких кредитных карт и обязательств.
>
>

## <a id="learn"></a>Содержание обучения
В учебнике показано, как выполнять следующие задачи.

* Подготовьте компьютер к разработке Azure, установив пакет Azure SDK (только для пользователей Visual Studio 2013 и 2015).
* Создание проекта приложения консоли, который автоматически развертывается как веб-задание Azure при развертывании связанного веб-проекта.
* Локальное тестирование внутреннего сервера SDK веб-заданий на компьютере разработки.
* Публикация приложения с помощью внутреннего сервера веб-заданий в веб-приложение в службе приложений.
* Отправка файлов и сохранение их в службе больших двоичных объектов Azure.
* Использование пакета SDK веб-заданий Azure для работы с очередями и большими двоичными объектами хранилища Azure.

## <a id="contosoads"></a>Архитектура приложения
Пример приложения использует [рабочий шаблон на основе очередей](http://www.asp.net/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern) для разгрузки процессора от задач создания эскизов для обработки внутреннего сервера

Приложение хранит рекламу в базе данных SQL, используя Entity Framework Code First для создания таблиц и доступа к данным. Для каждого рекламного объявления база данных хранит два URL-адреса: один для полноразмерного изображения, другой для эскиза.

![Таблица рекламы](./media/websites-dotnet-webjobs-sdk-get-started/adtable.png)

Когда пользователь отправляет изображение, веб-приложение сохраняет его в [BLOB-объекте Azure](http://www.asp.net/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/unstructured-blob-storage), а рекламную информацию — в базе данных с URL-адресом, который указывает на этот BLOB-объект. В это же время оно записывает сообщение в очередь Azure. В ходе серверного процесса, выполняемого как веб-задание Azure, пакет WebJobs SDK опрашивает очередь на предмет новых сообщений. Когда появляется новое сообщение, веб-задание создает эскиз для изображения и обновляет поле базы данных с URL-адресом эскиза для этой рекламы. Вот диаграмма, которая показывает, как взаимодействуют части приложения:

![Архитектура Contoso Ads](./media/websites-dotnet-webjobs-sdk-get-started/apparchitecture.png)

[!INCLUDE [install-sdk](../../includes/install-sdk-2017-2015-2013.md)]  
Инструкции учебника применимы к пакету Azure SDK для .NET 2.7.1 или более поздней версии.

## <a id="storage"></a>Создание учетной записи хранения Azure
Учетная запись хранилища Azure обеспечивает ресурсы для хранения данных очередей и больших двоичных объектов в облаке. Она также используется пакетом SDK веб-заданий для хранения данных журналов для панели мониторинга.

В реальном приложении обычно создают отдельные учетные записи для данных приложения и данных журналов, а также отдельные учетные записи для тестовых данных и рабочих данных. В этом руководстве будет использоваться одна учетная запись.

1. Откройте окно **Обозреватель серверов** в Visual Studio.
2. Щелкните правой кнопкой мыши узел **Azure** и выберите **Подключиться к подписке Microsoft Azure...**.
   
   ![Подключение к Azure](./media/websites-dotnet-webjobs-sdk-get-started/connaz.png)

3. Выполните вход с использованием учетных данных Azure.
4. Щелкните правой кнопкой мыши **Хранилище** в узле Azure и выберите пункт **Создать учетную запись хранения**.
   
   ![Учетная запись хранения](./media/websites-dotnet-webjobs-sdk-get-started/createstor.png)
   
5. В диалоговом окне **Создание учетной записи хранения** введите имя для учетной записи хранения.

    Имя должно быть уникальным (не допускается существование учетных записей хранения Azure с одинаковыми именами). Если введенное имя уже используется, вы получите возможность изменить его.

    URL-адрес для доступа к вашей учетной записи хранения будет выглядеть следующим образом: *{имя}*.core.windows.net.
6. В раскрывающемся списке **Регион или территориальная группа** укажите ближайший к вам регион.

    Этот параметр указывает, в каком центре обработки данных Azure будет размещаться учетная запись хранения. Теоретически этот выбор не имеет большого значения. Но для рабочего веб-приложения веб-сервер и учетная запись хранения должны находиться в одном регионе, чтобы свести к минимуму задержку и стоимость исходящих данных. Веб-приложение (которое будет создано позже) должно находиться как можно ближе к браузерам, получившим доступ к нему, чтобы свести к минимуму задержку.
7. В раскрывающемся списке **Репликация** установите значение **Локально избыточное**.

    При включении георепликации для учетной записи хранения хранящиеся данные реплицируются в дополнительный центр обработки данных для обеспечения возможности отработки отказа в это расположение в случае крупной аварии в основном расположении. Георепликация может потребовать дополнительных затрат. Для учетных записей тестирования и разработки оплачивать георепликацию обычно не требуется. Дополнительные сведения см. в статье [Об учетных записях хранения Azure](../storage/common/storage-create-storage-account.md).
8. Щелкните **Создать**.

    ![Новая учетная запись хранения](./media/websites-dotnet-webjobs-sdk-get-started/newstorage.png)

## <a id="download"></a>Загрузка приложения
1. Загрузите и распакуйте [готовое решение](http://code.msdn.microsoft.com/Simple-Azure-Website-with-b4391eeb).
2. Запустите Visual Studio.
3. В меню **Файл** выберите **Открыть > Решение или проект**, перейдите к скачанному решению и откройте файл решения.
4. Чтобы построить решение, нажмите CTRL+SHIFT+B.

    По умолчанию Visual Studio автоматически восстанавливает содержимое пакета NuGet, которое не включено в *ZIP*-файл. Если пакеты не восстановлены, установите их вручную, перейдя к диалоговому окну **Управление пакетами для NuGet решения** и нажав кнопку **Восстановить** вверху справа.
5. В **обозревателе решений** выберите **ContosoAdsWeb** в качестве запускаемого проекта.

## <a id="configurestorage"></a>Настройка приложения для использования учетной записи хранения
1. Откройте файл приложения *Web.config* в проекте ContosoAdsWeb.

    Файл содержит строку подключения SQL и строку подключения хранилища Azure для работы с большими двоичными объектами и очередями.

    Строка подключения SQL указывает на базу данных [SQL Server Express LocalDB](http://msdn.microsoft.com/library/hh510202.aspx) .

    В примере строки подключения к хранилищу использованы заполнители для имени учетной записи хранения и ключа доступа. Замените это строкой подключения, которая содержит имя и ключ для вашей учетной записи хранения.  

    ```
    <connectionStrings>
        <add name="ContosoAdsContext" connectionString="Data Source=(localdb)\v11.0; Initial Catalog=ContosoAds; Integrated Security=True; MultipleActiveResultSets=True;" providerName="System.Data.SqlClient" />
        <add name="AzureWebJobsStorage" connectionString="DefaultEndpointsProtocol=https;AccountName=[accountname];AccountKey=[accesskey]"/>
    </connectionStrings>
    ```
    Строка подключения хранилища называется AzureWebJobsStorage, поскольку пакет SDK веб-заданий использует это имя по умолчанию. Здесь используется то же имя, поэтому вам нужно задать только одно значение строки подключения в среде Azure.
2. В **обозревателе сервера** щелкните правой кнопкой мыши учетную запись хранения в узле **Хранилище** и выберите **Свойства**.

    ![Щелкните свойства учетной записи хранения](./media/websites-dotnet-webjobs-sdk-get-started/storppty.png)
3. В окне **Свойства** щелкните **Ключи учетной записи хранилища** и нажмите кнопку с многоточием.

    ![Ключи учетной записи хранения](./media/websites-dotnet-webjobs-sdk-get-started/stor-account-keys.png)
4. Скопируйте **строку подключения**.

    ![Диалоговое окно "Ключи учетной записи хранения"](./media/websites-dotnet-webjobs-sdk-get-started/cpak.png)
5. Замените строку подключения к хранилищу в файле *Web.config* на скопированную строку подключения. Перед вставкой убедитесь, что выбраны все элементы внутри кавычек, но не сами кавычки.
6. Откройте файл *App.config* в проекте ContosoAdsWebJob.

    Этот файл содержит две строки подключения хранилища: одну для данных приложения, а другую для ведения журнала. Можно использовать отдельные учетные записи хранения для данных приложений и ведения журнала; также можно использовать [несколько учетных записей хранения для данных](https://github.com/Azure/azure-webjobs-sdk/blob/master/test/Microsoft.Azure.WebJobs.Host.EndToEndTests/MultipleStorageAccountsEndToEndTests.cs). В этом руководстве будет использоваться одна учетная запись. Строки подключения имеют заполнители для ключей учетной записи хранения.

    ```
    <configuration>
        <connectionStrings>
            <add name="AzureWebJobsDashboard" connectionString="DefaultEndpointsProtocol=https;AccountName=[accountname];AccountKey=[accesskey]"/>
            <add name="AzureWebJobsStorage" connectionString="DefaultEndpointsProtocol=https;AccountName=[accountname];AccountKey=[accesskey]"/>
            <add name="ContosoAdsContext" connectionString="Data Source=(localdb)\v11.0; Initial Catalog=ContosoAds; Integrated Security=True; MultipleActiveResultSets=True;"/>
    </connectionStrings>
        <startup>
            <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />
    </startup>
    </configuration>

    ```

    По умолчанию пакет SDK веб-заданий ищет строки подключения с именами AzureWebJobsStorage и AzureWebJobsDashboard. В качестве альтернативы можно [сохранить строку подключения любым способом и передать ее явно в `JobHost`объект](websites-dotnet-webjobs-sdk-storage-queues-how-to.md#config).
7. Замените обе строки подключения к хранилищу скопированной ранее строкой подключения.
8. Сохраните изменения.

## <a id="run"></a>Локальный запуск приложения
1. Чтобы запустить внешний сервер приложения, нажмите клавиши CTRL+F5.

    Откроется домашняя страница браузера по умолчанию. (Запускается веб-проект, поскольку он стал запускаемым проектом.)

    ![Домашняя страница Contoso Ads](./media/websites-dotnet-webjobs-sdk-get-started/home.png)
2. Чтобы запустить внутренний сервер веб-задания приложения, щелкните правой кнопкой мыши проект ContosoAdsWebJob в **обозревателе решений** и нажмите **Отладка** > **Запустить новый экземпляр**.

    Окно консоли приложения открывает и отображает сообщение для ведения журнала, указывающее начало выполнения объекта JobHost из веб-заданий SDK.

    ![Окно приложения консоли, отображающее, что внутренний сервер запущен](./media/websites-dotnet-webjobs-sdk-get-started/backendrunning.png)
3. В браузере нажмите кнопку **Create an Ad** (Создать рекламу).
4. Введите тестовые данные, выберите изображение для отправки и щелкните **Создать**.

    ![Страница создания](./media/websites-dotnet-webjobs-sdk-get-started/create.png)

    Приложение переходит к странице индексации, но не показывает эскиз для новой рекламы, поскольку индексирование еще не проводилось.

    В то же время после короткого ожидания в окне приложения консоли отобразится сообщение журнала, что сообщение очереди было получено и обработано.

    ![Окно приложения консоли, отображающее, что сообщение очереди обработано](./media/websites-dotnet-webjobs-sdk-get-started/backendlogs.png)
5. После того, как вы увидите сообщения журнала в окне приложения консоли, обновите страницу индексов, чтобы увидеть эскиз.

    ![Страница индексации](./media/websites-dotnet-webjobs-sdk-get-started/list.png)
6. Щелкните **Details** , чтобы увидеть рекламу в полный размер.

    ![Страница сведений](./media/websites-dotnet-webjobs-sdk-get-started/details.png)

Вы запустили приложение на локальном компьютере, и оно использует базу данных SQL Server, расположенную на компьютере, но она работает с очередями и большими двоичными объектами в облаке. В следующем разделе вы запустите приложение в облаке с помощью облачной базы данных, а также облачных больших двоичных объектов и очередей.  

## <a id="runincloud"></a>Запуск приложения в облаке
Чтобы запустить приложение в облаке, выполните следующие действия:

* Развертывание веб-приложений. Visual Studio автоматически создаст новое веб-приложение в службе приложений и экземпляр базы данных SQL.
* Настройка веб-приложения для использования базы данных SQL Azure и учетной записи хранения.

После создания рекламы во время работы в облаке вы просмотрите панель мониторинга SDK веб-заданий, чтобы увидеть предлагаемые обширные функции мониторинга.

### <a name="deploy-to-web-apps"></a>Развертывание веб-приложений

1. Закройте браузер и окно приложения консоли.
2. Следуйте указаниям, описанным в разделе [Публикация в Azure с базой данных SQL](https://docs.microsoft.com/azure/app-service-web/app-service-web-tutorial-dotnet-sqldatabase#publish-to-azure-with-sql-database).
3. После выполнения действий по развертыванию продолжите выполнять оставшиеся задачи из этой статьи.

### <a name="configure-the-web-app-to-use-your-azure-sql-database-and-storage-account"></a>Настройка веб-приложения для использования базы данных SQL Azure и учетной записи хранения
В целях безопасности рекомендуется [не указывать конфиденциальную информацию, такую как строки подключения, в файлах, которые хранятся в репозиториях исходного кода](http://www.asp.net/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/source-control#secrets). Это можно сделать с помощью Azure: вы можете задать строку подключения и другие значения параметров в среде Azure, и API конфигурации ASP.NET автоматически выберут эти значения при запуске приложения в Azure. Вы можете задать эти значения в Azure с помощью **обозревателя сервера**, портала Azure, Windows PowerShell или кроссплатформенного интерфейса командной строки. Дополнительные сведения см. в статье [Windows Azure Web Sites: How Application Strings and Connection Strings Work](https://azure.microsoft.com/blog/2013/07/17/windows-azure-web-sites-how-application-strings-and-connection-strings-work/) (Веб-сайты Microsoft Azure: как работают строки приложений и строки подключения).

В этом разделе вы сможете задать значения строк подключения в Azure с помощью **обозревателя серверов**.

1. В **обозревателе сервера** щелкните правой кнопкой мыши свое веб-приложение в узле **Azure > Служба приложений > {ваша группа ресурсов}**, а затем щелкните **Просмотреть параметры**.

    Окно **Веб-приложение Azure** откроется на вкладке **Конфигурация**.
2. Измените имя строки подключения DefaultConnection на имя, выбранное при настройке базы данных SQL во время работы с разделом [Публикация в Azure с базой данных SQL](https://docs.microsoft.com/azure/app-service-web/app-service-web-tutorial-dotnet-sqldatabase#publish-to-azure-with-sql-database).

    Служба Azure автоматически создала эту строку подключения, когда вы создали веб-приложение со связанной базой данных, поэтому она автоматически содержит правильное значение строки подключения. Нужно только изменить имя на искомый код.
3. Добавьте две новые строки подключения с именами AzureWebJobsStorage и AzureWebJobsDashboard. Задайте **настраиваемый** тип базы данных, а затем задайте для строки подключения то же значение, которое использовалось ранее для файлов *Web.config* и *App.config*. (Убедитесь, что включили всю строку подключения без кавычек, а не только ключ доступа.)

    Эти строки подключения используются пакетом SDK веб-заданий: одна для данных приложения, а другая для ведения журнала. Как было показано ранее, строка подключения для данных приложения также используется кодом внешнего сервера.
4. Щелкните **Сохранить**.

    ![Строки подключения на портале Azure](./media/websites-dotnet-webjobs-sdk-get-started/azconnstr.png)
5. В **обозревателе сервера** щелкните правой кнопкой мыши веб-приложение, а затем нажмите кнопку **Остановить**.
6. Остановив веб-приложение, снова щелкните его правой кнопкой мыши и выберите **Запустить**.

   Веб-задание запустится автоматически при публикации, но остановится при внесении изменений в конфигурацию. Его можно запустить повторно, перезапустив веб-приложение или веб-задание на [портале Azure](http://go.microsoft.com/fwlink/?LinkId=529715). Обычно рекомендуется перезапускать веб-приложение после изменения конфигурации.
7. Обновите окно браузера, которое содержит URL-адрес веб-приложения в адресной строке.

    Появится домашняя страница.
8. Создайте рекламу, как вы делали это при [локальном запуске приложения](https://docs.microsoft.com/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started#a-idrunarun-the-application-locally).

   Сначала появится страница индексов без эскизов.
9. Через несколько секунд обновите страницу, чтобы появился эскиз.

   Если эскиз не отображается, подождите какое-то время (около минуты), пока веб-задание запустится повторно. Если через некоторое время эскиз по-прежнему не отображается при обновлении страницы, возможно, веб-задание не запускается автоматически. В этом случае перейдите в колонку **Службы приложений** на [портале Azure](https://portal.azure.com/), найдите веб-приложение, а затем щелкните **Запустить**.

### <a name="view-the-webjobs-sdk-dashboard"></a>Просмотр панели мониторинга SDK веб-заданий
1. На [портале Azure](https://portal.azure.com/) выберите колонку **Службы приложений**, найдите веб-приложение и выберите **Веб-задания**.
3. Откройте вкладку **Журналы**.

    ![Вкладка "Журналы"](./media/websites-dotnet-webjobs-sdk-get-started/log-tab.png)

    На панели мониторинга SDK веб-заданий откроется новая вкладка браузера. На панели мониторинга отобразится, что веб-задание запущено, и появится список функций в коде, активированных пакетом SDK веб-заданий.
4. Щелкните одну из функций, чтобы получить сведения о ее выполнении.

    ![Панель мониторинга пакета SDK веб-заданий](./media/websites-dotnet-webjobs-sdk-get-started/wjdashboardhome.png)

    ![Панель мониторинга пакета SDK веб-заданий](./media/websites-dotnet-webjobs-sdk-get-started/wjfunctiondetails.png)

    Кнопка **Повторить функцию** на этой странице позволяет платформе SDK веб-заданий повторно вызывать функцию и дает возможность изменить данные, изначально переданные в функцию.

> [!NOTE]
> После окончания тестирования вы можете удалить веб-приложения, учетную запись хранения и экземпляр базы данных SQL. Веб-приложение бесплатно, но за экземпляр базы данных и учетную запись хранения SQL взимается плата (хотя и минимальная из-за небольшого размера). Также, если оставить веб-приложение работающим, любой, кто найдет этот URL-адрес, сможет создать и просмотреть рекламу. 
>
>

### <a name="delete-your-web-app"></a>Удаление веб-приложения
На портале перейдите в колонку **Службы приложений**, найдите и выберите свое веб-приложение, а затем щелкните **Удалить**. Если необходимо временно предотвратить доступ посторонних к веб-приложению, щелкните **Остановить**. В этом случае плата за базы данных SQL и учетную запись хранения продолжит взиматься.

### <a name="delete-your-storage-account"></a>Удаление учетной записи хранения
Дополнительные сведения об удалении учетной записи хранения см. в [этом разделе](https://docs.microsoft.com/azure/storage/storage-create-storage-account#delete-a-storage-account). 

### <a name="delete-your-database"></a>Удаление базы данных
Дополнительные сведения об удалении базы данных SQL см. в статье [Azure SQL Database REST API](https://docs.microsoft.com/rest/api/sql/) (REST API базы данных SQL Azure).

## <a id="create"></a>Создание приложения с самого начала
В этом разделе предстоит выполнить следующие задачи:

* Создание решения Visual Studio с веб-проектом.
* Добавление проекта библиотеки класса для уровня доступа данных, который совместно используется внешним и внутренним сервером.
* Добавление проекта приложения консоли для внутреннего сервера с включенным развертыванием веб-заданий.
* Добавление пакетов NuGet.
* Указание ссылок на проекты.
* Копирование кода приложения и файлов конфигурации из скачанного приложения, с которым вы работали в предыдущем разделе учебника.
* Просмотр фрагментов кода, которые работают с большими двоичными объектами и очередями Azure и пакетом SDK веб-заданий.

### <a name="create-a-visual-studio-solution-with-a-web-project-and-class-library-project"></a>Создание решения Visual Studio с веб-проектом и проектом библиотеки класса
1. В Visual Studio выберите **Файл** > **Создать** > **Проект**.
2. В диалоговом окне **Создать проект** выберите **Visual C#** > **Веб** > **Веб-приложение ASP.NET (.NET Framework)**.
3. Назовите проект "ContosoAdsWeb", назовите решение "ContosoAdsWebJobsSDK" (измените имя решения, если планируете поместить его в ту же папку, что и скачанное решение), а затем нажмите кнопку **ОК**.

    ![Новый проект](./media/websites-dotnet-webjobs-sdk-get-started/newproject.png)
4. В диалоговом окне **Создать веб-приложение ASP.NET** выберите шаблон MVC, а затем выберите **Изменить аутентификацию**.

    ![Изменить проверку подлинности](./media/websites-dotnet-webjobs-sdk-get-started/chgauth.png)
5. В диалоговом окне **Изменить способ проверки подлинности** щелкните **Без проверки подлинности** и нажмите кнопку **ОК**.

    ![Без аутентификации](./media/websites-dotnet-webjobs-sdk-get-started/noauth.png)
6. В диалоговом окне **Создать веб-приложение ASP.NET** нажмите кнопку **ОК**.

    Visual Studio создаст решение и веб-проект.
7. В **обозревателе решений** щелкните правой кнопкой мыши решение (а не проект) и выберите **Добавить** > **Новый проект**.
8. В диалоговом окне **Добавление нового проекта** выберите шаблон **Visual C#** > **Классический рабочий стол Windows** > **Библиотека классов (.NET Framework)**.  
9. Присвойте проекту имя *ContosoAdsCommon*и нажмите кнопку **ОК**.

    Этот проект будет содержать контекст и модель данных Entity Framework, которые будут использовать внешний и внутренний сервер. Как вариант, можно определить связанные с EF классы в веб-проекте и сослаться на этот проект из проекта веб-задания. Но тогда проект веб-задания будет содержать ссылку на веб-сборки, которые ему не нужны.

### <a name="add-a-console-application-project-that-has-webjobs-deployment-enabled"></a>Добавление проекта приложения консоли, в котором включено развертывание веб-заданий
1. Щелкните правой кнопкой мыши проект (а не решение или проект библиотеки классов) и нажмите кнопку **Добавить** > **Новый проект веб-задания Azure**.

    ![Пункт меню "Новый проект веб-задания Azure"](./media/websites-dotnet-webjobs-sdk-get-started/newawjp.png)
2. В диалоговом окне **Добавить веб-задание Azure** введите ContosoAdsWebJob в поля **Имя проекта** и **Имя веб-задания**. Оставьте в поле **Режим выполнения веб-задания** значение **Выполнять непрерывно**.
3. Нажмите кнопку **ОК**.

   Visual Studio создает приложение консоли, которое настроено для развертывания в качестве веб-задания при каждом развертывании веб-проекта. Для этого после создания проекта выполняются следующие задачи.

   * Добавляется файл *webjob-publish-settings.json* в папку "Свойства" проекта веб-задания.
   * Добавляется файл *webjobs-list.json* в папку "Свойства" веб-проекта.
   * Устанавливается пакет NuGet Microsoft.Web.WebJobs.Publish в проект веб-задания.

   Дополнительные сведения об этих изменениях см. в статье [Развертывание веб-заданий с помощью Visual Studio](websites-dotnet-deploy-webjobs.md).

### <a name="add-nuget-packages"></a>Добавление пакетов NuGet
Шаблон нового проекта для проекта веб-задания автоматически устанавливает пакет веб-заданий SDK NuGet [Microsoft.Azure.WebJobs](http://www.nuget.org/packages/Microsoft.Azure.WebJobs) и зависимости.

Одна из зависимостей пакета SDK веб-заданий, которая автоматически устанавливается в проекте веб-задания, это клиентская библиотека хранилища Azure (SCL). Однако, чтобы она работала с BLOB-объектами и очередями, вам необходимо добавить ее в веб-проект.

1. Откройте диалоговое окно **Управление пакетами NuGet** для решения.
2. В левой области выберите **Установленные пакеты**.
3. Найдите пакет *Хранилище Azure* и щелкните кнопку **Управление**.
4. В поле **Выбор проектов** установите флажок **ContosoAdsWeb** и нажмите кнопку **ОК**.

    Все три проекта используют Entity Framework для работы с данными в базе данных SQL.
5. В левой области щелкните **В сети**.
6. Найдите пакет NuGet *EntityFramework* и установите его во все проекты.

### <a name="set-project-references"></a>Установите ссылки проекта
Веб-проекты и проекты веб-заданий работают с базой данных SQL, поэтому и для тех, и для других необходима ссылка на проект ContosoAdsCommon.

1. Задайте в проекте ContosoAdsWeb ссылку на проект ContosoAdsCommon. (Щелкните правой кнопкой мыши проект ContosoAdsWeb и нажмите кнопку **Добавить** > **Ссылка**. 
2. В диалоговом окне **Диспетчер ссылок** выберите **Проекты** > **Решение** > **ContosoAdsCommon**, а затем нажмите кнопку **OK**.)
   
    Для проекта веб-задания нужны ссылки для работы с изображениями и для доступа к строкам подключения.

4. Задайте в проекте ContosoAdsWebJob ссылку на `System.Drawing` и `System.Configuration`.

### <a name="add-code-and-configuration-files"></a>Добавление кода и файлов конфигурации
В этом руководстве не описывается, как [создать контроллеры и представления MVC с помощью формирования шаблонов](http://www.asp.net/mvc/tutorials/mvc-5/introduction/getting-started), [записывать код Entity Framework, который работает с базами данных SQL Server](http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc), или [основы асинхронного программирования в ASP.NET 4.5](http://www.asp.net/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/web-development-best-practices#async). Поэтому все, что нужно сделать, — скопировать код и файлы конфигурации из скачанного решения в новое. После этого в следующих разделах будут показаны и объяснены основные фрагменты кода.

Чтобы добавить файлы в проект или папку, щелкните правой кнопкой мыши проект или папку и нажмите **Добавить** > **Существующий элемент**. Выберите необходимые файлы и щелкните **Добавить**. При запросе о том, заменять ли существующие файлы, щелкните **Да**.

1. В проекте ContosoAdsCommon удалите файл *Class1.cs* и добавьте на его место следующие файлы из скачанного проекта.

   * *Ad.cs*
   * *ContosoAdscontext.cs*
   * *BlobInformation.cs*
2. В проекте ContosoAdsCommon добавьте следующие файлы из загруженного проекта.

   * *Web.config*
   * *Global.asax.cs*  
   * в папку *Controllers*: *AdController.cs*;
   * в папку *Views\Shared*: файл *_Layout.cshtml*;
   * в папку *Views\Home*: файл *Index.cshtml*;
   * в папку *Views\Ad* (сначала создайте эту папку): пять файлов *CSHTML*.
3. В проекте ContosoAdsWebJob добавьте следующие файлы из скачанного проекта.

   * *App.config* (измените фильтр типов файлов на **Все файлы**)
   * *Program.cs*
   * *Functions.cs*

Теперь вы можете создать, запустить и развернуть приложение, как показано ранее в этом учебнике. Однако перед этим остановите веб-задание, которое все еще выполняется в первом веб-приложении, на котором произведено развертывание. В противном случае такое веб-задание обработает сообщения очереди, созданные локально или запущенные приложением в новом веб-приложении, так как все они используют одну учетную запись хранения.

## <a id="code"></a>Просмотр кода приложения
В следующих разделах объясняется код, связанный с работой с пакетом SDK веб-заданий и большими двоичными объектами и очередями Azure.

> [!NOTE]
> Код, связанный с пакетом SDK для веб-заданий, см. в разделах о [Program.cs и Functions.cs](#programcs).
>
>

### <a name="contosoadscommon---adcs"></a>ContosoAdsCommon - Ad.cs
Файл Ad.cs определяет перечисляемый тип для класса Ad и класс сущностей POCO для информации в рекламе.

        public enum Category
        {
            Cars,
            [Display(Name="Real Estate")]
            RealEstate,
            [Display(Name = "Free Stuff")]
            FreeStuff
        }

        public class Ad
        {
            public int AdId { get; set; }

            [StringLength(100)]
            public string Title { get; set; }

            public int Price { get; set; }

            [StringLength(1000)]
            [DataType(DataType.MultilineText)]
            public string Description { get; set; }

            [StringLength(1000)]
            [DisplayName("Full-size Image")]
            public string ImageURL { get; set; }

            [StringLength(1000)]
            [DisplayName("Thumbnail")]
            public string ThumbnailURL { get; set; }

            [DataType(DataType.Date)]
            [DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]
            public DateTime PostedDate { get; set; }

            public Category? Category { get; set; }
            [StringLength(12)]
            public string Phone { get; set; }
        }

### <a name="contosoadscommon---contosoadscontextcs"></a>ContosoAdsCommon - ContosoAdsContext.cs
Класс ContosoAdsContext указывает, что класс Ad используется коллекцией DbSet, которую Entity Framework хранит в базе данных SQL.

        public class ContosoAdsContext : DbContext
        {
            public ContosoAdsContext() : base("name=ContosoAdsContext")
            {
            }
            public ContosoAdsContext(string connString)
                : base(connString)
            {
            }
            public System.Data.Entity.DbSet<Ad> Ads { get; set; }
        }

Класс имеет два конструктора. Первый из них используется веб-проектом и указывает имя строки подключения, которая хранится в файле Web.config или в среде выполнения Azure. Второй конструктор дает возможность передачи действующей строки подключения. Это необходимо проекту веб-задания, поскольку он не имеет файла Web.config. Ранее было показано, где хранится строка подключения, а потом будет показано, как код извлекает строку подключения, когда он создает экземпляр класса DbContext.

### <a name="contosoadscommon---blobinformationcs"></a>ContosoAdsCommon — BlobInformation.cs
Класс `BlobInformation` используется для хранения информации о BLOB-объекте изображения в сообщении очереди.

        public class BlobInformation
        {
            public Uri BlobUri { get; set; }

            public string BlobName
            {
                get
                {
                    return BlobUri.Segments[BlobUri.Segments.Length - 1];
                }
            }
            public string BlobNameWithoutExtension
            {
                get
                {
                    return Path.GetFileNameWithoutExtension(BlobName);
                }
            }
            public int AdId { get; set; }
        }


### <a name="contosoadsweb---globalasaxcs"></a>ContosoAdsWeb - Global.asax.cs
Код, который вызывается из метода `Application_Start`, создает контейнер больших двоичных объектов *images* и очередь *images*, если они отсутствуют. Это гарантирует, что при каждом использовании новой учетной записи хранения необходимый контейнер больших двоичных объектов и очередь будут создаваться автоматически.

Код получает доступ к учетной записи хранения, используя строку подключения из файла *Web.config* или среду выполнения Azure.

        var storageAccount = CloudStorageAccount.Parse
            (ConfigurationManager.ConnectionStrings["AzureWebJobsStorage"].ToString());

Затем он получает ссылку на контейнер больших двоичных объектов *изображений*, создает контейнер, если он еще не существует, и устанавливает разрешения доступа к новому контейнеру. По умолчанию новые контейнеры разрешают доступ к большим двоичным объектам только клиентам с учетными данными записи хранения. Веб-приложению требуются общедоступные большие двоичные объекты, чтобы оно могло выводить изображения с использованием URL-адресов, которые указывают на объекты изображений.

        var blobClient = storageAccount.CreateCloudBlobClient();
        var imagesBlobContainer = blobClient.GetContainerReference("images");
        if (imagesBlobContainer.CreateIfNotExists())
        {
            imagesBlobContainer.SetPermissions(
                new BlobContainerPermissions
                {
                    PublicAccess = BlobContainerPublicAccessType.Blob
                });
        }

Похожий код получает ссылку на очередь *thumbnailrequest* и создает новую очередь. В этом случае изменений разрешений не требуется.

        CloudQueueClient queueClient = storageAccount.CreateCloudQueueClient();
        var imagesQueue = queueClient.GetQueueReference("thumbnailrequest");
        imagesQueue.CreateIfNotExists();

### <a name="contosoadsweb---layoutcshtml"></a>ContosoAdsWeb — _Layout.cshtml
Файл *_Layout.cshtml* задает имя приложения в заголовке и нижнем колонтитуле и создает запись меню "Ads".

### <a name="contosoadsweb---viewshomeindexcshtml"></a>ContosoAdsWeb - Views\Home\Index.cshtml
Файл *Views\Home\Index.cshtml* выводит ссылки категорий на домашней странице. Ссылки передают целочисленное значение перечисляемого типа `Category` в переменную querystring на странице индекса Ads.

        <li>@Html.ActionLink("Cars", "Index", "Ad", new { category = (int)Category.Cars }, null)</li>
        <li>@Html.ActionLink("Real estate", "Index", "Ad", new { category = (int)Category.RealEstate }, null)</li>
        <li>@Html.ActionLink("Free stuff", "Index", "Ad", new { category = (int)Category.FreeStuff }, null)</li>
        <li>@Html.ActionLink("All", "Index", "Ad", null, null)</li>

### <a name="contosoadsweb---adcontrollercs"></a>ContosoAdsWeb - AdController.cs
В файле *AdController.cs* конструктор вызывает метод `InitializeStorage` для создания объектов клиентской библиотеки службы хранилища Azure, которые предоставляют API-интерфейс для работы с большими двоичными объектами и очередями.

Затем код получает ссылку на контейнер больших двоичных объектов *изображений*, как показано ранее в *Global.asax.cs*. При этом он устанавливает [политику повторения](http://www.asp.net/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/transient-fault-handling) по умолчанию, подходящую для веб-приложения. Политика повторения с экспоненциальной задержкой по умолчанию может застопорить веб-приложение более чем на минуту при повторяющихся повторах во время кратковременного сбоя. Политика повторения здесь указывает ожидание в три секунды после каждой попытки, всего до трех повторений.

        var blobClient = storageAccount.CreateCloudBlobClient();
        blobClient.DefaultRequestOptions.RetryPolicy = new LinearRetry(TimeSpan.FromSeconds(3), 3);
        imagesBlobContainer = blobClient.GetContainerReference("images");

Аналогичный код получает ссылку на очередь *images* .

        CloudQueueClient queueClient = storageAccount.CreateCloudQueueClient();
        queueClient.DefaultRequestOptions.RetryPolicy = new LinearRetry(TimeSpan.FromSeconds(3), 3);
        imagesQueue = queueClient.GetQueueReference("blobnamerequest");

Большая часть кода контроллера обычна для работы с моделью данных Entity Framework с использованием класса DbContext. Исключением является метод `Create` HttpPost, который отправляет файл и сохраняет его в хранилище больших двоичных объектов. Связыватель модели предоставляет объект [HttpPostedFileBase](http://msdn.microsoft.com/library/system.web.httppostedfilebase.aspx) для метода.

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<ActionResult> Create(
            [Bind(Include = "Title,Price,Description,Category,Phone")] Ad ad,
            HttpPostedFileBase imageFile)

При выбора файла для отправки код отправляет его, сохраняет его в большом двоичном объекте и обновляет запись базы данных URL-адресом, который указывает на большой двоичный объект.

        if (imageFile != null && imageFile.ContentLength != 0)
        {
            blob = await UploadAndSaveBlobAsync(imageFile);
            ad.ImageURL = blob.Uri.ToString();
        }

Код отправки содержится в методе `UploadAndSaveBlobAsync` . Он создает имя GUID для большого двоичного объекта, отправляет и сохраняет файл, а также возвращает ссылку на сохраненный большой двоичный объект.

        private async Task<CloudBlockBlob> UploadAndSaveBlobAsync(HttpPostedFileBase imageFile)
        {
            string blobName = Guid.NewGuid().ToString() + Path.GetExtension(imageFile.FileName);
            CloudBlockBlob imageBlob = imagesBlobContainer.GetBlockBlobReference(blobName);
            using (var fileStream = imageFile.InputStream)
            {
                await imageBlob.UploadFromStreamAsync(fileStream);
            }
            return imageBlob;
        }

После того как метод `Create` HttpPost отправит большой двоичный объект и обновит базу данных, он создаст сообщение в очереди для информирования фонового процесса о том, что изображение готово для конвертации в эскиз.

        BlobInformation blobInfo = new BlobInformation() { AdId = ad.AdId, BlobUri = new Uri(ad.ImageURL) };
        var queueMessage = new CloudQueueMessage(JsonConvert.SerializeObject(blobInfo));
        await thumbnailRequestQueue.AddMessageAsync(queueMessage);

Код для метода `Edit` HttpPost аналогичен, за одним исключением — если пользователь выбирает новый файл изображения, все большие двоичные объекты, которые уже существуют для этой рекламы, должны быть удалены.

        if (imageFile != null && imageFile.ContentLength != 0)
        {
            await DeleteAdBlobsAsync(ad);
            imageBlob = await UploadAndSaveBlobAsync(imageFile);
            ad.ImageURL = imageBlob.Uri.ToString();
        }

Вот код, который удаляет большие двоичные объекты при удалении элемента рекламы:

        private async Task DeleteAdBlobsAsync(Ad ad)
        {
            if (!string.IsNullOrWhiteSpace(ad.ImageURL))
            {
                Uri blobUri = new Uri(ad.ImageURL);
                await DeleteAdBlobAsync(blobUri);
            }
            if (!string.IsNullOrWhiteSpace(ad.ThumbnailURL))
            {
                Uri blobUri = new Uri(ad.ThumbnailURL);
                await DeleteAdBlobAsync(blobUri);
            }
        }
        private static async Task DeleteAdBlobAsync(Uri blobUri)
        {
            string blobName = blobUri.Segments[blobUri.Segments.Length - 1];
            CloudBlockBlob blobToDelete = imagesBlobContainer.GetBlockBlobReference(blobName);
            await blobToDelete.DeleteAsync();
        }

### <a name="contosoadsweb---viewsadindexcshtml-and-detailscshtml"></a>ContosoAdsWeb - Views\Ad\Index.cshtml и Details.cshtml
Файл *Index.cshtml* выводит эскиз с другими данными рекламы:

        <img  src="@Html.Raw(item.ThumbnailURL)" />

Файл *Details.cshtml* выводит изображение в полном размере:

        <img src="@Html.Raw(Model.ImageURL)" />

### <a name="contosoadsweb---viewsadcreatecshtml-and-editcshtml"></a>ContosoAdsWeb - Views\Ad\Create.cshtml и Edit.cshtml
Файлы *Create.cshtml* и *Edit.cshtml* указывают кодирование формы, которое дает возможность контроллеру получить объект `HttpPostedFileBase`.

        @using (Html.BeginForm("Create", "Ad", FormMethod.Post, new { enctype = "multipart/form-data" }))

Элемент `<input>` сообщает браузеру, что нужно открыть диалоговое окно выбора файла.

        <input type="file" name="imageFile" accept="image/*" class="form-control fileupload" />

### <a id="programcs"></a>ContosoAdsWebJob - Program.cs
При запуске веб-задания метод `Main` вызывает метод пакета `JobHost.RunAndBlock` SDK веб-заданий, чтобы начать выполнение инициированных функций в текущем потоке.

        static void Main(string[] args)
        {
            JobHost host = new JobHost();
            host.RunAndBlock();
        }

### <a id="generatethumbnail"></a>ContosoAdsWebJob - Functions.cs - GenerateThumbnail
Пакет SDK веб-заданий вызывает этот метод при получении сообщения очереди. Метод создает эскиз и помещает URL-адрес эскиза в базу данных.

        public static void GenerateThumbnail(
        [QueueTrigger("thumbnailrequest")] BlobInformation blobInfo,
        [Blob("images/{BlobName}", FileAccess.Read)] Stream input,
        [Blob("images/{BlobNameWithoutExtension}_thumbnail.jpg")] CloudBlockBlob outputBlob)
        {
            using (Stream output = outputBlob.OpenWrite())
            {
                ConvertImageToThumbnailJPG(input, output);
                outputBlob.Properties.ContentType = "image/jpeg";
            }

            // Entity Framework context class is not thread-safe, so it must
            // be instantiated and disposed within the function.
            using (ContosoAdsContext db = new ContosoAdsContext())
            {
                var id = blobInfo.AdId;
                Ad ad = db.Ads.Find(id);
                if (ad == null)
                {
                    throw new Exception(String.Format("AdId {0} not found, can't create thumbnail", id.ToString()));
                }
                ad.ThumbnailURL = outputBlob.Uri.ToString();
                db.SaveChanges();
            }
        }

* Атрибут `QueueTrigger` направляет пакет SDK веб-заданий для вызова этого метода при получении нового сообщения в очереди запросов эскизов.

        [QueueTrigger("thumbnailrequest")] BlobInformation blobInfo,

    Для объекта `BlobInformation` в сообщении очереди автоматически выполняется десериализация в параметр `blobInfo`. По завершении метода сообщение очереди удаляется. Если происходит сбой метода до его завершения, сообщение очереди не удаляется. После истечения 10-минутного срока действия аренды сообщение передается для повторной обработки. Если сообщение вызывает исключение, эта последовательность не будет повторяться бесконечно. После 5 неудачных попыток обработать сообщение, оно будет перемещено в очередь с именем {queuename}-poison. Можно настроить максимальное количество попыток.
* Два атрибута `Blob` указывают на объекты, связанные с большими двоичными объектами: первый — на существующий большой двоичный объект изображения, второй — на большой двоичный объект эскиза, создаваемый методом.

        [Blob("images/{BlobName}", FileAccess.Read)] Stream input,
        [Blob("images/{BlobNameWithoutExtension}_thumbnail.jpg")] CloudBlockBlob outputBlob)

    Имена больших двоичных объектов задаются в соответствии со свойствами объекта `BlobInformation`, полученного в сообщении очереди (`BlobName` и `BlobNameWithoutExtension`). Чтобы получить все функции клиентской библиотеки хранилища, можно использовать класс `CloudBlockBlob` для работы с большими двоичными объектами. Если вы хотите повторно использовать код, написанный для работы с объектами `Stream`, можно использовать класс `Stream`.

Дополнительные сведения о написании функций, использующих атрибуты пакета SDK для веб-заданий, см. в следующих ресурсах:

* [Использование пакета SDK веб-заданий для работы с хранилищем очередей Azure](websites-dotnet-webjobs-sdk-storage-queues-how-to.md)
* [Использование хранилища больших двоичных объектов Azure с пакетом SDK веб-заданий](websites-dotnet-webjobs-sdk-storage-blobs-how-to.md)
* [Использование табличного хранилища Azure с пакетом SDK веб-заданий](websites-dotnet-webjobs-sdk-storage-tables-how-to.md)
* [Использование служебной шины Azure с пакетом SDK для веб-заданий](websites-dotnet-webjobs-sdk-service-bus.md)

> [!NOTE]
> * Если веб-приложение выполняется на нескольких виртуальных машинах, одновременно будет выполнятся несколько веб-заданий, а это в некоторых случаях может привести к многократной обработке одних и тех же данных. Такой проблемы не будет при использовании встроенной очереди, BLOB-объектов и триггеров служебной шины. Пакет SDK гарантирует, что функции для каждого сообщения или BLOB-объекта будут обрабатываться только один раз.
> * Сведения о нормальном завершении работы см. в [этом разделе](websites-dotnet-webjobs-sdk-storage-queues-how-to.md#graceful).
> * Для простоты код в методе `ConvertImageToThumbnailJPG` (не показан) использует классы в пространстве имен `System.Drawing`. Однако классы в этом пространстве имен были спроектированы для использования с формами Windows. Они не поддерживаются в службе Windows или ASP.NET. Дополнительные сведения о параметрах обработки изображений см. в статьях [Back to Basics: Dynamic Image Generation, ASP.NET Controllers, Routing, IHttpHandlers, and runAllManagedModulesForAllRequests](http://www.hanselman.com/blog/BackToBasicsDynamicImageGenerationASPNETControllersRoutingIHttpHandlersAndRunAllManagedModulesForAllRequests.aspx) (Основы: создание динамического образа, контроллеры ASP.NET, маршрутизация и runAllManagedModulesForAllRequests) и [Deep Inside Image Resizing and scaling with ASP.NET and IIS with ImageResizing.net author Nathanael](http://www.hanselminutes.com/313/deep-inside-image-resizing-and-scaling-with-aspnet-and-iis-with-imageresizingnet-author-na) (Особенности изменения размеров и масштабирования изображения с использованием ASP.NET и IIS с автором ImageResizing.net Натанаэлем).
>
>

## <a name="next-steps"></a>Дальнейшие действия
В этом руководстве было показано простое многоуровневое приложение, которое использует пакет SDK веб-заданий для обработки внутреннего сервера. В этом разделе приведены рекомендации по дальнейшему изучению многоуровневых приложений ASP.NET и веб-заданий.

### <a name="missing-features"></a>Отсутствующие функции
Приложение намеренно сделано простым, поскольку это учебник для начинающих. В реальном приложении вам понадобилось бы реализовать [внедрение зависимостей](http://www.asp.net/mvc/tutorials/hands-on-labs/aspnet-mvc-4-dependency-injection), а также [репозиторий и блок рабочих шаблонов](http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc/advanced-entity-framework-scenarios-for-an-mvc-web-application#repo), использовать [интерфейс для ведения журнала](http://www.asp.net/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry#log), использовать [EF Code First Migrations](http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc/migrations-and-deployment-with-the-entity-framework-in-an-asp-net-mvc-application) для управления изменениями модели данных и [EF Connection Resiliency](http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application) для управления кратковременными ошибками сети.

### <a name="scaling-webjobs"></a>Масштабирование веб-заданий
Веб-задания запускаются в контексте веб-приложения и не масштабируются отдельно. Например, если у вас есть один экземпляр веб-приложения Standard, вы можете запустить только один экземпляр внутренней обработки и он будет использовать некоторые ресурсы сервера (ЦП, память и т. д.), которые в противном случае были бы доступны для обработки веб-содержимого.

Если трафик зависит от времени дня или дня недели и если необходимую обработку внутреннего сервера можно запустить позже, запланируйте запуск веб-заданий на период, когда трафик мало используется. Если нагрузка по-прежнему слишком высока для данного решения, серверную часть можно запускать как веб-задание в отдельном веб-приложении, выделенном для этой цели. Затем можно масштабировать веб-приложение внутреннего сервера отдельно от веб-приложения внешнего сервера.

Дополнительные сведения см. в разделе [Масштабирование веб-заданий](websites-webjobs-resources.md#scale).

### <a name="avoiding-web-app-timeout-shut-downs"></a>Предотвращение завершения работы веб-приложений из-за превышения времени ожидания
Чтобы веб-задания всегда выполнялись и работали во всех экземплярах веб-приложения, необходимо включить функцию [AlwaysOn](http://weblogs.asp.net/scottgu/archive/2014/01/16/windows-azure-staging-publishing-support-for-web-sites-monitoring-improvements-hyper-v-recovery-manager-ga-and-pci-compliance.aspx).

### <a name="using-the-webjobs-sdk-outside-of-webjobs"></a>Использование пакета SDK веб-заданий вне сферы применения веб-заданий
Программа, которая использует пакет SDK веб-заданий, не должна запускаться в Azure в веб-задании. Ее можно запустить локально, а также в другой среде, например в рабочей роли облачной службы или службы Windows. Однако доступ к панели мониторинга пакета SDK веб-заданий можно получить только с помощью веб-приложения Azure. Чтобы использовать панель мониторинга, необходимо подключить веб-приложение к используемой учетной записи хранения, указав строку подключения AzureWebJobsDashboard на вкладке **Настройка** классического портала. Затем можно перейти на панель мониторинга по URL-адресу:

https://{webappname}.scm.azurewebsites.net/azurejobs/#/functions

Дополнительные сведения см. в записи блога [Получение панели мониторинга для локальной разработки с помощью пакета SDK веб-заданий](http://blogs.msdn.com/b/jmstall/archive/2014/01/27/getting-a-dashboard-for-local-development-with-the-webjobs-sdk.aspx), но обратите внимание, что она отображает имя старой строки подключения.

### <a name="more-webjobs-documentation"></a>Дополнительная документация по веб-заданиям
Дополнительные сведения см. в статье [Документация по веб-заданиям Azure](http://go.microsoft.com/fwlink/?LinkId=390226).
