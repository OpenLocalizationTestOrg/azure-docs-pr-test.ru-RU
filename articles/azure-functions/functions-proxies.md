---
title: "Работа с прокси в Функциях Azure | Документация Майкрософт"
description: "Общие сведения об использовании прокси Функций Azure"
services: functions
documentationcenter: 
author: alexkarcher-msft
manager: cfowler
editor: 
ms.assetid: 
ms.service: functions
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: multiple
ms.topic: article
ms.date: 04/11/2017
ms.author: alkarche
ms.openlocfilehash: dd022b189783f2d8c6209a6cd656704ff144bfd6
ms.sourcegitcommit: 4256ebfe683b08fedd1a63937328931a5d35b157
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/23/2017
---
# <a name="work-with-azure-functions-proxies"></a>Работа с функцией "Прокси-серверы Функций Azure"

В этой статье описано, как настроить прокси Функций Azure и работать с ними. Эта функция позволяет указать конечные точки в приложении-функции, реализуемые другим ресурсом. Эти прокси можно использовать для разбиения большого API-интерфейса на несколько приложений-функций (как в архитектуре микрослужб), сохраняя при этом единую область API для клиентов.

[!INCLUDE [intro](../../includes/functions-bindings-intro.md)]

> [!NOTE] 
> На выполнение прокси-сервера распространяется стандартная тарификация службы "Функции". Дополнительные сведения см. на странице [цен на Функции Azure](https://azure.microsoft.com/pricing/details/functions/).

## <a name="create"></a>Создание прокси-сервера

В этом разделе показано, как создать прокси-сервер на портале Функций.

1. Откройте [портал Azure] и перейдите к своему приложению-функции.
2. В левой области выберите **Создать прокси-сервер**.
3. Задайте имя прокси.
4. Настройте конечную точку в этом приложении-функции, указав **шаблон маршрута** и **методы HTTP**. Поведение этих параметров соответствует правилам для [триггеров HTTP].
5. Задайте **URL-адрес внутреннего сервера** для другой конечной точки. Ею может быть функция в другом приложении-функции или другой API. Значение не обязательно должно быть статическим и может ссылаться на [параметры приложения] и [параметры исходного запроса клиента].
6. Нажмите кнопку **Создать**.

Прокси теперь существует в виде новой конечной точки в приложении-функции. С точки зрения клиента это аналогично HttpTrigger в Функциях Azure. Можно испытать новый прокси, скопировав URL-адрес прокси и протестировав его с помощью избранного клиента HTTP.

## <a name="modify-requests-responses"></a>Изменение запросов и ответов

Функции Azure учетных записей-посредников можно изменить, запросов и ответов из серверной части. При таком преобразовании используются переменные, указанные в разделе [Использование переменных].

### <a name="modify-backend-request"></a>Изменение запроса внутреннего сервера

По умолчанию запрос внутреннего сервера инициализируется в качестве копии исходного запроса. Кроме настройки URL-адреса внутреннего сервера вы также можете изменить метод, заголовки и параметры строки запроса HTTP. Измененные значения могут ссылаться на [параметры приложения] и [параметры исходного запроса клиента].

Сейчас на портале не предусмотрена возможность изменения запросов внутреннего сервера. Чтобы узнать, как применять эту возможность от *proxies.json*, в разделе [Определите объект requestOverrides].

### <a name="modify-response"></a>Изменение ответа

По умолчанию ответ клиента инициализируется в качестве копии ответа внутреннего сервера. Вы можете изменить код состояния, описание, заголовки и текст ответа. Измененные значения могут ссылаться на [параметры приложения], [параметры исходного запроса клиента] и [параметры ответа внутреннего сервера].

Сейчас на портале не предусмотрена возможность изменения ответов. Чтобы узнать, как применять эту возможность от *proxies.json*, в разделе [Определите объект responseOverrides].

## <a name="using-variables"></a>Использование переменных

Использовать статическую конфигурацию для прокси-сервера необязательно. Можно условия, чтобы использовать переменные из исходного запроса клиента, внутренней ответа или параметры приложения.

### <a name="request-parameters"></a>Ссылки на параметры запроса

Параметры запроса можно использовать в качестве входных данных для свойства URL-адреса внутреннего сервера или в рамках изменения запросов и ответов. Некоторые параметры могут быть связаны с шаблоном маршрута, указанным в основной конфигурации прокси-сервера, тогда как другие задаются в соответствии со свойствами входящих запросов.

#### <a name="route-template-parameters"></a>Параметры шаблона маршрута
Параметры, используемые в шаблоне маршрута, указываются по именам, которые заключаются в фигурные скобки — {}.

Например, если прокси-сервер использует шаблон маршрута, подобный `/pets/{petId}`, URL-адрес внутреннего сервера может содержать значение `{petId}`, как в `https://<AnotherApp>.azurewebsites.net/api/pets/{petId}`. Если шаблон маршрута заканчивается подстановочным знаком, например `/api/{*restOfPath}`, значение `{restOfPath}` будет строковым представлением остальных сегментов пути входящего запроса.

#### <a name="additional-request-parameters"></a>Дополнительные параметры запроса
В дополнение к параметрам шаблона маршрута вы можете использовать следующие значения конфигурации:

* **{request.method}.** Метод HTTP, используемый в исходном запросе.
* **{request.headers.\<имя_заголовка\>}.** Заголовок, который можно считать из исходного запроса. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь считать. Если заголовок не включен в запрос, в качестве значения будет отображаться пустая строка.
* **{request.querystring.\<имя_параметра\>}.** Параметр строки запроса, который можно считать из исходного запроса. Замените *\<имя_параметра\>* именем параметра, который вы собираетесь считать. Если параметр не включен в запрос, в качестве значения будет отображаться пустая строка.

### <a name="response-parameters"></a>Ссылки на параметры ответа внутреннего сервера

Параметры ответа можно использовать при изменении ответов для клиента. Следующие значения можно использовать в качестве значений конфигурации:

* **{backend.response.statusCode}.** Код состояния HTTP, возвращаемый для ответа внутреннего сервера.
* **{backend.response.statusReason}.** Код состояния HTTP, возвращаемый для ответа внутреннего сервера.
* **{backend.response.headers.\<имя_заголовка\>}.** Заголовок, который можно считать из ответа внутреннего сервера. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь считать. Если заголовок не включен в ответе, значение будет пустая строка.

### <a name="use-appsettings"></a>Ссылки на параметры приложения

Вы также можете ссылаться на [параметры приложения, определенные для приложения-функции](https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings#develop), поставив знаки процента (%) перед именем параметра и после него.

Например, в URL-адресе внутреннего сервера *https://%ORDER_PROCESSING_HOST%/api/orders* %ORDER_PROCESSING_HOST% будет заменено значением параметра ORDER_PROCESSING_HOST.

> [!TIP] 
> Используйте параметры приложения для внутренних узлов при наличии нескольких развертываний или тестовых сред. Таким образом, можно гарантировать, что всегда идет справа серверной части для этой среды.

## <a name="advanced-configuration"></a>Расширенная конфигурация

Прокси-серверы, настроенные хранятся в *proxies.json* файл, расположенный в корневом каталоге приложения функции. Вы можете вручную изменить этот файл и развернуть его как часть приложения, используя любой из [методов развертывания](https://docs.microsoft.com/azure/azure-functions/functions-continuous-deployment), поддерживаемых Функциями. Компонент Azure функции прокси-серверов должно быть [включен](#enable) для файла должен быть обработан. 

> [!TIP] 
> Если вы не настроили одним из способов развертывания, вы также можете работать с *proxies.json* файл на портале. Перейдите к приложению-функции и выберите **Функции платформы**, а затем — **Редактор службы приложений**. Так вы сможете просмотреть всю структуру файла приложения-функции и внести изменения.

*Proxies.JSON* определяется объектом прокси, который состоит из именованного прокси-серверов и их определений. При необходимости для автозавершения кода можно ссылаться на [схему JSON](http://json.schemastore.org/proxies), если ваш редактор поддерживает такую возможность. Например, файл может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>"
        }
    }
}
```

Каждый прокси имеет понятное имя, как например *proxy1* в предыдущем примере. Соответствующий объект определения прокси определяется следующими свойствами:

* **matchCondition** (обязательное) — объект, который определяет запросы, активирующие выполнение этого прокси-сервера. Он содержит два свойства, используемые совместно с [триггеров HTTP]:
    * _methods_ — массив методов HTTP, на которые отвечает прокси-сервер. Если свойство не указано, прокси-сервер будет отвечать на все методы HTTP в маршруте.
    * _route_ (обязательное) — шаблон маршрута, определяющий URL-адреса запросов, на которые будет отвечать прокси-сервер. В отличие от триггеров HTTP значение по умолчанию отсутствует.
* **backendUri** — URL-адрес внутреннего ресурса, к которому должен быть отправлен запрос. Это значение может ссылаться на параметры приложения и параметры исходного запроса клиента. Если это свойство не включено, Функции Azure вернут ответ HTTP 200 OK.
* **requestOverrides.** Объект, определяющий преобразование запросов внутреннего сервера. Ознакомьтесь с разделом [Определите объект requestOverrides].
* **responseOverrides.** Объект, определяющий преобразование ответа клиента. Ознакомьтесь с разделом [Определите объект responseOverrides].

> [!NOTE] 
> *Маршрута* свойства в функции Azure учетные записи-посредники, не учитывают *routePrefix* функции приложения узла конфигурации. Если необходимо включать префикс, таких как `/api`, он должен быть включен в *маршрута* свойство.

### <a name="requestOverrides"></a>Определение объекта requestOverrides

Объект requestOverrides определяет изменения, внесенные в запрос во время вызова внутреннего ресурса. Объект определяется следующими свойствами:

* **backend.Request.Method**: метод HTTP, который используется для вызова серверной части.
* **backend.Request.Querystring. \<Имя_параметра\>**: параметр строки запроса, можно задать для вызова серверной части. Замените *\<имя_параметра\>* именем параметра, который вы собираетесь задать. Если указана пустая строка, параметр не включается в запрос внутреннего сервера.
* **backend.Request.Headers. \<HeaderName\>**: заголовок, который можно задать для вызова серверной части. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь задать. Если указана пустая строка, заголовок не включается в запрос внутреннего сервера.

Значения могут ссылаться на параметры приложения и параметры исходного запроса клиента.

Пример конфигурации может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>",
            "requestOverrides": {
                "backend.request.headers.Accept": "application/xml",
                "backend.request.headers.x-functions-key": "%ANOTHERAPP_API_KEY%"
            }
        }
    }
}
```

### <a name="responseOverrides"></a>Определение объекта responseOverrides

Объект requestOverrides определяет изменения, внесенные в ответ, который передается обратно к клиенту. Объект определяется следующими свойствами:

* **response.statusCode.** Код состояния HTTP, который будет возвращен клиенту.
* **response.statusReason.** Описание HTTP, которое будет возвращено клиенту.
* **response.body.** Строковое представление текста, который будет возвращен клиенту.
* **response.headers.\<имя_заголовка\>.** Заголовок, который можно задать для ответа клиенту. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь задать. Если указана пустая строка, заголовок не включается в ответ.

Значения могут ссылаться на параметры приложения, параметры исходного запроса клиента и параметры ответа внутреннего сервера.

Пример конфигурации может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "responseOverrides": {
                "response.body": "Hello, {test}",
                "response.headers.Content-Type": "text/plain"
            }
        }
    }
}
```
> [!NOTE] 
> В этом примере текст ответа имеет значение напрямую, поэтому нет `backendUri` необходимые свойства. В примере показано, как можно использовать прокси-серверы Функций Azure для имитации API.

## <a name="enable"></a>Включение прокси-серверов Функций Azure

По умолчанию прокси-серверы включены. Если вы использовали старую версию предварительной версии прокси-серверов и выключенных прокси-серверов, необходимо вручную включить их, чтобы они работали.

1. Откройте [портал Azure] и перейдите к своему приложению-функции.
2. Выберите **Параметры приложения-функции**.
3. Включите **параметр** **Включить прокси-серверы для функций Azure (предварительная версия)**.

Вы можете также возвращаться сюда для обновления среды выполнения прокси по мере появления новых функций.

[портал Azure]: https://portal.azure.com
[триггеров HTTP]: https://docs.microsoft.com/azure/azure-functions/functions-bindings-http-webhook#http-trigger
[Modify the back-end request]: #modify-backend-request
[Modify the response]: #modify-response
[Определите объект requestOverrides]: #requestOverrides
[Определите объект responseOverrides]: #responseOverrides
[параметры приложения]: #use-appsettings
[Использование переменных]: #using-variables
[параметры исходного запроса клиента]: #request-parameters
[параметры ответа внутреннего сервера]: #response-parameters
