---
title: "Создание интерфейсов веб-API и REST API для Azure Logic Apps | Документация Майкрософт"
description: "Создание интерфейсов веб-API и REST API для вызова API, служб или систем из рабочих процессов приложения логики для интеграции систем"
keywords: "интерфейсы веб-API, REST API, рабочие процессы, интеграция систем"
services: logic-apps
author: jeffhollan
manager: anneta
editor: 
documentationcenter: 
ms.assetid: bd229179-7199-4aab-bae0-1baf072c7659
ms.service: logic-apps
ms.workload: integration
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 5/26/2017
ms.author: LADocs; jehollan
ms.openlocfilehash: ec7fe2adfb89edd635adcf247eea0b98f7007b1b
ms.sourcegitcommit: be9a42d7b321304d9a33786ed8e2b9b972a5977e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/19/2018
---
# <a name="create-custom-apis-that-you-can-call-from-logic-app-workflows"></a>Создание пользовательских API, которые можно вызывать из рабочих процессов приложения логики

Azure Logic Apps предоставляет [более 100 встроенных соединителей](../connectors/apis-list.md) для рабочих процессов приложений логики. Но вам может потребоваться вызвать интерфейсы API, системы и службы, недоступные в качестве соединителей. Вы можете создавать собственные API с действиями и триггерами для использования в приложениях логики. Ниже приведены другие причины создания собственных интерфейсов API, которые можно вызывать из рабочих процессов приложения логики.

* Расширение текущих рабочих процессов интеграции систем и данных.
* Помощь клиентам в использовании службы для управления профессиональными или личными задачами.
* Увеличение охвата, возможности обнаружения и уровня использования вашей службы.

По сути, соединители — это веб-интерфейсы API, использующие REST для модульных интерфейсов, [формат метаданных Swagger](http://swagger.io/specification/) для документации и формат JSON для обмена данными. Соединители являются интерфейсами REST API, которые обмениваются данными через конечные точки HTTP, и для их создания можно использовать любой язык, например .NET, Java или Node.js. Интерфейсы API также можно разместить в [службе приложений Azure](../app-service/app-service-web-overview.md). Это платформа как услуга (PaaS), предоставляющая один из лучших, самых простых и масштабируемых способов размещения API. 

Пользовательские API для работы с приложениями логики предоставляют [*действия*](./logic-apps-overview.md#logic-app-concepts) для выполнения определенных задач в рабочих процессах приложений логики. Кроме того, API может действовать как [*триггер*](./logic-apps-overview.md#logic-app-concepts), запускающий рабочий процесс приложения логики, если новые данные или событие соответствует заданному условию. В этом разделе описаны общие модели для создания действий и триггеров в API в зависимости от ожидаемого поведения интерфейса.

API-интерфейсы можно разместить в [службе приложений Azure](../app-service/app-service-web-overview.md). Это служба PaaS (платформа как услуга), предоставляющая удобное размещение API с высоким уровнем масштабирования.

> [!TIP] 
> Интерфейсы API можно развернуть в качестве веб-приложений, но лучше развернуть их в качестве приложений API, что облегчит создание, размещение и использование интерфейсов API, как в облаке, так и локально. Не нужно изменять код в API-интерфейсах, просто разверните свой код в приложении API. Например, узнайте, как создавать приложения API с помощью таких языков: 
> 
> * [ASP.NET](../app-service/app-service-web-get-started-dotnet.md) 
> * [Java](../app-service/app-service-web-get-started-java.md)
> * [Node.js](../app-service/app-service-web-get-started-nodejs.md)
> * [PHP](../app-service/app-service-web-get-started-php.md)
> * [Python](../app-service/app-service-web-get-started-python.md)
>
> Примеры приложений API для приложений логики см. в [репозитории GitHub для Azure Logic Apps](http://github.com/logicappsio) или [блоге](http://aka.ms/logicappsblog).

## <a name="how-do-custom-apis-differ-from-custom-connectors"></a>Чем отличаются пользовательские API от пользовательских соединителей?

Пользовательские API и [пользовательские соединители](../logic-apps/custom-connector-overview.md) — это интерфейсы веб-API, использующие REST для модульных интерфейсов, [формат метаданных Swagger](http://swagger.io/specification/) для документации и формат JSON для обмена данными. Поскольку API и соединители являются интерфейсами REST API, которые обмениваются данными через конечные точки HTTP, то для создания пользовательских API и соединителей можно использовать любой язык, например .NET, Java или Node.js.

Пользовательские API позволяют вызывать API, не являющиеся соединителями, и предоставлять конечные точки, которые можно вызывать с помощью HTTP + Swagger, службы управления Azure API или служб приложений. Пользовательские соединители работают как пользовательские API, но кроме этого имеют следующие атрибуты:

* зарегистрированы как ресурсы соединителя Logic Apps в Azure;
* отображаются в конструкторе Logic Apps со значками рядом с соединителями, управляемыми корпорацией Майкрософт;
* доступны только авторам соединителей и пользователям приложений логики с тем же клиентом Azure Active Directory и той же подпиской Azure в регионе, где развернуты приложения логики.

Вы также можете предложить зарегистрированные соединители для сертификации Майкрософт. Этот процесс позволяет проверить зарегистрированные соединители на соответствие критериям для общего использования и делает эти соединители доступными для пользователей в Microsoft Flow и Microsoft PowerApps.

Дополнительные сведения о пользовательских соединителях см. в следующих разделах: 

* [Обзор настраиваемых соединителей](../logic-apps/custom-connector-overview.md)
* [Создание соединителей с помощью интерфейсов веб-API](../logic-apps/custom-connector-build-web-api-app-tutorial.md)
* [Register custom connectors in Azure Logic Apps](../logic-apps/logic-apps-custom-connector-register.md) (Регистрация пользовательских соединителей в Azure Logic Apps)

## <a name="helpful-tools"></a>Полезные инструменты

Пользовательский API наиболее оптимально работает с приложениями логики, если он содержит [документ Swagger](http://swagger.io/specification/) с описанием операций и параметров API.
Есть много библиотек, например [Swashbuckle](https://github.com/domaindrivendev/Swashbuckle), которые могут автоматически создавать файл Swagger. Чтобы обеспечить оптимальную работу Swagger с приложением логики, можно добавить к нему заметку для отображаемых имен, типов свойств и т. д. при помощи [TRex](https://github.com/nihaue/TRex).

<a name="actions"></a>

## <a name="action-patterns"></a>Модели действий

Для выполнения задач приложениями логики пользовательский API должен предоставлять определенные [*действия*](./logic-apps-overview.md#logic-app-concepts). Каждая операция в API сопоставляется с действием. Базовое действие — это контроллер, который принимает запросы HTTP и возвращает ответы HTTP. Например, приложение логики отправляет запрос HTTP в веб- или API-приложение. Приложение возвращает ответ HTTP с содержимым для обработки приложением логики.

Для стандартных действий можно написать метод HTTP-запроса в API и описать этот метод в файле Swagger. Затем можно напрямую вызвать API при помощи [действия HTTP](../connectors/connectors-native-http.md) или [HTTP + Swagger](../connectors/connectors-native-http-swagger.md). По умолчанию ответы должны возвращаться в [пределах времени ожидания запроса](./logic-apps-limits-and-config.md). 

![Модель стандартного действия](./media/logic-apps-create-api-app/standard-action.png)

<a name="pattern-overview"></a>Чтобы приложение логики находилось в ожидании, пока в API обрабатываются длительно выполняемые задачи, в API можно использовать [асинхронную модель опроса](#async-pattern) или [асинхронную модель веб-перехватчика](#webhook-actions), описанные в этом разделе. Чтобы продемонстрировать различия этих моделей, используем аналогию. Представьте себе, что вы обращаетесь в кондитерскую, чтобы вам приготовили торт на заказ. Модель опроса — это если вы каждые 20 минут звоните в кондитерскую, чтобы проверить, готов ли торт. Модель веб-перехватчика — это если в кондитерской у вас взяли номер телефона, чтобы позвонить, когда торт будет готов.

См. с примеры в [репозитории GitHub для Logic Apps](https://github.com/logicappsio). А также узнайте больше о [метриках использования для действий](logic-apps-pricing.md).

<a name="async-pattern"></a>

### <a name="perform-long-running-tasks-with-the-polling-action-pattern"></a>Обработка длительно выполняемых задач с помощью модели действия опроса

Чтобы в API выполнялись задачи, длительность обработки которых превышает [предельное время ожидания запроса](./logic-apps-limits-and-config.md), можно использовать асинхронную модель опроса. Эта модель обеспечивает работу API в отдельном потоке, сохраняя активное подключение к обработчику Logic Apps. Таким образом, приложение логики не отключится по истечении времени ожидания и не перейдет к следующему действию в рабочем процессе, пока API не завершит работу.

Общая схема работы

1. Убедитесь, что обработчик получил данные о том, что API принял запрос и начал его выполнение.
2. При последующих запросах состояния задания от обработчика он должен получить данные о завершении задачи API.
3. Обработчик должен получать актуальные данные для продолжения рабочего процесса приложения логики.

<a name="bakery-polling-action"></a> Теперь вернемся к аналогии кондитерской и применим ее к модели опроса. Представьте что вы звоните в кондитерскую, чтобы вам доставили торт на заказ. Приготовление торта займет определенное время, а вы не собираетесь ждать звонка, пока в кондитерской работают над заказом. В кондитерской подтверждают заказ и просят вас звонить каждые 20 минут для проверки его состояния. Вы звоните через 20 минут, но в кондитерской говорят, что торт не готов и вам нужно перезвонить еще через 20 минут. Этот процесс повторяется, пока вы не позвоните и вам не скажут, что заказ готов, и не доставят ваш торт. 

А теперь рассмотрим модель опроса. Кондитерская представляет собой пользовательский API, а вы, заказчик торта, представляете собой обработчик Logic Apps. При запросе обработчика API подтверждает запрос и отвечает через определенный интервал времени, снабжая обработчик данными о состоянии задания. Обработчик продолжает проверять состояние задания, пока API не ответит, что оно выполнено. Затем данные возвращаются в приложение логики и рабочий процесс возобновляется. 

![Модель действия опроса](./media/logic-apps-create-api-app/custom-api-async-action-pattern.png)

Ниже описаны конкретные действия API.

1. При получении API HTTP-запроса на начало работы немедленно должен возвращаться ответ HTTP `202 ACCEPTED` с заголовком `location`, описанным далее в этом шаге. Этот ответ информирует обработчик Logic Apps о том, что в API поступил запрос, приняты полезные данные запроса (входные данные) и выполняется обработка. 
   
   Ответ `202 ACCEPTED` должен содержать описанные ниже заголовки.
   
   * *Обязательный*: заголовок `location`, который указывает абсолютный путь к URL-адресу, по которому обработчик Logic Apps сможет проверить состояние задания API.

   * *Необязательный*: заголовок `retry-after`, который указывает для обработчика количество секунд ожидания перед проверкой состояния задания по URL-адресу `location`. 

     По умолчанию обработчик выполняет проверку каждые 20 секунд. Чтобы задать другой интервал, включите в ответ заголовок `retry-after` и количество секунд до следующей операции опроса.

2. По истечении указанного времени обработчик Logic Apps выполняет опрос по URL-адресу `location`, чтобы проверить состояние задания. После этих проверок из API должны поступать следующие ответы:
   
   * если задание выполнено, поступает ответ HTTP `200 OK` и полезные данные ответа (входные данные для следующего шага);

   * если задание еще обрабатывается, должен поступить еще один ответ HTTP `202 ACCEPTED` с такими же заголовками, как и в первоначальном ответе.

Если в API применена эта модель, в определении рабочего процесса приложения логики не нужно выполнять никаких действий, чтобы продолжать проверку состояния задания. Когда обработчик получает ответ HTTP `202 ACCEPTED` с допустимым заголовком `location`, он действует в соответствии с асинхронной моделью и проверяет заголовок `location`, пока из API не поступит ответ, отличный от 202.

> [!TIP]
> Ознакомьтесь с примером асинхронной модели в этом [образце ответа асинхронного контроллера в GitHub](https://github.com/logicappsio/LogicAppsAsyncResponseSample).

<a name="webhook-actions"></a>

### <a name="perform-long-running-tasks-with-the-webhook-action-pattern"></a>Обработка длительно выполняемых задач с помощью модели действия веб-перехватчика

В качестве альтернативы можно использовать модель веб-перехватчика для длительно выполняемых задач и асинхронной обработки. Эта модель приостанавливает приложение логики и переводит его в режим ожидания "обратного вызова" из API, чтобы завершить обработку перед продолжением рабочего процесса. Этот обратный вызов является запросом HTTP POST. Когда происходит событие, он отправляет сообщение по URL-адресу. 

<a name="bakery-webhook-action"></a> Теперь применим аналогию кондитерской к модели веб-перехватчика. Итак, вы звоните в кондитерскую, чтобы вам доставили торт на заказ. Приготовление торта займет определенное время, а вы не собираетесь ждать звонка, пока в кондитерской работают над заказом. В кондитерской подтверждают заказ, но на этот раз вы оставляете свой номер телефона, чтобы вам позвонили, когда торт будет готов. Затем вам сообщают, что заказ готов, и доставляют торт.

Рассмотрим модель веб-перехватчика. Кондитерская представляет собой пользовательский интерфейс API, а вы, заказчик торта, представляете собой обработчик Logic Apps. Обработчик вызывает API при помощи запроса с URL-адресом для "обратного вызова".
Выполнив задание, API использует URL-адрес для оповещения обработчика и возврата данных в приложение логики, которое возобновляет рабочий процесс. 

Для этой модели настройте на контроллере две конечные точки: `subscribe` и`unsubscribe`

*  Конечная точка `subscribe`: когда в рабочем процессе приходит очередь действия API, обработчик Logic Apps вызывает конечную точку `subscribe`. После этого приложение логики создает URL-адрес обратного вызова, который сохраняется в API, и ожидает от API обратного вызова по завершении работы. Затем API выполняет обратный вызов с запросом HTTP POST по URL-адресу и передает любое полученное содержимое и заголовки в качестве входных данных для приложения логики.

* Конечная точка `unsubscribe`: при отмене выполнения приложения логики обработчик Logic Apps вызывает конечную точку `unsubscribe`. В таком случае API может отменить регистрацию URL-адреса обратного вызова и при необходимости остановить любые процессы.

![Модель действия веб-перехватчика](./media/logic-apps-create-api-app/custom-api-webhook-action-pattern.png)

> [!NOTE]
> В настоящее время конструктор приложений логики не поддерживает обнаружение конечных точек веб-перехватчика с помощью Swagger. Поэтому для модели необходимо добавить [действие **веб-перехватчика**](../connectors/connectors-native-webhook.md) и указать URL-адрес, заголовки и текст запроса. Также см. раздел [Действия и триггеры рабочего процесса](logic-apps-workflow-actions-triggers.md#apiconnection-webhook-action). Чтобы передать URL-адрес обратного вызова, можно при необходимости использовать функцию рабочего процесса `@listCallbackUrl()` в любом предыдущем поле.

> [!TIP]
> Пример модели веб-перехватчика см. в [образце триггера веб-перехватчика в GitHub](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs).

<a name="triggers"></a>

## <a name="trigger-patterns"></a>Модели триггеров

Пользовательский API может действовать как [*триггер*](./logic-apps-overview.md#logic-app-concepts), запускающий приложение логики, если новые данные или событие соответствует заданному условию. Этот триггер может как выполнять регулярную проверку, так и ожидать передачи новых данных или информации о событиях в конечной точке службы. Если новые данные или событие соответствуют заданному условию, триггер срабатывает и запускает приложение логики, которое ожидает передачи данных от этого триггера. Для такого запуска приложения логики в API можно применить модель [*опрашивающего триггера*](#polling-triggers) или [*триггера веб-перехватчика*](#webhook-triggers). Эти модели похожи на аналогичные решения для [действий опроса](#async-pattern) и [действий веб-перехватчика](#webhook-actions). См. дополнительные сведения о [метриках использования для триггеров](logic-apps-pricing.md).

<a name="polling-triggers"></a>

### <a name="check-for-new-data-or-events-regularly-with-the-polling-trigger-pattern"></a>Регулярная проверка наличия новых данных или событий при помощи модели опрашивающего триггера

*Опрашивающий триггер* работает так же, как и [действие опроса](#async-pattern), описанное ранее в этой статье. Обработчик Logic Apps периодически вызывает и проверяет конечную точку триггера на наличие новых данных или событий. Если обработчик обнаруживает новые данные или событие, соответствующие указанным условиям, триггер срабатывает. Затем обработчик создает экземпляр приложения логики, который обрабатывает данные в качестве входных. 

![Модель опрашивающего триггера](./media/logic-apps-create-api-app/custom-api-polling-trigger-pattern.png)

> [!NOTE]
> Каждый опрашивающий запрос считается выполнением действия, даже если экземпляр логики приложения не создается. Чтобы предотвратить повторную обработку данных, триггер должен удалять данные, которые уже считаны и переданы в приложение логики.

Ниже описаны конкретные действия опрашивающего триггера с точки зрения API.

| Найдены ли новые данные или событие?  | Ответ API | 
| ------------------------- | ------------ |
| Найдено | Возврат данных состояния HTTP `200 OK` с полезными данными ответа (входные данные для следующего шага). <br/>При поступлении такого ответа создается экземпляр приложения логики и запускается рабочий процесс. | 
| Не найдено | Возврат данных состояние HTTP `202 ACCEPTED` с заголовками `location` и `retry-after`. <br/>Для триггеров заголовок `location` также должен содержать параметр запроса `triggerState`, который обычно является меткой времени. API может использовать этот идентификатор для отслеживания времени последнего запуска приложения логики. | 
||| 

Например, для регулярной проверки службы на предмет новых файлов можно создать опрашивающий триггер со следующим поведением:

| Включает ли запрос `triggerState`? | Ответ API | 
| -------------------------------- | -------------| 
| Нет  | Возврат данных состояния HTTP `202 ACCEPTED` и заголовка `location` (для `triggerState` установлено текущее время, а для `retry-after` — интервал в 15 секунд). | 
| Yes | Проверка службы на наличие файлов, добавленных после `DateTime` для `triggerState`. | 
||| 

| Количество найденных файлов | Ответ API | 
| --------------------- | -------------| 
| Один файл | Возврат информации о состоянии HTTP `200 OK` и содержимого с полезными данными, обновление `triggerState` до `DateTime` для возвращенного файла и установка для `retry-after` интервала в 15 секунд. | 
| Разделение на несколько файлов | Поочередный возврат файлов и данных состояния HTTP `200 OK`, обновление `triggerState` и установка для `retry-after` интервала в 0 секунд. </br>Эти действия информируют обработчик о том, что доступны дополнительные данные и требуется немедленный запрос данных по URL-адресу в заголовке `location`. | 
| Нет файлов | Возврат данных состояния HTTP `202 ACCEPTED`, `triggerState` без изменений и установка для `retry-after` интервала в 15 секунд. | 
||| 

> [!TIP]
> Пример модели опрашивающего триггера см. в [образце контроллера опрашивающего триггера в GitHub](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/PollTriggerController.cs).

<a name="webhook-triggers"></a>

### <a name="wait-and-listen-for-new-data-or-events-with-the-webhook-trigger-pattern"></a>Ожидание передачи новых данных или информации о событиях с помощью модели триггера веб-перехватчика

Триггер веб-перехватчика — *извещающий триггер*, который ожидает передачи новых данных или информации о событиях в конечной точке службы. Если новые данные или событие соответствуют заданному условию, триггер срабатывает и создается экземпляр приложения логики, который обрабатывает данные как входные.
Триггеры веб-перехватчика работают аналогично [действиям веб-перехватчика](#webhook-actions), описанным в этой статье ранее и настраиваются при помощи конечных точек `subscribe` и `unsubscribe`. 

* Конечная точка `subscribe`: при добавлении и сохранении триггера веб-перехватчика в приложении логики обработчик Logic Apps вызывает конечную точку `subscribe`. После этого приложение логики создает URL-адрес обратного вызова, который сохраняется в API. Если есть новые данные или событие, которое соответствуют заданному условию, API выполняет обратный вызов по URL-адресу при помощи HTTP POST. Полезные данные содержимого и заголовки передаются в приложение логики как входные данные.

* Конечная точка `unsubscribe`: при удалении триггера веб-перехватчика или всего приложения логики обработчик Logic Apps вызывает конечную точку `unsubscribe`. В таком случае API может отменить регистрацию URL-адреса обратного вызова и при необходимости остановить любые процессы.

![Модель триггера веб-перехватчика](./media/logic-apps-create-api-app/custom-api-webhook-trigger-pattern.png)

> [!NOTE]
> В настоящее время конструктор приложений логики не поддерживает обнаружение конечных точек веб-перехватчика с помощью Swagger. Поэтому для модели необходимо добавить [**триггер** веб-перехватчика](../connectors/connectors-native-webhook.md) и указать URL-адрес, заголовки и текст для запроса. См. раздел [Триггер httpWebhook](logic-apps-workflow-actions-triggers.md#httpwebhook-trigger). Чтобы передать URL-адрес обратного вызова, можно при необходимости использовать функцию рабочего процесса `@listCallbackUrl()` в любом предыдущем поле.
>
> Чтобы предотвратить повторную обработку данных, триггер должен удалять данные, которые уже считаны и переданы в приложение логики.

> [!TIP]
> Пример модели веб-перехватчика см. в [образце контроллера триггера веб-перехватчика в GitHub](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs).

## <a name="secure-calls-to-your-apis-from-logic-apps"></a>Защита вызовов к API из приложений логики

После создания пользовательских API настройте аутентификацию для API, чтобы обеспечить безопасность при их вызове из приложений логики. Узнайте, [как защитить вызовы к пользовательским API из приложений логики](../logic-apps/logic-apps-custom-api-authentication.md).

## <a name="deploy-and-call-your-apis"></a>Развертывание и вызов интерфейсов API

После настройки аутентификации настройте развертывание своих API. Узнайте, [как развертывать и вызывать пользовательские API из приложений логики](../logic-apps/logic-apps-custom-api-host-deploy-call.md).

## <a name="publish-custom-apis-to-azure"></a>Публикация пользовательских API в Azure

Чтобы сделать пользовательские API доступными для других пользователей Logic Apps в Azure, необходимо повысить безопасность и зарегистрировать их как соединители Logic Apps. Дополнительные сведения см. в разделе [Обзор настраиваемых соединителей](../logic-apps/custom-connector-overview.md). 

Чтобы сделать свои пользовательские API доступными для всех пользователей в Logic Apps, Microsoft Flow и Microsoft PowerApps, необходимо повысить безопасность, зарегистрировать эти API как соединители Logic Apps и предложить свои соединители для [программы сертификации Microsoft Azure](https://azure.microsoft.com/marketplace/programs/certified/logic-apps/). 

## <a name="get-support"></a>Получение поддержки

* За специализированной помощью по пользовательским API обращайтесь по адресу [customapishelp@microsoft.com](mailto:customapishelp@microsoft.com).

* Если у вас возникли вопросы, то посетите [форум Azure Logic Apps](https://social.msdn.microsoft.com/Forums/en-US/home?forum=azurelogicapps).

* Чтобы улучшить Logic Apps, голосуйте за идеи или предлагайте собственные на [сайте обратной связи Logic Apps](http://aka.ms/logicapps-wish). 

## <a name="next-steps"></a>Дополнительная информация

* [Обработка ошибок и исключений](../logic-apps/logic-apps-exception-handling.md)
* [Вызовы, срабатывания триггеров и создание вложенных приложений логики с конечными точками HTTP](../logic-apps/logic-apps-http-endpoint.md)
* [Метрики использования для действий и триггеров](../logic-apps/logic-apps-pricing.md)
