---
title: "Обработка типов содержимого в Azure Logic Apps | Документация Майкрософт"
description: "Принципы работы Azure Logic Apps с типами содержимого в среде разработки и в среде выполнения"
services: logic-apps
documentationcenter: .net,nodejs,java
author: jeffhollan
manager: anneta
editor: 
ms.assetid: cd1f08fd-8cde-4afc-86ff-2e5738cc8288
ms.service: logic-apps
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: integration
ms.date: 10/18/2016
ms.author: LADocs; jehollan
ms.openlocfilehash: ac67838344bbd10384299c086ff096fbe5dec6a9
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2017
---
# <a name="handle-content-types-in-logic-apps"></a>Обработка типов содержимого в приложениях логики

Через приложение логики могут проходить различные типы содержимого, включая JSON, XML, неструктурированные файлы и двоичные данные. Обработчик приложений логики поддерживает все типы содержимого, однако некоторые типы он распознает изначально, а другие могут потребовать преобразования или приведения. В этой статье описывается, как обработчик работает с различными типами содержимого и как при необходимости добиться их корректной обработки.

## <a name="content-type-header"></a>Заголовок Content-Type

Для начала рассмотрим два типа `Content-Types`, не требующих преобразования или приведения для использования в приложении логики: `application/json` и `text/plain`.

## <a name="applicationjson"></a>Приложение/JSON

Обработчик рабочего процесса определяет способ обработки по заголовку `Content-Type` в HTTP-вызовах. Любой запрос с типом содержимого `application/json` храниться и обрабатывается как объект JSON. Кроме того, содержимое JSON может быть проанализировано по умолчанию без преобразования. 

Например, в рабочем процессе можно проанализировать запрос, который имеет заголовок типа содержимого `application/json `, с помощью выражения `@body('myAction')['foo'][0]` для получения значения `bar` (в данном случае):

```
{
    "data": "a",
    "foo": [
        "bar"
    ]
}
```

Дополнительное преобразование не требуется. Если вы работаете с данными формата JSON и у вас не указан заголовок, их можно привести в формат JSON вручную с помощью функции `@json()`, например `@json(triggerBody())['foo']`.

### <a name="schema-and-schema-generator"></a>Схема и генератор схем

Триггер запроса позволяет добавить схему JSON для полезных данных, которые ожидается получить. Это схема позволяет конструктору генерировать токены, чтобы упростить использование содержимого запроса. Если у вас нет схемы, выберите **Использовать полезную нагрузку из примера для создания схемы**, чтобы создать схему JSON из примера полезных данных.

![SCHEMA (Схема)](./media/logic-apps-http-endpoint/manualtrigger.png)

### <a name="parse-json-action"></a>Действие Parse JSON

Действие `Parse JSON` позволяет проанализировать содержимое JSON, преобразив его в понятные токены для приложения логики. Как и триггер запроса, это действие позволяет добавить или создать схему JSON для содержимого, которое необходимо проанализировать. Этот инструмент упрощает использование данных из служебной шины, Azure Cosmos DB и т. д.

![Parse JSON](./media/logic-apps-content-type/ParseJSON.png)

## <a name="textplain"></a>Text/plain

Как и в случае с `application/json`, HTTP-сообщения, полученные с заголовком `Content-Type` типа `text/plain`, хранятся в необработанном виде. Кроме того, если эти сообщения включены в последующие действия без какого-либо приведения, запрос будет передан с заголовком `Content-Type`: `text/plain`. Например, при работе с неструктурированным файлом вы можете получить содержимое HTTP в виде `text/plain`:

```
Date,Name,Address
Oct-1,Frank,123 Ave.
```

Если в следующем действии запрос отправляется как тело другого запроса (`@body('flatfile')`), запрос получает заголовок Content-Type типа `text/plain`. Если вы работаете с данными в формате простого текста и у вас не указан заголовок, их можно привести в формат текста вручную с помощью функции `@string()`, например `@string(triggerBody())`.

## <a name="applicationxml-and-applicationoctet-stream-and-converter-functions"></a>Application/xml, Application/octet-stream и функции преобразователя

Обработчик приложений логики всегда сохраняет `Content-Type`, полученный в HTTP-запросе или ответе. Поэтому, если обработчик получает содержимое с заголовком `Content-Type` типа `application/octet-stream` и вы добавляете это содержимое в последующее действие без приведения, исходящий запрос будет иметь заголовок `Content-Type`: `application/octet-stream`. Таким образом обработчик может гарантировать, что при прохождении через рабочий процесс данные не будут потеряны. При этом состояние действия (входные и выходные данные) хранится в объекте JSON, так как оно проходит через рабочий процесс. Поэтому для сохранения некоторых типов данных обработчик преобразует содержимое в двоичную строку в кодировке Base64 с соответствующими метаданными, сохраняя и `$content`, и `$content-type`, преобразование которых выполняется автоматически. 

* `@json()`: приводит данные в `application/json`.
* `@xml()`: приводит данные в `application/xml`.
* `@binary()`: приводит данные в `application/octet-stream`.
* `@string()`: приводит данные в `text/plain`.
* `@base64()` приводит содержимое в строку Base64.
* `@base64toString()` приводит строку в кодировке Base64 в `text/plain`.
* `@base64toBinary()` приводит строку в кодировке Base64 в `application/octet-stream`.
* `@encodeDataUri()` кодирует строку как массив байтов dataUri.
* `@decodeDataUri()` декодирует dataUri в массив байтов.

Например, при получении HTTP-запроса с `Content-Type`: `application/xml`:

```
<?xml version="1.0" encoding="UTF-8" ?>
<CustomerName>Frank</CustomerName>
```

Вы можете привести данные, а затем использовать их, например, в `@xml(triggerBody())` либо в какой-то функции, например в `@xpath(xml(triggerBody()), '/CustomerName')`.

## <a name="other-content-types"></a>Другие типы содержимого

Другие типы содержимого поддерживаются и работают с приложениями логики, но для этого может потребоваться извлечение тела запроса вручную путем декодирования `$content`. Например, предположим вы инициируете запрос `application/x-www-url-formencoded`, где `$content` — это полезная нагрузка, закодированная в виде строки Base64 для сохранения всех данных:

```
CustomerName=Frank&Address=123+Avenue
```

Так как запрос не имеет формат простого текста или JSON, он сохраняется в действии в следующем виде:

```
...
"body": {
    "$content-type": "application/x-www-url-formencoded",
    "$content": "AAB1241BACDFA=="
}
```

В настоящее время встроенной функции для формирования данных нет, поэтому эти данные можно использовать в рабочем процессе, обращаясь к ним вручную с помощью функции вида `@string(body('formdataAction'))`. Если исходящий запрос должен также иметь заголовок content-type типа `application/x-www-url-formencoded`, вы можете добавить запрос в тело действия без приведения (например, `@body('formdataAction')`). Однако этот метод работает, только если тело запроса является единственным параметром входных данных `body`. Если вы попытаетесь использовать `@body('formdataAction')` в запросе `application/json`, вы получите ошибку выполнения, так как тело запроса будет отправлено в закодированном виде.

