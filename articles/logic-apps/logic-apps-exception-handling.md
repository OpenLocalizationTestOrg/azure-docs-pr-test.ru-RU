---
title: "Ошибки и обработке исключений для логики приложений в Azure | Документы Microsoft"
description: "Шаблоны для ошибок и обработка исключений в логике приложения."
services: logic-apps
documentationcenter: .net,nodejs,java
author: derek1ee
manager: anneta
editor: 
ms.assetid: e50ab2f2-1fdc-4d2a-be40-995a6cc5a0d4
ms.service: logic-apps
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: integration
ms.date: 10/18/2016
ms.author: LADocs; deli
ms.openlocfilehash: a74c7d18306359c9152f139299de1208b5932fe5
ms.sourcegitcommit: f46cbcff710f590aebe437c6dd459452ddf0af09
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2017
---
# <a name="handle-errors-and-exceptions-in-logic-apps"></a>Обработка ошибок и исключений в приложениях для логики

Логика приложения в Azure предоставляет широкие возможности средств и шаблонов, которые помогают обеспечить интеграцию надежным и устойчивым к сбоям. Любой архитектуры интеграции создает запрос соответствующим образом обрабатывать простоя или проблемы с зависимыми системами. Логика приложения делает обработка ошибок эффективные возможности. Она предоставляет средства, необходимые для обработки исключения и ошибки в рабочих процессах.

## <a name="retry-policies"></a>Политики повтора

Самое простое средство обработки ошибок и исключений — политика повтора. При сбое или время ожидания исходного запроса (запрос, который приводит к 429 или отклик 5xx), определяет политику повтора, если и каким образом следует повторить действие. 

Существует четыре типа политик повторных попыток: по умолчанию, нет фиксированного интервала и экспоненциального интервала. Если политика повторов не указано в определении рабочего процесса, используется политика по умолчанию в соответствии с определением службы. 

Политики повтора можно настроить в разделе *inputs* определенного действия или триггера, если они предусматривают повтор. Аналогичным образом можно настроить политики повтора (если применимо) в конструктор логику приложения. Чтобы настроить политику повтора в конструкторе логики приложения, перейдите к **параметры** для конкретного действия.

Сведения об ограничениях политик повторных попыток см. в разделе [ограничения логики приложения и конфигурации](../logic-apps/logic-apps-limits-and-config.md). Дополнительные сведения о поддерживаемом синтаксисе см. в разделе [повторите раздел политики в действиях рабочего процесса и триггеры][retryPolicyMSDN].

### <a name="default"></a>значение по умолчанию

Если не определить политику повтора (**retryPolicy** не определено), используется параметр по умолчанию. Политика по умолчанию — политику экспоненциального интервал, которая отправляет до четырех повторных попыток, в экспоненциальной нотации увеличением интервалов, умноженного на 7,5 секунды. Интервал составляет от 5 до 45 секунд. Эта политика по умолчанию эквивалентен политики в этом примере определение рабочего процесса HTTP:

```json
"HTTP":
{
    "inputs": {
        "method": "GET",
        "uri": "http://myAPIendpoint/api/action",
        "retryPolicy" : {
            "type": "exponential",
            "count": 4,
            "interval": "PT7.5S",
            "minimumInterval": "PT5S",
            "maximumInterval": "PT45S"
        }
    },
    "runAfter": {},
    "type": "Http"
}
```

### <a name="none"></a>None

Если **retryPolicy** равно **нет**, неудачных запросов не выполняется повторно.

| Имя элемента | Требуется | type | ОПИСАНИЕ |
| ------------ | -------- | ---- | ----------- |
| Тип | Yes | Строка | **Нет** |

### <a name="fixed-interval"></a>Фиксированный интервал

Если **retryPolicy** равно **фиксированной**, политика повторяет попытку невыполненных запросов, ожидающих истечения заданного интервала времени до отправки следующего запроса.

| Имя элемента | Требуется | type | ОПИСАНИЕ |
| ------------ | -------- | ---- | ----------- |
| Тип | Yes | Строка | **исправлена** |
| count | Yes | Целое число  | Количество повторных попыток. Должен находиться в диапазоне от 1 до 90. |
| interval | Yes | Строка | Интервал в повтора [формата ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Должно быть между PT5S и PT1D. |

### <a name="exponential-interval"></a>Экспоненциальный интервал

Если **retryPolicy** равно **экспоненциального**, политика повторов неудачных запросов после с экспоненциально растущим диапазона с произвольным интервалом. Каждой повторной попытке гарантированно предоставляется произвольный интервал времени в диапазоне от **minimumInterval** до **maximumInterval**. Универсальный случайной переменной в диапазоне, указанном в следующей таблице создается для каждой попытки до и включая **число**:

**Случайной переменной диапазона**

| Повторная попытка | Минимальный интервал | Максимальный интервал |
| ------------ |  ------------ |  ------------ |
| 1 | Max(0, **minimumInterval**) | Min(interval, **maximumInterval**) |
| 2 | Max(interval, **minimumInterval**) | Min(2 * interval, **maximumInterval**) |
| 3 | Max (2 * интервал, **minimumInterval**) | Min(4 * interval, **maximumInterval**) |
| 4. | Max(4 * interval, **minimumInterval**) | Min(8 * interval, **maximumInterval**) |
| ... |

Для экспоненциального тип политики **число** и **интервал** являются обязательными. Значения для **minimumInterval** и **maximumInterval** являются необязательными. Можно добавить их для переопределения значений по умолчанию PT5S и PT1D, соответственно.

| Имя элемента | Требуется | type | ОПИСАНИЕ |
| ------------ | -------- | ---- | ----------- |
| Тип | Yes | Строка | **Экспоненциальное** |
| count | Yes | Целое число  | Количество повторных попыток. Должен находиться в диапазоне от 1 до 90.  |
| interval | Yes | Строка | Интервал в повтора [формата ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Должно быть между PT5S и PT1D. |
| minimumInterval | Нет  | Строка | Повторите минимальный интервал в [формата ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Должно быть между PT5S и **интервал**. |
| maximumInterval | Нет  | Строка | Повторите минимальный интервал в [формата ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Должен находиться в диапазоне от **интервал** и PT1D. |

## <a name="catch-failures-with-the-runafter-property"></a>Перехватываться сбои, связанные со свойством runAfter

Каждое действие логику приложения объявляет действий должно закончиться до запуска действия. Это похоже на порядок действия в рабочем процессе. В определении действия, этот порядок называется **runAfter** свойство. 

**RunAfter** свойство является объект, описывающий, какие действия и действия состояния выполнения действия. По умолчанию, все действия, которые вы добавили с помощью конструктора логики приложения установлены для запуска после предыдущего шага, если предыдущий результат шага **успешно**. 

Тем не менее, можно настроить **runAfter** значение срабатывание действий при предыдущем действия имеют результат **сбой**, **пропускаются**, или возможный набор из следующих значений. Если вы хотите добавить элемент в указанный раздел служебной шины Azure после определенного действия **Insert_Row** завершается ошибкой, можно использовать следующие **runAfter** конфигурации:

```json
"Send_message": {
    "inputs": {
        "body": {
            "ContentData": "@{encodeBase64(body('Insert_Row'))}",
            "ContentType": "{ \"content-type\" : \"application/json\" }"
        },
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-westus.azure-apim.net/apim/servicebus"
            },
            "connection": {
                "name": "@parameters('$connections')['servicebus']['connectionId']"
            }
        },
        "method": "post",
        "path": "/@{encodeURIComponent('failures')}/messages"
    },
    "runAfter": {
        "Insert_Row": [
            "Failed"
        ]
    }
}
```

Обратите внимание, что **runAfter** имеет значение Если срабатывают **Insert_Row** — результат действия **сбой**. Для выполнения этого действия, если действие статус **успешно**, **сбой**, или **пропускаются**, используйте следующий синтаксис:

```json
"runAfter": {
        "Insert_Row": [
            "Failed", "Succeeded", "Skipped"
        ]
    }
```

> [!TIP]
> Действия, которые запуска и завершается ошибкой после сбоя предыдущего действия, помечаются как **успешно**. Это означает, что если вы успешно перехватывать все ошибки в рабочем процессе, выполнение сам помечен как **успешно**.

## <a name="scopes-and-results-to-evaluate-actions"></a>Области и результаты для оценки действий

Можно сгруппировать действия внутри [область](../logic-apps/logic-apps-loops-and-scopes.md), аналогично тому, как запускается после отдельных действий. Область действует логическое группирование действий. 

Области полезны, как для организации ваши действия приложения логики, так и для выполнения статистических вычислений на состояние области. Сама область получает определенное состояние после завершения в ней всех действий. Состояние области определяется теми же критериями, которые используются для выполнения. Если финальное действие в ветвь выполнения **сбой** или **Aborted**, находится в состоянии **сбой**.

Для запуска определенных действий для исправления ошибок, которые произошли в области, можно использовать **runAfter** с областью, помеченного **сбой**. Если *любой* действия в области ошибкой, если вы используете **runAfter** для области, можно создать одно действие для перехвата ошибок.

### <a name="get-the-context-of-failures-with-results"></a>Получите контекст сбоев с результатами

Несмотря на то, что полезно перехват ошибок из области, можно также контекст помогают точно понять, какие действия проблема и понять все ошибки и коды состояния, которые были возвращены.  **@result()** Функции рабочего процесса предоставляет контекст для результат всех действий в области видимости.

 **@result()** Функция принимает один параметр (имя области) и возвращает массив всех результатов действий из в пределах данной области. Эти объекты действия включают атрибуты  **@actions()** выводит объекта, включая время начала действия, время окончания действия, состояние действия, входными параметрами действий, идентификаторы корреляции действия и действия. 

В контексте каких-либо действий, которые не удалось отправить в пределах области, вы могли легко сопоставить  **@result()** функционировать с **runAfter** свойство.

Следует выполнить действие *для каждого* действия в области, которая имеет **сбой** результата, и для фильтрации массив результатов к действиям, которые не удается, может быть использована  **@result()** с [Filter_array](../connectors/connectors-native-query.md) действия и [foreach](../logic-apps/logic-apps-loops-and-scopes.md) цикла. С помощью отфильтрованного результирующего массива, можно выполнять действия для каждой ошибки с помощью **foreach** цикла. 

Вот пример, в котором отправляет HTTP POST запроса с текстом ответа каких-либо действий, завершившихся с ошибкой My_Scope область:

```json
"Filter_array": {
    "inputs": {
        "from": "@result('My_Scope')",
        "where": "@equals(item()['status'], 'Failed')"
    },
    "runAfter": {
        "My_Scope": [
            "Failed"
        ]
    },
    "type": "Query"
},
"For_each": {
    "actions": {
        "Log_Exception": {
            "inputs": {
                "body": "@item()['outputs']['body']",
                "method": "POST",
                "headers": {
                    "x-failed-action-name": "@item()['name']",
                    "x-failed-tracking-id": "@item()['clientTrackingId']"
                },
                "uri": "http://requestb.in/"
            },
            "runAfter": {},
            "type": "Http"
        }
    },
    "foreach": "@body('Filter_array')",
    "runAfter": {
        "Filter_array": [
            "Succeeded"
        ]
    },
    "type": "Foreach"
}
```

Ниже приводится подробное Пошаговое руководство для описания того, что происходит в предыдущем примере:

1. Чтобы получить результат всех действий в My_Scope, **Filter_array** фильтры действий  **@result(My_Scope)**.

2. Условие для **Filter_array** любой  **@result()** элемент, имеющий состояние равно **сбой**. Это условие фильтрует массив из всех результатов действий из My_Scope, в массив с результатами только действие, завершившееся ошибкой.

3. Выполнить **foreach** действие на *отфильтрованный массив* выходов. При этом выполняется действие *для каждого* ранее отфильтрованного результата действия, завершившегося сбоем.

    Если сбой одного действия в области действий в **foreach** запустить только один раз. Несколько неудачных действий в одной операции на сбой.

4. Отправить запрос HTTP POST от **foreach** элементов текста ответа или  **@item() [«выходные данные»] [текст]**.  **@result()** Фигуры элемента совпадает с  **@actions()** фигуры. Он может быть проанализирован одинаково.

5. Включение два пользовательских заголовков с именем действие, завершившееся ошибкой  **@item() [name]** и не удалось запустить клиент, идентификатор отслеживания  **@item() [clientTrackingId]**.

Для справки ниже приведен пример с одним  **@result()** элемента. Он показывает **имя**, **текст**, и **clientTrackingId** свойства, которые были получены в предыдущем примере. За пределами **foreach** действия,  **@result()** возвращает массив из этих объектов.

```json
{
    "name": "Example_Action_That_Failed",
    "inputs": {
        "uri": "https://myfailedaction.azurewebsites.net",
        "method": "POST"
    },
    "outputs": {
        "statusCode": 404,
        "headers": {
            "Date": "Thu, 11 Aug 2016 03:18:18 GMT",
            "Server": "Microsoft-IIS/8.0",
            "X-Powered-By": "ASP.NET",
            "Content-Length": "68",
            "Content-Type": "application/json"
        },
        "body": {
            "code": "ResourceNotFound",
            "message": "/docs/folder-name/resource-name does not exist"
        }
    },
    "startTime": "2016-08-11T03:18:19.7755341Z",
    "endTime": "2016-08-11T03:18:20.2598835Z",
    "trackingId": "bdd82e28-ba2c-4160-a700-e3a8f1a38e22",
    "clientTrackingId": "08587307213861835591296330354",
    "code": "NotFound",
    "status": "Failed"
}
```

Для обработки шаблонов другое исключение можно использовать выражения, описанные ранее в этой статье. Можно задать выполнение одного действия за пределами области, принимающий отфильтрованные весь массив ошибок обработки исключения и удалить **foreach**. Можно также включить других полезных свойств из  **@result()** ответа, как описано выше.

## <a name="azure-diagnostics-and-telemetry"></a>Система диагностики и телеметрия Azure

Описанные в этой статье модели обеспечивают замечательные возможности для обработки ошибок и исключений внутри запуска, но также можно обнаруживать и реагировать на ошибки, независимо от выполнения самого. [Диагностика Azure](../logic-apps/logic-apps-monitor-your-logic-apps.md) предоставляет простой способ для отправки всех событий рабочего процесса (включая все состояния выполнения и действия) для учетной записи хранилища Azure или концентратор событий в концентраторы событий Azure. 

Для оценки состояния выполнения, можно отслеживать журналы и показатели или публиковать их на любое средство мониторинга, вы предпочитаете. Потенциальные вариант заключается в создании потока через концентраторы событий для всех событий [Azure Stream Analytics](https://azure.microsoft.com/services/stream-analytics/). В Stream Analytics можно написать активные запросы на основе любого аномалий, средние значения или сбои из журналов диагностики. Stream Analytics можно использовать для отправки информации для других источников данных, как очереди, разделы, SQL, Azure Cosmos DB или Power BI.

## <a name="next-steps"></a>Дальнейшие действия

* В разделе Заказчик [строит обработки ошибок с помощью логики приложения в Azure](../logic-apps/logic-apps-scenario-error-and-exception-handling.md).
* Найти дополнительные [Logic Apps примеры и сценарии](../logic-apps/logic-apps-examples-and-scenarios.md).
* Сведения о создании [автоматического развертывания для приложения логики](../logic-apps/logic-apps-create-deploy-template.md).
* Узнайте, как [построить и развернуть логики приложения с помощью Visual Studio](logic-apps-deploy-from-vs.md).

<!-- References -->
[retryPolicyMSDN]: https://docs.microsoft.com/rest/api/logic/actions-and-triggers#Anchor_9
