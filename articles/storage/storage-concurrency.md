---
title: "aaaManaging параллелизма в хранилище Microsoft Azure"
description: "Как toomanage параллелизма для hello служб больших двоичных объектов, очередей, таблицы и файла"
services: storage
documentationcenter: 
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 277fbbb880906da6be67b2267ed5c8e457455bd1
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a>Управление параллелизмом в службе хранилища Microsoft Azure
## <a name="overview"></a>Обзор
В современных интернет-приложениях данные могут одновременно просматриваться и обновляться несколькими пользователями. Это требуется toothink разработчикам приложений, тщательно о том, как tooprovide a прогнозируемого возникнуть tootheir конечных пользователей, особенно сценарии, когда несколько пользователей могут обновлять hello же данных. Обычно разработчики рассматривают три следующие основные стратегии конфликтов данных:  

1. Оптимистический параллелизм — приложения выполнении обновления в ходе его обновления проверит Если hello данные изменились с момента приложения hello последнего чтения этих данных. Например если два пользователя, просматривающего страницу вики-сайте обновления toohello же страницы hello вики-сайте платформы необходимо убедиться, что это обновление второй hello не перезаписывает hello первого обновления — и оба пользователям понять, успешно ли их обновления. Стратегия наиболее часто применяется в веб-приложениях.
2. Пессимистичный параллелизм — приложения поиска tooperform обновления займет блокировки на объект, не позволяя другим пользователям обновлять данные hello до снятия блокировки hello. Например в сценарии репликации данных ведущий и ведомый, где будет обновлять только образец hello образец hello обычно для хранения монопольную блокировку для продолжительного периода времени на tooensure данных hello не никто другой не может обновлять ее.
3. Последний записавший, побеждает — подход, позволяющий любой tooproceed операций обновления без проверки, если любого другого приложения обновил hello данных, так как приложение hello сначала прочитать данные hello. Этой стратегии (или отсутствие стратегии формальных) обычно используется где данные секционированы таким образом, что имеется не вероятность того, что доступ к нескольким пользователям hello и тех же данных. Она также применяется при обработке кратковременных потоков данных.  

Приводятся общие сведения о том, как платформа hello хранилища Azure упрощает разработку, предоставляя поддержку первого класса для всех трех этих стратегий параллелизма.  

## <a name="azure-storage--simplifies-cloud-development"></a>Служба хранилища Azure — Упрощает облачные разработки
Hello службой хранилища Azure поддерживает все три стратегии, хотя это различение в его возможности tooprovide полная поддержка оптимистичный и пессимистичный параллелизм за спроектированный tooembrace строго согласованная модель, которая гарантирует, что при Здравствуйте фиксации службы хранилища данных, вставить или обновить операции, все последующие обращается к данным toothat увидите hello последнего обновления. Платформы для хранения данных, использующих модель окончательной согласованности имеют промежуток между при записи выполняется одним пользователем, и при обновлении hello может их видеть других пользователей, тем самым усложнения разработки клиентских приложений к несогласованности tooprevent заказа из влияния на конечных пользователей.  

В дополнение к этому tooselecting разработчики стратегии подходящий параллелизм необходимо принимать во внимание из как платформа хранения изолирует изменения — особенно изменения toohello один объектов между транзакциями. Hello службой хранилища Azure использует tooallow изоляции моментальных снимков, чтения toohappen операций одновременно с операций записи в одной секции. В отличие от других уровней изоляции изоляции моментального снимка гарантирует, что все операции чтения разделе согласованный моментальный снимок данных hello даже в том случае, если обновления выполняются — по существу, возвращая hello последних зафиксированных значений во время обработки транзакции обновления.  

## <a name="managing-concurrency-in-blob-storage"></a>Управление параллелизмом в хранилище BLOB-объектов
Вы можете toouse оптимистичное или пессимистичное управление параллелизмом моделирует tooblobs toomanage доступа и контейнеры в hello службы BLOB-объектов. Если явно не укажете стратегии последней записи wins по умолчанию hello.  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a>Оптимистичный параллелизм для BLOB-объектов и контейнеров
Hello службы хранилища назначает идентификатор объекта tooevery хранятся. Идентификатор обновляется при каждом обновлении объекта. Идентификатор Hello возвращается toohello клиента как часть ответ HTTP GET, используя заголовок ETag (тег сущности) hello, определенные в hello HTTP-протокола. Пользователь, выполняющий обновления на такой объект можно отправить в hello исходного ETag вместе с tooensure условный заголовок, обновление только возникает, если выполнены определенные условия — в этом случае hello условие является заголовком «If-Match», требующая hello хранилища Служба tooensure hello значение ETag, указанный в запросе обновления hello hello совпадение с кодом, хранятся в hello службы хранилища hello.  

Структура Hello этот процесс выглядит следующим образом:  

1. Получить большой двоичный объект из службы хранилища hello, hello ответ включает значение HTTP-заголовка ETag, которое идентифицирует hello текущая версия объекта hello в службе хранилища hello.
2. При обновлении большого двоичного объекта hello содержать значение ETag hello, полученный на шаге 1 в hello **If-Match** условный заголовок запроса hello отправки toohello службы.
3. Служба Hello сравнивает значение ETag hello в запросе hello с Привет текущее значение ETag большого двоичного объекта hello.
4. Если hello текущее значение ETag большого двоичного объекта hello другую версию, чем hello ETag в hello **If-Match** условного заголовка в запросе hello, hello службы возвращает ошибки 412 toohello клиента. Клиент toohello, что другой процесс обновлена hello blob с момента получения hello клиента, он указывает.
5. Если текущий hello hello большого двоичного объекта значение ETag hello совпадает с версией hello ETag в hello **If-Match** условного заголовка в запросе hello, hello служба выполняет hello запросил операцию и обновления hello текущее значение ETag большого двоичного объекта hello tooshow, что она создана новая версия.  

Hello следующий фрагмент кода C# (с помощью клиентской библиотеки хранилища 4.2.0 hello) показан простой пример того, как tooconstruct **AccessCondition If-Match** основании hello значение ETag, которое осуществляется из hello свойства большого двоичного объекта, который был ранее полученные либо inserted. Затем он использует hello **AccessCondition** объекта при его обновление hello BLOB-объектов: hello **AccessCondition** объект добавляет hello **If-Match** заголовок toohello запроса. Если другой процесс уже обновлен hello больших двоичных объектов, hello BLOB-объектов возвращает сообщение о состоянии HTTP 412 (необходимое условие не выполнено). Полный образец hello можно загрузить здесь: [управление параллелизмом, использование хранилища Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).  

```csharp
// Retrieve hello ETag from hello newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// toostorage blob service which returns hello etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try tooupdate hello blob using hello orignal ETag provided when hello blob was created
try
{
    Console.WriteLine("Trying tooupdate blob using orignal etag toogenerate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants toohandle hello 3rd party updated content.
    }
    else
        throw;
}  
```

Hello службы хранилища также включает поддержку дополнительные заголовки например **If-Modified-Since**, **If-Unmodified-Since** и **If-None-Match** производительны, чем их сочетания. Дополнительные сведения см. в статье [Указание условных заголовков для операций службы BLOB-объектов](http://msdn.microsoft.com/library/azure/dd179371.aspx) в MSDN.  

Hello следующей таблице перечислены hello контейнера операции, такие как условные заголовки accept **If-Match** в hello запроса, которые возвращают значение ETag в ответ hello.  

| Операция | Возврат значения ETag для контейнера | Принятие дополнительных заголовков |
|:--- |:--- |:--- |
| Create Container (Создание контейнера) |Да |Нет |
| Get Container Properties (Получение свойств контейнера) |Да |Нет |
| Get Container Metadata (Получение метаданных контейнера) |Да |Нет |
| Определение метаданных контейнера |Да |Да |
| Get Container ACL (Получение списка управления доступом для контейнера) |Да |Нет |
| Set Container ACL (Задание списка управления доступом для контейнера) |Да |Да (*) |
| Delete Container (Удаление контейнера) |Нет |Да |
| Lease Container (Аренда контейнера) |Да |Да |
| List Blobs (Отображение списка BLOB-объектов) |Нет |Нет |

разрешения hello (*), определяемые SetContainerACL кэшируются и обновления toothese разрешения имеют toopropagate какой период обновления, не гарантируется согласованность toobe 30 секунд.  

Hello следующей таблице перечислены операции hello BLOB-объекта, которые принимают условные заголовки, такие как **If-Match** в hello запроса, которые возвращают значение ETag в ответ hello.

| Операция | Returns ETag value (Возврат значения ETag) | Принятие дополнительных заголовков |
|:--- |:--- |:--- |
| Put BLOB (Вставка BLOB-объекта) |Да |Да |
| Get BLOB (Получение BLOB-объекта) |Да |Да |
| Get BLOB Properties (Получение свойств BLOB-объекта) |Да |Да |
| Set BLOB Properties (Задание свойств службы BLOB-объекта) |Да |Да |
| Get BLOB Metadata (Получение метаданных BLOB-объекта) |Да |Да |
| Set BLOB Metadata (Задание метаданных BLOB-объекта) |Да |Да |
| Lease Blob (Аренда BLOB-объекта) (*) |Да |Да |
| Создание моментального снимка большого двоичного объекта |Да |Да |
| Копирование BLOB-объекта |Да |Да (для исходного и целевого большого двоичного объекта) |
| Прерывание копирования большого двоичного объекта |Нет |Нет |
| Delete BLOB (Удаление BLOB-объекта) |Нет |Да |
| Put Block (Вставка блокировки) |Нет |Нет |
| Put Block List (Вставка списка блокировки) |Да |Да |
| Get Block List (Получение списка блокировки) |Да |Нет |
| Put Page (Вставка страницы) |Да |Да |
| Get Page Ranges (Получение диапазона страницы) |Да |Да |

(*) Большой двоичный объект не изменяет hello ETag для большого двоичного объекта.  

### <a name="pessimistic-concurrency-for-blobs"></a>Пессимистичный параллелизм для BLOB-объектов
toolock большой двоичный объект для монопольного использования, можно получить [аренды](http://msdn.microsoft.com/library/azure/ee691972.aspx) на нем. При приобретения аренды необходимо указать, как долго требуется hello аренды: это может быть для между 15 секунд too60 или бесконечной какие суммы tooan монопольная блокировка. Можно обновить tooextend конечное аренды и можно освободить все аренду при завершении работы с ним. Служба BLOB-объектов Hello автоматически освобождает конечное аренды истечении их срока действия.  

Аренды Включение синхронизации различных стратегий toobe поддерживается, включая Монопольная запись / общих чтения, за исключением записи или только чтения и записи совместно / только чтение. Там, где существует аренда hello службы хранилища применяет монопольную записи (put набор операций и удаления) Однако обеспечение эксклюзивность для операций чтения требует tooensure developer Привет, все клиентские приложения используют идентификатор аренды и, только один клиент по одному не является идентификатором аренды. Операции чтения, не имеющие идентификатора аренды, окажутся в общем чтении.  

Hello следующий фрагмент кода C# демонстрируется получение монопольного аренду на 30 секунд для большого двоичного объекта, обновление содержимого hello hello большого двоичного объекта и затем Освобождение аренды hello. Если уже существует допустимая Аренда на большой двоичный объект hello при попытке tooacquire новую аренду, hello BLOB-объектов возвращает результат состояния «HTTP (409) конфликт». фрагмент кода Hello ниже, используется **AccessCondition** объекта сведений об аренде hello tooencapsulate при большой двоичный объект запроса tooupdate hello в службе хранилища hello.  Полный образец hello можно загрузить здесь: [управление параллелизмом, использование хранилища Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update tooblob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying tooupdate blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

При попытке операцию записи на арендованного BLOB-объекта без передачи идентификатора аренды hello hello запрос приведет к ошибке 412. Обратите внимание, что если hello истечения срока аренды перед вызовом hello **UploadText** метода, но по-прежнему передавать идентификатор аренды hello, также hello запрос завершится ошибкой с **412** ошибки. Дополнительные сведения об управлении время истечения срока действия аренды и идентификаторы аренды см. в разделе hello [большой двоичный объект](http://msdn.microsoft.com/library/azure/ee691972.aspx) ОСТАЛЬНОЙ документации.  

Hello следующие операции с BLOB-объекта можно использовать аренды toomanage пессимистичного параллелизма.  

* Put BLOB (Вставка BLOB-объекта)
* Get BLOB (Получение BLOB-объекта)
* Get BLOB Properties (Получение свойств BLOB-объекта)
* Set BLOB Properties (Задание свойств службы BLOB-объекта)
* Get BLOB Metadata (Получение метаданных BLOB-объекта)
* Set BLOB Metadata (Задание метаданных BLOB-объекта)
* Delete BLOB (Удаление BLOB-объекта)
* Put Block (Вставка блокировки)
* Put Block List (Вставка списка блокировки)
* Get Block List (Получение списка блокировки)
* Put Page (Вставка страницы)
* Get Page Ranges (Получение диапазона страницы)
* Snapshot Blob (Моментальные снимки BLOB-объектов) — идентификатор аренды не обязателен, если есть аренда
* Требуется идентификатор аренды копирования BLOB-объекта — наличие аренды на BLOB-объект назначения hello
* Прерывание копирования Blob - идентификатор аренды необходимо наличие бесконечная Аренда на BLOB-объект назначения hello
* Lease Blob (Аренда BLOB-объекта)  

### <a name="pessimistic-concurrency-for-containers"></a>Пессимистичный параллелизм для контейнеров
Аренды адресов для контейнеров включить hello же toobe стратегии синхронизации поддерживается как для больших двоичных объектов (монопольной записи и чтения, за исключением записи совместно / эксклюзивным чтения и записи совместно / только чтение) Однако в отличие от больших двоичных объектов службы хранилища hello только применяет эксклюзивность на операции удаления. toodelete контейнер с активной арендой, клиент должен включить идентификатор активной аренды hello hello запроса delete. Все другие операции выполняются успешно для арендуемого контейнера без идентификатора аренды hello в этом случае они являются общими операциями. Если требуется монополия на операции обновления (put или set) или чтения, разработчик должен обеспечить всех клиентов возможностью использования идентификатора аренды, а также наличие действительного идентификатора аренды одновременно только у одного клиента.  

Hello следующие операции контейнера можно использовать аренды toomanage пессимистичного параллелизма.  

* Delete Container (Удаление контейнера)
* Get Container Properties (Получение свойств контейнера)
* Get Container Metadata (Получение метаданных контейнера)
* Определение метаданных контейнера
* Get Container ACL (Получение списка управления доступом для контейнера)
* Set Container ACL (Задание списка управления доступом для контейнера)
* Lease Container (Аренда контейнера)  

Дополнительные сведения см. в разделах:  

* [Указание условных заголовков для операций службы BLOB-объектов](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [Аренда контейнера](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [Аренда большого двоичного объекта ](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-hello-table-service"></a>Управление параллелизмом в hello службы таблиц
Служба таблиц Hello использует проверку оптимистического параллелизма по умолчанию hello при работе с объектами, в отличие от службы BLOB-объектов hello, где необходимо явно указать tooperform проверок оптимистического параллелизма. Hello других различий между hello службы таблиц и больших двоичных объектов — что можно управлять только параллелизма по умолчанию hello сущностей, тогда как hello службы больших двоичных объектов позволяет управлять параллелизмом hello контейнеров и больших двоичных объектов.  

Оптимистический параллелизм toouse и toocheck, если другой процесс изменения сущности с момента получения его из службы хранилища таблиц hello, можно использовать значение ETag hello, получаемых при hello служба таблиц возвращает сущности. Структура Hello этот процесс выглядит следующим образом:  

1. Получить сущности из службы хранилища таблиц hello, hello ответ включает значение ETag, которое идентифицирует текущий идентификатор hello, связанных с этой сущностью в службе хранилища hello.
2. При обновлении сущности hello, содержать значение ETag hello, полученный на шаге 1 в hello обязательные **If-Match** заголовок запроса hello отправки toohello службы.
3. Служба Hello сравнивает значение ETag hello в запросе hello с hello значение ETag текущей сущности hello.
4. Если текущее значение ETag hello hello объекта отличается от hello ETag в hello обязательные **If-Match** заголовка в запросе hello, hello службы возвращает ошибки 412 toohello клиента. Клиент toohello, что другой процесс обновлена hello сущности с момента получения hello клиента, он указывает.
5. Если hello значение ETag текущей сущности hello Здравствуйте, так же, как hello ETag в hello обязательные **If-Match** заголовка в запросе hello или hello **If-Match** заголовок содержит hello подстановочный знак (*), служба hello выполняет hello запросил операцию и обновления hello текущее значение ETag сущности tooshow hello, что она была обновлена.  

Обратите внимание, в отличие от службы BLOB-объектов hello, служба таблиц hello требует hello клиента tooinclude **If-Match** заголовок в запросы на обновление. Однако это возможно tooforce Безусловное обновление (стратегии wins последней записи) и обхода проверки параллелизма, если клиент hello задает hello **If-Match** заголовок toohello подстановочный знак (*) в запросе hello.  

Привет, следующий фрагмент кода C# показано сущность «клиент», который ранее создана или получить которых свой адрес электронной почты обновить. Hello начальный вставки или получения операция сохраняет значение ETag hello hello объекта клиента, а поскольку образец hello использует hello же экземпляр объекта при его выполнении hello заменить операции, он автоматически отправляет службы таблиц обратной toohello значение ETag hello, Включение toocheck службы hello нарушений параллелизма. Если другой процесс уже обновлен hello объекта в хранилище таблиц, hello служба возвращает сообщение о состоянии HTTP 412 (необходимое условие не выполнено).  Полный образец hello можно загрузить здесь: [управление параллелизмом, использование хранилища Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

tooexplicitly отключить проверку параллелизма hello, необходимо задать hello **ETag** свойство hello **сотрудника** объекта слишком «*» до выполнения операции замены hello.  

```csharp
customer.ETag = "*";  
```

Hello следующей таблице перечислены как операции с сущностями hello таблицы использовать значения ETag.

| Операция | Returns ETag value (Возврат значения ETag) | Requires If-Match request header (Требует заголовок запроса If-Match) |
|:--- |:--- |:--- |
| Query Entities (Сущности запроса) |Да |Нет |
| Insert Entity (Вставка сущности ) |Да |Нет |
| Update Entity (Обновление сущности) |Да |Да |
| Merge Entity (Слияние сущностей) |Да |Да |
| Delete Entity (Удаление сущности) |Нет |Да |
| Insert or Replace Entity (Вставка или замена сущности) |Да |Нет |
| Insert or Merge Entity (Вставка или слияние сущностей) |Да |Нет |

Обратите внимание, что hello **Вставка или замена сущности** и **Вставка или слияние сущности** выполните операции *не* выполняют проверку параллелизма, так как они не отправляют toohello значение ETag Служба таблиц.  

В основном разработчики, использующие таблицы, при разработке масштабируемых приложений должны полагаться на оптимистичный параллелизм. При необходимости Пессимистическая блокировка разработчики одним из подходов можно воспользоваться при доступе к таблицам tooassign большого двоичного объекта, указанного для каждой таблицы и повторите tootake аренду для большого двоичного объекта hello перед выполнением операции с hello таблицы. Этот подход требует tooensure приложения hello доступом пути получения предыдущих toooperating hello аренды в таблице hello. Следует отметить, что hello аренды минимальное время составляет 15 секунд что требует тщательного анализа последствий для масштабируемости.  

Дополнительные сведения см. в разделах:  

* [Операции с сущностями](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-hello-queue-service"></a>Управление параллелизмом в hello службы очередей
Один сценарий, в которой параллелизма проблемой в службе очередей hello — где нескольким клиентам получении сообщений из очереди. При получении сообщения из очереди hello hello ответа включает приветственное сообщение и значение подтверждения, который является обязательным toodelete приветственное сообщение. приветственное сообщение не удаляется из очереди hello автоматически, но после его получения, не видны tooother клиентов hello временного интервала, указанного параметром visibilitytimeout hello. Hello клиента, который получает сообщение hello является ожидаемым toodelete приветственное сообщение после обработки, а перед hello времени указывает hello TimeNextVisible элемент ответа hello, которое вычисляется на основе значения hello hello visibilitytimeout параметр. значение Hello visibilitytimeout добавляется значение hello toodetermine TimeNextVisible получить toohello времени, какие hello является сообщение.  

Hello очереди службы отсутствует поддержка пессимистичного или оптимистичного параллелизма и для этого клиентам причина обработки сообщения, отбираемые из очереди следует убедитесь, что сообщения обрабатываются в режиме идемпотентными. Стратегия "Сохраняются изменения, внесенные последними" используется для обновления операций, таких как SetQueueServiceProperties, SetQueueMetaData, SetQueueACL и UpdateMessage.  

Дополнительные сведения см. в разделах:  

* [REST API службы очередей](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [Получение сообщений](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-hello-file-service"></a>Управление параллелизмом в hello файловой службы
Служба файлов Hello осуществляется с помощью две конечные точки разных протоколов — SMB и REST. Hello службы REST не поддерживает оптимистической блокировки или пессимистичных блокировок и все обновления будут следовать стратегии wins последней записи. Клиенты SMB, которые подключают общие файловые ресурсы можно использовать файлы файловой системы блокировки механизмов toomanage доступа tooshared — включая hello возможность tooperform пессимистичных блокировок. Когда клиент SMB открывает файл, он указывает, доступ к файлам hello и общую папку режиме. Задание «Запись» или «Чтение» является параметром доступ к файлам и режим общей папки «None» приведет файл hello блокируемого клиентом SMB до закрытия файла hello. Если предпринимается попытка операции REST для файла, где клиент SMB открыл файл hello заблокирован hello службы REST возвращает код состояния 409 (конфликт) с кодом ошибки SharingViolation.  

Клиент SMB открывает файл для удаления, отмечает hello файл как ожидающий удаления, пока все SMB-клиент закрываются открытые дескрипторы для этого файла. Пока файл отмечен как "ожидающий удаления", любая операция REST на этом файле вернется кодом состояния 409 (конфликт) и с кодом ошибки SMBDeletePending. Код состояния 404 (не найдено) не возвращается, поскольку существует возможность приветствия tooremove клиента SMB hello ожидающие удаления флага предыдущих tooclosing hello файла. Другими словами код состояния 404 (не найдено) ожидается только после удаления файла hello. Обратите внимание, что если файл находится в состоянии ожидания удаления SMB, он не включается в приветствия приводит список файлов. Также Обратите внимание, что операции REST удаление файла и удаления каталога REST hello фиксируются автоматически и не приводят к ожидающие удаления состояния.  

Дополнительные сведения см. в разделах:  

* [Управление блокировкой файлов](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a>Сводка и дальнейшие действия
Hello хранилища Microsoft Azure, служба была разработана потребностей hello toomeet сложные интерактивные приложения hello без перезагрузки разработчики toocompromise или пересмотреть ключевые особенности допущения, например согласованности параллелизма и данных, требуют tootake должное.  

Для hello выполните образец приложения, на которые ссылается этот блог.  

* [Управление параллелизмом с помощью службы хранилища Azure: пример приложения](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

Подробнее о службе хранения Azure:  

* [Домашняя страница службы хранилища Microsoft Azure](https://azure.microsoft.com/services/storage/)
* [Введение tooAzure хранилища](storage-introduction.md)
* Приступая к работе с хранилищем: [большой двоичный объект](storage-dotnet-how-to-use-blobs.md), [таблица](storage-dotnet-how-to-use-tables.md), [очереди](storage-dotnet-how-to-use-queues.md) и [файлы](storage-dotnet-how-to-use-files.md).
* Архитектура службы хранилища — [служба хранилища Azure: высокодоступная служба облачного хранения со строгой согласованностью](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)

