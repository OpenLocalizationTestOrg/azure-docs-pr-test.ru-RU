---
title: "Управление параллелизмом в службе хранилища Microsoft Azure"
description: "Как управлять параллелизмом для служб BLOB-объектов, очередей, таблиц и файлов"
services: storage
documentationcenter: 
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 8b894af2f15cd22f04701c545d8250e20b99a094
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2017
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a><span data-ttu-id="0c3f8-103">Управление параллелизмом в службе хранилища Microsoft Azure</span><span class="sxs-lookup"><span data-stu-id="0c3f8-103">Managing Concurrency in Microsoft Azure Storage</span></span>
## <a name="overview"></a><span data-ttu-id="0c3f8-104">Обзор</span><span class="sxs-lookup"><span data-stu-id="0c3f8-104">Overview</span></span>
<span data-ttu-id="0c3f8-105">В современных интернет-приложениях данные могут одновременно просматриваться и обновляться несколькими пользователями.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-105">Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</span></span> <span data-ttu-id="0c3f8-106">Это требует от разработчиков приложений тщательного подхода для обеспечения предсказуемого взаимодействия с конечным пользователем, в частности для сценариев с одновременным обновлением данных несколькими пользователями.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-106">This requires application developers to think carefully about how to provide a predictable experience to their end users, particularly for scenarios where multiple users can update the same data.</span></span> <span data-ttu-id="0c3f8-107">Обычно разработчики рассматривают три следующие основные стратегии конфликтов данных:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-107">There are three main data concurrency strategies developers will typically consider:</span></span>  

1. <span data-ttu-id="0c3f8-108">Оптимистический параллелизм — Обновляемое приложение при обновлении определяет, произошли ли изменения данных с момента последнего считывания данных приложением.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-108">Optimistic concurrency – An application performing an update will as part of its update verify if the data has changed since the application last read that data.</span></span> <span data-ttu-id="0c3f8-109">Например, если два пользователя просматривают одну и ту же вики-страницу и вносят изменения в нее, платформа вики должна обеспечить возможность для первого обновления не быть перезаписанным вторым, а пользователи должны понять, удачно ли прошло их обновление.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-109">For example, if two users viewing a wiki page make an update to the same page then the wiki platform must ensure that the second update does not overwrite the first update – and that both users understand whether their update was successful or not.</span></span> <span data-ttu-id="0c3f8-110">Стратегия наиболее часто применяется в веб-приложениях.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-110">This strategy is most often used in web applications.</span></span>
2. <span data-ttu-id="0c3f8-111">Пессимистичный параллелизм — До начала обновления приложение блокирует доступ к объекту, не позволяя пользователю изменить данные до снятия блокировки.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-111">Pessimistic concurrency – An application looking to perform an update will take a lock on an object preventing other users from updating the data until the lock is released.</span></span> <span data-ttu-id="0c3f8-112">Например, в сценарии репликации данных ведущий/ведомый, где данные обновляются только ведущим, ведущий применяет монопольную блокировку данных на длительный период времени для предотвращения его изменений кем-либо еще.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-112">For example, in a master/slave data replication scenario where only the master will perform updates the master will typically hold an exclusive lock for an extended period of time on the data to ensure no one else can update it.</span></span>
3. <span data-ttu-id="0c3f8-113">Сохраняются изменения, внесенные последними — Подход, позволяющий обновлять данные, не определяя, произошли ли изменения данных с момента последнего считывания их приложением.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-113">Last writer wins – An approach that allows any update operations to proceed without verifying if any other application has updated the data since the application first read the data.</span></span> <span data-ttu-id="0c3f8-114">Эта стратегия (или отсутствие формальной стратегии) применяется обычно при таком разделении данных, которое не позволяет доступ нескольким пользователям к одним и тем же данным.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-114">This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access the same data.</span></span> <span data-ttu-id="0c3f8-115">Она также применяется при обработке кратковременных потоков данных.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-115">It can also be useful where short-lived data streams are being processed.</span></span>  

<span data-ttu-id="0c3f8-116">В статье описывается, как платформа службы хранилища Azure облегчает разработки, предоставляя первоклассную поддержку всем трем стратегиям параллелизма.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-116">This article provides an overview of how the Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</span></span>  

## <a name="azure-storage--simplifies-cloud-development"></a><span data-ttu-id="0c3f8-117">Служба хранилища Azure — Упрощает облачные разработки</span><span class="sxs-lookup"><span data-stu-id="0c3f8-117">Azure Storage – Simplifies Cloud Development</span></span>
<span data-ttu-id="0c3f8-118">Служба хранилища Azure поддерживает все три стратегии, хотя отличается возможностью полной поддержки оптимистического и пессимистичного параллелизма. Она разработана для поддержания модели строгой согласованности, при которой при вводе или обновлении данных в службе хранилища пользователям, получившим дальнейший доступ к данным, будут гарантированно показаны последние введенные данные.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-118">The Azure storage service supports all three strategies, although it is distinctive in its ability to provide full support for optimistic and pessimistic concurrency because it was designed to embrace a strong consistency model which guarantees that when the Storage service commits a data insert or update operation all further accesses to that data will see the latest update.</span></span> <span data-ttu-id="0c3f8-119">Платформы службы хранилища, иногда применяющие модель согласованности, имеют небольшой интервал между записью данных одним пользователем и возможностью другим пользователем видеть обновленные данные. Это усложняет разработку клиентских приложений с целью предотвращения воздействия несоответствий на конечных пользователей.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-119">Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when the updated data can be seen by other users thus complicating development of client applications in order to prevent inconsistencies from affecting end users.</span></span>  

<span data-ttu-id="0c3f8-120">Кроме выбора соответствующей стратегии параллелизма разработчики должны иметь представление о том, как платформа службы хранилища изолирует изменения, в частности изменения одних и тех же объектов между транзакциями.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-120">In addition to selecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes to the same object across transactions.</span></span> <span data-ttu-id="0c3f8-121">Служба хранилища Azure использует изоляцию моментального снимка, чтобы позволить одновременное выполнение операций чтения и записи в рамках одного раздела.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-121">The Azure storage service uses snapshot isolation to allow read operations to happen concurrently with write operations within a single partition.</span></span> <span data-ttu-id="0c3f8-122">В отличие от других уровней изоляции, изоляция моментального снимка гарантирует видимость операциям чтения только согласованных моментальных снимков данных даже при их обновлении, возвращая, по сути, в процессе обновления последние фиксированные значения.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-122">Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of the data even while updates are occurring – essentially by returning the last committed values while an update transaction is being processed.</span></span>  

## <a name="managing-concurrency-in-blob-storage"></a><span data-ttu-id="0c3f8-123">Управление параллелизмом в хранилище BLOB-объектов</span><span class="sxs-lookup"><span data-stu-id="0c3f8-123">Managing Concurrency in Blob storage</span></span>
<span data-ttu-id="0c3f8-124">Вы можете выбрать модель оптимистического или пессимистичного параллелизма для управления доступа к BLOB-объектам и контейнерам службы BLOB-объектов.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-124">You can opt to use either optimistic or pessimistic concurrency models to manage access to blobs and containers in the blob service.</span></span> <span data-ttu-id="0c3f8-125">Если вы не указываете стратегию, то применяется стратегия по умолчанию "Сохраняются изменения, внесенные последними".</span><span class="sxs-lookup"><span data-stu-id="0c3f8-125">If you do not explicitly specify a strategy last writes wins is the default.</span></span>  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a><span data-ttu-id="0c3f8-126">Оптимистичный параллелизм для BLOB-объектов и контейнеров</span><span class="sxs-lookup"><span data-stu-id="0c3f8-126">Optimistic concurrency for blobs and containers</span></span>
<span data-ttu-id="0c3f8-127">Служба хранилища присваивает идентификатор каждому сохраненному объекту.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-127">The Storage service assigns an identifier to every object stored.</span></span> <span data-ttu-id="0c3f8-128">Идентификатор обновляется при каждом обновлении объекта.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-128">This identifier is updated every time an update operation is performed on an object.</span></span> <span data-ttu-id="0c3f8-129">Идентификатор возвращается клиенту в качестве ответа HTTP GET с помощью заголовка ETag (тег объекта), определенного в протоколе HTTP.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-129">The identifier is returned to the client as part of an HTTP GET response using the ETag (entity tag) header that is defined within the HTTP protocol.</span></span> <span data-ttu-id="0c3f8-130">Пользователь, вносящий изменение в объект, может отправить оригинальный ETag с условным заголовком, чтобы удостовериться в том, что обновление произойдет только при удовлетворении определенного условия: в этом случае условие — заголовок "If-Match", который требует, чтобы значение ETag, определенное в запросе на обновление, соответствовало сохраненному в службе хранилища.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-130">A user performing an update on such an object can send in the original ETag along with a conditional header to ensure that an update will only occur if a certain condition has been met – in this case the condition is an "If-Match" header which requires the Storage Service to ensure the value of the ETag specified in the update request is the same as that stored in the Storage Service.</span></span>  

<span data-ttu-id="0c3f8-131">Для этой команды используется следующая структура:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-131">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="0c3f8-132">Извлеките BLOB-объект из службы хранилища, ответ содержит значение заголовка HTTP ETag, указывающее текущую версию объекта в службе хранилища.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-132">Retrieve a blob from the storage service, the response includes an HTTP ETag Header value that identifies the current version of the object in the storage service.</span></span>
2. <span data-ttu-id="0c3f8-133">При обновлении BLOB-объекта включите полученное после выполнения шага 1 значение ETag в условный заголовок **If-Match** запроса, отправляемого вами в службу.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-133">When you update the blob, include the ETag value you received in step 1 in the **If-Match** conditional header of the request you send to the service.</span></span>
3. <span data-ttu-id="0c3f8-134">Служба сравнивает значение ETag запроса с текущим значением ETag BLOB-объекта.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-134">The service compares the ETag value in the request with the current ETag value of the blob.</span></span>
4. <span data-ttu-id="0c3f8-135">Если текущее значение ETag BLOB-объекта отличается от ETag в условном заголовке запроса **If-Match** , служба возвращает клиенту ошибку 412.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-135">If the current ETag value of the blob is a different version than the ETag in the **If-Match** conditional header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="0c3f8-136">Это указывает клиенту на то, что после извлечения клиентом BLOB-объекта он был обновлен другим процессом.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-136">This indicates to the client that another process has updated the blob since the client retrieved it.</span></span>
5. <span data-ttu-id="0c3f8-137">Если текущее значение ETag BLOB-объекта совпадает со значением ETag в условном заголовке запроса **If-Match** , служба выполняет запрошенную операцию и обновляет текущее значение ETag BLOB-объекта, указывая тем самым на создание новой версии.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-137">If the current ETag value of the blob is the same version as the ETag in the **If-Match** conditional header in the request, the service performs the requested operation and updates the current ETag value of the blob to show that it has created a new version.</span></span>  

<span data-ttu-id="0c3f8-138">Следующий фрагмент C#-кода (с использованием клиентской библиотеки хранилища версии 4.2.0) является простым примером того, как построить **If-Match AccessCondition** , основанное на значении ETag, доступном из свойств извлеченного или вставленного до этого BLOB-объекта.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-138">The following C# snippet (using the Client Storage Library 4.2.0) shows a simple example of how to construct an **If-Match AccessCondition** based on the ETag value that is accessed from the properties of a blob that was previously either retrieved or inserted.</span></span> <span data-ttu-id="0c3f8-139">Затем он использует объект **AccessCondition** при обновлении большого двоичного объекта: объект **AccessCondition** добавляет заголовок **If-Match** к запросу.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-139">It then uses the **AccessCondition** object when it updating the blob: the **AccessCondition** object adds the **If-Match** header to the request.</span></span> <span data-ttu-id="0c3f8-140">Если произошло обновление BLOB-объекта другим процессом, служба возвращает сообщение о состоянии HTTP 412 (Необходимое условие не выполнено).</span><span class="sxs-lookup"><span data-stu-id="0c3f8-140">If another process has updated the blob, the blob service returns an HTTP 412 (Precondition Failed) status message.</span></span> <span data-ttu-id="0c3f8-141">Полный пример можно скачать здесь: [Управление параллелизмом с помощью службы хранилища Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="0c3f8-141">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>  

```csharp
// Retrieve the ETag from the newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// to storage blob service which returns the etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try to update the blob using the orignal ETag provided when the blob was created
try
{
    Console.WriteLine("Trying to update blob using orignal etag to generate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants to handle the 3rd party updated content.
    }
    else
        throw;
}  
```

<span data-ttu-id="0c3f8-142">Служба хранилища включает также поддержку дополнительных условных заголовков, таких как **If-Modified-Since**, **If-Unmodified-Since** и **If-None-Match**, а также их комбинаций.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-142">The Storage Service also includes support for additional conditional headers such as **If-Modified-Since**, **If-Unmodified-Since** and **If-None-Match** as well as combinations thereof.</span></span> <span data-ttu-id="0c3f8-143">Дополнительные сведения см. в статье [Указание условных заголовков для операций службы BLOB-объектов](http://msdn.microsoft.com/library/azure/dd179371.aspx) в MSDN.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-143">For more information see [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) on MSDN.</span></span>  

<span data-ttu-id="0c3f8-144">В таблице содержится свод операций с контейнером, принимающих в запросе такие условные заголовки, как **If-Match** и возвращающих в ответе значение ETag.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-144">The following table summarizes the container operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>  

| <span data-ttu-id="0c3f8-145">Операция</span><span class="sxs-lookup"><span data-stu-id="0c3f8-145">Operation</span></span> | <span data-ttu-id="0c3f8-146">Возврат значения ETag для контейнера</span><span class="sxs-lookup"><span data-stu-id="0c3f8-146">Returns Container ETag value</span></span> | <span data-ttu-id="0c3f8-147">Принятие дополнительных заголовков</span><span class="sxs-lookup"><span data-stu-id="0c3f8-147">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="0c3f8-148">Create Container (Создание контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-148">Create Container</span></span> |<span data-ttu-id="0c3f8-149">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-149">Yes</span></span> |<span data-ttu-id="0c3f8-150">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-150">No</span></span> |
| <span data-ttu-id="0c3f8-151">Get Container Properties (Получение свойств контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-151">Get Container Properties</span></span> |<span data-ttu-id="0c3f8-152">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-152">Yes</span></span> |<span data-ttu-id="0c3f8-153">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-153">No</span></span> |
| <span data-ttu-id="0c3f8-154">Get Container Metadata (Получение метаданных контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-154">Get Container Metadata</span></span> |<span data-ttu-id="0c3f8-155">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-155">Yes</span></span> |<span data-ttu-id="0c3f8-156">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-156">No</span></span> |
| <span data-ttu-id="0c3f8-157">Определение метаданных контейнера</span><span class="sxs-lookup"><span data-stu-id="0c3f8-157">Set Container Metadata</span></span> |<span data-ttu-id="0c3f8-158">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-158">Yes</span></span> |<span data-ttu-id="0c3f8-159">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-159">Yes</span></span> |
| <span data-ttu-id="0c3f8-160">Get Container ACL (Получение списка управления доступом для контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-160">Get Container ACL</span></span> |<span data-ttu-id="0c3f8-161">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-161">Yes</span></span> |<span data-ttu-id="0c3f8-162">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-162">No</span></span> |
| <span data-ttu-id="0c3f8-163">Set Container ACL (Задание списка управления доступом для контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-163">Set Container ACL</span></span> |<span data-ttu-id="0c3f8-164">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-164">Yes</span></span> |<span data-ttu-id="0c3f8-165">Да (*)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-165">Yes (*)</span></span> |
| <span data-ttu-id="0c3f8-166">Delete Container (Удаление контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-166">Delete Container</span></span> |<span data-ttu-id="0c3f8-167">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-167">No</span></span> |<span data-ttu-id="0c3f8-168">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-168">Yes</span></span> |
| <span data-ttu-id="0c3f8-169">Lease Container (Аренда контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-169">Lease Container</span></span> |<span data-ttu-id="0c3f8-170">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-170">Yes</span></span> |<span data-ttu-id="0c3f8-171">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-171">Yes</span></span> |
| <span data-ttu-id="0c3f8-172">List Blobs (Отображение списка BLOB-объектов)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-172">List Blobs</span></span> |<span data-ttu-id="0c3f8-173">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-173">No</span></span> |<span data-ttu-id="0c3f8-174">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-174">No</span></span> |

<span data-ttu-id="0c3f8-175">(*) Разрешения, определенные SetContainerACL, кэшируются, а обновление разрешений занимает 30 секунд, в течение которых нельзя гарантировать согласованность обновлений.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-175">(*) The permissions defined by SetContainerACL are cached and updates to these permissions take 30 seconds to propagate during which period updates are not guaranteed to be consistent.</span></span>  

<span data-ttu-id="0c3f8-176">В таблице содержится свод операций с BLOB-объектами, принимающих в запросе такие условные заголовки, как **If-Match** и возвращающих в ответе значение ETag.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-176">The following table summarizes the blob operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>

| <span data-ttu-id="0c3f8-177">Операция</span><span class="sxs-lookup"><span data-stu-id="0c3f8-177">Operation</span></span> | <span data-ttu-id="0c3f8-178">Returns ETag value (Возврат значения ETag)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-178">Returns ETag value</span></span> | <span data-ttu-id="0c3f8-179">Принятие дополнительных заголовков</span><span class="sxs-lookup"><span data-stu-id="0c3f8-179">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="0c3f8-180">Put BLOB (Вставка BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-180">Put Blob</span></span> |<span data-ttu-id="0c3f8-181">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-181">Yes</span></span> |<span data-ttu-id="0c3f8-182">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-182">Yes</span></span> |
| <span data-ttu-id="0c3f8-183">Get BLOB (Получение BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-183">Get Blob</span></span> |<span data-ttu-id="0c3f8-184">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-184">Yes</span></span> |<span data-ttu-id="0c3f8-185">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-185">Yes</span></span> |
| <span data-ttu-id="0c3f8-186">Get BLOB Properties (Получение свойств BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-186">Get Blob Properties</span></span> |<span data-ttu-id="0c3f8-187">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-187">Yes</span></span> |<span data-ttu-id="0c3f8-188">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-188">Yes</span></span> |
| <span data-ttu-id="0c3f8-189">Set BLOB Properties (Задание свойств службы BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-189">Set Blob Properties</span></span> |<span data-ttu-id="0c3f8-190">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-190">Yes</span></span> |<span data-ttu-id="0c3f8-191">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-191">Yes</span></span> |
| <span data-ttu-id="0c3f8-192">Get BLOB Metadata (Получение метаданных BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-192">Get Blob Metadata</span></span> |<span data-ttu-id="0c3f8-193">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-193">Yes</span></span> |<span data-ttu-id="0c3f8-194">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-194">Yes</span></span> |
| <span data-ttu-id="0c3f8-195">Set BLOB Metadata (Задание метаданных BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-195">Set Blob Metadata</span></span> |<span data-ttu-id="0c3f8-196">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-196">Yes</span></span> |<span data-ttu-id="0c3f8-197">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-197">Yes</span></span> |
| <span data-ttu-id="0c3f8-198">Lease Blob (Аренда BLOB-объекта) (*)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-198">Lease Blob (*)</span></span> |<span data-ttu-id="0c3f8-199">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-199">Yes</span></span> |<span data-ttu-id="0c3f8-200">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-200">Yes</span></span> |
| <span data-ttu-id="0c3f8-201">Создание моментального снимка большого двоичного объекта</span><span class="sxs-lookup"><span data-stu-id="0c3f8-201">Snapshot Blob</span></span> |<span data-ttu-id="0c3f8-202">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-202">Yes</span></span> |<span data-ttu-id="0c3f8-203">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-203">Yes</span></span> |
| <span data-ttu-id="0c3f8-204">Копирование BLOB-объекта</span><span class="sxs-lookup"><span data-stu-id="0c3f8-204">Copy Blob</span></span> |<span data-ttu-id="0c3f8-205">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-205">Yes</span></span> |<span data-ttu-id="0c3f8-206">Да (для исходного и целевого большого двоичного объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-206">Yes (for source and destination blob)</span></span> |
| <span data-ttu-id="0c3f8-207">Прерывание копирования большого двоичного объекта</span><span class="sxs-lookup"><span data-stu-id="0c3f8-207">Abort Copy Blob</span></span> |<span data-ttu-id="0c3f8-208">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-208">No</span></span> |<span data-ttu-id="0c3f8-209">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-209">No</span></span> |
| <span data-ttu-id="0c3f8-210">Delete BLOB (Удаление BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-210">Delete Blob</span></span> |<span data-ttu-id="0c3f8-211">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-211">No</span></span> |<span data-ttu-id="0c3f8-212">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-212">Yes</span></span> |
| <span data-ttu-id="0c3f8-213">Put Block (Вставка блокировки)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-213">Put Block</span></span> |<span data-ttu-id="0c3f8-214">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-214">No</span></span> |<span data-ttu-id="0c3f8-215">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-215">No</span></span> |
| <span data-ttu-id="0c3f8-216">Put Block List (Вставка списка блокировки)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-216">Put Block List</span></span> |<span data-ttu-id="0c3f8-217">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-217">Yes</span></span> |<span data-ttu-id="0c3f8-218">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-218">Yes</span></span> |
| <span data-ttu-id="0c3f8-219">Get Block List (Получение списка блокировки)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-219">Get Block List</span></span> |<span data-ttu-id="0c3f8-220">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-220">Yes</span></span> |<span data-ttu-id="0c3f8-221">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-221">No</span></span> |
| <span data-ttu-id="0c3f8-222">Put Page (Вставка страницы)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-222">Put Page</span></span> |<span data-ttu-id="0c3f8-223">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-223">Yes</span></span> |<span data-ttu-id="0c3f8-224">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-224">Yes</span></span> |
| <span data-ttu-id="0c3f8-225">Get Page Ranges (Получение диапазона страницы)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-225">Get Page Ranges</span></span> |<span data-ttu-id="0c3f8-226">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-226">Yes</span></span> |<span data-ttu-id="0c3f8-227">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-227">Yes</span></span> |

<span data-ttu-id="0c3f8-228">(*) Аренда BLOB-объекта не заменяет ETag на BLOB-объект.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-228">(*) Lease Blob does not change the ETag on a blob.</span></span>  

### <a name="pessimistic-concurrency-for-blobs"></a><span data-ttu-id="0c3f8-229">Пессимистичный параллелизм для BLOB-объектов</span><span class="sxs-lookup"><span data-stu-id="0c3f8-229">Pessimistic concurrency for blobs</span></span>
<span data-ttu-id="0c3f8-230">Для блокировки BLOB-объекта в целях монопольного использования вы можете получить его в [аренду](http://msdn.microsoft.com/library/azure/ee691972.aspx) .</span><span class="sxs-lookup"><span data-stu-id="0c3f8-230">To lock a blob for exclusive use, you can acquire a [lease](http://msdn.microsoft.com/library/azure/ee691972.aspx) on it.</span></span> <span data-ttu-id="0c3f8-231">При получении его в аренду вы можете определить, на какой срок она вам нужна: 15—60 секунд или на неограниченный период, что равносильно монопольной блокировке.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-231">When you acquire a lease, you specify for how long you need the lease: this can be for between 15 to 60 seconds or infinite which amounts to an exclusive lock.</span></span> <span data-ttu-id="0c3f8-232">Вы можете обновить ограниченную аренду, продлив ее, а также освободиться от нее, если она вам более не нужна.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-232">You can renew a finite lease to extend it, and you can release any lease when you are finished with it.</span></span> <span data-ttu-id="0c3f8-233">Служба BLOB-объектов автоматически освобождается от ограниченной аренды после завершения ее срока.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-233">The blob service automatically releases finite leases when they expire.</span></span>  

<span data-ttu-id="0c3f8-234">Аренда разрешает поддержку различных стратегий синхронизации, включая монопольную запись / общее чтение, монопольная запись / монопольное чтение и общую запись / монопольное чтение.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-234">Leases enable different synchronization strategies to be supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</span></span> <span data-ttu-id="0c3f8-235">При наличии аренды служба хранилища включает монопольное чтение (операции put, set и delete), однако, чтобы сделать возможным монопольное чтение, разработчику необходимо обеспечить использование всеми клиентскими приложениями идентификатора аренды, а также наличие действительного идентификатора аренды одновременно только у одного клиента.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-235">Where a lease exists the storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires the developer to ensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</span></span> <span data-ttu-id="0c3f8-236">Операции чтения, не имеющие идентификатора аренды, окажутся в общем чтении.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-236">Read operations that do not include a lease ID result in shared reads.</span></span>  

<span data-ttu-id="0c3f8-237">Следующий фрагмент C#-кода является примером получения на 30 секунд монопольной аренды на BLOB-объект, обновления содержимого BLOB-объекта и освобождения от аренды.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-237">The following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating the content of the blob, and then releasing the lease.</span></span> <span data-ttu-id="0c3f8-238">Если на большом двоичном объекте уже есть действительная аренда, а вы пытаетесь получить новую аренду, то служба BLOB-объектов возвращает статус "HTTP (409) Conflict" (HTTP (409) — конфликт).</span><span class="sxs-lookup"><span data-stu-id="0c3f8-238">If there is already a valid lease on the blob when you try to acquire a new lease, the blob service returns an "HTTP (409) Conflict" status result.</span></span> <span data-ttu-id="0c3f8-239">Полный пример можно скачать на странице **Managing Concurrency using Azure Storage - Sample Application** (Управление параллелизмом с помощью службы хранилища Azure.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-239">The snippet below uses an **AccessCondition** object to encapsulate the lease information when it makes a request to update the blob in the storage service.</span></span>  <span data-ttu-id="0c3f8-240">Полный пример можно скачать здесь: [Управление параллелизмом с помощью службы хранилища Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="0c3f8-240">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update to blob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying to update blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

<span data-ttu-id="0c3f8-241">Если вы пытаетесь совершить операцию записи на арендованном BLOB-объекте, не идентифицировав аренду, неудавшийся запрос возвращается с ошибкой 412.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-241">If you attempt a write operation on a leased blob without passing the lease ID, the request fails with a 412 error.</span></span> <span data-ttu-id="0c3f8-242">Если срок аренды истекает до вызова метода **UploadText**, но вы все еще проходите идентификацию аренды, запрос также завершается неудачей с ошибкой **412**.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-242">Note that if the lease expires before calling the **UploadText** method but you still pass the lease ID, the request also fails with a **412** error.</span></span> <span data-ttu-id="0c3f8-243">Дальнейшая информация об истечении срока аренды и идентификаторов аренды в [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) документации REST.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-243">For more information about managing lease expiry times and lease ids, see the [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST documentation.</span></span>  

<span data-ttu-id="0c3f8-244">Для управления пессимистичным параллелизмом аренда может использоваться в следующих операциях с BLOB-объектами:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-244">The following blob operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="0c3f8-245">Put BLOB (Вставка BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-245">Put Blob</span></span>
* <span data-ttu-id="0c3f8-246">Get BLOB (Получение BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-246">Get Blob</span></span>
* <span data-ttu-id="0c3f8-247">Get BLOB Properties (Получение свойств BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-247">Get Blob Properties</span></span>
* <span data-ttu-id="0c3f8-248">Set BLOB Properties (Задание свойств службы BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-248">Set Blob Properties</span></span>
* <span data-ttu-id="0c3f8-249">Get BLOB Metadata (Получение метаданных BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-249">Get Blob Metadata</span></span>
* <span data-ttu-id="0c3f8-250">Set BLOB Metadata (Задание метаданных BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-250">Set Blob Metadata</span></span>
* <span data-ttu-id="0c3f8-251">Delete BLOB (Удаление BLOB-объекта)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-251">Delete Blob</span></span>
* <span data-ttu-id="0c3f8-252">Put Block (Вставка блокировки)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-252">Put Block</span></span>
* <span data-ttu-id="0c3f8-253">Put Block List (Вставка списка блокировки)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-253">Put Block List</span></span>
* <span data-ttu-id="0c3f8-254">Get Block List (Получение списка блокировки)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-254">Get Block List</span></span>
* <span data-ttu-id="0c3f8-255">Put Page (Вставка страницы)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-255">Put Page</span></span>
* <span data-ttu-id="0c3f8-256">Get Page Ranges (Получение диапазона страницы)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-256">Get Page Ranges</span></span>
* <span data-ttu-id="0c3f8-257">Snapshot Blob (Моментальные снимки BLOB-объектов) — идентификатор аренды не обязателен, если есть аренда</span><span class="sxs-lookup"><span data-stu-id="0c3f8-257">Snapshot Blob - lease ID optional if a lease exists</span></span>
* <span data-ttu-id="0c3f8-258">Copy Blob (Копирование BLOB-объекта) — необходим идентификатор аренды, если есть аренда на целевой BLOB-объект</span><span class="sxs-lookup"><span data-stu-id="0c3f8-258">Copy Blob - lease ID required if a lease exists on the destination blob</span></span>
* <span data-ttu-id="0c3f8-259">Abort Copy Blob (Прерывание копирования BLOB-объекта) — необходим идентификатор аренды, если есть неограниченная аренда на целевой BLOB-объект</span><span class="sxs-lookup"><span data-stu-id="0c3f8-259">Abort Copy Blob - lease ID required if an infinite lease exists on the destination blob</span></span>
* <span data-ttu-id="0c3f8-260">Lease Blob</span><span class="sxs-lookup"><span data-stu-id="0c3f8-260">Lease Blob</span></span>  

### <a name="pessimistic-concurrency-for-containers"></a><span data-ttu-id="0c3f8-261">Пессимистичный параллелизм для контейнеров</span><span class="sxs-lookup"><span data-stu-id="0c3f8-261">Pessimistic concurrency for containers</span></span>
<span data-ttu-id="0c3f8-262">Аренда на контейнеры разрешает поддержку тех же стратегий синхронизации, что и на BLOB-объектах (монопольная запись / общее чтение, монопольная запись / монопольное чтение и общая запись / монопольное чтение), однако, в отличие от BLOB-объектов, служба хранилища применяет монополию только к операциям удаления (delete operations).</span><span class="sxs-lookup"><span data-stu-id="0c3f8-262">Leases on containers enable the same synchronization strategies to be supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs the storage service only enforces exclusivity on delete operations.</span></span> <span data-ttu-id="0c3f8-263">Для удаления контейнера с активной арендой клиент наряду с запросом на удаление должен ввести активный идентификатор аренды.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-263">To delete a container with an active lease, a client must include the active lease ID with the delete request.</span></span> <span data-ttu-id="0c3f8-264">Остальные операции по контейнерам выполняются без введения идентификатора аренды, являясь общими операциями.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-264">All other container operations succeed on a leased container without including the lease ID in which case they are shared operations.</span></span> <span data-ttu-id="0c3f8-265">Если требуется монополия на операции обновления (put или set) или чтения, разработчик должен обеспечить всех клиентов возможностью использования идентификатора аренды, а также наличие действительного идентификатора аренды одновременно только у одного клиента.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-265">If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</span></span>  

<span data-ttu-id="0c3f8-266">Для управления пессимистичным параллелизмом аренда может использоваться в следующих операциях с контейнерами:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-266">The following container operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="0c3f8-267">Delete Container (Удаление контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-267">Delete Container</span></span>
* <span data-ttu-id="0c3f8-268">Get Container Properties (Получение свойств контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-268">Get Container Properties</span></span>
* <span data-ttu-id="0c3f8-269">Get Container Metadata (Получение метаданных контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-269">Get Container Metadata</span></span>
* <span data-ttu-id="0c3f8-270">Определение метаданных контейнера</span><span class="sxs-lookup"><span data-stu-id="0c3f8-270">Set Container Metadata</span></span>
* <span data-ttu-id="0c3f8-271">Get Container ACL (Получение списка управления доступом для контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-271">Get Container ACL</span></span>
* <span data-ttu-id="0c3f8-272">Set Container ACL (Задание списка управления доступом для контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-272">Set Container ACL</span></span>
* <span data-ttu-id="0c3f8-273">Lease Container (Аренда контейнера)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-273">Lease Container</span></span>  

<span data-ttu-id="0c3f8-274">Дополнительные сведения см. в разделах:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-274">For more information see:</span></span>  

* [<span data-ttu-id="0c3f8-275">Указание условных заголовков для операций службы BLOB-объектов</span><span class="sxs-lookup"><span data-stu-id="0c3f8-275">Specifying Conditional Headers for Blob Service Operations</span></span>](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [<span data-ttu-id="0c3f8-276">Аренда контейнера</span><span class="sxs-lookup"><span data-stu-id="0c3f8-276">Lease Container</span></span>](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [<span data-ttu-id="0c3f8-277">Аренда большого двоичного объекта </span><span class="sxs-lookup"><span data-stu-id="0c3f8-277">Lease Blob </span></span>](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-the-table-service"></a><span data-ttu-id="0c3f8-278">Управление параллелизмом в службе таблиц</span><span class="sxs-lookup"><span data-stu-id="0c3f8-278">Managing Concurrency in the Table Service</span></span>
<span data-ttu-id="0c3f8-279">Когда вы работаете с сущностями, служба таблиц использует по умолчанию проверку оптимистичного параллелизма в отличие от службы BLOB-объектов, где вы должны монопольно выбирать проверку оптимистичного параллелизма.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-279">The table service uses optimistic concurrency checks as the default behavior when you are working with entities, unlike the blob service where you must explicitly choose to perform optimistic concurrency checks.</span></span> <span data-ttu-id="0c3f8-280">Другое отличие служб таблиц и BLOB-объектов заключается в том, что вы можете управлять параллельным поведением только сущностей, в то время как в службе BLOB-объектов можно управлять параллелизмом контейнеров и BLOB-объектов.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-280">The other difference between the table and blob services is that you can only manage the concurrency behavior of entities whereas with the blob service you can manage the concurrency of both containers and blobs.</span></span>  

<span data-ttu-id="0c3f8-281">Чтобы использовать оптимистичный параллелизм и проверить, модифицировал ли какой-либо процесс сущность с момента его извлечения из службы табличного хранилища, вы можете использовать значение ETag, которое вы получите при возвращении службой таблиц сущности.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-281">To use optimistic concurrency and to check if another process modified an entity since you retrieved it from the table storage service, you can use the ETag value you receive when the table service returns an entity.</span></span> <span data-ttu-id="0c3f8-282">Для этой команды используется следующая структура:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-282">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="0c3f8-283">Извлеките сущность из службы табличного хранилища. Ответ включает значение ETag, определяющее текущий идентификатор, ассоциирующийся с этой сущностью в службе хранилища.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-283">Retrieve an entity from the table storage service, the response includes an ETag value that identifies the current identifier associated with that entity in the storage service.</span></span>
2. <span data-ttu-id="0c3f8-284">При обновлении сущности включите полученное после выполнения шага 1 значение ETag в обязательный заголовок **If-Match** запроса, отправляемого вами в службу.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-284">When you update the entity, include the ETag value you received in step 1 in the mandatory **If-Match** header of the request you send to the service.</span></span>
3. <span data-ttu-id="0c3f8-285">Служба сравнивает значение ETag запроса с текущим значением ETag сущности.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-285">The service compares the ETag value in the request with the current ETag value of the entity.</span></span>
4. <span data-ttu-id="0c3f8-286">Если текущее значение ETag сущности отличается от ETag в обязательном заголовке запроса **If-Match** , служба возвращает клиенту ошибку 412.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-286">If the current ETag value of the entity is different than the ETag in the mandatory **If-Match** header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="0c3f8-287">Это указывает клиенту на то, что после извлечения клиентом сущности он был обновлен другим процессом.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-287">This indicates to the client that another process has updated the entity since the client retrieved it.</span></span>
5. <span data-ttu-id="0c3f8-288">Если текущее значение сущности совпадает со значением ETag в обязательном заголовке запроса **If-Match** или заголовок **If-Match** содержит подстановочный знак (*), служба выполняет запрошенную операцию и обновляет текущее значение ETag сущности, указывая тем самым на создание версии.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-288">If the current ETag value of the entity is the same as the ETag in the mandatory **If-Match** header in the request or the **If-Match** header contains the wildcard character (*), the service performs the requested operation and updates the current ETag value of the entity to show that it has been updated.</span></span>  

<span data-ttu-id="0c3f8-289">Обратите внимание, что в отличие от службы BLOB-объектов служба таблиц требует от клиента включения заголовка **If-Match** в обновленный запрос.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-289">Note that unlike the blob service, the table service requires the client to include an **If-Match** header in update requests.</span></span> <span data-ttu-id="0c3f8-290">Однако можно принудительно применить безусловное обновление (стратегия "Сохраняются изменения, внесенные последними") и избежать проверки параллелизма, если клиент устанавливает в заголовке **If-Match** подстановочный знак (*), когда делает запрос.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-290">However, it is possible to force an unconditional update (last writer wins strategy) and bypass concurrency checks if the client sets the **If-Match** header to the wildcard character (*) in the request.</span></span>  

<span data-ttu-id="0c3f8-291">Следующий фрагмент C#-кода показывает пользователю сущность, предварительно созданную или извлеченную, с обновленным электронным адресом.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-291">The following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</span></span> <span data-ttu-id="0c3f8-292">Начальная операция по вводу или извлечению сохраняет значение ETag в объекте пользователя, а так как образец использует тот же экземпляр при операции замены, он автоматически отправляет значение ETag назад в службу таблиц, вызывая проверку на нарушение параллелизма.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-292">The initial insert or retrieve operation stores the ETag value in the customer object, and because the sample uses the same object instance when it executes the replace operation, it automatically sends the ETag value back to the table service, enabling the service to check for concurrency violations.</span></span> <span data-ttu-id="0c3f8-293">Если произошло обновление сущности в службе хранилища другим процессом, служба возвращает сообщение о состоянии HTTP 412 (Необходимое условие не выполнено).</span><span class="sxs-lookup"><span data-stu-id="0c3f8-293">If another process has updated the entity in table storage, the service returns an HTTP 412 (Precondition Failed) status message.</span></span>  <span data-ttu-id="0c3f8-294">Полный пример можно скачать здесь: [Управление параллелизмом с помощью службы хранилища Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="0c3f8-294">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

<span data-ttu-id="0c3f8-295">Для явного отключения проверки на параллелизм вам следует задать характеристику **ETag** объекта **employee** в виде "*", прежде чем выполнить операцию замены.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-295">To explicitly disable the concurrency check, you should set the **ETag** property of the **employee** object to "*" before you execute the replace operation.</span></span>  

```csharp
customer.ETag = "*";  
```

<span data-ttu-id="0c3f8-296">Таблица показывает, как операции сущности в таблице используют значения ETag:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-296">The following table summarizes how the table entity operations use ETag values:</span></span>

| <span data-ttu-id="0c3f8-297">Операция</span><span class="sxs-lookup"><span data-stu-id="0c3f8-297">Operation</span></span> | <span data-ttu-id="0c3f8-298">Returns ETag value (Возврат значения ETag)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-298">Returns ETag value</span></span> | <span data-ttu-id="0c3f8-299">Requires If-Match request header (Требует заголовок запроса If-Match)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-299">Requires If-Match request header</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="0c3f8-300">Query Entities (Сущности запроса)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-300">Query Entities</span></span> |<span data-ttu-id="0c3f8-301">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-301">Yes</span></span> |<span data-ttu-id="0c3f8-302">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-302">No</span></span> |
| <span data-ttu-id="0c3f8-303">Insert Entity (Вставка сущности )</span><span class="sxs-lookup"><span data-stu-id="0c3f8-303">Insert Entity</span></span> |<span data-ttu-id="0c3f8-304">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-304">Yes</span></span> |<span data-ttu-id="0c3f8-305">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-305">No</span></span> |
| <span data-ttu-id="0c3f8-306">Update Entity (Обновление сущности)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-306">Update Entity</span></span> |<span data-ttu-id="0c3f8-307">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-307">Yes</span></span> |<span data-ttu-id="0c3f8-308">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-308">Yes</span></span> |
| <span data-ttu-id="0c3f8-309">Merge Entity (Слияние сущностей)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-309">Merge Entity</span></span> |<span data-ttu-id="0c3f8-310">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-310">Yes</span></span> |<span data-ttu-id="0c3f8-311">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-311">Yes</span></span> |
| <span data-ttu-id="0c3f8-312">Delete Entity (Удаление сущности)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-312">Delete Entity</span></span> |<span data-ttu-id="0c3f8-313">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-313">No</span></span> |<span data-ttu-id="0c3f8-314">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-314">Yes</span></span> |
| <span data-ttu-id="0c3f8-315">Insert or Replace Entity (Вставка или замена сущности)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-315">Insert or Replace Entity</span></span> |<span data-ttu-id="0c3f8-316">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-316">Yes</span></span> |<span data-ttu-id="0c3f8-317">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-317">No</span></span> |
| <span data-ttu-id="0c3f8-318">Insert or Merge Entity (Вставка или слияние сущностей)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-318">Insert or Merge Entity</span></span> |<span data-ttu-id="0c3f8-319">Да</span><span class="sxs-lookup"><span data-stu-id="0c3f8-319">Yes</span></span> |<span data-ttu-id="0c3f8-320">Нет</span><span class="sxs-lookup"><span data-stu-id="0c3f8-320">No</span></span> |

<span data-ttu-id="0c3f8-321">Обратите внимание, что операции **Insert or Replace Entity** и **Insert or Merge Entity** *не* проверяют параллелизм, так как они не отправляют значение ETag в службу таблиц.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-321">Note that the **Insert or Replace Entity** and **Insert or Merge Entity** operations do *not* perform any concurrency checks because they do not send an ETag value to the table service.</span></span>  

<span data-ttu-id="0c3f8-322">В основном разработчики, использующие таблицы, при разработке масштабируемых приложений должны полагаться на оптимистичный параллелизм.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-322">In general developers using tables should rely on optimistic concurrency when developing scalable applications.</span></span> <span data-ttu-id="0c3f8-323">При необходимости в пессимистической блокировке, разработчики при получении доступа к таблицам могут сделать следующее: назначить для каждой таблицы определенный BLOB-объект и попытаться арендовать BLOB-объект до операции на таблице.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-323">If pessimistic locking is needed, one approach developers can take when accessing Tables is to assign a designated blob for each table and try to take a lease on the blob before operating on the table.</span></span> <span data-ttu-id="0c3f8-324">Этот подход требует, чтобы приложение обеспечило путям доступа ко всем данным возможность получить аренду до операций на таблице.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-324">This approach does require the application to ensure all data access paths obtain the lease prior to operating on the table.</span></span> <span data-ttu-id="0c3f8-325">Вам следует обратить внимание на то, что минимальный срок аренды составляет 15 секунд, что необходимо тщательно изучить для масштабируемости.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-325">You should also note that the minimum lease time is 15 seconds which requires careful consideration for scalability.</span></span>  

<span data-ttu-id="0c3f8-326">Дополнительные сведения см. в разделах:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-326">For more information see:</span></span>  

* [<span data-ttu-id="0c3f8-327">Операции с сущностями</span><span class="sxs-lookup"><span data-stu-id="0c3f8-327">Operations on Entities</span></span>](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-the-queue-service"></a><span data-ttu-id="0c3f8-328">Управление параллелизмом в службе очередей</span><span class="sxs-lookup"><span data-stu-id="0c3f8-328">Managing Concurrency in the Queue Service</span></span>
<span data-ttu-id="0c3f8-329">Одним из сценариев, в котором параллелизм является проблемой, является служба очередей, в которой из очереди получают сообщения несколько клиентов.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-329">One scenario in which concurrency is a concern in the queueing service is where multiple clients are retrieving messages from a queue.</span></span> <span data-ttu-id="0c3f8-330">Когда сообщение извлекается из очереди, ответ включает в себя сообщение и значение подтверждения получения, необходимое для удаления очереди.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-330">When a message is retrieved from the queue, the response includes the message and a pop receipt value, which is required to delete the message.</span></span> <span data-ttu-id="0c3f8-331">Сообщение не удаляется из очереди автоматически, но после извлечения оно становится невидимым для других клиентов на интервал времени, установленный параметрами visibilitytimeout (время ожидания видимости).</span><span class="sxs-lookup"><span data-stu-id="0c3f8-331">The message is not automatically deleted from the queue, but after it has been retrieved, it is not visible to other clients for the time interval specified by the visibilitytimeout parameter.</span></span> <span data-ttu-id="0c3f8-332">Предполагается, что клиент, извлекший сообщение, удалит его после обработки до времени, указанного элементом ответа TimeNextVisible и рассчитанного на основе значения параметра visibilitytimeout.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-332">The client that retrieves the message is expected to delete the message after it has been processed, and before the time specified by the TimeNextVisible element of the response, which is calculated based on the value of the visibilitytimeout parameter.</span></span> <span data-ttu-id="0c3f8-333">Значение visibilitytimeout добавляется ко времени, за которое извлекается сообщение, для определения значения TimeNextVisible.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-333">The value of visibilitytimeout is added to the time at which the message is retrieved to determine the value of TimeNextVisible.</span></span>  

<span data-ttu-id="0c3f8-334">Служба очередей не имеет поддержки ни оптимистического, ни пессимистичного параллелизма, поэтому клиент, обрабатывающий сообщение, извлеченное из очереди, должен обеспечить обработку сообщения идемпотентным образом.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-334">The queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</span></span> <span data-ttu-id="0c3f8-335">Стратегия "Сохраняются изменения, внесенные последними" используется для обновления операций, таких как SetQueueServiceProperties, SetQueueMetaData, SetQueueACL и UpdateMessage.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-335">A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</span></span>  

<span data-ttu-id="0c3f8-336">Дополнительные сведения см. в разделах:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-336">For more information see:</span></span>  

* [<span data-ttu-id="0c3f8-337">REST API службы очередей</span><span class="sxs-lookup"><span data-stu-id="0c3f8-337">Queue Service REST API</span></span>](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [<span data-ttu-id="0c3f8-338">Получение сообщений</span><span class="sxs-lookup"><span data-stu-id="0c3f8-338">Get Messages</span></span>](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-the-file-service"></a><span data-ttu-id="0c3f8-339">Управление параллелизмом в файловой службе</span><span class="sxs-lookup"><span data-stu-id="0c3f8-339">Managing Concurrency in the File Service</span></span>
<span data-ttu-id="0c3f8-340">Доступ к файловой службе можно получить с помощью двух протоколов конечной точки — SMB и REST.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-340">The file service can be accessed using two different protocol endpoints – SMB and REST.</span></span> <span data-ttu-id="0c3f8-341">Служба REST не поддерживает ни оптимистическую, ни пессимистическую блокировки, и все обновления происходят по стратегии "Сохраняются изменения, внесенные последними".</span><span class="sxs-lookup"><span data-stu-id="0c3f8-341">The REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</span></span> <span data-ttu-id="0c3f8-342">Клиент SMB, монтирующий общий ресурс, может использовать механизм блокировки файловой системы для управления доступом к общим файлам, включая возможность пессимистической блокировки.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-342">SMB clients that mount file shares can leverage file system locking mechanisms to manage access to shared files – including the ability to perform pessimistic locking.</span></span> <span data-ttu-id="0c3f8-343">При открытии файла клиентом SMB он определяет как доступ к файлам, так и режим общего доступа.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-343">When an SMB client opens a file, it specifies both the file access and share mode.</span></span> <span data-ttu-id="0c3f8-344">Параметры доступа к файлам "Write" или "Read/Write" ("Для записи" или "Для чтения и записи"), а также режима совместного использования файлам "None" ("Ни один") приводят к блокировке файла клиентом SMB до закрытия файла.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-344">Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in the file being locked by an SMB client until the file is closed.</span></span> <span data-ttu-id="0c3f8-345">Если попытаться осуществить операцию REST на файле, заблокированном клиентом, SMB служба REST вернет код состояния 409 (конфликт) с кодом ошибки SharingViolation.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-345">If REST operation is attempted on a file where an SMB client has the file locked the REST service will return status code 409 (Conflict) with error code SharingViolation.</span></span>  

<span data-ttu-id="0c3f8-346">При открытии клиентом SMB файла для удаления она отмечает файл как "ожидающий удаления" до тех пор, пока все остальные клиенты SMB, открывшие дескрипторы на файл, закроются.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-346">When an SMB client opens a file for delete, it marks the file as pending delete until all other SMB client open handles on that file are closed.</span></span> <span data-ttu-id="0c3f8-347">Пока файл отмечен как "ожидающий удаления", любая операция REST на этом файле вернется кодом состояния 409 (конфликт) и с кодом ошибки SMBDeletePending.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-347">While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</span></span> <span data-ttu-id="0c3f8-348">Код состояния 404 (не найден) не возвращается, так как клиент SMB не может удалить флажок "ожидающий удаления" с файла до его закрытия.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-348">Status code 404 (Not Found) is not returned since it is possible for the SMB client to remove the pending deletion flag prior to closing the file.</span></span> <span data-ttu-id="0c3f8-349">Иными словами, получение кода состояния 404 (не найден) возможно только после удаления файла.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-349">In other words, status code 404 (Not Found) is only expected when the file has been removed.</span></span> <span data-ttu-id="0c3f8-350">Заметьте, что пока файл находится в состоянии "ожидающий удаления" SMB, он не будет быть включен в результаты операции "Перечислить файлы". Обратите также внимание на то, что операции REST Delete File (Удалить файлы) и REST Delete Directory (удалить папку) выполняются атомарным образом и не ведут к состоянию "ожидающий удаления".</span><span class="sxs-lookup"><span data-stu-id="0c3f8-350">Note that while a file is in a SMB pending delete state, it will not be included in the List Files results.Also note that the REST Delete File and REST Delete Directory operations are committed atomically and do not result in pending delete state.</span></span>  

<span data-ttu-id="0c3f8-351">Дополнительные сведения см. в разделах:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-351">For more information see:</span></span>  

* [<span data-ttu-id="0c3f8-352">Управление блокировкой файлов</span><span class="sxs-lookup"><span data-stu-id="0c3f8-352">Managing File Locks</span></span>](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a><span data-ttu-id="0c3f8-353">Сводка и дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="0c3f8-353">Summary and Next Steps</span></span>
<span data-ttu-id="0c3f8-354">Служба хранилища Microsoft Azure разработана для удовлетворения потребностей большинства сложных интерактивных приложений, при этом не принуждает разработчиков нарушать или пересматривать ключевые допущения в разработках, такие как параллелизм и согласованность данных, которые уже учтены.</span><span class="sxs-lookup"><span data-stu-id="0c3f8-354">The Microsoft Azure Storage service has been designed to meet the needs of the most complex online applications without forcing developers to compromise or rethink key design assumptions such as concurrency and data consistency that they have come to take for granted.</span></span>  

<span data-ttu-id="0c3f8-355">Полный образец приложения, упомянутый в блоге:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-355">For the complete sample application referenced in this blog:</span></span>  

* [<span data-ttu-id="0c3f8-356">Управление параллелизмом с помощью службы хранилища Azure: пример приложения</span><span class="sxs-lookup"><span data-stu-id="0c3f8-356">Managing Concurrency using Azure Storage - Sample Application</span></span>](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

<span data-ttu-id="0c3f8-357">Подробнее о службе хранения Azure:</span><span class="sxs-lookup"><span data-stu-id="0c3f8-357">For more information on Azure Storage see:</span></span>  

* [<span data-ttu-id="0c3f8-358">Домашняя страница службы хранилища Microsoft Azure</span><span class="sxs-lookup"><span data-stu-id="0c3f8-358">Microsoft Azure Storage Home Page</span></span>](https://azure.microsoft.com/services/storage/)
* [<span data-ttu-id="0c3f8-359">Введение в хранилище Azure</span><span class="sxs-lookup"><span data-stu-id="0c3f8-359">Introduction to Azure Storage</span></span>](storage-introduction.md)
* <span data-ttu-id="0c3f8-360">Приступая к работе с хранилищем: [большой двоичный объект](storage-dotnet-how-to-use-blobs.md), [таблица](storage-dotnet-how-to-use-tables.md), [очереди](storage-dotnet-how-to-use-queues.md) и [файлы](storage-dotnet-how-to-use-files.md).</span><span class="sxs-lookup"><span data-stu-id="0c3f8-360">Storage Getting Started for [Blob](storage-dotnet-how-to-use-blobs.md), [Table](storage-dotnet-how-to-use-tables.md),  [Queues](storage-dotnet-how-to-use-queues.md), and [Files](storage-dotnet-how-to-use-files.md)</span></span>
* <span data-ttu-id="0c3f8-361">Архитектура службы хранилища — [служба хранилища Azure: высокодоступная служба облачного хранения со строгой согласованностью](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span><span class="sxs-lookup"><span data-stu-id="0c3f8-361">Storage Architecture – [Azure Storage : A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span></span>

