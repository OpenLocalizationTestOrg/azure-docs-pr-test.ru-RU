---
title: "Шифрование на стороне aaaClient в .NET Framework для хранилища Microsoft Azure | Документы Microsoft"
description: "Hello клиентская библиотека хранилища Azure для .NET поддерживает шифрования на стороне клиента и интеграции с хранилищем ключей Azure для обеспечения максимальной безопасности для приложений хранилища Azure."
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: becfccca-510a-479e-a798-2044becd9a64
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: c09246f43801e17aff96ea453182d11ffbf5e420
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="client-side-encryption-and-azure-key-vault-for-microsoft-azure-storage"></a>Шифрование на стороне клиента для службы хранилища Microsoft Azure
[!INCLUDE [storage-selector-client-side-encryption-include](../../../includes/storage-selector-client-side-encryption-include.md)]

## <a name="overview"></a>Обзор
Hello [клиентская библиотека хранилища Azure для пакета .NET Nuget](https://www.nuget.org/packages/WindowsAzure.Storage) поддерживает шифрование данных в клиентские приложения перед загрузкой tooAzure хранилища и расшифровки данных при загрузке toohello клиента. Библиотека Hello также поддерживает интеграцию с [хранилище ключей Azure](https://azure.microsoft.com/services/key-vault/) для управления ключами учетной записи хранилища.

Пошаговый учебник, описываются шаги процесса hello шифрования с помощью шифрования на стороне клиента и хранилищем ключей Azure BLOB-объектов см. в разделе [шифрования и расшифровки больших двоичных объектов в хранилище Microsoft Azure с помощью хранилища ключей Azure](../blobs/storage-encrypt-decrypt-blobs-key-vault.md).

Сведения о шифровании на стороне клиента с помощью Java см. в статье [Шифрование на стороне клиента с помощью Java для службы хранилища Microsoft Azure](storage-client-side-encryption-java.md).

## <a name="encryption-and-decryption-via-hello-envelope-technique"></a>Шифрование и расшифровка через метод конверт hello
процессы Hello шифрования и расшифровки выполните метод конверт hello.

### <a name="encryption-via-hello-envelope-technique"></a>Шифрование через метод конверт hello
Шифрование через метод конверт hello работает в hello следующими способами:

1. Клиентская библиотека хранилища Azure Hello создает ключ шифрования содержимого (CEK), который является симметричным ключом, используйте один раз.
2. Данные пользователя шифруются с помощью этого ключа CEK.
3. Hello CEK заключается в оболочку (зашифрованный) с помощью ключа hello ключа шифрования (ключ обмена Ключами). Hello KEK идентифицируется идентификатора ключа; его можно пары асимметричных ключей или симметричного ключа и может быть управлять локально и хранятся в хранилищах ключей Azure.
   
    Клиентская библиотека хранилища Hello сам никогда не имеет доступа tooKEK. Библиотека Hello вызывает hello упаковка ключа алгоритма, предоставляемые хранилища ключей. Пользователи могут выбирать toouse настраиваемых поставщиков для ключа упаковки и развертывания классом при необходимости.

4. Hello зашифрованные данные будет отправлен службе toohello хранилища Azure. Hello упакованного ключа и некоторые метаданные дополнительное шифрование хранятся как метаданные (blob) либо интерполируются с hello зашифрованные данные (очереди сообщений и сущностей таблиц).

### <a name="decryption-via-hello-envelope-technique"></a>Расшифровка через метод конверт hello
Расшифровка через метод конверт hello работает в hello следующими способами:

1. Hello клиентская библиотека предполагает, что этот пользователь hello управляет ключ hello ключа шифрования (ключ обмена Ключами) локально или в хранилищах Azure ключ. Hello пользователя не требуется определенного ключа hello tooknow, который использовался для шифрования. Вместо этого можно настроить и использовать ключа Сопоставитель, который разрешает tookeys разные идентификаторы ключей.
2. Клиентская библиотека Hello загружает hello зашифрованные данные вместе с материалами шифрования, хранящиеся в службе hello.
3. ключ шифрования перенесенного содержимого Hello (CEK) — затем распаковать (расшифрованные) с помощью ключа шифрования ключа (ключ обмена Ключами) "hello". Здесь снова, hello клиентская библиотека не имеет доступа tooKEK. Он просто вызывает hello пользовательских или распаковки алгоритм поставщика хранилища ключей.
4. Hello содержимого ключа шифрования (CEK) будет использовать toodecrypt hello шифрования пользовательских данных.

## <a name="encryption-mechanism"></a>Механизм шифрования
Клиентская библиотека хранилища Hello использует [AES](http://en.wikipedia.org/wiki/Advanced_Encryption_Standard) в порядке tooencrypt пользовательских данных. Говоря более конкретно, это режим [цепочки цифровых блоков или CBC](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28CBC.29) вместе с AES. Каждая служба работает по-разному, поэтому каждая служба рассматривается отдельно.

### <a name="blobs"></a>BLOB-объекты
Клиентская библиотека Hello в настоящее время поддерживает шифрование всего больших двоичных объектов только. В частности, шифрование поддерживается, если пользователи используют hello **UploadFrom*** методы или hello **OpenWrite** метод. Что касается загрузок, то поддерживаются как полные, так и диапазонные загрузки.

Во время шифрования hello клиентская библиотека создаст случайных вектор инициализации (IV) из 16 байтов, вместе с ключом шифрования произвольного содержимого (CEK) 32 байта и выполнять шифрование конвертов hello данных большого двоичного объекта с помощью этих сведений. Hello изолировано CEK и некоторые метаданные дополнительное шифрование затем сохраняются как метаданные вместе с hello зашифрованный BLOB-объект в службе hello больших двоичных объектов.

> [!WARNING]
> Если вы изменяете или отправке метаданные для большого двоичного объекта hello, требуется tooensure, что эти метаданные сохраняются. При отправке новых метаданных без метаданных hello упакованного CEK, вектор Инициализации и другие метаданные будут потеряны и содержимое большого двоичного объекта hello никогда не будет извлекаемые еще раз.
> 
> 

Загрузка BLOB-объект зашифрованного подразумевает получение содержимого hello hello весь большой двоичный объект с помощью hello **DownloadTo***/**BlobReadStream** удобства методы. Hello упакованного CEK без оболочки и использовать в сочетании с hello вектор Инициализации (хранятся в виде метаданных большого двоичного объекта в этом случае) tooreturn hello расшифровать данные toohello пользователи.

Загрузка произвольный диапазон (**DownloadRange*** методы) в hello зашифрованный BLOB-объект состоит в настройке диапазона hello, предоставляемых пользователями в порядке tooget небольшой объем дополнительных данных, которые можно использовать toosuccessfully расшифровать hello Запрошенный диапазон.

Все типы больших двоичных объектов (блочные, страничные и инкрементируемые) могут быть зашифрованы и расшифрованы с помощью этой схемы.

### <a name="queues"></a>Очереди
Так как очередь сообщений может иметь любой формат, hello клиентская библиотека определяет пользовательский формат, который включает в текст сообщения hello hello вектор инициализации (IV) и ключа шифрования зашифрованного содержимого hello (CEK).

Во время шифрования hello клиентская библиотека создает случайные IV 16 байтов вместе с случайных CEK 32 байта и выполняет шифрование конвертов для текста сообщения hello очереди, используя эту информацию. Hello изолировано CEK и некоторые метаданные дополнительное шифрование затем добавляются toohello зашифрованные очереди сообщений. Это измененное сообщение (см. ниже) хранится на службу hello.

    <MessageText>{"EncryptedMessageContents":"6kOu8Rq1C3+M1QO4alKLmWthWXSmHV3mEfxBAgP9QGTU++MKn2uPq3t2UjF1DO6w","EncryptionData":{…}}</MessageText>

Во время расшифровки упакованный ключ hello извлечено из очереди сообщения hello и без оболочки. Hello IV также извлекаются из очереди сообщения hello и используются вместе с данные hello без оболочки ключа toodecrypt hello очереди сообщений. Обратите внимание, что метаданные шифрования hello мал (под 500 байт), пока учитываются hello ограничение 64 КБ для очереди сообщений, hello влияние должно быть управляемым.

### <a name="tables"></a>Таблицы
Здравствуйте клиента библиотека поддерживает шифрование свойств сущности, для вставки операций и замены.

> [!NOTE]
> Слияние в настоящее время не поддерживается. Так как подмножество свойств может зашифрованные ранее с помощью другой ключ, просто слияние новых свойств hello и обновление метаданных hello приведет к потере данных. Слияние либо требует внесения дополнительных службы вызывает tooread hello существующих сущностей из службы hello, либо с помощью нового ключа каждого свойства, которые не подходят для повышения производительности.
> 
> 

Шифрование табличных данных выполняется следующим образом.  

1. Пользователи указывают toobe свойства hello зашифрованы.
2. Клиентская библиотека Hello приводит к возникновению случайных вектор инициализации (IV) 16 байтов вместе с случайных ключ шифрования содержимого (CEK) 32 байта для каждой сущности и выполняет шифрование конвертов toobe отдельные свойства hello зашифрованные путем наследования новый вектор Инициализации, на свойство. Свойство Hello шифрования, хранимые как двоичные данные.
3. Hello изолировано CEK и некоторые метаданные дополнительное шифрование затем сохраняются как два дополнительных свойства зарезервированным. Первый зарезервированного свойства Hello (_ClientEncryptionMetadata1) является строковое свойство, которое содержит сведения hello IV, версию и упакованный ключ. второй зарезервированного свойства Hello (_ClientEncryptionMetadata2) является двоичное свойство, которое содержит hello сведения о свойствах hello, которые зашифрованы. Информация Hello в это второе свойство (_ClientEncryptionMetadata2) является сам по себе зашифрован.
4. Из-за toothese дополнительные зарезервированные свойства, необходимые для шифрования пользователи теперь могут иметь только 250 пользовательские свойства вместо 252. общий размер Hello hello объекта должен быть меньше 1 МБ.

Обратите внимание, что зашифрованы могут быть только строковые свойства. Если других типов свойств toobe зашифрованы, они должны быть преобразованный toostrings. Hello зашифрованные строки хранятся в службе hello как двоичные свойства и их преобразование задней toostrings после расшифровки.

Для таблиц Кроме toohello политики шифрования, пользователи должны указать toobe свойства hello зашифрованы. Это можно сделать путем указания атрибута [PropertyAttribute] \(для сущностей POCO, которые являются производными от TableEntity) или с помощью сопоставителя шифрования в параметрах запроса. Сопоставитель шифрования — это делегат, который получает ключ секции, ключ строки и имя свойства, а затем возвращает логическое значение, которое указывает, следует ли это свойство шифровать. Во время шифрования hello клиентской библиотеки будет использовать этот toodecide сведения ли свойства должны быть зашифрованы при записи toohello сети. Делегат Hello также предоставляет возможность hello логики вокруг как свойства шифруются. (Например, если значение равно X, то шифровать свойство А; в противном случае шифровать свойства А и В.) Обратите внимание, что он является не обязательным tooprovide эти сведения при чтении или выполнения запросов к сущностям.

### <a name="batch-operations"></a>Пакетные операции
В пакетных операций hello того же ключа обмена Ключами будет использоваться для всех строк hello в пакетной операции, так как клиентская библиотека hello допускает только один объект параметров (и следовательно одной политики или ключ обмена Ключами) в пакетной операции. Тем не менее клиентская библиотека hello внутренне создаст новый произвольного вектора Инициализации и случайных CEK каждой строки в пакете hello. Пользователи также могут выбирать tooencrypt различные свойства для каждой операции в пакете hello, определив это поведение в сопоставителе шифрования hello.

### <a name="queries"></a>Запросы
tooperform операций запроса, необходимо указать Сопоставитель ключа, может tooresolve все hello ключей в результирующем наборе hello. Если сущность, содержащиеся в результатах запроса hello не удается разрешить tooa поставщика, клиентская библиотека hello вызовет ошибку. Для любого запроса, который выполняет проекций на стороне сервера hello клиентская библиотека будет добавить свойства метаданных hello специальные шифрования (_ClientEncryptionMetadata1 и _ClientEncryptionMetadata2) с toohello выбранные столбцы по умолчанию.

## <a name="azure-key-vault"></a>Хранилище ключей Azure
Хранилище ключей Azure помогает защитить криптографические ключи и секреты, используемые облачными приложениями и службами. Хранилище ключей Azure позволяет шифровать ключи и секреты (например, ключи проверки подлинности, ключи учетных записей хранения, ключи шифрования данных, PFX-файлы и пароли), используя ключи, защищенные аппаратными модулями безопасности. Дополнительные сведения см. в статье [Что такое хранилище ключей Azure?](../../key-vault/key-vault-whatis.md)

Клиентская библиотека хранилища Hello использует библиотеки ядра hello хранилище ключей в порядке tooprovide общей инфраструктуры в Azure для управления ключами. Пользователи также будут hello дополнительное преимущество использования библиотеки расширений hello хранилища ключей. Библиотека расширения Hello предоставляет полезные функции вокруг простой и удобный симметричные/RSA локальной и ключа поставщиков облачных служб, а также с помощью статистической обработки и кэширования.

### <a name="interface-and-dependencies"></a>Интерфейс и зависимости
Существует три пакета хранилища ключей:

* Microsoft.Azure.KeyVault.Core содержит hello IKey и IKeyResolver. Это небольшой пакет без зависимостей. Hello клиентская библиотека хранилища для .NET определяет его как зависимость.
* Microsoft.Azure.KeyVault содержит hello REST хранилища ключей клиента.
* Microsoft.Azure.KeyVault.Extensions содержит код расширения, который включает реализации криптографических алгоритмов, а также ключи RSAKey и SymmetricKey. Он зависит от пространства имен основных компонентов и KeyVault hello и предоставляет функциональные возможности toodefine Сопоставитель aggregate (при необходимости пользователи toouse несколько поставщиков ключей) и кэширования ключей арбитр конфликтов. Несмотря на то, что клиентская библиотека хранилища hello не зависит от непосредственно этого пакета, если пользователи обратиться toostore toouse хранилище ключей Azure свои ключи или toouse hello хранилище ключей расширения tooconsume hello в локальных и облачных поставщиков служб шифрования, им потребуется этот пакет.

Хранилище ключей разработано для главных ключей, и ограничения регулирования, связанные с хранилищем ключей, учитывают это. При выполнении шифрования на стороне клиента с хранилищем ключей, предпочтительной моделью hello — toouse симметричный главные ключи хранятся в виде секретов в хранилище ключей и в локальном кэше. Пользователи должны выполнять hello следующее:

1. Создание секрета в автономном режиме и отправьте его tooKey хранилища.
2. Используйте базовый идентификатор секрета hello как tooresolve параметр hello текущей версии hello секрет для шифрования и кэшировать информацию в локально. Использовать CachingKeyResolver для кэширования; пользователи являются не ожидаемый tooimplement свою собственную кэширование логику.
3. Использование кэширования сопоставителя hello в качестве ввода при создании политики шифрования hello.

Дополнительные сведения об использовании хранилища ключей можно найти в hello [образцы кода шифрования](https://github.com/Azure/azure-storage-net/tree/master/Samples/GettingStarted/EncryptionSamples).

## <a name="best-practices"></a>Рекомендации
Поддержка шифрования доступен только в клиентской библиотеке hello хранилища для .NET. Windows Phone и среда выполнения Windows в настоящее время не поддерживают шифрование.

> [!IMPORTANT]
> Учтите следующие важные моменты при использовании шифрования на стороне клиента.
> 
> * Если чтение из или написанием tooan зашифрован blob, передачи всего большого двоичного объекта с помощью команд и команды загрузки диапазона или целые больших двоичных объектов. Избежать написания tooan зашифрованный BLOB-объект с помощью протокола операции, такие как Put, поместить список блокировок, записи страниц, снимите страниц или добавить блок; в противном случае может привести к повреждению hello зашифрованный BLOB-объект и не мог прочитать.
> * Для таблиц существуют аналогичные ограничения. Быть тщательно toonot зашифрованные свойства без обновления метаданных шифрования hello.
> * Если задать метаданные для зашифрованных hello большого двоичного объекта, могут быть перезаписаны hello связанные с шифрованием метаданных, необходимых для расшифровки, так как не аддитивны помещение метаданных. Это также касается моментальных снимков. Не указывайте метаданные во время создания моментального снимка зашифрованного большого двоичного объекта. Если должны быть заданы метаданные, будет убедиться, что hello toocall **FetchAttributes** tooget первый метод hello текущих метаданных шифрования и избежать параллельных операций записи, во время метаданных.
> * Включить hello **RequireEncryption** свойство в параметры запроса по умолчанию hello для пользователей, которые должны работать только с зашифрованных данных. См. дополнительные сведения ниже.
> 
> 

## <a name="client-api--interface"></a>API-интерфейс клиента / интерфейс
При создании объекта EncryptionPolicy пользователи могут предоставить только ключ (который реализует IKey), только сопоставитель (который реализует IKeyResolver) или оба этих объекта. IKey — hello базовый тип ключа, определяется с помощью идентификатора ключа и предоставляющий hello логику для упаковки и развертывания. IKeyResolver — используется tooresolve ключ во время расшифровки hello. IKeyResolver определяет метод, который возвращает IKey в зависимости от идентификатора ключа. Это обеспечивает toochoose возможность hello пользователей между несколько ключей, управление которыми осуществляется в нескольких местах.

* Для шифрования всегда используется ключ hello и hello отсутствия ключа приведет к ошибке.
* Для расшифровки:
  * Сопоставитель ключа Hello вызывается в том случае, если указан ключ tooget hello. Если указан Сопоставитель hello, но нет сопоставления для идентификатора ключа hello, возникает ошибка.
  * Если Сопоставитель не указан, но указанный ключ, ключ hello используется в том случае, если ее идентификатор совпадает с идентификатором ключа требуется hello. Если идентификатор hello не совпадают, возникает ошибка.

Hello [образцы шифрования](https://github.com/Azure/azure-storage-net/tree/master/Samples/GettingStarted/EncryptionSamples) демонстрируют более подробные сценарии конца в конец BLOB-объектов, очередей и таблиц, наряду с интеграцией хранилища ключей.

### <a name="requireencryption-mode"></a>Режим RequireEncryption
При необходимости можно включить режим работы, где все передачи и загрузки должны быть зашифрованы. В этом режиме не удастся попыток tooupload данные без шифрования политики или загрузки данных, не шифруются на службу hello на приветствия клиента. Hello **RequireEncryption** это поведение контролируется свойство hello объект параметров запроса. Если ваше приложение будет шифровать все объекты, хранящиеся в хранилище Azure, то можно задать hello **RequireEncryption** свойство параметры запроса по умолчанию hello объекта клиента службы hello. Например, задать **CloudBlobClient.DefaultRequestOptions.RequireEncryption** слишком**true** toorequire шифрования для всех операций BLOB-объектов выполняются с помощью этого объекта клиента.

### <a name="blob-service-encryption"></a>Шифрование службы BLOB-объектов
Создание **BlobEncryptionPolicy** и задайте его в параметрах запроса hello (на API или на уровне клиента с помощью **DefaultRequestOptions**). Все остальные будут обрабатываться клиентской библиотекой hello внутренним образом.

```csharp
// Create hello IKey used for encryption.
 RsaKey key = new RsaKey("private:key1" /* key identifier */);

 // Create hello encryption policy toobe used for upload and download.
 BlobEncryptionPolicy policy = new BlobEncryptionPolicy(key, null);

 // Set hello encryption policy on hello request options.
 BlobRequestOptions options = new BlobRequestOptions() { EncryptionPolicy = policy };

 // Upload hello encrypted contents toohello blob.
 blob.UploadFromStream(stream, size, null, options, null);

 // Download and decrypt hello encrypted contents from hello blob.
 MemoryStream outputStream = new MemoryStream();
 blob.DownloadToStream(outputStream, null, options, null);
```

### <a name="queue-service-encryption"></a>Шифрование службы очередей
Создание **QueueEncryptionPolicy** и задайте его в параметрах запроса hello (на API или на уровне клиента с помощью **DefaultRequestOptions**). Все остальные будут обрабатываться клиентской библиотекой hello внутренним образом.

```csharp
// Create hello IKey used for encryption.
 RsaKey key = new RsaKey("private:key1" /* key identifier */);

 // Create hello encryption policy toobe used for upload and download.
 QueueEncryptionPolicy policy = new QueueEncryptionPolicy(key, null);

 // Add message
 QueueRequestOptions options = new QueueRequestOptions() { EncryptionPolicy = policy };
 queue.AddMessage(message, null, null, options, null);

 // Retrieve message
 CloudQueueMessage retrMessage = queue.GetMessage(null, options, null);
```

### <a name="table-service-encryption"></a>Шифрование службы таблиц
В дополнение к этому toocreating политику шифрования и задание его параметров запроса, необходимо указать **EncryptionResolver** в **TableRequestOptions**, или установите атрибут [EncryptProperty] hello на сущность Hello.

#### <a name="using-hello-resolver"></a>С помощью сопоставителя hello

```csharp
// Create hello IKey used for encryption.
 RsaKey key = new RsaKey("private:key1" /* key identifier */);

 // Create hello encryption policy toobe used for upload and download.
 TableEncryptionPolicy policy = new TableEncryptionPolicy(key, null);

 TableRequestOptions options = new TableRequestOptions()
 {
    EncryptionResolver = (pk, rk, propName) =>
     {
        if (propName == "foo")
         {
            return true;
         }
         return false;
     },
     EncryptionPolicy = policy
 };

 // Insert Entity
 currentTable.Execute(TableOperation.Insert(ent), options, null);

 // Retrieve Entity
 // No need toospecify an encryption resolver for retrieve
 TableRequestOptions retrieveOptions = new TableRequestOptions()
 {
    EncryptionPolicy = policy
 };

 TableOperation operation = TableOperation.Retrieve(ent.PartitionKey, ent.RowKey);
 TableResult result = currentTable.Execute(operation, retrieveOptions, null);
```

#### <a name="using-attributes"></a>Использование атрибутов
Как было сказано выше, если сущность hello реализует TableEntity, затем hello свойства можно снабдить атрибутом hello [EncryptProperty] вместо указания hello **EncryptionResolver**.

```csharp
[EncryptProperty]
 public string EncryptedProperty1 { get; set; }
```

## <a name="encryption-and-performance"></a>Шифрование и производительность
Обратите внимание, что шифрование результатов анализа данных хранилища отрицательно влияет на производительность. Здравствуйте, содержимое, ключ и вектор Инициализации должен быть создан, должен быть зашифрован само содержимое hello и дополнительных метаданных необходимо форматирования и отправки. Эти затраты будут зависеть от hello Кол-во время шифрования данных. Мы рекомендуем клиентам всегда тестировать свои приложения для повышения производительности во время разработки.

## <a name="next-steps"></a>Дальнейшие действия
* [Шифрование и расшифровка BLOB-объектов в хранилище Microsoft Azure с помощью хранилища ключей Azure](../blobs/storage-encrypt-decrypt-blobs-key-vault.md)
* Загрузите hello [клиентская библиотека хранилища Azure для пакета .NET NuGet](https://www.nuget.org/packages/WindowsAzure.Storage)
* Загрузите hello NuGet хранилища ключей Azure [Core](http://www.nuget.org/packages/Microsoft.Azure.KeyVault.Core/), [клиента](http://www.nuget.org/packages/Microsoft.Azure.KeyVault/), и [расширения](http://www.nuget.org/packages/Microsoft.Azure.KeyVault.Extensions/) пакетов  
* Посетите hello [документацию по хранилищу ключей Azure](../../key-vault/key-vault-whatis.md)
