---
title: "Контрольный список: масштабируемость и производительность службы хранилища Azure | Документация Майкрософт"
description: "Контрольный список проверенных методов для использования с хранилищем Azure при разработке приложений с высокой производительностью."
services: storage
documentationcenter: 
author: tamram
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: tamram
ms.openlocfilehash: 6f5a136d1be7a4bb4093baad820271770305b718
ms.sourcegitcommit: 6699c77dcbd5f8a1a2f21fba3d0a0005ac9ed6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a>Производительность хранилища Microsoft Azure и контрольный список масштабируемости
## <a name="overview"></a>Обзор
С момента выпуска служб хранилища Microsoft Azure корпорация Microsoft разработала ряд проверенных принципов для эффективного использования этих служб. Эта статья служит для объединения наиболее важных из них в "контрольный список". Целью этой статьи является помочь разработчикам приложений убедиться, что они используют проверенные методы работы с хранилищем Azure, и найти другие проверенные методы, которые можно использовать в будущем. В данной статье не рассматриваются все возможные способы оптимизации производительности и масштабируемости. Мы не описываем методики, последствия применения которых несущественны, а также методики, которые не нашли широкого применения. Поскольку поведение приложения можно предвидеть в процессе разработки, важно помнить об этом на ранних стадиях во избежание создания проектов, которые приведут к проблемам с производительностью.  

Каждый разработчик приложения, использующий хранилище Azure, должен уделить время прочтению этой статьи и убедиться в том, что его или ее приложение следует всем проверенным методикам, перечисленным ниже.  

## <a name="checklist"></a>Контрольный список
В этой статье методики поделены на следующие группы. Методики, применимые в отношении:  

* всех служб хранилища Azure (BLOB-объектов, таблиц, очередей и файлов);
* BLOB-объекты
* Таблицы
* Очереди  

| Готово | Область | Категория | Вопрос |
| --- | --- | --- | --- |
| &nbsp; | Все службы |Целевые показатели масштабируемости |[Спроектировано ли приложение таким образом, чтобы избежать приближения к целевым показателям масштабируемости?](#subheading1) |
| &nbsp; | Все службы |Целевые показатели масштабируемости |[Помогает ли ваше соглашения об именовании улучшить распределение нагрузки?](#subheading47) |
| &nbsp; | Все службы |Сеть |[Имеют ли клиентские устройства достаточно высокую пропускную способность и низкую степень задержки для достижения необходимой производительности?](#subheading2) |
| &nbsp; | Все службы |Сеть |[Имеют ли клиентские устройства достаточно высокое качество связи?](#subheading3) |
| &nbsp; | Все службы |Сеть |[Расположено ли клиентское приложение "вблизи" учетной записи хранения?](#subheading4) |
| &nbsp; | Все службы |Распространение содержимого |[Используете ли вы CDN для распределения содержимого?](#subheading5) |
| &nbsp; | Все службы |Прямой клиентский доступ |[Используете ли вы SAS и CORS для прямого доступа к хранилищу вместо прокси-сервера?](#subheading6) |
| &nbsp; | Все службы |Caching |[Данные кэширования приложений используются постоянно и изменяются редко?](#subheading7) |
| &nbsp; | Все службы |Caching |[Ваше приложение группирует обновления (кэширует на стороне клиента, а затем загружает в виде большого массива)?](#subheading8) |
| &nbsp; | Все службы |Конфигурация .NET |[Вы настроили свой клиент на использование достаточного количества одновременных подключений?](#subheading9) |
| &nbsp; | Все службы |Конфигурация .NET |[Вы настроили .NET на использование достаточного количества потоков?](#subheading10) |
| &nbsp; | Все службы |Конфигурация .NET |[Используете ли вы .NET 4.5 или более позднюю версию, в которой улучшена функция сборки мусора?](#subheading11) |
| &nbsp; | Все службы |Параллелизм |[Вы уверены в том, что параллелизм ограничен соответствующим образом, чтобы не перегружать ни возможности клиента, ни целевые показатели масштабируемости?](#subheading12) |
| &nbsp; | Все службы |Средства |[Вы используете последние версии клиентских библиотек и инструментов, предоставленных корпорацией Microsoft?](#subheading13) |
| &nbsp; | Все службы |Повторы |[Вы используете политику повтора экспоненциального откладывания для регулирования ошибок и времени ожидания?](#subheading14) |
| &nbsp; | Все службы |Повторы |[Ваше приложение избегает повторов неповторяемых ошибок?](#subheading15) |
| &nbsp; | BLOB-объекты |Целевые показатели масштабируемости |[Имеется большое число клиентов, одновременно обращающихся к одному объекту?](#subheading46) |
| &nbsp; | BLOB-объекты |Целевые показатели масштабируемости |[Ваше приложение придерживается уровня пропускной способности или рабочего целевого показателя масштабируемости для одинарного BLOB-объекта?](#subheading16) |
| &nbsp; | BLOB-объекты |Копирование BLOB-объектов |[Вы копируете BLOB-объекты эффективным способом?](#subheading17) |
| &nbsp; | BLOB-объекты |Копирование BLOB-объектов |[Используете ли вы AzCopy для массового копирования BLOB-объектов?](#subheading18) |
| &nbsp; | BLOB-объекты |Копирование BLOB-объектов |[Используете ли вы импорт и экспорт Azure для перемещения очень больших объемов данных?](#subheading19) |
| &nbsp; | BLOB-объекты |Использование метаданных |[Вы храните часто используемые метаданные, касающиеся BLOB-объектов, в их метаданных?](#subheading20) |
| &nbsp; | BLOB-объекты |Быстрая отправка |[При попытке быстро отправить один BLOB-объект вы осуществляете параллельную отправку блоков?](#subheading21) |
| &nbsp; | BLOB-объекты |Быстрая отправка |[При попытке быстро отправить множество BLOB-объектов вы отправляете BLOB-объекты параллельно?](#subheading22) |
| &nbsp; | BLOB-объекты |Правильный тип BLOB-объекта |[Используете ли вы при необходимости страничные BLOB-объекты или блочные BLOB-объекты?](#subheading23) |
| &nbsp; | Таблицы |Целевые показатели масштабируемости |[Вы приближаетесь к целевым показателям масштабируемости для сущностей в секунду?](#subheading24) |
| &nbsp; | Таблицы |Конфигурация |[Используете ли вы JSON в запросах таблиц?](#subheading25) |
| &nbsp; | Таблицы |Конфигурация |[Вы отключили алгоритм Nagle для повышения производительность небольших запросов?](#subheading26) |
| &nbsp; | Таблицы |Таблицы и разделы |[Вы правильно разделили свои данные?](#subheading27) |
| &nbsp; | Таблицы |Горячие разделы |[Вы избегаете использования инкрементируемых и декрементируемых шаблонов?](#subheading28) |
| &nbsp; | Таблицы |Горячие разделы |[Вы распределяете свои вставки и обновления по нескольким разделам?](#subheading29) |
| &nbsp; | Таблицы |Область запроса |[Вы спроектировали свою схему таким образом, чтобы в большинстве случаев использовать точечные запросы, а табличные запросы использовать редко?](#subheading30) |
| &nbsp; | Таблицы |Плотность запроса |[Ваши запросы обычно только сканируют и возвращают строки, которые будет использовать приложение?](#subheading31) |
| &nbsp; | Таблицы |Ограничение возвращаемых данных |[Используете ли вы фильтрацию, чтобы избежать возвращения ненужных сущностей?](#subheading32) |
| &nbsp; | Таблицы |Ограничение возвращаемых данных |[Используете ли вы проекцию, чтобы избежать возвращения ненужных свойств?](#subheading33) |
| &nbsp; | Таблицы |Денормализация |[Вы денормализовали свои данные таким образом, чтобы избежать неэффективных или множественных запросов чтения при попытке получения данных?](#subheading34) |
| &nbsp; | Таблицы |Вставить, обновить, удалить |[Вы применяете пакетную обработку запросов, которые должны быть транзакционными или могут быть выполнены в одно и то же время, чтобы уменьшить число циклов обработки?](#subheading35) |
| &nbsp; | Таблицы |Вставить, обновить, удалить |[Вы избегаете извлечения сущности только для того, чтобы определить, какую операцию следует выполнить: вставку или обновление?](#subheading36) |
| &nbsp; | Таблицы |Вставить, обновить, удалить |[Рассматривали ли вы возможность хранения ряда данных, которые будут часто извлекаться в качестве свойств вместе с единственной сущностью, а не в виде множества сущностей?](#subheading37) |
| &nbsp; | Таблицы |Вставить, обновить, удалить |[Для сущностей, которые всегда будут извлекаться вместе и могут быть записаны в пакеты (например, данные временных рядов), рассматривали ли вы возможность использования BLOB-объектов вместо таблиц?](#subheading38) |
| &nbsp; | Очереди |Целевые показатели масштабируемости |[Вы достигаете целевых показателей масштабируемости для сообщений в секунду?](#subheading39) |
| &nbsp; | Очереди |Конфигурация |[Вы отключили алгоритм Nagle для повышения производительность небольших запросов?](#subheading40) |
| &nbsp; | Очереди |Размер сообщения |[Ваши сообщения сжаты для повышения производительности очереди?](#subheading41) |
| &nbsp; | Очереди |Массовое получение |[Вы получаете множество сообщений при выполнении одной операции "Получить"?](#subheading42) |
| &nbsp; | Очереди |Частота опроса |[Частота опроса достаточна для уменьшения наблюдаемой задержки приложения?](#subheading43) |
| &nbsp; | Очереди |Сообщение об обновлении |[Используете ли вы UpdateMessage для хранения хода выполнения обработки сообщений, избегая повторной обработки всего сообщения при возникновении ошибки?](#subheading44) |
| &nbsp; | Очереди |Архитектура |[Используете ли вы очереди для того, чтобы сделать все приложение более масштабируемым, не допуская длительных рабочих нагрузок на критическом пути и масштабируя их самостоятельно?](#subheading45) |

## <a name="allservices"></a>Все службы
В этом разделе перечислены проверенные методики, применимые для использования любой из служб хранилища Azure (BLOB-объекты, таблицы, очереди или файлы).  

### <a name="subheading1"></a>Целевые показатели масштабируемости
Каждая служба хранилища Azure имеет целевые показатели масштабируемости по производительности (ГБ), скорости транзакции и пропускной способности. Если приложение достигает одного из целевых показателей масштабируемости или превышает его, оно может столкнуться с увеличением задержки транзакций или запуском механизма регулировки количества запросов. Когда служба хранилища включает механизм регулировки количества запросов приложения, для некоторых транзакций с хранилищем она начинает возвращать коды ошибки "503 Сервер занят" или "500 Время ожидания операции истекло". В этом разделе рассматривается как подход к целевым показателям масштабируемости в целом, так и к целевым показателям масштабируемости в отношении пропускной способности в частности. В следующих разделах, которые касаются отдельных служб хранилища, обсуждаются целевые показатели масштабируемости в контексте конкретной службы:  

* [Пропускная способность больших двоичных объектов и количество запросов в секунду](#subheading16)
* [Сущности таблицы в секунду](#subheading24)
* [Сообщения очереди в секунду](#subheading39)  

#### <a name="sub1bandwidth"></a>Целевой показатель масштабируемости пропускной способности для всех служб
На момент написания данной статьи целевыми показателями пропускной способности в США для учетной записи геоизбыточного хранилища (GRS) является скорость в 10 гигабит в секунду (Гбит/с) на входе (данные, отправленные в учетную запись хранения) и 20 Гбит/с на выходе (данные, отправленные из учетной записи хранения). Для учетной записи локально избыточного хранилища (LRS) эти ограничения выше и составляют до 20 Гбит/с на входе и 30 Гбит/с на выходе.  Международные ограничения пропускной способности могут быть ниже. О них можно узнать на [странице целевых показателей масштабируемости](http://msdn.microsoft.com/library/azure/dn249410.aspx).  Для получения дополнительной информации о параметрах избыточности хранилищ см. ссылки в разделе [Полезные ресурсы](#sub1useful) далее в этой статье.  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a>Действия при достижении целевого показателя масштабируемости
Если приложение достигает целевых показателей масштабируемости, когда речь идет об одной учетной записи хранения, рассмотрите вопрос об использовании одного из следующих подходов:  

* Пересмотрите рабочую нагрузку, которая приводит к достижению приложением целевого показателя масштабируемости или его превышению. Вы можете спроектировать его по-другому, чтобы использовать меньшую полосу пропускания или производительность, или меньшее количество транзакций?
* Если приложение должно превышать один из целевых показателей масштабируемости, следует создать несколько учетных записей хранения и разделить по ним данные приложения. При использовании этого подхода необходимо разработать приложение таким образом, чтобы в будущем для балансировки нагрузки в него можно было добавлять другие учетные записи хранения. На момент написания данной статьи каждая подписка Azure может иметь до 100 учетных записей хранения.  Кроме случаев использования с целью хранения данных, совершения транзакций или передачи данных плата за учетные записи хранения не взимается.
* Если приложение достигает целевых показателей пропускной способности, рассмотрите вопрос сжатия данных на стороне клиента, чтобы уменьшить полосу пропускания, необходимую для отправки данных в службу хранилища.  Обратите внимание, этот способ может как сэкономить полосу пропускания и повысить производительность сети, так и иметь некоторые негативные последствия.  Вам следует оценить влияние на производительность этих дополнительных требований по сжатию и распаковке данных, выполняемых на стороне клиента. Кроме того, хранение сжатых данных может усложнить устранение обнаруженных в них неполадок, так как в этом случае может возникнуть трудность с просмотром сохраненных данных с помощью стандартных инструментов.
* Если приложение достигает целевых показателей масштабируемости, убедитесь в том, что используется экспоненциальная отсрочка для повторов (см. раздел [Повторы](#subheading14)).  Лучше всего сделать так, чтобы ваше приложение никогда не приближалось к целевым показателям масштабируемости (с помощью одного из вышеуказанных методов), но это приведет к тому, что приложение просто не будет продолжать выполнять быстрые повторения, еще более активируя механизм регулировки количества запросов.  

#### <a name="useful-resources"></a>Полезные ресурсы
Приведенные ниже ссылки предоставляют дополнительную информацию о целевых показателях масштабируемости:

* Дополнительные сведения о целевых показателях масштабируемости см. в статье [Целевые показатели масштабируемости и производительности службы хранилища Azure](storage-scalability-targets.md).
* Дополнительные сведения о параметрах избыточности хранилищ см. в статье [Репликация службы хранилища Azure](storage-redundancy.md) и записи блога [Microsoft Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) (Параметры избыточности службы хранилища Microsoft Azure и геоизбыточное хранилище с доступом на чтение).
* Для получения актуальной информации о ценах за использование служб Azure см. страницу [Цены Azure](https://azure.microsoft.com/pricing/overview/).  

### <a name="subheading47"></a>Соглашение об именовании секций
Для масштабирования и распределения нагрузки в системы в хранилище Azure используется схема секционирования на основе диапазонов. Данные распределяются по диапазонам с помощью ключа секции, а затем эти диапазоны распределяются по системе. Это означает, что соглашения об именовании, такие как лексическое упорядочение (например, msftpayroll, msftperformance, msftemployees и т. д.) или использование отметок времени (log20160101, log20160102, log20160102 и т. д.), будут применяться для секций, которые могут размещаться на том же сервере секционирования, пока операция балансировки нагрузки разбивает их на более мелкие диапазоны. Например, все BLOB-объекты в контейнере могут обрабатываться одним и тем же сервером, пока нагрузка на эти BLOB-объекты не потребует дополнительного перераспределения диапазонов секций. Точно так же группу незначительно нагруженных учетных записей с именами, упорядоченными в лексическом порядке, может обслуживать один и тот же сервер, пока нагрузка на одну или несколько из этих учетных записей не потребует разбить их между несколькими серверами секций. Каждая операция балансировки нагрузки может вызывать задержку вызовов хранилища во время ее выполнения. Способность системы справляться с внезапным всплеском трафика в секции ограничивается масштабированием единственного сервера секционирования, пока не будет запущена операция балансировки нагрузки, которая перераспределит диапазон ключей секций.  

Частоту выполнения таких операций можно уменьшить.  

* Внимательно проверьте используемое соглашение об именовании учетных записей, контейнеров, BLOB-объектов, таблиц и очередей. К именам учетных записей можно добавить трехзначный хэш в виде префикса, используя функцию хэширования, наиболее соответствующую вашим задачам.  
* Если данные упорядочены по меткам времени или числовым идентификаторам, убедитесь в том, что вы используете инкрементируемые (или декрементируемые) шаблоны трафика. Эти шаблоны не подходят для системы секционирования на основе диапазонов и могут приводить к тому, что весь трафик будет направляться в одну и ту же секцию, препятствуя эффективной балансировке нагрузки. Например, при наличии ежедневных операций с BLOB-объектом, имеющим метку времени вида ГГГГММДД, весь трафик этой ежедневной операции направляется в один объект, который обслуживается одним-единственным сервером секционирования. Проверьте, соответствуют ли ограничения по BLOB-объектам и ограничения по секциям вашим потребностям и, если нужно, разбейте эту операцию на несколько BLOB-объектов. Точно так же, если в таблицах хранятся данные временных рядов, весь трафик может направляться в последнюю часть ключевого пространства имен. Если вам нужно использовать метки времени или числовые идентификаторы, добавляйте в идентификатор префикс в виде трехзначного хэша. Если нужны метки времени, добавляйте секунды в качестве префикса к значению времени: ссггггммдд. Если операции перечисления и запросов выполняются регулярно, выберите функцию хэширования, ограничивающую число запросов. В других случаях может быть достаточно случайного префикса.  
* Дополнительные сведения о схеме секционирования, которая используется в службе хранилища Azure, см. документ SOSP [здесь](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).

### <a name="networking"></a>Сеть
Хотя API вызывается независимо, часто физические ограничения сети, в котором работает приложение, оказывают существенное влияние на производительность. Ниже описаны некоторые ограничения, с которыми могут столкнуться пользователи.  

#### <a name="client-network-capability"></a>Возможность клиентской сети
##### <a name="subheading2"></a>Пропускная способность
Что касается полосы пропускания, частой проблемой являются возможности клиента. Например, в то время как одна учетная запись хранения может обрабатывать данные со скоростью 10 Гбит/с или более на входе (см. [целевые показатели масштабируемости пропускной способности](#sub1bandwidth)), скорость работы сети в "небольшом" экземпляре рабочей роли Azure способна достигать только около 100 Мбит/с. Очень крупные экземпляры Azure имеют сетевые карты, обладающие большими возможностями, поэтому если необходимы более высокие сетевые ограничения от одной машины, следует рассмотреть возможность использования более крупного экземпляра или большего количества виртуальных машин. При обращении к службе хранилища из локального приложения применяется то же правило: понять сетевые возможности клиентского устройства и сетевого подключения к месту расположения хранилища Azure и либо улучшить их по мере необходимости, либо разработать приложение для работы в рамках их возможностей.  

##### <a name="subheading3"></a>Качество связи
Как и при любом использовании сети, имейте в виду, что состояние сети, приводящее к ошибкам и потере пакетов, снижает эффективную пропускную способность.  Использование инструмента WireShark или NetMon может помочь в диагностике этой проблемы.  

##### <a name="useful-resources"></a>Полезные ресурсы
Дополнительные сведения о размерах виртуальной машины и выделенной пропускной способности см. в статье [Размеры виртуальных машин в Azure](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) (Windows) или [Размеры виртуальных машин в Azure](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) (Linux).  

#### <a name="subheading4"></a>Расположение
В любой распределенной среде наилучшее быстродействие достигается при нахождении клиента рядом с сервером. Для доступа к хранилищу Azure с наименьшей задержкой лучшим местом для клиента будет его нахождение в том же регионе Azure. Например, при наличии веб-сайта Azure, который использует хранилище Azure, оба следует разместить внутри одного региона (например, на Западе США или в Юго-Восточной Азии). Это уменьшает задержку и стоимость. На момент написания этой статьи использование полосы пропускания в пределах одного региона является бесплатным.  

Опять же, если клиентские приложения не размещены в Azure (например, в приложениях для мобильных устройств или в локальных корпоративных службах), размещение учетной записи хранения в регионе рядом с устройствами, которые будут к нему обращаться, как правило, уменьшает задержку. Если клиенты разбросаны по всему миру (например, одни находятся в Северной Америке, другие — в Европе), следует рассмотреть возможность использования нескольких учетных записей хранения: одна размещенная в североамериканском регионе и одна — в европейском. Это поможет сократить задержку для пользователей в обоих регионах. Такой подход, как правило, легче реализовать, если данные, которые хранят приложения, предназначены для отдельных пользователей, и не требуют репликации между учетными записями хранения.  Для широкого распространения содержимого рекомендуется использовать сеть CDN. Для получения более подробной информации см. ​следующий раздел.  

### <a name="subheading5"></a>Распространение содержимого
Иногда приложению необходимо предоставить одинаковое содержимое множеству пользователей (например, демо-видео продукта, используемое на домашней странице веб-сайта), которые находятся в одном или в нескольких регионах. В этом случае следует использовать сеть доставки содержимого (CDN), такую как сеть Azure CDN, где CDN будет использовать хранилище Azure в качестве источника данных. В отличие от учетной записи хранилища Azure, которая существует в одном регионе и которая не может распространять содержимое с минимальной задержкой в другие регионы, сеть Azure CDN использует серверы, расположенные в нескольких центрах обработки данных по всему миру. Кроме того, сеть CDN обычно поддерживает гораздо более высокие ограничения на выходе, чем одна учетная запись хранения.  

Для получения дополнительной информации о сети Azure CDN см. статью [Сеть кэширующих серверов](https://azure.microsoft.com/services/cdn/).  

### <a name="subheading6"></a>Использование SAS и CORS
Если для получения доступа к данным службы хранилища Azure в пользовательском браузере или приложении мобильного телефона необходимо авторизовать такой код, как JavaScript, то используйте в качестве прокси-сервера приложение с веб-ролью. Таким образом, пользовательское устройство проходит аутентификацию для веб-роли, которая в свою очередь проходит аутентификацию для службы хранилища. Таким образом, на небезопасных устройствах можно не сообщать ключи своей учетной записи хранения. Однако это приводит к большим затратам вычислительных ресурсов на обработку веб-роли, потому что все данные, передаваемые между пользовательским устройством и службой хранилища, должны пройти через эту веб-роль. Избежать использования веб-роли в качестве прокси-сервера для службы хранилища можно путем использования подписей совместного доступа (Shared Access Signatures, или SAS), иногда в сочетании с заголовками для общего доступа к ресурсам независимо от источника (Cross-Origin Resource Sharing, или CORS). Используя технологию SAS, пользовательскому устройству можно позволить осуществлять запросы непосредственно к службе хранилища с помощью ограниченного маркера доступа. Например, если пользователь хочет загрузить фото в приложение, то веб-роль может создать и отправить на пользовательское устройство маркер SAS, который предоставляет разрешение на запись определенному большому двоичному объекту или контейнеру в течение ближайших 30 минут (после чего срок действия маркера SAS истекает).

Обычно браузер не позволяет коду JavaScript, находящемуся на странице, размещенной на веб-сайте в одном домене, выполнять определенные операции, такие, как "PUT", направленные на другой домен. Например, если при размещении веб-роли в домене contosomarketing.cloudapp.net необходимо использовать код JavaScript, находящийся на стороне клиента, чтобы загрузить большой двоичный объект в учетную запись хранения, расположенную в домене contosoproducts.blob.core.windows.net, то "политика одинакового источника" браузера запретит эту операцию. Технология CORS является функцией браузера, которая позволяет целевому домену (в данном случае учетной записи хранения) связаться с браузером, которому она доверяет запросы, созданные в исходном домене (в данном случае веб-роли).  

Обе эти технологии могут помочь избежать излишней нагрузки (и узких мест) веб-приложения.  

#### <a name="useful-resources"></a>Полезные ресурсы
Дополнительные сведения о подписанном URL-адресе см. в статье [Использование подписанных URL-адресов (SAS)](../storage-dotnet-shared-access-signature-part-1.md).  

Дополнительные сведения о технологии CORS см. в статье [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx) (Поддержка общего доступа к ресурсам независимо от источника (CORS) для служб хранилища Azure).  

### <a name="caching"></a>Caching
#### <a name="subheading7"></a>Получение данных
В большинстве случаев получение данных из службы с одной попытки лучше, чем с двух. Рассмотрим пример веб-приложения MVC, выполняющегося в веб-роли, которая уже получила 50 МБ BLOB-объекта из службы хранилища для его предоставления пользователю в качестве содержимого. Затем приложение может получать тот же самый BLOB-объект каждый раз, когда его запрашивает пользователь, или же оно может кэшировать его локально на диск и повторно использовать кэшированную версию для обработки последующих запросов пользователей. Кроме того, каждый раз, когда пользователь запрашивает данные, приложение может вызывать команду GET с условным заголовком для времени изменения, благодаря чему можно не получать весь большой двоичный объект в том случае, если он не был изменен. Такую же схему можно применить для работы с сущностями таблицы.  

В некоторых случаях можно решить, что приложение может считать BLOB-объект действующим в течение короткого периода времени после его получения и что в течение этого периода времени приложению не нужно проверять, был ли изменен этот BLOB-объект.

Прекрасными кандидатами на кэширование являются данные конфигурации, поиска, а также другие данные, которые используются приложением всегда.  

Пример того, как получить свойства большого двоичного объекта, необходимые для выяснения даты последнего изменения с помощью .NET, см. в статье [Задание и получение свойств и метаданных](../blobs/storage-properties-metadata.md). Дополнительные сведения об условных загрузках см. в статье [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) (Указание условных заголовков для операций службы BLOB-объектов).  

#### <a name="subheading8"></a>Передача данных в пакетах
В некоторых случаях приложения могут объединять данные локально, а затем периодически отправлять их в пакете вместо немедленной отправки каждого фрагмента данных. Например, веб-приложение может хранить файл журнала операций: приложение может или отправлять информацию о каждой операции по мере их появления в виде табличной сущности (что требует выполнения множества операций хранилища), или сохранять данные об операциях в локальный файл журнала, а затем периодически отправлять все эти данные в виде файла с разделителями в большой двоичный объект. Если размер каждой записи журнала составляет 1 КБ, их можно отправлять тысячами в одной транзакции "Put Blob" (Вставка большого двоичного объекта) (в одной транзакции можно отправить большой двоичный объект размером до 64 МБ). Конечно, в том случае, если локальная машина выходит из строя до завершения отправки, некоторые данные журнала будут утеряны: разработчик приложения должен предусмотреть возможность ошибок клиентского устройства или ошибок передачи.  Если необходимо загрузить данные о действиях, совершенных в определенные временные интервалы (а не только за одиночную операцию), рекомендуются использовать BLOB-объекты, а не таблицы.

### <a name="net-configuration"></a>Конфигурация .NET
В данном разделе перечислены несколько быстрых параметров конфигурации, которые можно использовать для значительного повышения производительности при использовании платформы .NET Framework.  При использовании других языков проверьте, применяются ли в выбранном языке подобные концепции.  

#### <a name="subheading9"></a>Увеличение ограничения числа подключений по умолчанию
В языке .NET указанный ниже код увеличивает ограничение количества подключений по умолчанию (которое обычно соответствует 2 в клиентской среде или 10 в серверной среде) до 100. В обычном случае следует установить значение, приблизительно соответствующее количеству потоков, используемых приложением.  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

Ограничение числа подключений должно быть установлено до открытия каких-либо подключений.  

Что касается других языков программирования, то для определения механизма установки ограничения числа подключений см. документацию по соответствующему языку.  

Дополнительные сведения см. в записи блога [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx) (Веб-службы: параллельные подключения).  

#### <a name="subheading10"></a>
Данный код позволяет увеличить минимальное количество потоков в пуле потоков:  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

Дополнительные сведения см. в статье [ThreadPool.SetMinThreads Method (Int32, Int32)](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx) (Метод ThreadPool.SetMinThreads (Int32, Int32)).  

#### <a name="subheading11"></a>
Используйте для клиентского приложения .NET 4.5 или более поздней версии, чтобы воспользоваться новыми способами повышения производительности в технологии сборки серверного мусора.

Дополнительные сведения см. в статье [Обзор усовершенствований, направленных на повышение производительности](http://msdn.microsoft.com/magazine/hh882452.aspx).  

### <a name="subheading12"></a>Неограниченный параллелизм
Хотя параллелизм может быть привлекательным с точки зрения производительности, будьте внимательны при использовании неограниченного параллелизма (отсутствие ограничения на количество потоков и (или) параллельных запросов) для отправки или загрузки данных, наличии нескольких работников с доступом к нескольким разделам (контейнерам, очередям или разделам таблиц) в одной учетной записи хранения или доступом к нескольким элементам в одном разделе. Если параллелизм неограничен, то приложение может превышать возможности клиентского устройства или целевые показатели масштабируемости учетных записей хранения из-за более длинных задержек и регулирования количества запросов.  

### <a name="subheading13"></a>Клиентские библиотеки и средства хранилища
Всегда используйте самые последние версии клиентских библиотек и инструментов, предоставляемых корпорацией Microsoft. На момент написания данной статьи существуют клиентские библиотеки, доступные для .NET, Windows Phone, Windows Runtime, Java и C++, а также библиотеки предварительного просмотра для других языков. Кроме того, корпорация Майкрософт выпустила командлеты PowerShell и команды CLI Azure для работы с хранилищем Azure. Корпорация Microsoft активно разрабатывает эти инструменты с учетом производительности, поддерживает их в соответствии с последними версиями служб и обеспечивает в них поддержку проверенных и производительных методов работы.  

### <a name="retries"></a>Повторы
#### <a name="subheading14"></a>Регулирование количества запросов и состояние "Сервер занят"
В некоторых случаях служба хранилища может регулировать количество запросов приложения или может просто быть не в состоянии обслуживать запрос из-за некоего переходного состояния и возвращает сообщение "503 Сервер занят" или "500 Время ожидания операции истекло".  Это может произойти в том случае, если приложение достигает одного из целевых показателей масштабируемости или если система занята повторной балансировкой секционированных данных для обеспечения более высокой пропускной способности.  Клиентское приложение должно, как правило, повторить операцию, которая вызывает эту ошибку: попытка выполнить тот же самый запрос позже может быть успешной. Однако если служба хранилища запускает механизм регулировки количества запросов из приложения из-за превышения целевых показателей масштабируемости или даже если служба была не в состоянии обслуживать данный запрос по какой-то другой причине, настойчивые повторы обычно только усугубляют проблему. По этой причине следует использовать экспоненциальное откладывание (по умолчанию клиентские библиотеки настроены реагировать именно так). Например, приложение может повторить действие через 2 секунды, затем через 4 секунды, затем через 10 секунд, затем через 30 секунд, а затем полностью отказаться от повторения. Такое поведение приводит к тому, что приложение значительно снижает свою нагрузку на службу и не усугубляет проблем.  

Обратите внимание: ошибки подключения могут вызывать немедленные повторы, так как они не являются результатом регулирования количества запросов и, как ожидается, будут временными.  

#### <a name="subheading15"></a>Ошибки без повторов
Клиентским библиотекам известно, какие ошибки предполагают повторный запрос, а какие нет. Тем не менее при написании своего собственного кода в отношении REST API для служб хранилища помните, что существуют такие ошибки, после которых запрос не следует повторять: например, ответ 400 (Неправильный запрос) указывает на то, что клиентское приложение направило запрос, который не может быть обработан из-за того, что он не был представлен в ожидаемой форме. Повторная отправка этого запроса каждый раз будет приводить к такому же ответу, поэтому в его повторной попытке нет смысла. При написании своего собственного кода в отношении API-интерфейса REST для служб хранилища помните о значениях кодов ошибок и выбирайте правильный способ повторного запроса (или его отсутствия).  

#### <a name="useful-resources"></a>Полезные ресурсы
Для получения дополнительной информации о кодах ошибок хранилища см. статью [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) (Коды ошибок и состояний) на веб-сайте Microsoft Azure.  

## <a name="blobs"></a>BLOB-объекты
В дополнение к проверенным практическим подходам, ранее описанным в разделе [Все службы](#allservices) , следующие проверенные подходы применяются специально для службы BLOB-объектов.  

### <a name="blob-specific-scalability-targets"></a>Целевые показатели масштабируемости, характерные для BLOB-объекта
#### <a name="subheading46"></a>Несколько клиентов, одновременно обращающихся к одному объекту
При наличии большого количества клиентов, одновременно обращающихся к одному объекту, необходимо учитывать целевые показатели масштабируемости для объекта и учетной записи хранения. Точное число клиентов, которые могут обратиться к одному объекту, будет зависеть от таких факторов, как количество клиентов, одновременно запрашивающих объект, размер объекта, состояние сети и т. д.

Если объект можно распространить по CDN (например, если это изображения или видео с веб-сайта), то следует использовать CDN. Дополнительные сведения см. [здесь](#subheading5).

В других сценариях, например в научном моделировании, где данные являются конфиденциальными, имеется две возможности. Первая — дифференцировать доступ рабочей нагрузки таким образом, чтобы доступ к объекту в одни периоды времени осуществлялся эксклюзивно, а в другие — одновременно. Кроме того, можно временно скопировать объект в несколько учетных записей хранения, тем самым увеличивая общее число операций ввода-вывода для объекта и учетных записей хранения. Проведя ограниченное тестирование, мы обнаружили, что примерно 25 виртуальных машин могут одновременно скачивать большой двоичный объект размером в 100 ГБ (каждая виртуальная машина распараллеливала скачивание на 32 потока). Если у вас 100 клиентов, которым требуется доступ к объекту, сначала скопируйте его во вторую учетную запись хранения, а затем пусть первые 50 виртуальных машин обращаются к первому большому двоичному объекту, а вторые 50 — ко второму. Результаты будут зависеть от поведения приложений, поэтому это следует проверить во время разработки. 

#### <a name="subheading16"></a>Пропускная способность и операции с BLOB-объектом
Данные одного BLOB-объекта можно считывать или записывать с максимальной скоростью до 60 МБ/с (это примерно 480 Мбит/с, что превышает возможности большинства клиентских сетей, в том числе физической сетевой карты на клиентском устройстве). Кроме того, один BLOB-объект поддерживает до 500 запросов в секунду. При наличии нескольких клиентов, которым необходимо выполнить чтение одного BLOB-объекта, и высокой вероятности превысить эти ограничения следует рассмотреть возможность использования сети CDN для распределения BLOB-объекта.  

Дополнительные сведения о целевой пропускной способности для больших двоичных объектов см. в статье [Целевые показатели масштабируемости и производительности службы хранилища Azure](storage-scalability-targets.md).  

### <a name="copying-and-moving-blobs"></a>Копирование и перемещение BLOB-объектов
#### <a name="subheading17"></a>Копирование BLOB-объекта
В REST API для служб хранилища версии 02-12-2012 представлена полезная возможность копирования больших двоичных объектов между учетными записями: клиентское приложение может отдать команду службе хранилища скопировать большой двоичный объект из другого источника (возможно, в другой учетной записи хранения), а затем предоставить службе возможность выполнить асинхронное копирование. Это может значительно снизить пропускную способность, необходимую приложению при миграции данных из других учетных записей хранения, потому что при этом не нужно загружать и отправлять данные.  

Однако существует один важный момент: при копировании между учетными записями хранения отсутствует гарантия по сроку завершения процесса копирования. Если приложение должно быстро и под контролем завершить копирование BLOB-объекта, лучшим вариантом для этого может быть его копирование путем загрузки BLOB-объекта на виртуальную машину с последующей его отправкой в место назначения.  Для обеспечения полной предсказуемости в этой ситуации убедитесь в том, что копирование выполнено с помощью виртуальной машины, работающей в том же регионе Azure. В противном случае условия работы сети могут (и, вероятно, будут) влиять на скорость копирования.  Кроме того, можно следить за ходом асинхронного копирования программным способом.  

Обратите внимание на то, что копирование внутри одной учетной записи хранения, как правило, выполняется быстро.  

Дополнительную информацию см. в статье [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx) (Копирование большого двоичного объекта).  

#### <a name="subheading18"></a>Использование программы AzCopy
Разработчики службы хранилища Azure выпустили программу командной строки AzCopy, которая предназначена помочь с одновременной передачей большого количества больших двоичных объектов между учетными записями хранения.  Этот инструмент оптимизирован специально для такого случая и может достигать высоких скоростей передачи данных.  Его использование рекомендуется для случаев массовой отправки, загрузки и копирования данных. Чтобы больше узнать об этом инструменте и скачать его, см. статью [Приступая к работе со служебной программой командной строки AzCopy](storage-use-azcopy.md).  

#### <a name="subheading19"></a>Служба импорта и экспорта Azure
Для очень больших объемов данных (более 1 ТБ) хранилище Azure предлагает службу импорта и экспорта, которая позволяет размещать или загружать данные хранилищ BLOB-объектов путем доставки жестких дисков.  Можно поместить свои данные на жесткий диск и отправить его в корпорацию Microsoft для размещения в сети или отправить пустой жесткий диск в корпорацию Microsoft для загрузки данных из сети.  Дополнительную информацию см. в статье [Использование службы импорта и экспорта Azure для передачи данных в хранилище BLOB-объектов](../storage-import-export-service.md).  Это может быть гораздо более эффективным, чем отправка или загрузка такого объема данных по сети.  

### <a name="subheading20"></a>Использование метаданных
Служба BLOB-объектов поддерживает запросы HEAD, которые могут включать метаданные о BLOB-объекте. Например, если приложению необходимы EXIF-данные из фотографии, оно может получить фотографию и извлечь их из нее. Для сохранения пропускной способности и повышения производительности приложение может сохранить данные EXIF в метаданных большого двоичного объекта при загрузке фотографии приложением: можно получить данные EXIF, находящиеся в метаданных, используя только запрос HEAD, тем самым экономя значительную пропускную способность и время обработки, необходимые для извлечения данных EXIF каждый раз при чтении большого двоичного объекта. Это было бы полезным в ситуациях, когда необходимы только метаданные, а не полное содержимое BLOB-объекта.  Обратите внимание, что в большом двоичном объекте могут храниться только 8 КБ метаданных (служба не будет принимать запрос на хранение большего, чем этот, объема данных), поэтому если данные превышают этот размер, использование такого подхода становится невозможным.  

Пример того, как получить метаданные большого двоичного объекта с помощью .NET, см. в статье [Задание и получение свойств и метаданных](../blobs/storage-properties-metadata.md).  

### <a name="uploading-fast"></a>Быстрая отправка
Чтобы быстро отправить большие двоичные объекты, необходимо ответить на первый вопрос: вы отправляете один большой двоичный объект или много?  Чтобы правильно выбрать метод работы, используйте сведения из приведенного ниже руководства.  

#### <a name="subheading21"></a>Быстрая отправка одного BLOB-объекта
Чтобы быстро отправить один большой BLOB-объект, клиентское приложение должно отправить его блоки или страницы параллельно (помня о целевых показателях масштабируемости для отдельных BLOB-объектов и учетной записи хранения в целом).  Обратите внимание на то, что этой способностью обладают клиентские библиотеки хранилища RTM, официально предоставляемые корпорацией Microsoft (.NET, Java).  Для установки уровня параллелизма для каждой библиотеки используйте указанный ниже объект или свойство:  

* .NET: установите ParallelOperationThreadCount в объекте BlobRequestOptions, который будет использоваться.
* Java/Android: используйте функцию BlobRequestOptions.setConcurrentRequestCount()
* Node.js: используйте parallelOperationThreadCount в параметрах запроса или в службе BLOB-объектов.
* C++: используйте метод blob_request_options::set_parallelism_factor.

#### <a name="subheading22"></a>Быстрая отправка множества BLOB-объектов
Чтобы быстро отправить множество BLOB-объектов, отправьте их параллельно. Это быстрее по времени, чем отправка отдельных BLOB-объектов с параллельной отправкой блоков, потому что в данном случае отправка распределяется по нескольким разделам службы хранилища. Один BLOB-объект поддерживает пропускную способность не более 60 МБ/с (около 480 Мбит/с). На момент написания статьи базирующаяся в США учетная запись LRS поддерживает входящую скорость до 20 Гбит/с, что гораздо больше, чем пропускная способность, поддерживаемая отдельными BLOB-объектами.  [AzCopy](#subheading18) выполняет параллельную отправку по умолчанию, как и рекомендуется для данного случая.  

### <a name="subheading23"></a>Выбор правильного типа BLOB-объекта
Служба хранилища Azure поддерживает два типа больших двоичных объектов: *страничные* BLOB-объекты и *блочные* BLOB-объекты. В данном случае использования выбор типа BLOB-объекта будет влиять на производительность и масштабируемость решения. Блочные большие двоичные объекты подходят тогда, когда необходимо эффективно отправить большие объемы данных: например, клиентскому приложению может понадобиться отправить в хранилище больших двоичных объектов фотографии или видео. Станичные большие двоичные объекты подходят в том случае, если в данных необходимо выполнять случайные операции записи: например, виртуальные жесткие диски Azure хранятся в виде страничных больших двоичных объектов.  

Дополнительные сведения см. в статье [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx) (Основные сведения о блочных, добавочных и страничных BLOB-объектах).  

## <a name="tables"></a>Таблицы
В дополнение к проверенным практическим подходам, ранее описанным в разделе [Все службы](#allservices) , следующие проверенные подходы применяются специально для службы таблиц.  

### <a name="subheading24"></a>Целевые показатели масштабирования для таблицы
В дополнение к ограничениям пропускной способности всей учетной записи хранения таблицы имеют следующее ограничение масштабируемости.  Обратите внимание: система будет распределять нагрузку по мере увеличения трафика, но если трафик имеет внезапные вспышки, вы будете не в состоянии получить немедленно весь объем пропускной способности.  Если метод работает скачками, следует ожидать применения технологии регулировки запросов и (или) тайм-ауты во время скачков по мере того, как служба хранилища автоматически распределяет нагрузку по таблице.  Медленное повышение, как правило, дает лучшие результаты, поскольку предоставляет системное время для распределения нагрузки.  

#### <a name="entities-per-second-account"></a>Сущностей в секунду (учетная запись)
Ограничение масштабируемости для доступа к таблицам составляет до 20 000 сущностей (каждая по 1 КВ) в секунду для одной учетной записи.  Обычно каждая сущность, которая вставляется, обновляется, удаляется или сканируется, идет в счет этой цели.  Так, пакетная вставка, которая содержит 100 сущностей, будет считаться за 100 сущностей.  Запрос, который сканирует 1000 сущностей и возвращает 5 из них, будет считаться за 1000 сущностей.  

#### <a name="entities-per-second-partition"></a>Сущностей в секунду (раздел)
В одном разделе целевой показатель масштабируемости для доступа к таблицам составляет 2 000 сущностей (каждая по 1 КБ) в секунду. Тут используется тот же принцип подсчета, что и описанный в предыдущем разделе.  

### <a name="configuration"></a>Конфигурация
В данном разделе перечислены несколько параметров быстрой конфигурации, которые можно использовать для значительного увеличения производительности в службе таблиц:  

#### <a name="subheading25"></a>Использование JSON
Начиная со службы хранилища версии 2013-08-15, для передачи данных таблицы служба таблиц вместо формата AtomPub на базе XML поддерживает формат JSON. Это может уменьшить размеры полезной нагрузки не меньше, чем на 75 %, и может значительно увеличить производительность приложения.

Дополнительные сведения см. в статьях [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) (Таблицы Microsoft Azure: введение в JSON) и [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx) (Формат полезных данных для операций службы таблиц).

#### <a name="subheading26"></a>Отключение алгоритма Nagle
Алгоритм Нейгла широко применяется во всех TCP/IP-сетях в качестве средства повышения производительности сети. Тем не менее он не является оптимальным во всех случаях (включая высокоинтерактивные среды). В службе хранилища Azure алгоритм Нейгла оказывает негативное влияние на производительность запросов к таблице и службам очереди, и при возможности его следует отключать.  

Дополнительные сведения см. в нашей записи блога [Nagle’s Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx) (Алгоритм Нейгла не ориентирован на мелкие запросы), в которой объясняется, почему алгоритм Нейгла плохо взаимодействует с запросами к таблицам и очередям и как его отключить в клиентском приложении.  

### <a name="schema"></a>SCHEMA (Схема)
То, каким образом вы представляете и запрашиваете данные, является одним из основных факторов, влияющих на производительность службы таблиц. Поскольку приложения отличаются друг от друга, в данном разделе излагаются некоторые общие проверенные подходы, которые относятся к:  

* конструктору таблиц;
* эффективным запросам;
* эффективным обновлениям данных.  

#### <a name="subheading27"></a>Таблицы и секции
Таблицы разделены на разделы. Каждая сущность, хранящаяся в разделе, совместно использует один ключ раздела и имеет уникальный ключ строки для своей идентификации внутри этого раздела. Разделы предоставляют преимущества, но также вводят ограничения по масштабируемости.  

* Преимущества: можно обновить сущности в одной секции в рамках одной неделимой пакетной транзакции, содержащей до 100 отдельных операций хранения (общий размер ограничен 4 МБ). Предполагая некоторое количество сущностей, которые будут получены, также можно более эффективно запросить данные, хранящиеся внутри одного раздела, чем данные, охватывающие несколько разделов (в то время как чтение по дальнейшим рекомендациям необходимо проводить по запрашиваемым табличным данным).
* Ограничения масштабируемости: невозможно сбалансировать нагрузку доступа к сущностям, хранящимся в одной секции, поскольку секции поддерживают неделимые пакетные транзакции. По этой причине целевой показатель масштабируемости для отдельного раздела таблицы ниже, чем для службы таблиц в целом.  

Учитывая эти характеристики таблиц и разделов, следует принять следующие принципы проектирования:  

* Данные, которые клиентское приложение часто обновляет или запрашивает в одном логическом блоке работы, должны быть расположены в одном разделе.  Эта необходимость может возникнуть потому, что приложение создает сводку записей, или потому, что вы хотите воспользоваться атомарной пакетной операцией.  Кроме того, данные, находящиеся в одном разделе, могут быть с большим успехом запрошены в одном обращении, чем данные, которые находятся в разных разделах.
* Данные, которые клиентское приложение не вставляет, не обновляет и не запрашивает в одном логическом блоке работы (одном запросе или пакетном обновлении), должны быть расположены в отдельных разделах.  Важно отметить, что ограничения на количество ключей раздела в одной таблице не существует, так что наличие миллионов ключей раздела не является проблемой и не влияет на производительность.  Например, если приложение является популярным веб-сайтом с механизмом входа пользователя в систему, в качестве ключа раздела может хорошо подойти идентификатор пользователя.  

#### <a name="hot-partitions"></a>Горячие разделы
Горячий раздел — это раздел, который получает несоразмерный процент трафика на одну учетную запись и не может распределять нагрузку между разделами, так как является единственным разделом.  Обычно горячие разделы создаются одним из двух способов:  

##### <a name="subheading28"></a>Инкрементируемые и декрементируемые шаблоны
"Инкрементируемый" шаблон — это шаблон, в котором весь (или почти весь) трафик для данного ключа секции увеличивается и уменьшается в зависимости от текущего времени.  Примером может служить ситуация, при которой приложение использует текущую дату в качестве ключа раздела для данных журнала.  Это приводит к тому, что все вставки попадают в самый последний раздел таблицы, и система не может распределять нагрузку, потому что все записи попадают в конец таблицы.  Если объем трафика в этом разделе превышает целевой показатель масштабируемости на уровне раздела, это приведет к включению механизма регулировки количества запросов.  Обеспечение отправки трафика к нескольким секциям — более удачный вариант, чем включение механизма распределения нагрузки при запросах по всей таблице.  

##### <a name="subheading29"></a>Данные с интенсивным трафиком
Если схема создания разделов приводит к созданию одного раздела, в котором имеются только данные, которые используются значительно чаще, чем данные в других разделах, по мере достижения этим разделом целевого показателя масштабируемости для одного раздела можно также обнаружить, что включен механизм регулировки количества запросов.  Лучше всего сделать так, чтобы в схеме секционирования не было отдельных секций, приближающихся к целевым показателям масштабируемости.  

#### <a name="querying"></a>Выполнение запроса
В этом разделе описываются проверенные подходы, касающиеся выполнения запросов службы таблицы.  

##### <a name="subheading30"></a>Область запроса
Существует несколько способов для определения диапазона сущностей для запросов.  Ниже обсуждается использование каждого из них.  

В целом, старайтесь избегать сканирования (запросы, превышающие одну сущность), но если это необходимо, попытайтесь организовать данные таким образом, чтобы сканирование извлекало необходимые данные без сканирования или возвращения значительного количества ненужных сущностей.  

###### <a name="point-queries"></a>Точечные запросы
Точечный запрос извлекает ровно одну сущность. Он делает это, указав как ключ раздела, так и ключ строки сущности. Эти запросы являются очень эффективными, и их следует использовать везде, где это возможно.  

###### <a name="partition-queries"></a>Запросы разделов
Запрос раздела — это запрос, который извлекает набор данных, совместно использующих общий ключ раздела. Как правило, в запросе указывается диапазон значений ключа строки или — в дополнение к ключу раздела — диапазон значений для свойства некоторой сущности. Они менее эффективны, чем точечные запросы, и их следует использовать с осторожностью.  

###### <a name="table-queries"></a>Табличные запросы
Табличный запрос — это запрос, который извлекает набор сущностей, не использующих совместно общий ключ раздела. Эти запросы не являются эффективными, и, если это возможно, следует избегать их использования.  

##### <a name="subheading31"></a>Плотность запроса
Еще одним важным фактором в эффективности запроса является соотношение между количеством возвращенных сущностей и количеством сканированных сущностей, использованных при поиске возвращаемого набора. Если приложение выполняет табличный запрос с фильтром для значения свойства, которое соответствует только 1 % совместно используемых данных, запрос будет сканировать по 100 сущностей для каждой одной сущности, которую он возвращает. Все рассмотренные ранее целевые показатели масштабируемости таблицы относятся к количеству сканированных сущностей, а не к количеству возвращенных сущностей: низкая плотность запроса может легко привести службу таблиц к регулированию количества запросов приложения, потому что для извлечения искомой сущности она должна сканировать слишком много других сущностей.  Для получения дополнительной информации о том, как этого избежать, см. раздел [Денормализация](#subheading34) ниже.  

##### <a name="limiting-the-amount-of-data-returned"></a>Ограничение объема возвращаемых данных
###### <a name="subheading32"></a>Фильтрация
Если известно, что запрос вернет ненужные в клиентском приложении сущности, рассмотрите вопрос об использовании фильтра, позволяющего уменьшить размер возвращаемого набора. Несмотря на то, что не возвращаемые клиенту сущности учитываются в подсчете ограничений масштабируемости, производительность приложения увеличится из-за снижения полезной нагрузки на сеть и сокращения количества сущностей, которые должно обрабатывать клиентское приложение.  См. информацию в разделе о [плотности запроса](#subheading31) выше. Однако целевые показатели масштабируемости относятся к количеству сканируемых сущностей, поэтому выполнение запроса, фильтрующего множество сущностей, может привести к запуску механизма регулирования количества запросов даже в том случае, если возвращается небольшое число сущностей.  

###### <a name="subheading33"></a>Проекция
Если клиентскому приложению необходим лишь ограниченный набор свойств из сущностей таблицы, для ограничения размера возвращаемого набора данных можно использовать проекцию. Как и в случае с фильтрацией, это помогает снизить нагрузку на сеть и обработку запросов клиента.  

##### <a name="subheading34"></a>Денормализация
В отличие от работы с реляционными базами данных, проверенные подходы для осуществления эффективного запроса данных таблицы ведут к денормализации данных. То есть дублирование одних данных в нескольких сущностях (для поиска данных можно использовать по одной сущности для каждого ключа) с целью минимизации количества сущностей, которые должен сканировать запрос для поиска необходимых клиенту данных, вместо того чтобы сканировать большое количество сущностей для поиска данных, необходимых приложению.  Например, на веб-сайте электронной коммерции может понадобиться найти заказ как по идентификатору клиента (найти заказы данного клиента), так и по дате (найти заказы на определенную дату).  В табличном хранилище лучше всего хранить сущность (или ссылку на нее) в двух видах: один с именем таблицы, ключом раздела и ключом строки для облегчения поиска по идентификатору клиента, один для облегчения его поиска по дате.  

#### <a name="insertupdatedelete"></a>Вставить, обновить, удалить
В этом разделе описываются проверенные методики для изменения сущностей, хранящихся в службе таблиц.  

##### <a name="subheading35"></a>Пакетная обработка
Пакетные транзакции в хранилище Azure называются транзакциями группы сущностей (Entity Group Transactions, ETG). Все операции, выполняющиеся в ETG, должны производиться в одном разделе и в одной таблице. Там, где это возможно, для выполнения пакетных команд вставки, обновления и удаления используйте транзакции группы сущностей. Это сокращает количество циклов обработки между клиентским приложением и сервером, снижает количество подсчитываемых транзакций (при подсчете транзакция группы сущностей считается одной транзакцией и может содержать до 100 операций хранения) и позволяет выполнять атомарные обновления (в транзакции группы сущностей операции завершаются или все успешно, или все с ошибкой). Среды с большими задержками, такие как мобильные устройства, в результате использования транзакций групп сущностей получают большие преимущества.  

##### <a name="subheading36"></a>Операция Upsert
Используйте табличные операции **Upsert** как можно чаще. Существует два типа операций **Upsert**. Оба они могут быть более эффективными, чем обычные операции **Insert** и **Update**:  

* **InsertOrMerge**: используйте, если требуется передать подмножество свойств сущности, но неизвестно, существует ли она. Если сущность существует, она вызывает обновление свойств, включенных в операцию **Upsert** , и оставляет все имеющиеся свойства нетронутыми, если же сущность не существует, вставляется новая сущность. Это похоже на использование проекции в запросе, в котором нужно отправить только изменяющиеся свойства.
* **InsertOrReplace**: используйте, если требуется передать совершенно новую сущность, но неизвестно, существует ли она. Команду следует использовать только тогда, когда известно, что недавно отправленная сущность является абсолютно правильной, потому что она полностью заменяет старую сущность. Например, необходимо обновить сущность, в которой хранится текущее местоположение пользователя, независимо от того, сохраняло ли ранее приложение данные о местоположении пользователя. В данном случае создается сущность с новым местоположением пользователя, а потребность в какой-либо информации из любой предыдущей сущности отсутствует.

##### <a name="subheading37"></a>Хранение ряда данных в одной сущности
Иногда приложение хранит ряд данных, которые часто бывают необходимыми для их единовременного получения: например, приложение может отслеживать загрузку ЦП в течение долгого времени для того, чтобы построить волнообразный график из данных за последние 24 часа. Один подход заключается в том, чтобы для каждого часа иметь одну табличную сущность, при этом каждая сущность представляет определенный час и хранит значение загрузки ЦП для этого часа. Для построения этих данных приложению необходимо извлечь сущности, в которых хранятся данные за последние 24 часа.  

Кроме того, приложение может хранить данные о загрузке ЦП для каждого часа в виде отдельного свойства одной сущности: для ежечасного обновления приложение может использовать один вызов **InsertOrMerge Upsert**, чтобы обновить значение за последний час. Для построения этих данных приложению необходимо получить только одну сущность, а не 24, выполняя при этом очень эффективный запрос (см. представленное выше обсуждение в разделе [Область запроса](#subheading30)).

##### <a name="subheading38"></a>Хранение структурированных данных в BLOB-объектах
Иногда кажется, что структурированные данные должны попадать в таблицы, но диапазоны сущностей всегда извлекаются вместе и могут быть вставлены пакетным образом.  Хорошим примером такой ситуации является файл журнала.  В этом случае несколько минут из журнала можно укомплектовать в пакет, затем произвести их вставку и потом, с тем же успехом, извлекать несколько минут журнала за раз.  В этом случае с точки зрения производительности вместо таблиц лучше использовать большие двоичные объекты, так как при этом можно значительно уменьшить количество записываемых или возвращаемых объектов, а также, как правило, количество необходимых для выполнения запросов.  

## <a name="queues"></a>Очереди
В дополнение к проверенным практическим подходам, ранее описанным в разделе [Все службы](#allservices), следующие проверенные подходы применяются специально для службы очередей.  

### <a name="subheading39"></a>Ограничения масштабируемости
Одна очередь может обрабатывать около 2000 сообщений (размером 1 КБ каждое) в секунду (здесь каждая операция AddMessage, GetMessage и DeleteMessage считается сообщением). Если для вашего приложения этого недостаточно, следует распределить сообщения по нескольким очередям.  

Текущие целевые показатели масштабируемости можно посмотреть на странице [Цели масштабируемости хранилища и производительности Azure](storage-scalability-targets.md).  

### <a name="subheading40"></a>Отключение алгоритма Nagle
См. раздел по конфигурации таблицы, в котором обсуждается алгоритм Nagle. Алгоритм Nagle, как правило, плохо влияет на производительность запросов в очереди, поэтому его следует отключать.  

### <a name="subheading41"></a>Размер сообщения
Производительность и масштабируемость очередей уменьшается по мере увеличения размера сообщения. В сообщении следует размещать только ту информацию, которая необходима получателю.  

### <a name="subheading42"></a>Пакетное извлечение
В одной операции из очереди можно извлечь до 32 сообщений. Это может уменьшить количество циклов обработки клиентского приложения, что особенно полезно в таких средах с большой задержкой, как мобильные устройства.  

### <a name="subheading43"></a>Интервал опроса очереди
Большинство приложений опрашивают сообщения из такой очереди, которая может быть одним из самых крупных источников транзакций для этих приложений. Выбирайте интервал опроса тщательно: слишком высокая частота опросов может привести к тому, что будет достигнуто целевое значений масштабируемости очереди. Но при тарифе 0,01 долларов США за 200 000 транзакций (во время записи) опрос одного процессора с интервалом один раз в секунду будет стоить меньше 15 центов в месяц, поэтому стоимость обычно не влияет на выбор интервала опроса.  

Актуальные сведения о стоимости см. на странице [Цены на хранилища Azure](https://azure.microsoft.com/pricing/details/storage/).  

### <a name="subheading44"></a>UpdateMessage
Для увеличения невидимого времени ожидания или для обновления информации о состоянии сообщения можно использовать операцию **UpdateMessage** . Несмотря на ее эффективность, помните, что каждая операция **UpdateMessage** учитывается при подсчете целевого показателя масштабируемости. Тем не менее ее использование может быть гораздо более эффективным, чем наличие рабочего процесса, который передает работу из одной очереди в другую по мере завершения каждого этапа работы. Использование операции **UpdateMessage** позволяет приложению сохранить состояние работы в сообщении, а затем продолжить работу, вместо того чтобы повторно запрашивать сообщение для выполнения следующего этапа работы по мере завершения каждого предыдущего.  

Дополнительные сведения см. в разделе [Изменение содержимого сообщения в очереди](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).  

### <a name="subheading45"></a>Архитектура приложения
Чтобы сделать архитектуру приложения масштабируемой, следует использовать очереди. Ниже перечислены некоторые способы использования очередей для того, чтобы сделать приложение более масштабируемым:  

* Очереди можно использовать для инициации отставания от работы, необходимого для обработки и сглаживания рабочих нагрузок в приложении. Например, запросы от пользователей можно поместить в очередь, чтобы позволить процессору выполнить трудоемкую работу, такую как изменение размера загружаемых изображений.
* Очереди можно использовать, чтобы отделить части приложения для их независимого масштабирования. Например, клиент веб-интерфейса может разместить результаты опроса пользователей в очередь для последующего анализа и хранения. По мере необходимости для обработки данных очереди можно добавлять экземпляры роли worker.  

## <a name="conclusion"></a>Заключение
В этой статье обсуждаются некоторые из наиболее распространенных, проверенных подходов для оптимизации производительности при использовании службы хранилища Azure. Мы призываем разработчиков оценить применимость описанных выше методик к их приложениям и рассмотреть, исходя из рекомендаций, возможность повышения производительности подобных приложений, использующих службу хранилища Azure.