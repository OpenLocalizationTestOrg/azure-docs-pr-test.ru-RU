---
title: "aaaDesigning высокой доступные приложения, использующие географически избыточное хранилище Azure доступ для чтения (RA-GRS) | Документы Microsoft"
description: "Как tooarchitect хранилища Azure RA-GRS toouse приложение с высокой доступностью гибкие достаточно toohandle сбоев."
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: e4a9fe7ef33eecd894408b3c1ef59920a248d1bd
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a>Проектирование высокодоступных приложений с использованием RA-GRS

Характерной чертой облачных инфраструктур является то, что они предоставляют высокодоступную платформу для размещения приложений. Разработчикам облачных приложений необходимо учитывать как тщательно tooleverage такое платформы приложения с высокой доступностью toodeliver tootheir пользователи. Эта статья посвящена специально как разработчики могут использовать hello Azure хранилища доступ на чтение географически избыточное хранилище (RA-GRS) toomake больше доступных приложений.

Доступно четыре варианта обеспечения избыточности: LRS (локально избыточное хранилище), ZRS (хранилище, избыточное в пределах зоны), GRS (геоизбыточное хранилище) и RA-GRS (геоизбыточное хранилище с доступом на чтение). Мы будем toodiscuss GRS и RA-GRS в этой статье. При использовании GRS три копии данных хранятся в основной регион hello, выбранных при настройке учетной записи хранилища hello. Три дополнительные копии сохраняются асинхронно в дополнительном регионе, заданном Azure. RA-GRS — hello же, что и GRS, за исключением того, что у вас есть доступ для чтения toohello дополнительная копия. Дополнительные сведения о hello различные варианты избыточности хранилища Azure см. в разделе [репликацию хранилища Azure](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy). статьи для репликации Hello также показаны пары hello hello основного и дополнительного регионов.

Существует фрагментов кода в этой статье и полный пример tooa ссылку в конце hello, можно загрузить и запустить.

## <a name="key-features-of-ra-grs"></a>Ключевые возможности RA-GRS

Прежде чем мы расскажем, как toouse хранилище RA-GRS, давайте поговорим об его свойства и поведение.

* Хранилище Azure поддерживает только для чтения копию данных hello, хранящихся в основном регионе в дополнительном регионе; как указано выше, служба хранилища hello определяет расположение hello hello дополнительный регион.

* только для чтения копия Hello [согласованным](https://en.wikipedia.org/wiki/Eventual_consistency) с данными hello в основном регионе hello.

* Для больших двоичных объектов, таблиц и очередей, можно запросить hello дополнительный регион для *время последней синхронизации* значение, которое указывает, когда произошла Последняя репликация hello из вторичного региона основной toohello hello. (Это не работает для хранилища файлов Azure, которое не обеспечивает избыточность RA-GRS.)

* Клиентская библиотека хранилища toointeract hello можно использовать с данными hello в основном или дополнительном регионе либо hello. Также можно перенаправлять чтения автоматически запрашивает toohello дополнительный регион, если запрос чтения основного региона toohello времени ожидания.

* В случае очень важна влияния на доступность hello hello данные в основном регионе hello hello команды Azure может запускать географическая отработка отказа, после чего hello DNS-записей, указывающий основной регион toohello будет измененные toopoint toohello дополнительный регион.

* В случае географическая отработка отказа Azure выбрать новое местоположение вторичного и реплицировать расположение toothat данных hello, затем пункт hello вторичного DNS записи tooit. Вторичная конечная точка Hello будет оставаться недоступным до завершения репликации hello учетной записи хранилища. Дополнительные сведения см. в разделе [какие toodo в случае сбоя хранилища Azure](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).

## <a name="application-design-considerations-when-using-ra-grs"></a>Рекомендации по проектированию приложений при использовании RA-GRS

Основная цель этой статьи Hello — tooshow вы как center toodesign приложение, которое будет продолжать работу toofunction (хотя и в ограниченного объема) даже в событии hello серьезной аварии в hello основных данных. Для этого с вашей временной toohandle приложения или долго выполняющихся проблемы, переключение tooread из вторичного региона hello, пока проблема и переключение основной регион hello снова не станет доступным.

### <a name="using-eventually-consistent-data"></a>Использование данных, согласованных в конечном счете

Это предлагаемое решение предполагает, он хорошо tooreturn чем может быть устаревшие данные toohello вызывающему приложению. Так как база данных-получатель hello согласованным, возможна hello данные были записаны toohello основной, но toohello обновления hello получателя не был завершен репликации при hello первичный регион стал недоступен.

Например клиент может отправить обновление, которое успешно, а затем hello основной удалось перейдите до hello обновления получателей распространенный toohello. В этом случае если hello клиента, после чего просит tooread hello данные назад, он получает hello устаревшие данные вместо hello обновления данных. Если это допустимо и если да, необходимо решить, каким образом будет сообщения приветствия клиента. Вы увидите, как toocheck hello время последней синхронизации на hello получателя данных далее в этой статье toosee, если актуально hello получателей.

### <a name="handling-services-separately-or-all-together"></a>Отдельная или совместная обработка служб

Хотя это маловероятно, возможна toobecome одна служба недоступна во время hello другие службы работают по-прежнему полностью. Вы можно попыток дескриптор hello и режиме только для чтения для каждой службы отдельно (больших двоичных объектов, очередей, таблиц) или повторных попыток, общим для всех служб хранилища hello можно обрабатывать вместе.

Например при использовании очередей и больших двоичных объектов в приложении можно tooput ошибкам повторяемая toohandle отдельный код для каждого из них. Затем Если повторная попытка получить из службы BLOB-объектов hello, но по-прежнему работает служба очередей hello, будут затронуты только hello часть приложения, которые обрабатывают большие двоичные объекты. Если вы решите toohandle универсальной повторяет все службы хранилища и службы больших двоичных объектов toohello вызов возвращает Повторяемая ошибка, а затем запросов tooboth hello BLOB-объектов службы и службы очередей hello повлияет.

В конечном счете это зависит от сложности приложения hello. Вы можете решить не сбоев hello toohandle службой, а tooredirect запросов на чтение для всех служб toohello дополнительный регион хранилища и запустите приложение hello в режиме только для чтения, при обнаружении проблемы с любой службой хранения в первичном регионе hello.

### <a name="other-considerations"></a>Дополнительные рекомендации

Они являются hello другие вопросы, которые обсуждаются в hello оставшейся части этой статьи.

*   Обработка повторных запросов на чтение, используя шаблон Размыкатель цепи hello

*   В конечном итоге целостность данных и время последней синхронизации hello

*   Тестирование

## <a name="running-your-application-in-read-only-mode"></a>Выполнение приложения в режиме только для чтения

toouse хранилища RA-GRS, вы должны быть запросов может toohandle как сбой чтения и неудачных запросов update (с обновления в данном случае это означает операции вставки, обновления и удаления). Если hello завершается ошибкой center первичных данных, для чтения запросы могут быть перенаправленный toohello вторичный центр обработки данных, но запросы на обновление невозможно, так как hello получателя доступно только для чтения. По этой причине необходимо некоторые toorun способом приложения в режиме только для чтения.

Например можно задать флаг, который будет проверяться перед отправкой любой службы хранилища toohello запросы обновления. Если один из запросов на обновление hello поступает может пропустить этот и возвращать toohello соответствующий ответ клиенту. Можно даже toodisable полностью определенные компоненты пока не будет устранена проблема hello и уведомить пользователей, что эти функции будут временно недоступна.

В случае ошибки toohandle для каждой службы отдельно, необходимо также toohandle hello возможности toorun приложения в режиме только для чтения службой. У вас может быть только для чтения флаги для каждой службы, который может быть включен и отключен и дескриптор hello соответствующий флаг в нужных местах hello в коде.

Может toorun приложение в режиме только для чтения имеет другой дополнительное преимущество — она предоставляет возможность tooensure hello ограниченной функциональностью во время обновления основного приложения. Вы можете активировать toorun вашего приложения в только для чтения режим и toohello точки вторичный центр обработки данных, гарантируя, что никто не обращается к данным hello в основном регионе hello время выполнения обновления.

## <a name="handling-updates-when-running-in-read-only-mode"></a>Обработка обновлений в режиме только для чтения

Существует множество способов обновления toohandle запрашивает при работе в режиме только для чтения. Мы не сможем подробно рассмотреть их все, но в целом существует несколько шаблонов, которые вам стоит принять во внимание.

1.  Можно ответить пользователь tooyour и сообщите, что вы не принимаете в настоящее время обновления. Например в системе управления контактами может включить заказчиков tooaccess контактные данные, но не выполнять обновления.

2.  Можно поставить обновления в очередь в другом регионе. В этом случае следует писать запросы tooa ожидает обновления очереди в другом регионе и затем после tooprocess способом эти запросы hello основного центра обработки данных в оперативный еще раз. В этом сценарии должен сообщить клиенту hello информацию о запросе обновления hello помещается в очередь для последующей обработки.

3.  Можно написать обновления tooa учетной записи хранилища в другом регионе. Затем hello основного центра обработки данных в оперативный после будет toomerge способом эти обновления в hello первичных данных, в зависимости от структуры hello hello данных. Например при создании отдельные файлы с метки даты и времени в имени hello можно скопировать основной регион задней toohello эти файлы. Это подходит для некоторых рабочих нагрузок, например ведения журнала и данных Интернета вещей.

## <a name="handling-retries"></a>Обработка повторных попыток

Как узнать, какие ошибки допускают повторение? Это определяется клиентской библиотеки хранилища hello. Например сообщение об ошибке 404 (ресурс не найден) является возможности повторной попытки, поскольку повторная попытка его не является скорее всего, tooresult в успех. На hello другой стороны, ошибка 500 можно выполнить повторно, так как это ошибка сервера, и может быть просто временная проблема. Дополнительные сведения см. hello [открытый исходный код для класса ExponentialRetry hello](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) в клиентской библиотеки хранилища .NET hello. (Найдите hello метод ShouldRetry).

### <a name="read-requests"></a>Запросы на чтение

Запросов на чтение может быть перенаправленный toosecondary хранилища, если имеется проблема с основного хранилища. Как было отмечено выше, в [с помощью со временем согласованных данных](#using-eventually-consistent-data), он должен быть приемлемым для вашего приложения toopotentially читать устаревшие данные. При использовании hello хранилища клиента библиотеки tooaccess RA-GRS данных можно указать поведение запроса на чтение "Повторить" hello, задав значение для hello **LocationMode** tooone свойство hello следующее:

*   **PrimaryOnly** (hello по умолчанию)

*   **PrimaryThenSecondary**;

*   **SecondaryOnly**;

*   **SecondaryThenPrimary**.

При задании hello **LocationMode** слишком**PrimaryThenSecondary**, если начальный hello чтения основную конечную точку toohello запрос завершается с Повторяемая ошибка, клиент hello автоматически делает другая операция чтения запрос toohello вторичной конечной точки. Если hello ошибка времени ожидания сервера, клиента hello будет иметь toowait для hello tooexpire время ожидания до получения от службы hello Повторяемая ошибка.

Существуют две сценарии tooconsider при выборе как toorespond tooa Повторяемая ошибка:

*   Это изолированной проблемы и основную конечную точку toohello последующие запросы не вернет Повторяемая ошибка. Например, такая ситуация может сложиться при временной ошибке в сети.

    В этом сценарии ничего страшного значительного увеличения производительности в необходимости **LocationMode** значение слишком**PrimaryThenSecondary** как это происходит редко.

*   Это проблема с по крайней мере одной из служб хранения hello в основном регионе hello и все последующие запросы службы toothat, в основном регионе hello повторяемая ошибок tooreturn скорее всего, в течение заданного времени. Примером этого является ли основной регион hello полностью недоступен.

    В этом сценарии существует производительность снижается, так как все запросы чтения будет сначала hello основной конечной точки, дождитесь hello tooexpire время ожидания, а затем переключиться toohello вторичной конечной точки.

В таких случаях необходимо определить, что текущая проблема с основной конечной точки hello и отправки всех запросов на чтение напрямую hello toohello вторичной конечной точки, задав **LocationMode** свойство слишком **SecondaryOnly**. В данный момент необходимо также изменить toorun приложения hello в режиме только для чтения. Такой подход известен как hello [шаблон Размыкатель цепи](https://msdn.microsoft.com/library/dn589784.aspx).

### <a name="update-requests"></a>Запросы на обновление

шаблон Hello Размыкатель цепи также может быть применен tooupdate запросов. Тем не менее запросы на обновление не может быть перенаправленный toosecondary хранилища, которое доступно только для чтения. Для этих запросов, следует оставить hello **LocationMode** значение свойства слишком**PrimaryOnly** (по умолчанию hello). toohandle эти ошибки можно применять запросы, метрики toothese — например 10 сбоев подряд — и при соблюдении порог переключения приложения hello в режиме только для чтения. Можно использовать такие же методы, возвращающие режим tooupdate как описанных ниже в следующем разделе hello о шаблоне Размыкатель цепи hello hello.

## <a name="circuit-breaker-pattern"></a>Шаблон автоматического выключения

С помощью шаблона Размыкатель цепи hello в приложении можно запретить его повторной попытки выполнения операции, скорее всего, toofail несколько раз. Она позволяет toorun toocontinue приложения hello, а не занимают время, пока операция hello повторяется экспоненциально. Также обнаруживает ошибку hello была исправлена, по которому приложение hello времени можно попытку hello.

### <a name="how-tooimplement-hello-circuit-breaker-pattern"></a>Как tooimplement hello шаблон Размыкатель цепи

tooidentify наличие постоянная проблема с основную конечную точку, можно отслеживать, как часто клиент hello возникли ошибки при возможности повторной попытки. Поскольку каждый вариант отличается, у вас есть toodecide на пороговое значение hello toouse для hello решение tooswitch toohello вторичной конечной точки и запустите приложение hello в режиме только для чтения. Например можно принять решение коммутатора hello tooperform случае в строке нет успешных 10 сбоев. Другой пример — tooswitch при сбое 90% hello запросов в течение 2 минут.

Для первого сценария hello можно просто вести счетчик сбоев hello и при наличии до достижения успеха hello задней toozero hello, необходимо задать максимальное число. Для второй сценарий hello одним из способов tooimplement это toouse hello объекта MemoryCache (в .NET). Для каждого запроса добавления кэша toohello CacheItem, задайте значение hello toosuccess (1) или сбой (0) и задание минут too2 времени истечения срока действия hello с теперь (или что там ограничение времени). По истечении времени истечения срока действия записи hello запись автоматически удаляется. Это обеспечит скользящее окно в 2 минуты. Каждый раз при внесении в службу хранилища toohello запрос, сначала используется запрос Linq через hello MemoryCache объекта toocalculate hello процент успешных операций путем суммирования значений hello hello count. Если процент успешных операций hello становится меньше некоторое пороговое значение (например, 10%), задать hello **LocationMode** свойство для чтения запросов слишком**SecondaryOnly** и переключение приложения hello в режиме только для чтения, прежде чем Продолжение.

Порог ошибок, произошедших Hello используется toodetermine при toomake hello коммутатор может отличаться от tooservice службы в приложении, это следует учитывать, что их можно настроить параметры. Это также где решить повторяемая ошибки toohandle из каждой службы, отдельно или как один, как описано выше.

Другой аспект — как toohandle несколько экземпляров приложения и какие toodo при обнаружении ошибки, допускающей повторение попытки в каждом экземпляре. Например имеется 20 виртуальных машин, работающих с hello загрузки того же приложения. Каждый экземпляр будет обрабатываться отдельно? Если один экземпляр начинается возникают проблемы, действительно toojust ответ toolimit hello, один экземпляр или вы хотите tootry toohave все экземпляры ответ в hello таким же, каким образом в том случае, когда один экземпляр возникла проблема? Обработка экземпляров hello отдельно гораздо проще, чем toocoordinate hello ответа между ними, но способ определения зависит от архитектуры приложения.

### <a name="options-for-monitoring-hello-error-frequency"></a>Средства наблюдения за частоты ошибок hello

У вас есть три основные параметры для мониторинга hello частоту повторов в первичном регионе hello в порядке toodetermine при tooswitch над toohello дополнительный регион и изменение hello toorun приложения в режиме только для чтения.

*   Добавление обработчика для hello [ **Повтор** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) события hello [ **OperationContext** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) объекта передачи запросов хранилища tooyour — в данном случае hello метод отображается в этой статье и используется в сообщения, сопровождающие образец hello. Эти события возникают всякий раз, когда клиент hello пытается выполнить запрос, позволяя tootrack как часто клиент hello обнаруживает повторяемая ошибки на основную конечную точку.

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in hello primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   В hello [ **Evaluate** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) метод в пользовательскую политику повторения можно выполнять пользовательский код каждый раз, когда выполняется повторная попытка. В дополнение toorecording, когда происходит повторная попытка, это также дает возможности toomodify hello поведение повторных попыток.

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in hello primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   Hello третий способ — tooimplement пользовательского компонента мониторинга в приложении, которое постоянно опрашивает ваш конечная точка основного хранилища с фиктивным прочитать его работоспособности toodetermine запросов (таких как чтение небольших больших двоичных объектов). Это может потребовать какое-то количество ресурсов, но не значительное. При обнаружении проблемы, который достигает порог, которые затем выполняются коммутатора hello слишком**SecondaryOnly** и только для чтения.

На некотором этапе может потребоваться назад toousing tooswitch hello основную конечную точку и разрешение обновлений. Если используется один из перечисленных выше первые два метода hello, можно просто переключиться назад toohello основную конечную точку и включите режим обновления после выполнения произвольно выбранного периода времени или несколько операций. Затем можно его пройти hello логику повторных попыток. Если hello проблема была исправлена, оно основную конечную точку hello toouse продолжить и разрешить обновления. Если проблема остается, он еще раз переключается назад toohello вторичной конечной точки и только для чтения после сбоя hello критерии, которые заданы.

Для третьего сценария hello, когда обмен пакетами конечная точка основного хранилища hello становится успешно снова, вы можете активировать вернуться к использованию hello слишком**PrimaryOnly** и продолжить разрешение обновлений.

## <a name="handling-eventually-consistent-data"></a>Обработка данных, согласованных в конечном счете

RA-GRS работает путем репликации транзакции из вторичного региона основной toohello hello. Репликация обеспечивает hello данные в дополнительный регион hello *согласованным*. Это означает, что все транзакции hello в основном регионе hello в конечном счете будут отображаться в дополнительный регион hello, но что возможна задержка до их появления, а что нет никакой гарантии hello транзакции поступают в дополнительный регион hello в же порядка следования hello в котором они были первоначально применены в основном регионе hello. Если в транзакциях поступают в дополнительный регион hello не по порядку, вы *может* рассмотрите возможность данные в toobe hello дополнительный регион в несогласованном состоянии, пока захватывается hello службы.

Hello следующей таблице показан пример что может произойти при обновлении hello подробные сведения о сотрудниках toomake ей членом hello *Администраторы* роли. Ради hello в этом примере для этого необходимо обновить hello **сотрудника** сущности и обновление **роли администратора** сущности с количеством hello общее число администраторов. Обратите внимание на то, как hello обновления применяются по порядку в дополнительный регион hello.

| **Время** | **Транзакция**                                            | **Репликация**                       | **Last Sync Time** | **Результат** |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| T0       | Транзакция А: <br> вставка сущности <br> сотрудника в основном регионе. |                                   |                    | Транзакция А вставлены tooprimary,<br> но еще не реплицирована. |
| T1       |                                                            | Транзакция А <br> реплицирована в<br> дополнительный регион. | T1 | Транзакция А реплицируются toosecondary. <br>Значение Last Sync Time обновлено.    |
| T2       | Транзакция Б:<br>Блокировка изменений<br> обновление сущности сотрудника<br> в основном регионе.  |                                | T1                 | Транзакция Б, записанных tooprimary,<br> но еще не реплицирована.  |
| T3       | Транзакция В:<br> Блокировка изменений <br>administrator<br>сущности роли в<br>primary |                    | T1                 | Транзакции записываются tooprimary, C<br> но еще не реплицирована.  |
| *T4*     |                                                       | Транзакция В <br>реплицирована в<br> дополнительный регион. | T1         | Операции C реплицируются toosecondary.<br>Значение Last Sync Time не обновлено, так как <br>транзакция Б еще не реплицирована.|
| *T5*     | Чтение сущностей <br>из дополнительного региона.                           |                                  | T1                 | Получить hello устаревшее значение для сотрудника <br> сущности employee, так как транзакция Б <br> еще не реплицирована. Получить hello новое значение<br> сущности administrator role, так как<br> транзакция В реплицирована. Значение Last Sync Time<br> все еще не обновлено, так как транзакция Б<br> не реплицирована. Можно считать сущность<br>administrator role несогласованной, <br>так как после hello объекта даты и времени <br>Здравствуйте, время последней синхронизации. |
| *T6*     |                                                      | Транзакция Б<br> реплицирована в<br> дополнительный регион. | T6                 | *T6* — всех транзакции вплоть до В <br>реплицированы, значение Last Sync Time<br> обновлено. |

В этом примере предполагается tooreading коммутаторы hello клиента из вторичного региона hello в T5. Успешно прочитать hello **роли администратора** сущности в данный момент, но hello объекта содержит значение для hello число администраторов, не согласуется с количеством hello **сотрудника** сущностей в настоящее время, которые помечены как администраторов в дополнительный регион hello. Клиент может просто отобразить это значение с hello риск, что это несогласованные данные. Кроме того, hello клиент может попытаться toodetermine, hello **роли администратора** находится в состоянии несовместимости, поскольку обновления hello произойти не по порядку и уведомите пользователя hello этого факта.

toorecognize при наличии потенциально несогласованности данных, hello клиент может использовать значение hello hello *время последней синхронизации* получить в любое время с помощью запроса к службе хранения. Это значит hello время, время последнего hello данные в дополнительный регион hello согласованное и когда hello службы был применен все hello точки предыдущего toothat транзакции времени. В примере hello, показанном выше, после обновления hello вставок hello **сотрудника** сущности в дополнительный регион hello hello время последней синхронизации задано слишком*T1*. Остается на *T1* до обновления службы hello hello **сотрудника** сущности в дополнительный регион hello, если он установлен слишком*T6*. Если клиент hello получает hello чтением hello объекта во время последней синхронизации *T5*, его можно сравнить с меткой времени hello hello сущности. Если отметки времени hello сущности hello позже hello время последней синхронизации, а затем hello сущность является потенциально несогласованное состояние на, а может занять все, что является hello необходимые действия для приложения. С помощью этого поля требуется знать завершения hello последнего обновления toohello первичной.

## <a name="testing"></a>Тестирование

Это важные tootest поведения приложения должным образом при обнаружении ошибки, допускающей повторение попытки. Например потребуется tootest, hello toohello коммутаторы приложение получателей, и в режиме только для чтения после обнаруживает проблему, и возвращается при первичном регионе hello снова становится доступным. toodo это, нужно ошибки, допускающей повторение попытки способом toosimulate и контролировать, как часто они встречаются.

Можно использовать [Fiddler](http://www.telerik.com/fiddler) toointercept и изменить HTTP-ответов в скрипте. Этот скрипт можно определить ответов, полученных от первичной конечной точки и изменение tooone код состояния HTTP hello приветствия, клиентская библиотека хранилища распознает как Повторяемая ошибка. Этот фрагмент кода показан простой пример Fiddler скрипта, который перехватывает запросы tooread ответы на основе hello **employeedata** tooreturn таблицы 502 состояния:

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

Можно расширить этот пример toointercept более широкого круга запросов и изменять только hello **responseCode** на некоторые из них toobetter имитировать реальном сценарии. Дополнительные сведения о настройке Fiddler скриптов см. в разделе [изменения запроса или ответа](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) в hello Fiddler документации.

При внесении hello пороговые значения для вашего приложения tooread режиме можно настроить переключение будет проще поведение hello tootest с объемами транзакций нерабочей.

## <a name="next-steps"></a>Дальнейшие действия

* Дополнительные сведения о доступ на чтение географической избыточности, включая настроек hello LastSyncTime, еще один пример см. в разделе [параметры избыточности хранилища Windows Azure и доступ для чтения Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).

* Полный пример, показывающий, как toomake hello коммутатора вперед и назад между конечными точками hello первичной и вторичной, см. в разделе [образцы Azure — с помощью шаблона Размыкателя цепи hello с хранилищем RA-GRS](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).
