---
title: "Проектирование высокодоступных приложений с использованием геоизбыточного хранилища с доступом на чтение Azure (RA-GRS) | Документация Майкрософт"
description: "Как использовать хранилище RA-GRS Azure для разработки высокодоступного приложения, достаточно гибкого для обработки сбоев."
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: adc7e23d8c9f869f2951490020e3d0f1a2b2e81c
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/29/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="29100-103">Проектирование высокодоступных приложений с использованием RA-GRS</span><span class="sxs-lookup"><span data-stu-id="29100-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="29100-104">Характерной чертой облачных инфраструктур является то, что они предоставляют высокодоступную платформу для размещения приложений.</span><span class="sxs-lookup"><span data-stu-id="29100-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="29100-105">Разработчикам облачных приложений необходимо внимательно обдумать, как эффективно использовать эту платформу, чтобы обеспечить высокий уровень доступности приложений пользователям.</span><span class="sxs-lookup"><span data-stu-id="29100-105">Developers of cloud-based applications must consider carefully how to leverage this platform to deliver highly available applications to their users.</span></span> <span data-ttu-id="29100-106">В этой статье особое внимание уделяется тому, как разработчики могут использовать геоизбыточное хранилище с доступом на чтение (RA-GRS) в службе хранилища Azure для повышения доступности своих приложений.</span><span class="sxs-lookup"><span data-stu-id="29100-106">This article focuses specifically on how developers can use the Azure Storage Read Access Geo Redundant Storage (RA-GRS) to make their applications more available.</span></span>

<span data-ttu-id="29100-107">Доступно четыре варианта обеспечения избыточности: LRS (локально избыточное хранилище), ZRS (хранилище, избыточное в пределах зоны), GRS (геоизбыточное хранилище) и RA-GRS (геоизбыточное хранилище с доступом на чтение).</span><span class="sxs-lookup"><span data-stu-id="29100-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="29100-108">В этой статье мы рассмотрим GRS и RA-GRS.</span><span class="sxs-lookup"><span data-stu-id="29100-108">We are going to discuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="29100-109">При использовании GRS три копии ваших данных хранятся в основном регионе, выбранном при настройке учетной записи хранения.</span><span class="sxs-lookup"><span data-stu-id="29100-109">With GRS, three copies of your data are kept in the primary region you selected when setting up the storage account.</span></span> <span data-ttu-id="29100-110">Три дополнительные копии сохраняются асинхронно в дополнительном регионе, заданном Azure.</span><span class="sxs-lookup"><span data-stu-id="29100-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="29100-111">Хранилище RA-GRS похоже на GRS, за исключением того, что у вас есть доступ на чтение к дополнительной копии.</span><span class="sxs-lookup"><span data-stu-id="29100-111">RA-GRS is the same thing as GRS except that you have read access to the secondary copy.</span></span> <span data-ttu-id="29100-112">Дополнительные сведения о различных вариантах обеспечения избыточности в службе хранилища Azure см. в статье [Репликация службы хранилища Azure](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span><span class="sxs-lookup"><span data-stu-id="29100-112">For more information about the different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="29100-113">В статье о репликации также показано связывание основных и дополнительных регионов.</span><span class="sxs-lookup"><span data-stu-id="29100-113">The replication article also shows the pairings of the primary and secondary regions.</span></span>

<span data-ttu-id="29100-114">Эта статья содержит фрагменты кода и ссылку на полный пример в конце, который можно скачать и запустить.</span><span class="sxs-lookup"><span data-stu-id="29100-114">There are code snippets included in this article, and a link to a complete sample at the end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="29100-115">Ключевые возможности RA-GRS</span><span class="sxs-lookup"><span data-stu-id="29100-115">Key features of RA-GRS</span></span>

<span data-ttu-id="29100-116">Прежде чем говорить о том, как использовать хранилище RA-GRS, давайте поговорим о его свойствах и поведении.</span><span class="sxs-lookup"><span data-stu-id="29100-116">Before we talk about how to use RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="29100-117">Служба хранилища Azure сохраняет в дополнительном регионе доступную только для чтения копию данных из основного региона. Как отмечалось выше, расположение этого дополнительного региона определяет служба хранилища.</span><span class="sxs-lookup"><span data-stu-id="29100-117">Azure Storage maintains a read-only copy of the data you store in your primary region in a secondary region; as noted above, the storage service determines the location of the secondary region.</span></span>

* <span data-ttu-id="29100-118">Доступная только для чтения копия [согласована в конечном счете](https://en.wikipedia.org/wiki/Eventual_consistency) с данными в основной области.</span><span class="sxs-lookup"><span data-stu-id="29100-118">The read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with the data in the primary region.</span></span>

* <span data-ttu-id="29100-119">Для больших двоичных объектов, таблиц и очередей можно отправить запрос в дополнительный регион, чтобы получить значение *Last Sync Time*. Оно указывает, когда произошла последняя репликация из основного региона в дополнительный.</span><span class="sxs-lookup"><span data-stu-id="29100-119">For blobs, tables, and queues, you can query the secondary region for a *Last Sync Time* value that tells you when the last replication from the primary to the secondary region occurred.</span></span> <span data-ttu-id="29100-120">(Это не работает для хранилища файлов Azure, которое не обеспечивает избыточность RA-GRS.)</span><span class="sxs-lookup"><span data-stu-id="29100-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="29100-121">Вы можете использовать клиентскую библиотеку службы хранилища для взаимодействия с данными в основном или дополнительном регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-121">You can use the Storage Client Library to interact with the data in either the primary or secondary region.</span></span> <span data-ttu-id="29100-122">Можно также автоматически перенаправлять запросы на чтение в дополнительный регион, если истекло время ожидания запроса на чтение в основном регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-122">You can also redirect read requests automatically to the secondary region if a read request to the primary region times out.</span></span>

* <span data-ttu-id="29100-123">В случае серьезной проблемы, влияющей на доступность данных в основном регионе, команда Azure может активировать географическую отработку отказа. При этом записи DNS, указывающие на основной регион, будут изменены, чтобы указывать на дополнительный регион.</span><span class="sxs-lookup"><span data-stu-id="29100-123">If there is a major issue affecting the accessibility of the data in the primary region, the Azure team may trigger a geo-failover, at which point the DNS entries pointing to the primary region will be changed to point to the secondary region.</span></span>

* <span data-ttu-id="29100-124">В случае географической отработки отказа Azure выберет новое дополнительное расположение и будет реплицировать данные в него, после чего укажет его в дополнительных записях DNS.</span><span class="sxs-lookup"><span data-stu-id="29100-124">If a geo-failover occurs, Azure will select a new secondary location and replicate the data to that location, then point the secondary DNS entries to it.</span></span> <span data-ttu-id="29100-125">Вторичная конечная точка будет недоступна до завершения репликации учетной записи хранения.</span><span class="sxs-lookup"><span data-stu-id="29100-125">The secondary endpoint will be unavailable until the storage account has finished replicating.</span></span> <span data-ttu-id="29100-126">Дополнительные сведения см. в разделе [Что делать в случае простоя службы хранилища Azure](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span><span class="sxs-lookup"><span data-stu-id="29100-126">For more information, please see [What to do if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="29100-127">Рекомендации по проектированию приложений при использовании RA-GRS</span><span class="sxs-lookup"><span data-stu-id="29100-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="29100-128">Главная цель этой статьи — показать, как спроектировать приложение, которое будет работать (хотя и с ограниченными возможностями) даже в случае серьезной аварии в центре обработки данных.</span><span class="sxs-lookup"><span data-stu-id="29100-128">The main purpose of this article is to show you how to design an application that will continue to function (albeit in a limited capacity) even in the event of a major disaster at the primary data center.</span></span> <span data-ttu-id="29100-129">Для этого приложение должно обрабатывать временные или длительные проблемы, переключаясь на чтение из дополнительного региона на период существования проблемы, а затем переключаясь обратно, когда основной регион снова станет доступным.</span><span class="sxs-lookup"><span data-stu-id="29100-129">You do this by having your application to handle transient or long-running issues by switching to read from the secondary region while there is a problem, and switching back when the primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="29100-130">Использование данных, согласованных в конечном счете</span><span class="sxs-lookup"><span data-stu-id="29100-130">Using eventually consistent data</span></span>

<span data-ttu-id="29100-131">Предлагаемое решение предполагает, что вполне допустимо вернуть вызывающему приложению потенциально устаревшие данные.</span><span class="sxs-lookup"><span data-stu-id="29100-131">This proposed solution assumes that it is okay to return what could be stale data to the calling application.</span></span> <span data-ttu-id="29100-132">Так как данные в дополнительном регионе являются согласованными в конечном счете, вполне возможна ситуация, когда они будут записаны в основной регион, но репликация обновления в дополнительный регион будет не завершена, когда основной регион станет недоступен.</span><span class="sxs-lookup"><span data-stu-id="29100-132">Because the secondary data is eventually consistent, it is possible that the data was written to the primary but the update to the secondary had not finished replicating when the primary region became inaccessible.</span></span>

<span data-ttu-id="29100-133">Например, клиент может успешно отправить обновление, после чего основной регион может выйти из строя до того, как обновления распространятся на дополнительный регион.</span><span class="sxs-lookup"><span data-stu-id="29100-133">For example, your customer could submit an update that is successful, and then the primary could go down before the update is propagated to the secondary.</span></span> <span data-ttu-id="29100-134">В этом случае, если клиент запросит чтение этих данных, то он получит устаревшие данные вместо обновленных данных.</span><span class="sxs-lookup"><span data-stu-id="29100-134">In this case, if the customer then asks to read the data back, he receives the stale data instead of the updated data.</span></span> <span data-ttu-id="29100-135">Вам нужно решить, допустимо ли это, и если допустимо, то необходимо определить способ уведомления клиента.</span><span class="sxs-lookup"><span data-stu-id="29100-135">You must decide if this is acceptable, and if so, how you will message the customer.</span></span> <span data-ttu-id="29100-136">Далее в этой статье вы узнаете, как проверить время последней синхронизации данных в дополнительном регионе, чтобы определить, актуальны ли они.</span><span class="sxs-lookup"><span data-stu-id="29100-136">You'll see how to check the Last Sync Time on the secondary data later in this article to see if the secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="29100-137">Отдельная или совместная обработка служб</span><span class="sxs-lookup"><span data-stu-id="29100-137">Handling services separately or all together</span></span>

<span data-ttu-id="29100-138">Хотя это маловероятно, возможна ситуация, когда одна служба станет недоступна, в то время как другие службы будут по-прежнему работать в полнофункциональном режиме.</span><span class="sxs-lookup"><span data-stu-id="29100-138">While not likely, it is possible for one service to become unavailable while the other services are still fully functional.</span></span> <span data-ttu-id="29100-139">Можно обрабатывать повторные попытки и режим только для чтения для каждой службы отдельно (большие двоичные объекты, очереди, таблицы) или универсально для всех служб хранилища.</span><span class="sxs-lookup"><span data-stu-id="29100-139">You can handle the retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all the storage services together.</span></span>

<span data-ttu-id="29100-140">Например, при использовании очередей и больших двоичных объектов в приложении можно добавить отдельный код для каждой из этих сущностей, обрабатывающий ошибки, допускающие повторение.</span><span class="sxs-lookup"><span data-stu-id="29100-140">For example, if you use queues and blobs in your application, you may decide to put in separate code to handle retryable errors for each of these.</span></span> <span data-ttu-id="29100-141">Затем, если произойдет ошибка службы BLOB-объектов и потребуется повторить попытку, а служба очередей останется работоспособной, будет затронута только та часть приложения, которая обрабатывают большие двоичные объекты.</span><span class="sxs-lookup"><span data-stu-id="29100-141">Then if you get a retry from the blob service, but the queue service is still working, only the part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="29100-142">Если вы решите универсально обрабатывать все повторные попытки операций служб хранилища и вызов к службе BLOB-объектов вернет ошибку, допускающую повторение, то будут запросы и к службе BLOB-объектов, и к службе очередей.</span><span class="sxs-lookup"><span data-stu-id="29100-142">If you decide to handle all storage service retries generically and a call to the blob service returns a retryable error, then requests to both the blob service and the queue service will be impacted.</span></span>

<span data-ttu-id="29100-143">В конечном счете решение зависит от сложности приложения.</span><span class="sxs-lookup"><span data-stu-id="29100-143">Ultimately, this depends on the complexity of your application.</span></span> <span data-ttu-id="29100-144">Можно не обрабатывать сбои каждой отдельной службы, а вместо этого перенаправлять запросы на чтение для всех служб хранилища в дополнительный регион чтения и запускать приложение в режиме только для чтения при обнаружении проблемы в работе какой-либо службы хранения в основном регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-144">You may decide not to handle the failures by service, but instead to redirect read requests for all storage services to the secondary region and run the application in read-only mode when you detect a problem with any storage service in the primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="29100-145">Дополнительные рекомендации</span><span class="sxs-lookup"><span data-stu-id="29100-145">Other considerations</span></span>

<span data-ttu-id="29100-146">Ниже приведены дополнительные рекомендации, которые будут рассмотрены в оставшейся части этой статьи.</span><span class="sxs-lookup"><span data-stu-id="29100-146">These are the other considerations we will discuss in the rest of this article.</span></span>

*   <span data-ttu-id="29100-147">Обработка повторных запросов на чтение с помощью шаблона автоматического выключения.</span><span class="sxs-lookup"><span data-stu-id="29100-147">Handling retries of read requests using the Circuit Breaker pattern</span></span>

*   <span data-ttu-id="29100-148">Согласованные в конечном счете данные и время последней синхронизации.</span><span class="sxs-lookup"><span data-stu-id="29100-148">Eventually-consistent data and the Last Sync Time</span></span>

*   <span data-ttu-id="29100-149">Тестирование</span><span class="sxs-lookup"><span data-stu-id="29100-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="29100-150">Выполнение приложения в режиме только для чтения</span><span class="sxs-lookup"><span data-stu-id="29100-150">Running your application in read-only mode</span></span>

<span data-ttu-id="29100-151">Чтобы использовать хранилище RA-GRS, требуется возможность обрабатывать как невыполненные запросы на чтение, так и невыполненные запросы на обновление (под обновлением в данном случае подразумеваются операции вставки, изменения и удаления).</span><span class="sxs-lookup"><span data-stu-id="29100-151">To use RA-GRS storage, you must be able to handle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="29100-152">В случае сбоя основного центра обработки данных запросы на чтение могут быть перенаправлены в дополнительный центр обработки данных, но запросы на обновление не могут, так как этот центр обработки данных доступен только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-152">If the primary data center fails, read requests can be redirected to the secondary data center, but update requests cannot because the secondary is read only.</span></span> <span data-ttu-id="29100-153">По этой причине нужен способ запуска приложения в режиме только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-153">For this reason, you need some way to run your application in read-only mode.</span></span>

<span data-ttu-id="29100-154">Например, можно установить флаг, который будет проверяться перед отправкой любых запросов на обновление в службу хранилища.</span><span class="sxs-lookup"><span data-stu-id="29100-154">For example, you can set a flag that will be checked before submitting any update requests to the storage service.</span></span> <span data-ttu-id="29100-155">Пр поступлении запроса на обновление его можно пропустить и вернуть пользователю соответствующий ответ.</span><span class="sxs-lookup"><span data-stu-id="29100-155">When one of the update requests comes through, you can skip it and return an appropriate response to the customer.</span></span> <span data-ttu-id="29100-156">Можно даже полностью отключить определенные функции до устранения проблемы и уведомить пользователей, что эти функции будут временно недоступны.</span><span class="sxs-lookup"><span data-stu-id="29100-156">You may even want to disable certain features altogether until the problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="29100-157">Если принято решение отдельно обрабатывать ошибки каждой службы, то необходимо также реализовать возможность запуска службой приложения в режиме только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-157">If you decide to handle errors for each service separately, you will also need to handle the ability to run your application in read-only mode by service.</span></span> <span data-ttu-id="29100-158">Для каждой службы можно использовать флаги режима только для чтения, которые можно включать и отключать, и обрабатывать соответствующий флаг в соответствующих частях кода.</span><span class="sxs-lookup"><span data-stu-id="29100-158">You could have read-only flags for each service that can be enabled and disabled and handle the appropriate flag in the appropriate places in your code.</span></span>

<span data-ttu-id="29100-159">Возможность запуска приложения в режиме только для чтения имеет еще одно преимущество — дает возможность ограничить функциональность во время обновления основного приложения.</span><span class="sxs-lookup"><span data-stu-id="29100-159">Being able to run your application in read-only mode has another side benefit – it gives you the ability to ensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="29100-160">Можно активировать запуск приложения в режиме только для чтения и указать дополнительный центр обработки данных. Это гарантирует, что никто не получит доступ к данным в основном регионе, пока выполняется обновление.</span><span class="sxs-lookup"><span data-stu-id="29100-160">You can trigger your application to run in read-only mode and point to the secondary data center, ensuring nobody is accessing the data in the primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="29100-161">Обработка обновлений в режиме только для чтения</span><span class="sxs-lookup"><span data-stu-id="29100-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="29100-162">Существует множество способов обработки запросов на обновление в режиме только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-162">There are many ways to handle update requests when running in read-only mode.</span></span> <span data-ttu-id="29100-163">Мы не сможем подробно рассмотреть их все, но в целом существует несколько шаблонов, которые вам стоит принять во внимание.</span><span class="sxs-lookup"><span data-stu-id="29100-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="29100-164">Можно ответить пользователям и сообщить, что в настоящее время обновления не принимаются.</span><span class="sxs-lookup"><span data-stu-id="29100-164">You can respond to your user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="29100-165">Например, система управления контактами может предоставлять клиентам доступ к контактной информации, но не сохранять изменения.</span><span class="sxs-lookup"><span data-stu-id="29100-165">For example, a contact management system could enable customers to access contact information but not make updates.</span></span>

2.  <span data-ttu-id="29100-166">Можно поставить обновления в очередь в другом регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="29100-167">В этом случае отложенные запросы на обновление нужно будет записывать в очередь в другом регионе, а затем каким-то образом обрабатывать их после возобновления работы основного центра обработки данных.</span><span class="sxs-lookup"><span data-stu-id="29100-167">In this case, you would write your pending update requests to a queue in a different region, and then have a way to process those requests after the primary data center comes online again.</span></span> <span data-ttu-id="29100-168">В этом сценарии следует сообщить пользователю, что запрошенное обновление поставлено в очередь для последующей обработки.</span><span class="sxs-lookup"><span data-stu-id="29100-168">In this scenario, you should let the customer know that the update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="29100-169">Можно записывать обновления в учетную запись хранения в другом регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-169">You can write your updates to a storage account in another region.</span></span> <span data-ttu-id="29100-170">А когда возобновится работоспособность основного центра обработки данных, каким-либо образом объединить эти обновления с основными данными, в зависимости от их структуры.</span><span class="sxs-lookup"><span data-stu-id="29100-170">Then when the primary data center comes back online, you can have a way to merge those updates into the primary data, depending on the structure of the data.</span></span> <span data-ttu-id="29100-171">Например, если создаются отдельные файлы с меткой даты и времени в имени, их можно скопировать обратно в основной регион.</span><span class="sxs-lookup"><span data-stu-id="29100-171">For example, if you are creating separate files with a date/time stamp in the name, you can copy those files back to the primary region.</span></span> <span data-ttu-id="29100-172">Это подходит для некоторых рабочих нагрузок, например ведения журнала и данных Интернета вещей.</span><span class="sxs-lookup"><span data-stu-id="29100-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="29100-173">Обработка повторных попыток</span><span class="sxs-lookup"><span data-stu-id="29100-173">Handling retries</span></span>

<span data-ttu-id="29100-174">Как узнать, какие ошибки допускают повторение?</span><span class="sxs-lookup"><span data-stu-id="29100-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="29100-175">Это определяет клиентская библиотека службы хранилища.</span><span class="sxs-lookup"><span data-stu-id="29100-175">This is determined by the storage client library.</span></span> <span data-ttu-id="29100-176">Например, сообщение об ошибке 404 (ресурс не найден) не допускает повторения, так как маловероятно, что повторная попытка увенчается успехом.</span><span class="sxs-lookup"><span data-stu-id="29100-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely to result in success.</span></span> <span data-ttu-id="29100-177">С другой стороны, ошибка 500 допускает повторение, так как это ошибка сервера, которая может оказаться лишь временной.</span><span class="sxs-lookup"><span data-stu-id="29100-177">On the other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="29100-178">Для получения дополнительных сведений ознакомьтесь с [открытым кодом класса ExponentialRetry](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) в клиентской библиотеке службы хранилища для .NET.</span><span class="sxs-lookup"><span data-stu-id="29100-178">For more details, check out the [open source code for the ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in the .NET storage client library.</span></span> <span data-ttu-id="29100-179">(Найдите метод ShouldRetry.)</span><span class="sxs-lookup"><span data-stu-id="29100-179">(Look for the ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="29100-180">Запросы на чтение</span><span class="sxs-lookup"><span data-stu-id="29100-180">Read requests</span></span>

<span data-ttu-id="29100-181">В случае проблем с основным хранилищем запросы на чтение можно перенаправлять в дополнительное хранилище.</span><span class="sxs-lookup"><span data-stu-id="29100-181">Read requests can be redirected to secondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="29100-182">Как было отмечено выше в разделе [Использование данных, согласованных в конечном счете](#using-eventually-consistent-data), для вашего приложения должно быть приемлемым чтение потенциально устаревших данных.</span><span class="sxs-lookup"><span data-stu-id="29100-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application to potentially read stale data.</span></span> <span data-ttu-id="29100-183">При использовании клиентской библиотеки службы хранилища для доступа к данным RA-GRS можно задать режим повторения запросов на чтение, задав для свойства **LocationMode** одно из следующих значений:</span><span class="sxs-lookup"><span data-stu-id="29100-183">If you are using the storage client library to access RA-GRS data, you can specify the retry behavior of a read request by setting a value for the **LocationMode** property to one of the following:</span></span>

*   <span data-ttu-id="29100-184">**PrimaryOnly** (по умолчанию);</span><span class="sxs-lookup"><span data-stu-id="29100-184">**PrimaryOnly** (the default)</span></span>

*   <span data-ttu-id="29100-185">**PrimaryThenSecondary**;</span><span class="sxs-lookup"><span data-stu-id="29100-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="29100-186">**SecondaryOnly**;</span><span class="sxs-lookup"><span data-stu-id="29100-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="29100-187">**SecondaryThenPrimary**.</span><span class="sxs-lookup"><span data-stu-id="29100-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="29100-188">Если присвоить **LocationMode** значение **PrimaryThenSecondary**, то если при первоначальном запросе на чтение к основной конечной точке происходит ошибка, допускающая повторение, то клиент автоматически выполняет другой запрос на чтение к дополнительной конечной точке.</span><span class="sxs-lookup"><span data-stu-id="29100-188">When you set the **LocationMode** to **PrimaryThenSecondary**, if the initial read request to the primary endpoint fails with a retryable error, the client automatically makes another read request to the secondary endpoint.</span></span> <span data-ttu-id="29100-189">Если ошибка возникла из-за времени ожидания сервера, то клиенту придется дождаться, пока не истечет время ожидания, прежде чем служба вернет ему сообщение об ошибке, допускающей повторение.</span><span class="sxs-lookup"><span data-stu-id="29100-189">If the error is a server timeout, then the client will have to wait for the timeout to expire before it receives a retryable error from the service.</span></span>

<span data-ttu-id="29100-190">По сути, решая, как реагировать на ошибки, допускающие повторение, следует учитывать два сценария:</span><span class="sxs-lookup"><span data-stu-id="29100-190">There are basically two scenarios to consider when you are deciding how to respond to a retryable error:</span></span>

*   <span data-ttu-id="29100-191">Это изолированная проблема, и последующие запросы к основной конечной точке не вернут ошибку, допускающую повторение.</span><span class="sxs-lookup"><span data-stu-id="29100-191">This is an isolated problem and subsequent requests to the primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="29100-192">Например, такая ситуация может сложиться при временной ошибке в сети.</span><span class="sxs-lookup"><span data-stu-id="29100-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="29100-193">В этом сценарии присвоение **LocationMode** значения **PrimaryThenSecondary** почти не скажется на производительности, так как это происходит редко.</span><span class="sxs-lookup"><span data-stu-id="29100-193">In this scenario, there is no significant performance penalty in having **LocationMode** set to **PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="29100-194">Это проблема в работе по крайней мере одной из служб хранилища в основном регионе, и все последующие запросы к этой службе в основном регионе, скорее всего, какое-то время будут возвращать ошибки, допускающие повторение.</span><span class="sxs-lookup"><span data-stu-id="29100-194">This is a problem with at least one of the storage services in the primary region and all subsequent requests to that service in the primary region are likely to return retryable errors for a period of time.</span></span> <span data-ttu-id="29100-195">Примером этого является ситуация, когда основной регион полностью недоступен.</span><span class="sxs-lookup"><span data-stu-id="29100-195">An example of this is if the primary region is completely inaccessible.</span></span>

    <span data-ttu-id="29100-196">В этом сценарии производительность снижается, так как все запросы на чтение сначала будут пытаться использовать основную конечную точку и ждать истечения времени ожидания, а затем переключаться на дополнительную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="29100-196">In this scenario, there is a performance penalty because all your read requests will try the primary endpoint first, wait for the timeout to expire, then switch to the secondary endpoint.</span></span>

<span data-ttu-id="29100-197">В таких сценариях следует выявлять текущие проблемы с основной конечной точки и отправлять все запросы на чтение напрямую к дополнительной конечной точке, присвоив свойству **LocationMode** значение **SecondaryOnly**.</span><span class="sxs-lookup"><span data-stu-id="29100-197">For these scenarios, you should identify that there is an ongoing issue with the primary endpoint and send all read requests directly to the secondary endpoint by setting the **LocationMode** property to **SecondaryOnly**.</span></span> <span data-ttu-id="29100-198">На данном этапе следует также изменить режим запуска приложения на "только для чтения".</span><span class="sxs-lookup"><span data-stu-id="29100-198">At this time, you should also change the application to run in read-only mode.</span></span> <span data-ttu-id="29100-199">Этот подход известен как [шаблон автоматического выключения](https://msdn.microsoft.com/library/dn589784.aspx).</span><span class="sxs-lookup"><span data-stu-id="29100-199">This approach is known as the [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="29100-200">Запросы на обновление</span><span class="sxs-lookup"><span data-stu-id="29100-200">Update requests</span></span>

<span data-ttu-id="29100-201">Шаблон автоматического выключения может также применяться для запросов на обновление.</span><span class="sxs-lookup"><span data-stu-id="29100-201">The Circuit Breaker pattern can also be applied to update requests.</span></span> <span data-ttu-id="29100-202">Тем не менее запросы на обновление невозможно перенаправлять в дополнительное хранилище, которое доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-202">However, update requests cannot be redirected to secondary storage, which is read-only.</span></span> <span data-ttu-id="29100-203">Для этих запросов следует оставить используемое по умолчанию значение свойства **LocationMode** — **PrimaryOnly**.</span><span class="sxs-lookup"><span data-stu-id="29100-203">For these requests, you should leave the **LocationMode** property set to **PrimaryOnly** (the default).</span></span> <span data-ttu-id="29100-204">Чтобы обработать данные ошибки, можно применить метрики для этих запросов (например, 10 ошибок подряд) и по достижении порога переключать приложение в режим только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-204">To handle these errors, you can apply a metric to these requests – such as 10 failures in a row – and when your threshold is met, switch the application into read-only mode.</span></span> <span data-ttu-id="29100-205">Эти же методы можно использовать для возвращения в режим обновления, как описано в следующем разделе о шаблоне автоматического выключения.</span><span class="sxs-lookup"><span data-stu-id="29100-205">You can use the same methods for returning to update mode as those described below in the next section about the Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="29100-206">Шаблон автоматического выключения</span><span class="sxs-lookup"><span data-stu-id="29100-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="29100-207">С помощью шаблона автоматического выключения в приложении можно предотвратить повторное выполнение операции, которая, вероятнее всего, будет приводить к повторным сбоям.</span><span class="sxs-lookup"><span data-stu-id="29100-207">Using the Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely to fail repeatedly.</span></span> <span data-ttu-id="29100-208">Это позволяет приложению продолжать работу, а не тратить время на повторение операций по нарастающей.</span><span class="sxs-lookup"><span data-stu-id="29100-208">It allows the application to continue to run rather than taking up time while the operation is retried exponentially.</span></span> <span data-ttu-id="29100-209">Шаблон также обнаружит, когда будет исправлена ошибка, и в этот момент приложение сможет повторить операцию.</span><span class="sxs-lookup"><span data-stu-id="29100-209">It also detects when the fault has been fixed, at which time the application can try the operation again.</span></span>

### <a name="how-to-implement-the-circuit-breaker-pattern"></a><span data-ttu-id="29100-210">Как реализовать шаблон автоматического выключения</span><span class="sxs-lookup"><span data-stu-id="29100-210">How to implement the circuit breaker pattern</span></span>

<span data-ttu-id="29100-211">Для выявления проблемы в работе основной конечной точки можно отслеживать, как часто клиент сталкивается с ошибками, допускающими повторение.</span><span class="sxs-lookup"><span data-stu-id="29100-211">To identify that there is an ongoing problem with a primary endpoint, you can monitor how frequently the client encounters retryable errors.</span></span> <span data-ttu-id="29100-212">Так как все случаи разные, необходимо определить пороговое значение для переключения на дополнительную конечную точку и запуска приложения в режиме только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-212">Because each case is different, you have to decide on the threshold you want to use for the decision to switch to the secondary endpoint and run the application in read-only mode.</span></span> <span data-ttu-id="29100-213">Например, можно выполнять переключение при 10 сбоев подряд, после которых запрос по-прежнему не выполнен.</span><span class="sxs-lookup"><span data-stu-id="29100-213">For example, you could decide to perform the switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="29100-214">Другой пример: переключение при сбое 90 % запросов в течение 2 минут.</span><span class="sxs-lookup"><span data-stu-id="29100-214">Another example is to switch if 90% of the requests in a 2-minute period fail.</span></span>

<span data-ttu-id="29100-215">В первом случае можно просто считать число ошибок, и если запрос успешно выполняется до достижения порога, сбрасывать это значение до нуля.</span><span class="sxs-lookup"><span data-stu-id="29100-215">For the first scenario, you can simply keep a count of the failures, and if there is a success before reaching the maximum, set the count back to zero.</span></span> <span data-ttu-id="29100-216">Во втором случае для реализации переключения можно использовать объект MemoryCache (в .NET).</span><span class="sxs-lookup"><span data-stu-id="29100-216">For the second scenario, one way to implement it is to use the MemoryCache object (in .NET).</span></span> <span data-ttu-id="29100-217">Для каждого запроса добавьте CacheItem в кэш, задайте значение для успешного (1) или неудачного выполнения (0) и задайте срок действия в 2 минуты от текущего времени (или установленное ограничение времени).</span><span class="sxs-lookup"><span data-stu-id="29100-217">For each request, add a CacheItem to the cache, set the value to success (1) or fail (0), and set the expiration time to 2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="29100-218">По истечении срока действия запись автоматически удаляется.</span><span class="sxs-lookup"><span data-stu-id="29100-218">When an entry's expiration time is reached, the entry is automatically removed.</span></span> <span data-ttu-id="29100-219">Это обеспечит скользящее окно в 2 минуты.</span><span class="sxs-lookup"><span data-stu-id="29100-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="29100-220">Каждый раз при отправке запроса к службе хранилища сначала используется запрос Linq через объект MemoryCache для вычисления процента успешных операций путем суммирования значений и деления их на количество.</span><span class="sxs-lookup"><span data-stu-id="29100-220">Each time you make a request to the storage service, you first use a Linq query across the MemoryCache object to calculate the percent success by summing the values and dividing by the count.</span></span> <span data-ttu-id="29100-221">Когда процент успешных операций опустится ниже некоторого порога (например, 10 %), следует присвоить свойству **LocationMode** для запросов на чтение значение **SecondaryOnly** и переключить приложение в режим только для чтения, прежде чем продолжить.</span><span class="sxs-lookup"><span data-stu-id="29100-221">When the percent success drops below some threshold (such as 10%), set the **LocationMode** property for read requests to **SecondaryOnly** and switch the application into read-only mode before continuing.</span></span>

<span data-ttu-id="29100-222">Пороговое число ошибок, которое определяет, когда нужно переключить приложение, может отличаться для различных служб в приложении. Поэтому рекомендуется сделать пороговые значения настраиваемыми параметрами.</span><span class="sxs-lookup"><span data-stu-id="29100-222">The threshold of errors used to determine when to make the switch may vary from service to service in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="29100-223">Кроме того, нужно решить, как обрабатывать ошибки, допускающие повторение, от каждой службы — по-отдельности или вместе, как было описано ранее.</span><span class="sxs-lookup"><span data-stu-id="29100-223">This is also where you decide to handle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="29100-224">Вам следует решить, как будут обрабатываться несколько экземпляров одного приложения и какие действия будут выполняться при обнаружении ошибок, допускающих повторение, в каждом экземпляре.</span><span class="sxs-lookup"><span data-stu-id="29100-224">Another consideration is how to handle multiple instances of an application, and what to do when you detect retryable errors in each instance.</span></span> <span data-ttu-id="29100-225">Например, одно приложение может быть загружено на 20 виртуальных машин.</span><span class="sxs-lookup"><span data-stu-id="29100-225">For example, you may have 20 VMs running with the same application loaded.</span></span> <span data-ttu-id="29100-226">Каждый экземпляр будет обрабатываться отдельно?</span><span class="sxs-lookup"><span data-stu-id="29100-226">Do you handle each instance separately?</span></span> <span data-ttu-id="29100-227">Если в работе одного экземпляра возникают проблемы, требуется ли ответное действие только для этого экземпляра, или вы хотите, чтобы все экземпляры попытались выполнить одинаковое ответное действие в случае проблемы с одним экземпляром?</span><span class="sxs-lookup"><span data-stu-id="29100-227">If one instance starts having problems, do you want to limit the response to just that one instance, or do you want to try to have all instances respond in the same way when one instance has a problem?</span></span> <span data-ttu-id="29100-228">Отдельная обработка экземпляров гораздо проще, чем одновременное координирование ответных действий всех экземпляров, но конкретная реализация зависит от архитектуры приложения.</span><span class="sxs-lookup"><span data-stu-id="29100-228">Handling the instances separately is much simpler than trying to coordinate the response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-the-error-frequency"></a><span data-ttu-id="29100-229">Способы мониторинга частоты ошибок</span><span class="sxs-lookup"><span data-stu-id="29100-229">Options for monitoring the error frequency</span></span>

<span data-ttu-id="29100-230">Существует три основных способа мониторинга частоты повторов в основном регионе, позволяющих определить, когда нужно переключиться на дополнительный регион и запустить приложение в режиме только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-230">You have three main options for monitoring the frequency of retries in the primary region in order to determine when to switch over to the secondary region and change the application to run in read-only mode.</span></span>

*   <span data-ttu-id="29100-231">Добавьте обработчик события [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) для объекта [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx), передаваемого в запросы к хранилищу. Этот метод показан в этой статье и используется в соответствующем примере.</span><span class="sxs-lookup"><span data-stu-id="29100-231">Add a handler for the [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on the [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass to your storage requests – this is the method displayed in this article and used in the accompanying sample.</span></span> <span data-ttu-id="29100-232">Данные события активируются, когда клиент повторяет запрос, что позволяет отслеживать, как часто клиент сталкивается с ошибками, допускающими повторение, на основной конечной точке.</span><span class="sxs-lookup"><span data-stu-id="29100-232">These events fire whenever the client retries a request, enabling you to track how often the client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in the primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="29100-233">В методе [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) в пользовательской политике повтора можно выполнять пользовательский код всякий раз, когда происходит повторная попытка.</span><span class="sxs-lookup"><span data-stu-id="29100-233">In the [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="29100-234">Помимо записи повторных попыток это также дает возможность изменить их режим.</span><span class="sxs-lookup"><span data-stu-id="29100-234">In addition to recording when a retry happens, this also gives you the opportunity to modify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in the primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="29100-235">Третий подход заключается в реализации пользовательского компонента мониторинга в приложении, который постоянно проверяет связь с конечной точкой основного хранилища с помощью фиктивных запросов на чтение (например, запросов на чтение большого двоичного объекта небольшого размера), чтобы определить его работоспособность.</span><span class="sxs-lookup"><span data-stu-id="29100-235">The third approach is to implement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) to determine its health.</span></span> <span data-ttu-id="29100-236">Это может потребовать какое-то количество ресурсов, но не значительное.</span><span class="sxs-lookup"><span data-stu-id="29100-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="29100-237">При обнаружении ошибки, которая достигла порога, выполняется переключение в режим **SecondaryOnly** с доступом только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-237">When a problem is discovered that reaches your threshold, you would then perform the switch to **SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="29100-238">В какой-то момент потребуется переключиться обратно на основную конечную точку и разрешить обновления.</span><span class="sxs-lookup"><span data-stu-id="29100-238">At some point, you will want to switch back to using the primary endpoint and allowing updates.</span></span> <span data-ttu-id="29100-239">Если используется один из первых двух методов, описанных выше, то можно просто переключиться обратно на основную конечную точку и включить режим обновления после истечения произвольного периода времени или выполнения произвольного количества операций.</span><span class="sxs-lookup"><span data-stu-id="29100-239">If using one of the first two methods listed above, you could simply switch back to the primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="29100-240">После этого можно будет снова задействовать логику повторных попыток.</span><span class="sxs-lookup"><span data-stu-id="29100-240">You can then let it go through the retry logic again.</span></span> <span data-ttu-id="29100-241">В случае устранения проблемы будет по-прежнему использоваться основная конечная точка с возможностью обновления данных.</span><span class="sxs-lookup"><span data-stu-id="29100-241">If the problem has been fixed, it will continue to use the primary endpoint and allow updates.</span></span> <span data-ttu-id="29100-242">Если проблема не устранена, то после нарушения установленных вами условий будет выполнено повторное переключение на дополнительную конечную точку и включен режим только для чтения.</span><span class="sxs-lookup"><span data-stu-id="29100-242">If there is still a problem, it will once more switch back to the secondary endpoint and read-only mode after failing the criteria you've set.</span></span>

<span data-ttu-id="29100-243">В третьем сценарии, когда при проверке связи конечная точка основного хранилища восстановит работоспособность, можно будет активировать переключение обратно в режим **PrimaryOnly** и не запрещать обновления.</span><span class="sxs-lookup"><span data-stu-id="29100-243">For the third scenario, when pinging the primary storage endpoint becomes successful again, you can trigger the switch back to **PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="29100-244">Обработка данных, согласованных в конечном счете</span><span class="sxs-lookup"><span data-stu-id="29100-244">Handling eventually consistent data</span></span>

<span data-ttu-id="29100-245">RA-GRS функционирует, реплицируя транзакции из основного в дополнительный регион.</span><span class="sxs-lookup"><span data-stu-id="29100-245">RA-GRS works by replicating transactions from the primary to the secondary region.</span></span> <span data-ttu-id="29100-246">Репликация гарантирует, что данные во дополнительном регионе *согласованы в конечном счете*.</span><span class="sxs-lookup"><span data-stu-id="29100-246">This replication process guarantees that the data in the secondary region is *eventually consistent*.</span></span> <span data-ttu-id="29100-247">Это означает, что все транзакции в основном регионе в конечном итоге появятся и в дополнительном регионе, но перед этим возможна задержка, и нет никакой гарантии, что транзакции поступят в дополнительный регион в том же порядке, в котором они первоначально были применены в основном регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-247">This means that all the transactions in the primary region will eventually appear in the secondary region, but that there may be a lag before they appear, and that there is no guarantee the transactions arrive in the secondary region in the same order as that in which they were originally applied in the primary region.</span></span> <span data-ttu-id="29100-248">Если транзакции поступают в дополнительный регион не по порядку, то вы *можете* рассматривать данные в этом регионе как несогласованные, пока служба не наверстает упущенное.</span><span class="sxs-lookup"><span data-stu-id="29100-248">If your transactions arrive in the secondary region out of order, you *may* consider your data in the secondary region to be in an inconsistent state until the service catches up.</span></span>

<span data-ttu-id="29100-249">В таблице ниже показан пример того, что может произойти при обновлении сведений о сотруднице для ее добавления в роль *administrators*.</span><span class="sxs-lookup"><span data-stu-id="29100-249">The following table shows an example of what might happen when you update the details of an employee to make her a member of the *administrators* role.</span></span> <span data-ttu-id="29100-250">В этом примере требуется обновить сущность **employee** и изменить в сущности **administrator role** общее число администраторов.</span><span class="sxs-lookup"><span data-stu-id="29100-250">For the sake of this example, this requires you update the **employee** entity and update an **administrator role** entity with a count of the total number of administrators.</span></span> <span data-ttu-id="29100-251">Обратите внимание на то, как обновления применяются не по порядку в дополнительном регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-251">Notice how the updates are applied out of order in the secondary region.</span></span>

| <span data-ttu-id="29100-252">**Время**</span><span class="sxs-lookup"><span data-stu-id="29100-252">**Time**</span></span> | <span data-ttu-id="29100-253">**Транзакция**</span><span class="sxs-lookup"><span data-stu-id="29100-253">**Transaction**</span></span>                                            | <span data-ttu-id="29100-254">**Репликация**</span><span class="sxs-lookup"><span data-stu-id="29100-254">**Replication**</span></span>                       | <span data-ttu-id="29100-255">**Last Sync Time**</span><span class="sxs-lookup"><span data-stu-id="29100-255">**Last Sync Time**</span></span> | <span data-ttu-id="29100-256">**Результат**</span><span class="sxs-lookup"><span data-stu-id="29100-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="29100-257">T0</span><span class="sxs-lookup"><span data-stu-id="29100-257">T0</span></span>       | <span data-ttu-id="29100-258">Транзакция А:</span><span class="sxs-lookup"><span data-stu-id="29100-258">Transaction A:</span></span> <br> <span data-ttu-id="29100-259">вставка сущности</span><span class="sxs-lookup"><span data-stu-id="29100-259">Insert employee</span></span> <br> <span data-ttu-id="29100-260">сотрудника в основном регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="29100-261">Транзакция А вставлена в основной регион,</span><span class="sxs-lookup"><span data-stu-id="29100-261">Transaction A inserted to primary,</span></span><br> <span data-ttu-id="29100-262">но еще не реплицирована.</span><span class="sxs-lookup"><span data-stu-id="29100-262">not replicated yet.</span></span> |
| <span data-ttu-id="29100-263">T1</span><span class="sxs-lookup"><span data-stu-id="29100-263">T1</span></span>       |                                                            | <span data-ttu-id="29100-264">Транзакция А</span><span class="sxs-lookup"><span data-stu-id="29100-264">Transaction A</span></span> <br> <span data-ttu-id="29100-265">реплицирована в</span><span class="sxs-lookup"><span data-stu-id="29100-265">replicated to</span></span><br> <span data-ttu-id="29100-266">дополнительный регион.</span><span class="sxs-lookup"><span data-stu-id="29100-266">secondary</span></span> | <span data-ttu-id="29100-267">T1</span><span class="sxs-lookup"><span data-stu-id="29100-267">T1</span></span> | <span data-ttu-id="29100-268">Транзакция А реплицирована в дополнительный регион.</span><span class="sxs-lookup"><span data-stu-id="29100-268">Transaction A replicated to secondary.</span></span> <br><span data-ttu-id="29100-269">Значение Last Sync Time обновлено.</span><span class="sxs-lookup"><span data-stu-id="29100-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="29100-270">T2</span><span class="sxs-lookup"><span data-stu-id="29100-270">T2</span></span>       | <span data-ttu-id="29100-271">Транзакция Б:</span><span class="sxs-lookup"><span data-stu-id="29100-271">Transaction B:</span></span><br><span data-ttu-id="29100-272">Блокировка изменений</span><span class="sxs-lookup"><span data-stu-id="29100-272">Update</span></span><br> <span data-ttu-id="29100-273">обновление сущности сотрудника</span><span class="sxs-lookup"><span data-stu-id="29100-273">employee entity</span></span><br> <span data-ttu-id="29100-274">в основном регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-274">in primary</span></span>  |                                | <span data-ttu-id="29100-275">T1</span><span class="sxs-lookup"><span data-stu-id="29100-275">T1</span></span>                 | <span data-ttu-id="29100-276">Транзакция Б записана в основной регион,</span><span class="sxs-lookup"><span data-stu-id="29100-276">Transaction B written to primary,</span></span><br> <span data-ttu-id="29100-277">но еще не реплицирована.</span><span class="sxs-lookup"><span data-stu-id="29100-277">not replicated yet.</span></span>  |
| <span data-ttu-id="29100-278">T3</span><span class="sxs-lookup"><span data-stu-id="29100-278">T3</span></span>       | <span data-ttu-id="29100-279">Транзакция В:</span><span class="sxs-lookup"><span data-stu-id="29100-279">Transaction C:</span></span><br> <span data-ttu-id="29100-280">Блокировка изменений</span><span class="sxs-lookup"><span data-stu-id="29100-280">Update</span></span> <br><span data-ttu-id="29100-281">administrator</span><span class="sxs-lookup"><span data-stu-id="29100-281">administrator</span></span><br><span data-ttu-id="29100-282">сущности роли в</span><span class="sxs-lookup"><span data-stu-id="29100-282">role entity in</span></span><br><span data-ttu-id="29100-283">primary</span><span class="sxs-lookup"><span data-stu-id="29100-283">primary</span></span> |                    | <span data-ttu-id="29100-284">T1</span><span class="sxs-lookup"><span data-stu-id="29100-284">T1</span></span>                 | <span data-ttu-id="29100-285">Транзакция В записана в основной регион,</span><span class="sxs-lookup"><span data-stu-id="29100-285">Transaction C written to primary,</span></span><br> <span data-ttu-id="29100-286">но еще не реплицирована.</span><span class="sxs-lookup"><span data-stu-id="29100-286">not replicated yet.</span></span>  |
| <span data-ttu-id="29100-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="29100-287">*T4*</span></span>     |                                                       | <span data-ttu-id="29100-288">Транзакция В</span><span class="sxs-lookup"><span data-stu-id="29100-288">Transaction C</span></span> <br><span data-ttu-id="29100-289">реплицирована в</span><span class="sxs-lookup"><span data-stu-id="29100-289">replicated to</span></span><br> <span data-ttu-id="29100-290">дополнительный регион.</span><span class="sxs-lookup"><span data-stu-id="29100-290">secondary</span></span> | <span data-ttu-id="29100-291">T1</span><span class="sxs-lookup"><span data-stu-id="29100-291">T1</span></span>         | <span data-ttu-id="29100-292">Транзакция В реплицирована в дополнительный регион.</span><span class="sxs-lookup"><span data-stu-id="29100-292">Transaction C replicated to secondary.</span></span><br><span data-ttu-id="29100-293">Значение Last Sync Time не обновлено, так как</span><span class="sxs-lookup"><span data-stu-id="29100-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="29100-294">транзакция Б еще не реплицирована.</span><span class="sxs-lookup"><span data-stu-id="29100-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="29100-295">*T5*</span><span class="sxs-lookup"><span data-stu-id="29100-295">*T5*</span></span>     | <span data-ttu-id="29100-296">Чтение сущностей</span><span class="sxs-lookup"><span data-stu-id="29100-296">Read entities</span></span> <br><span data-ttu-id="29100-297">из дополнительного региона.</span><span class="sxs-lookup"><span data-stu-id="29100-297">from secondary</span></span>                           |                                  | <span data-ttu-id="29100-298">T1</span><span class="sxs-lookup"><span data-stu-id="29100-298">T1</span></span>                 | <span data-ttu-id="29100-299">Вы получаете устаревшее значение для</span><span class="sxs-lookup"><span data-stu-id="29100-299">You get the stale value for employee</span></span> <br> <span data-ttu-id="29100-300">сущности employee, так как транзакция Б</span><span class="sxs-lookup"><span data-stu-id="29100-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="29100-301">еще не реплицирована.</span><span class="sxs-lookup"><span data-stu-id="29100-301">replicated yet.</span></span> <span data-ttu-id="29100-302">Вы получаете новое значение для</span><span class="sxs-lookup"><span data-stu-id="29100-302">You get the new value for</span></span><br> <span data-ttu-id="29100-303">сущности administrator role, так как</span><span class="sxs-lookup"><span data-stu-id="29100-303">administrator role entity because C has</span></span><br> <span data-ttu-id="29100-304">транзакция В реплицирована.</span><span class="sxs-lookup"><span data-stu-id="29100-304">replicated.</span></span> <span data-ttu-id="29100-305">Значение Last Sync Time</span><span class="sxs-lookup"><span data-stu-id="29100-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="29100-306">все еще не обновлено, так как транзакция Б</span><span class="sxs-lookup"><span data-stu-id="29100-306">been updated because transaction B</span></span><br> <span data-ttu-id="29100-307">не реплицирована.</span><span class="sxs-lookup"><span data-stu-id="29100-307">hasn't replicated.</span></span> <span data-ttu-id="29100-308">Можно считать сущность</span><span class="sxs-lookup"><span data-stu-id="29100-308">You can tell the</span></span><br><span data-ttu-id="29100-309">administrator role несогласованной,</span><span class="sxs-lookup"><span data-stu-id="29100-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="29100-310">так как ее дата и время превышают</span><span class="sxs-lookup"><span data-stu-id="29100-310">because the entity date/time is after</span></span> <br><span data-ttu-id="29100-311">значение Last Sync Time.</span><span class="sxs-lookup"><span data-stu-id="29100-311">the Last Sync Time.</span></span> |
| <span data-ttu-id="29100-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="29100-312">*T6*</span></span>     |                                                      | <span data-ttu-id="29100-313">Транзакция Б</span><span class="sxs-lookup"><span data-stu-id="29100-313">Transaction B</span></span><br> <span data-ttu-id="29100-314">реплицирована в</span><span class="sxs-lookup"><span data-stu-id="29100-314">replicated to</span></span><br> <span data-ttu-id="29100-315">дополнительный регион.</span><span class="sxs-lookup"><span data-stu-id="29100-315">secondary</span></span> | <span data-ttu-id="29100-316">T6</span><span class="sxs-lookup"><span data-stu-id="29100-316">T6</span></span>                 | <span data-ttu-id="29100-317">*T6* — всех транзакции вплоть до В</span><span class="sxs-lookup"><span data-stu-id="29100-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="29100-318">реплицированы, значение Last Sync Time</span><span class="sxs-lookup"><span data-stu-id="29100-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="29100-319">обновлено.</span><span class="sxs-lookup"><span data-stu-id="29100-319">is updated.</span></span> |

<span data-ttu-id="29100-320">В этом примере предполагается, что клиент переключается на чтение из дополнительного региона на этапе T5.</span><span class="sxs-lookup"><span data-stu-id="29100-320">In this example, assume the client switches to reading from the secondary region at T5.</span></span> <span data-ttu-id="29100-321">На этом этапе он может успешно считать сущность **administrator role**, но она содержит число администраторов, которое не согласовано с числом сущностей **employee**, которые на данный момент помечены как администраторы в дополнительном регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-321">It can successfully read the **administrator role** entity at this time, but the entity contains a value for the count of administrators that is not consistent with the number of **employee** entities that are marked as administrators in the secondary region at this time.</span></span> <span data-ttu-id="29100-322">Клиент просто может отобразить это значение с риском, что оно является несогласованным.</span><span class="sxs-lookup"><span data-stu-id="29100-322">Your client could simply display this value, with the risk that it is inconsistent information.</span></span> <span data-ttu-id="29100-323">Кроме того, клиент может попытаться определить, что сущность **administrator role** является потенциально несогласованной, так как обновления были выполнены не по порядку, и затем информировать пользователей об этом.</span><span class="sxs-lookup"><span data-stu-id="29100-323">Alternatively, the client could attempt to determine that the **administrator role** is in a potentially inconsistent state because the updates have happened out of order, and then inform the user of this fact.</span></span>

<span data-ttu-id="29100-324">Чтобы выявить потенциальную несогласованность данных, клиент может использовать значение *Last Sync Time*, которое можно получить в любое время с помощью запроса к службе хранилища.</span><span class="sxs-lookup"><span data-stu-id="29100-324">To recognize that it has potentially inconsistent data, the client can use the value of the *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="29100-325">Оно указывает время, когда данные в дополнительном регионе были согласованными в последний раз и когда служба применила все транзакции, предшествующие этому моменту времени.</span><span class="sxs-lookup"><span data-stu-id="29100-325">This tells you the time when the data in the secondary region was last consistent and when the service had applied all the transactions prior to that point in time.</span></span> <span data-ttu-id="29100-326">В примере, показанном выше, после того, как служба вставляет сущность **employee** в дополнительный регион, время последней синхронизации (Last Sync Time) принимает значение *T1*.</span><span class="sxs-lookup"><span data-stu-id="29100-326">In the example shown above, after the service inserts the **employee** entity in the secondary region, the last sync time is set to *T1*.</span></span> <span data-ttu-id="29100-327">Значение *T1* сохраняется до момента обновления службой сущности **employee** в дополнительном регионе, после чего Last Sync Time принимает значение *T6*.</span><span class="sxs-lookup"><span data-stu-id="29100-327">It remains at *T1* until the service updates the **employee** entity in the secondary region when it is set to *T6*.</span></span> <span data-ttu-id="29100-328">Если клиент получает время последней синхронизации при чтении сущности на этапе *T5*, то может сравнить его с меткой времени сущности.</span><span class="sxs-lookup"><span data-stu-id="29100-328">If the client retrieves the last sync time when it reads the entity at *T5*, it can compare it with the timestamp on the entity.</span></span> <span data-ttu-id="29100-329">Если метка времени сущности превышает время последней синхронизации, то сущность является потенциально несогласованной, и вы можете выполнить соответствующее действие для приложения.</span><span class="sxs-lookup"><span data-stu-id="29100-329">If the timestamp on the entity is later than the last sync time, then the entity is in a potentially inconsistent state, and you can take whatever is the appropriate action for your application.</span></span> <span data-ttu-id="29100-330">Чтобы использовать это поле, необходимо знать, когда было завершено последнее обновление в основном регионе.</span><span class="sxs-lookup"><span data-stu-id="29100-330">Using this field requires that you know when the last update to the primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="29100-331">Тестирование</span><span class="sxs-lookup"><span data-stu-id="29100-331">Testing</span></span>

<span data-ttu-id="29100-332">Важно проверить, правильно ли приложение работает при обнаружении ошибок, допускающих повторение.</span><span class="sxs-lookup"><span data-stu-id="29100-332">It's important to test that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="29100-333">Например, нужно проверить, что приложение переходит на дополнительный регион и переключается в режим только для чтения, когда обнаруживает неполадку, и переключается обратно, когда основной регион снова становится доступным.</span><span class="sxs-lookup"><span data-stu-id="29100-333">For example, you need to test that the application switches to the secondary and into read-only mode when it detects a problem, and switches back when the primary region becomes available again.</span></span> <span data-ttu-id="29100-334">Для этого требуется способ моделирования ошибок, допускающих повторение, и управления их частотой.</span><span class="sxs-lookup"><span data-stu-id="29100-334">To do this, you need a way to simulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="29100-335">Для перехвата и изменения ответов HTTP в сценарии можно использовать [Fiddler](http://www.telerik.com/fiddler).</span><span class="sxs-lookup"><span data-stu-id="29100-335">You can use [Fiddler](http://www.telerik.com/fiddler) to intercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="29100-336">Этот сценарий может определять ответы от основной конечной точки и заменять код состояния HTTP значением, которое клиентская библиотека службы хранилища распознает как ошибку, допускающую повторение.</span><span class="sxs-lookup"><span data-stu-id="29100-336">This script can identify responses that come from your primary endpoint and change the HTTP status code to one that the Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="29100-337">В этом фрагменте кода показан простой пример сценария Fiddler, который перехватывает ответы, получаемые на запросы на чтение к таблице **employeedata**, чтобы возвращать код состояния 502.</span><span class="sxs-lookup"><span data-stu-id="29100-337">This code snippet shows a simple example of a Fiddler script that intercepts responses to read requests against the **employeedata** table to return a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="29100-338">Вы можете расширить этот пример, перехватывая более широкий диапазон запросов и изменяя **responseCode** только некоторых из них, чтобы точнее имитировать реальную ситуацию.</span><span class="sxs-lookup"><span data-stu-id="29100-338">You could extend this example to intercept a wider range of requests and only change the **responseCode** on some of them to better simulate a real-world scenario.</span></span> <span data-ttu-id="29100-339">Дополнительные сведения о настройке сценариев Fiddler см. в разделе [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) (Изменение запроса или ответа) в документации по Fiddler.</span><span class="sxs-lookup"><span data-stu-id="29100-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in the Fiddler documentation.</span></span>

<span data-ttu-id="29100-340">Если вы сделали настраиваемыми пороговые значения для переключения приложения в режим только для чтения, то вам будет проще тестировать его поведение на определенных объемах непроизводственных транзакций.</span><span class="sxs-lookup"><span data-stu-id="29100-340">If you have made the thresholds for switching your application to read-only mode configurable, it will be easier to test the behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="29100-341">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="29100-341">Next Steps</span></span>

* <span data-ttu-id="29100-342">Дополнительные сведения о геоизбыточном хранилище с доступом на чтение, включая еще один пример настройки LastSyncTime, доступны в разделе [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/) (Варианты обеспечения избыточности службы хранилища Microsoft Azure и геоизбыточное хранилище с доступом на чтение).</span><span class="sxs-lookup"><span data-stu-id="29100-342">For more information about Read Access Geo-Redundancy, including another example of how the LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="29100-343">Полный пример, демонстрирующий, как переключаться между основной и дополнительной конечными точками, см. в разделе [Azure Samples – Using the Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs) (Примеры Azure. Использование шаблона автоматического выключения с хранилищем RA-GRS).</span><span class="sxs-lookup"><span data-stu-id="29100-343">For a complete sample showing how to make the switch back and forth between the Primary and Secondary endpoints, please see [Azure Samples – Using the Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
