---
title: "Контрольный список: масштабируемость и производительность службы хранилища Azure | Документация Майкрософт"
description: "Контрольный список проверенных методов для использования с хранилищем Azure при разработке приложений с высокой производительностью."
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: c12f98b069689e335d308d8f8edba2dece21d806
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="54c62-103">Производительность хранилища Microsoft Azure и контрольный список масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="54c62-104">Обзор</span><span class="sxs-lookup"><span data-stu-id="54c62-104">Overview</span></span>
<span data-ttu-id="54c62-105">С момента выпуска служб хранилища Microsoft Azure корпорация Microsoft разработала ряд проверенных принципов для эффективного использования этих служб. Эта статья служит для объединения наиболее важных из них в "контрольный список".</span><span class="sxs-lookup"><span data-stu-id="54c62-105">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</span></span> <span data-ttu-id="54c62-106">Целью этой статьи является помочь разработчикам приложений убедиться, что они используют проверенные методы работы с хранилищем Azure, и найти другие проверенные методы, которые можно использовать в будущем.</span><span class="sxs-lookup"><span data-stu-id="54c62-106">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="54c62-107">В данной статье не рассматриваются все возможные способы оптимизации производительности и масштабируемости. Мы не описываем методики, последствия применения которых несущественны, а также методики, которые не нашли широкого применения.</span><span class="sxs-lookup"><span data-stu-id="54c62-107">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="54c62-108">Поскольку поведение приложения можно предвидеть в процессе разработки, важно помнить об этом на ранних стадиях во избежание создания проектов, которые приведут к проблемам с производительностью.</span><span class="sxs-lookup"><span data-stu-id="54c62-108">To the extent that the application's behavior can be predicted during design, it's useful to keep these in mind early on to avoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="54c62-109">Каждый разработчик приложения, использующий хранилище Azure, должен уделить время прочтению этой статьи и убедиться в том, что его или ее приложение следует всем проверенным методикам, перечисленным ниже.</span><span class="sxs-lookup"><span data-stu-id="54c62-109">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="54c62-110">Контрольный список</span><span class="sxs-lookup"><span data-stu-id="54c62-110">Checklist</span></span>
<span data-ttu-id="54c62-111">В этой статье методики поделены на следующие группы.</span><span class="sxs-lookup"><span data-stu-id="54c62-111">This article organizes the proven practices into the following groups.</span></span> <span data-ttu-id="54c62-112">Методики, применимые в отношении:</span><span class="sxs-lookup"><span data-stu-id="54c62-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="54c62-113">всех служб хранилища Azure (BLOB-объектов, таблиц, очередей и файлов);</span><span class="sxs-lookup"><span data-stu-id="54c62-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="54c62-114">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-114">Blobs</span></span>
* <span data-ttu-id="54c62-115">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-115">Tables</span></span>
* <span data-ttu-id="54c62-116">Очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-116">Queues</span></span>  

| <span data-ttu-id="54c62-117">Готово</span><span class="sxs-lookup"><span data-stu-id="54c62-117">Done</span></span> | <span data-ttu-id="54c62-118">Область</span><span class="sxs-lookup"><span data-stu-id="54c62-118">Area</span></span> | <span data-ttu-id="54c62-119">Категория</span><span class="sxs-lookup"><span data-stu-id="54c62-119">Category</span></span> | <span data-ttu-id="54c62-120">Вопрос</span><span class="sxs-lookup"><span data-stu-id="54c62-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="54c62-121">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-121">All Services</span></span> |<span data-ttu-id="54c62-122">Целевые показатели масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-122">Scalability Targets</span></span> |[<span data-ttu-id="54c62-123">Спроектировано ли приложение таким образом, чтобы избежать приближения к целевым показателям масштабируемости?</span><span class="sxs-lookup"><span data-stu-id="54c62-123">Is your application designed to avoid approaching the scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="54c62-124">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-124">All Services</span></span> |<span data-ttu-id="54c62-125">Целевые показатели масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-125">Scalability Targets</span></span> |[<span data-ttu-id="54c62-126">Помогает ли ваше соглашения об именовании улучшить распределение нагрузки?</span><span class="sxs-lookup"><span data-stu-id="54c62-126">Is your naming convention designed to enable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="54c62-127">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-127">All Services</span></span> |<span data-ttu-id="54c62-128">Сеть</span><span class="sxs-lookup"><span data-stu-id="54c62-128">Networking</span></span> |[<span data-ttu-id="54c62-129">Имеют ли клиентские устройства достаточно высокую пропускную способность и низкую степень задержки для достижения необходимой производительности?</span><span class="sxs-lookup"><span data-stu-id="54c62-129">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="54c62-130">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-130">All Services</span></span> |<span data-ttu-id="54c62-131">Сеть</span><span class="sxs-lookup"><span data-stu-id="54c62-131">Networking</span></span> |[<span data-ttu-id="54c62-132">Имеют ли клиентские устройства достаточно высокое качество связи?</span><span class="sxs-lookup"><span data-stu-id="54c62-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="54c62-133">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-133">All Services</span></span> |<span data-ttu-id="54c62-134">Сеть</span><span class="sxs-lookup"><span data-stu-id="54c62-134">Networking</span></span> |[<span data-ttu-id="54c62-135">Расположено ли клиентское приложение "вблизи" учетной записи хранения?</span><span class="sxs-lookup"><span data-stu-id="54c62-135">Is the client application located "near" the storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="54c62-136">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-136">All Services</span></span> |<span data-ttu-id="54c62-137">Распространение содержимого</span><span class="sxs-lookup"><span data-stu-id="54c62-137">Content Distribution</span></span> |[<span data-ttu-id="54c62-138">Используете ли вы CDN для распределения содержимого?</span><span class="sxs-lookup"><span data-stu-id="54c62-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="54c62-139">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-139">All Services</span></span> |<span data-ttu-id="54c62-140">Прямой клиентский доступ</span><span class="sxs-lookup"><span data-stu-id="54c62-140">Direct Client Access</span></span> |[<span data-ttu-id="54c62-141">Используете ли вы SAS и CORS для прямого доступа к хранилищу вместо прокси-сервера?</span><span class="sxs-lookup"><span data-stu-id="54c62-141">Are you using SAS and CORS to allow direct access to storage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="54c62-142">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-142">All Services</span></span> |<span data-ttu-id="54c62-143">Caching</span><span class="sxs-lookup"><span data-stu-id="54c62-143">Caching</span></span> |[<span data-ttu-id="54c62-144">Данные кэширования приложений используются постоянно и изменяются редко?</span><span class="sxs-lookup"><span data-stu-id="54c62-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="54c62-145">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-145">All Services</span></span> |<span data-ttu-id="54c62-146">Caching</span><span class="sxs-lookup"><span data-stu-id="54c62-146">Caching</span></span> |[<span data-ttu-id="54c62-147">Ваше приложение группирует обновления (кэширует на стороне клиента, а затем загружает в виде большого массива)?</span><span class="sxs-lookup"><span data-stu-id="54c62-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="54c62-148">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-148">All Services</span></span> |<span data-ttu-id="54c62-149">Конфигурация .NET</span><span class="sxs-lookup"><span data-stu-id="54c62-149">.NET Configuration</span></span> |[<span data-ttu-id="54c62-150">Вы настроили свой клиент на использование достаточного количества одновременных подключений?</span><span class="sxs-lookup"><span data-stu-id="54c62-150">Have you configured your client to use a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="54c62-151">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-151">All Services</span></span> |<span data-ttu-id="54c62-152">Конфигурация .NET</span><span class="sxs-lookup"><span data-stu-id="54c62-152">.NET Configuration</span></span> |[<span data-ttu-id="54c62-153">Вы настроили .NET на использование достаточного количества потоков?</span><span class="sxs-lookup"><span data-stu-id="54c62-153">Have you configured .NET to use a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="54c62-154">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-154">All Services</span></span> |<span data-ttu-id="54c62-155">Конфигурация .NET</span><span class="sxs-lookup"><span data-stu-id="54c62-155">.NET Configuration</span></span> |[<span data-ttu-id="54c62-156">Используете ли вы .NET 4.5 или более позднюю версию, в которой улучшена функция сборки мусора?</span><span class="sxs-lookup"><span data-stu-id="54c62-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="54c62-157">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-157">All Services</span></span> |<span data-ttu-id="54c62-158">Параллелизм</span><span class="sxs-lookup"><span data-stu-id="54c62-158">Parallelism</span></span> |[<span data-ttu-id="54c62-159">Вы уверены в том, что параллелизм ограничен соответствующим образом, чтобы не перегружать ни возможности клиента, ни целевые показатели масштабируемости?</span><span class="sxs-lookup"><span data-stu-id="54c62-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or the scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="54c62-160">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-160">All Services</span></span> |<span data-ttu-id="54c62-161">Средства</span><span class="sxs-lookup"><span data-stu-id="54c62-161">Tools</span></span> |[<span data-ttu-id="54c62-162">Вы используете последние версии клиентских библиотек и инструментов, предоставленных корпорацией Microsoft?</span><span class="sxs-lookup"><span data-stu-id="54c62-162">Are you using the latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="54c62-163">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-163">All Services</span></span> |<span data-ttu-id="54c62-164">Повторы</span><span class="sxs-lookup"><span data-stu-id="54c62-164">Retries</span></span> |[<span data-ttu-id="54c62-165">Вы используете политику повтора экспоненциального откладывания для регулирования ошибок и времени ожидания?</span><span class="sxs-lookup"><span data-stu-id="54c62-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="54c62-166">Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-166">All Services</span></span> |<span data-ttu-id="54c62-167">Повторы</span><span class="sxs-lookup"><span data-stu-id="54c62-167">Retries</span></span> |[<span data-ttu-id="54c62-168">Ваше приложение избегает повторов неповторяемых ошибок?</span><span class="sxs-lookup"><span data-stu-id="54c62-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="54c62-169">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-169">Blobs</span></span> |<span data-ttu-id="54c62-170">Целевые показатели масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-170">Scalability Targets</span></span> |[<span data-ttu-id="54c62-171">Имеется большое число клиентов, одновременно обращающихся к одному объекту?</span><span class="sxs-lookup"><span data-stu-id="54c62-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="54c62-172">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-172">Blobs</span></span> |<span data-ttu-id="54c62-173">Целевые показатели масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-173">Scalability Targets</span></span> |[<span data-ttu-id="54c62-174">Ваше приложение придерживается уровня пропускной способности или рабочего целевого показателя масштабируемости для одинарного BLOB-объекта?</span><span class="sxs-lookup"><span data-stu-id="54c62-174">Is your application staying within the bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="54c62-175">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-175">Blobs</span></span> |<span data-ttu-id="54c62-176">Копирование BLOB-объектов</span><span class="sxs-lookup"><span data-stu-id="54c62-176">Copying Blobs</span></span> |[<span data-ttu-id="54c62-177">Вы копируете BLOB-объекты эффективным способом?</span><span class="sxs-lookup"><span data-stu-id="54c62-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="54c62-178">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-178">Blobs</span></span> |<span data-ttu-id="54c62-179">Копирование BLOB-объектов</span><span class="sxs-lookup"><span data-stu-id="54c62-179">Copying Blobs</span></span> |[<span data-ttu-id="54c62-180">Используете ли вы AzCopy для массового копирования BLOB-объектов?</span><span class="sxs-lookup"><span data-stu-id="54c62-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="54c62-181">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-181">Blobs</span></span> |<span data-ttu-id="54c62-182">Копирование BLOB-объектов</span><span class="sxs-lookup"><span data-stu-id="54c62-182">Copying Blobs</span></span> |[<span data-ttu-id="54c62-183">Используете ли вы импорт и экспорт Azure для перемещения очень больших объемов данных?</span><span class="sxs-lookup"><span data-stu-id="54c62-183">Are you using Azure Import/Export to transfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="54c62-184">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-184">Blobs</span></span> |<span data-ttu-id="54c62-185">Использование метаданных</span><span class="sxs-lookup"><span data-stu-id="54c62-185">Use Metadata</span></span> |[<span data-ttu-id="54c62-186">Вы храните часто используемые метаданные, касающиеся BLOB-объектов, в их метаданных?</span><span class="sxs-lookup"><span data-stu-id="54c62-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="54c62-187">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-187">Blobs</span></span> |<span data-ttu-id="54c62-188">Быстрая отправка</span><span class="sxs-lookup"><span data-stu-id="54c62-188">Uploading Fast</span></span> |[<span data-ttu-id="54c62-189">При попытке быстро отправить один BLOB-объект вы осуществляете параллельную отправку блоков?</span><span class="sxs-lookup"><span data-stu-id="54c62-189">When trying to upload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="54c62-190">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-190">Blobs</span></span> |<span data-ttu-id="54c62-191">Быстрая отправка</span><span class="sxs-lookup"><span data-stu-id="54c62-191">Uploading Fast</span></span> |[<span data-ttu-id="54c62-192">При попытке быстро отправить множество BLOB-объектов вы отправляете BLOB-объекты параллельно?</span><span class="sxs-lookup"><span data-stu-id="54c62-192">When trying to upload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="54c62-193">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-193">Blobs</span></span> |<span data-ttu-id="54c62-194">Правильный тип BLOB-объекта</span><span class="sxs-lookup"><span data-stu-id="54c62-194">Correct Blob Type</span></span> |[<span data-ttu-id="54c62-195">Используете ли вы при необходимости страничные BLOB-объекты или блочные BLOB-объекты?</span><span class="sxs-lookup"><span data-stu-id="54c62-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="54c62-196">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-196">Tables</span></span> |<span data-ttu-id="54c62-197">Целевые показатели масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-197">Scalability Targets</span></span> |[<span data-ttu-id="54c62-198">Вы приближаетесь к целевым показателям масштабируемости для сущностей в секунду?</span><span class="sxs-lookup"><span data-stu-id="54c62-198">Are you approaching the scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="54c62-199">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-199">Tables</span></span> |<span data-ttu-id="54c62-200">Конфигурация</span><span class="sxs-lookup"><span data-stu-id="54c62-200">Configuration</span></span> |[<span data-ttu-id="54c62-201">Используете ли вы JSON в запросах таблиц?</span><span class="sxs-lookup"><span data-stu-id="54c62-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="54c62-202">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-202">Tables</span></span> |<span data-ttu-id="54c62-203">Конфигурация</span><span class="sxs-lookup"><span data-stu-id="54c62-203">Configuration</span></span> |[<span data-ttu-id="54c62-204">Вы отключили алгоритм Nagle для повышения производительность небольших запросов?</span><span class="sxs-lookup"><span data-stu-id="54c62-204">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="54c62-205">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-205">Tables</span></span> |<span data-ttu-id="54c62-206">Таблицы и разделы</span><span class="sxs-lookup"><span data-stu-id="54c62-206">Tables and Partitions</span></span> |[<span data-ttu-id="54c62-207">Вы правильно разделили свои данные?</span><span class="sxs-lookup"><span data-stu-id="54c62-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="54c62-208">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-208">Tables</span></span> |<span data-ttu-id="54c62-209">Горячие разделы</span><span class="sxs-lookup"><span data-stu-id="54c62-209">Hot Partitions</span></span> |[<span data-ttu-id="54c62-210">Вы избегаете использования инкрементируемых и декрементируемых шаблонов?</span><span class="sxs-lookup"><span data-stu-id="54c62-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="54c62-211">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-211">Tables</span></span> |<span data-ttu-id="54c62-212">Горячие разделы</span><span class="sxs-lookup"><span data-stu-id="54c62-212">Hot Partitions</span></span> |[<span data-ttu-id="54c62-213">Вы распределяете свои вставки и обновления по нескольким разделам?</span><span class="sxs-lookup"><span data-stu-id="54c62-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="54c62-214">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-214">Tables</span></span> |<span data-ttu-id="54c62-215">Область запроса</span><span class="sxs-lookup"><span data-stu-id="54c62-215">Query Scope</span></span> |[<span data-ttu-id="54c62-216">Вы спроектировали свою схему таким образом, чтобы в большинстве случаев использовать точечные запросы, а табличные запросы использовать редко?</span><span class="sxs-lookup"><span data-stu-id="54c62-216">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="54c62-217">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-217">Tables</span></span> |<span data-ttu-id="54c62-218">Плотность запроса</span><span class="sxs-lookup"><span data-stu-id="54c62-218">Query Density</span></span> |[<span data-ttu-id="54c62-219">Ваши запросы обычно только сканируют и возвращают строки, которые будет использовать приложение?</span><span class="sxs-lookup"><span data-stu-id="54c62-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="54c62-220">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-220">Tables</span></span> |<span data-ttu-id="54c62-221">Ограничение возвращаемых данных</span><span class="sxs-lookup"><span data-stu-id="54c62-221">Limiting Returned Data</span></span> |[<span data-ttu-id="54c62-222">Используете ли вы фильтрацию, чтобы избежать возвращения ненужных сущностей?</span><span class="sxs-lookup"><span data-stu-id="54c62-222">Are you using filtering to avoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="54c62-223">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-223">Tables</span></span> |<span data-ttu-id="54c62-224">Ограничение возвращаемых данных</span><span class="sxs-lookup"><span data-stu-id="54c62-224">Limiting Returned Data</span></span> |[<span data-ttu-id="54c62-225">Используете ли вы проекцию, чтобы избежать возвращения ненужных свойств?</span><span class="sxs-lookup"><span data-stu-id="54c62-225">Are you using projection to avoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="54c62-226">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-226">Tables</span></span> |<span data-ttu-id="54c62-227">Денормализация</span><span class="sxs-lookup"><span data-stu-id="54c62-227">Denormalization</span></span> |[<span data-ttu-id="54c62-228">Вы денормализовали свои данные таким образом, чтобы избежать неэффективных или множественных запросов чтения при попытке получения данных?</span><span class="sxs-lookup"><span data-stu-id="54c62-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="54c62-229">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-229">Tables</span></span> |<span data-ttu-id="54c62-230">Вставить, обновить, удалить</span><span class="sxs-lookup"><span data-stu-id="54c62-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="54c62-231">Вы применяете пакетную обработку запросов, которые должны быть транзакционными или могут быть выполнены в одно и то же время, чтобы уменьшить число циклов обработки?</span><span class="sxs-lookup"><span data-stu-id="54c62-231">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="54c62-232">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-232">Tables</span></span> |<span data-ttu-id="54c62-233">Вставить, обновить, удалить</span><span class="sxs-lookup"><span data-stu-id="54c62-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="54c62-234">Вы избегаете извлечения сущности только для того, чтобы определить, какую операцию следует выполнить: вставку или обновление?</span><span class="sxs-lookup"><span data-stu-id="54c62-234">Are you avoiding retrieving an entity just to determine whether to call insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="54c62-235">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-235">Tables</span></span> |<span data-ttu-id="54c62-236">Вставить, обновить, удалить</span><span class="sxs-lookup"><span data-stu-id="54c62-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="54c62-237">Рассматривали ли вы возможность хранения ряда данных, которые будут часто извлекаться в качестве свойств вместе с единственной сущностью, а не в виде множества сущностей?</span><span class="sxs-lookup"><span data-stu-id="54c62-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="54c62-238">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-238">Tables</span></span> |<span data-ttu-id="54c62-239">Вставить, обновить, удалить</span><span class="sxs-lookup"><span data-stu-id="54c62-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="54c62-240">Для сущностей, которые всегда будут извлекаться вместе и могут быть записаны в пакеты (например, данные временных рядов), рассматривали ли вы возможность использования BLOB-объектов вместо таблиц?</span><span class="sxs-lookup"><span data-stu-id="54c62-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="54c62-241">Очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-241">Queues</span></span> |<span data-ttu-id="54c62-242">Целевые показатели масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-242">Scalability Targets</span></span> |[<span data-ttu-id="54c62-243">Вы достигаете целевых показателей масштабируемости для сообщений в секунду?</span><span class="sxs-lookup"><span data-stu-id="54c62-243">Are you approaching the scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="54c62-244">Очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-244">Queues</span></span> |<span data-ttu-id="54c62-245">Конфигурация</span><span class="sxs-lookup"><span data-stu-id="54c62-245">Configuration</span></span> |[<span data-ttu-id="54c62-246">Вы отключили алгоритм Nagle для повышения производительность небольших запросов?</span><span class="sxs-lookup"><span data-stu-id="54c62-246">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="54c62-247">Очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-247">Queues</span></span> |<span data-ttu-id="54c62-248">Размер сообщения</span><span class="sxs-lookup"><span data-stu-id="54c62-248">Message Size</span></span> |[<span data-ttu-id="54c62-249">Ваши сообщения сжаты для повышения производительности очереди?</span><span class="sxs-lookup"><span data-stu-id="54c62-249">Are your messages compact to improve the performance of the queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="54c62-250">Очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-250">Queues</span></span> |<span data-ttu-id="54c62-251">Массовое получение</span><span class="sxs-lookup"><span data-stu-id="54c62-251">Bulk Retrieve</span></span> |[<span data-ttu-id="54c62-252">Вы получаете множество сообщений при выполнении одной операции "Получить"?</span><span class="sxs-lookup"><span data-stu-id="54c62-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="54c62-253">Очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-253">Queues</span></span> |<span data-ttu-id="54c62-254">Частота опроса</span><span class="sxs-lookup"><span data-stu-id="54c62-254">Polling Frequency</span></span> |[<span data-ttu-id="54c62-255">Частота опроса достаточна для уменьшения наблюдаемой задержки приложения?</span><span class="sxs-lookup"><span data-stu-id="54c62-255">Are you polling frequently enough to reduce the perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="54c62-256">Очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-256">Queues</span></span> |<span data-ttu-id="54c62-257">Сообщение об обновлении</span><span class="sxs-lookup"><span data-stu-id="54c62-257">Update Message</span></span> |[<span data-ttu-id="54c62-258">Используете ли вы UpdateMessage для хранения хода выполнения обработки сообщений, избегая повторной обработки всего сообщения при возникновении ошибки?</span><span class="sxs-lookup"><span data-stu-id="54c62-258">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="54c62-259">Очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-259">Queues</span></span> |<span data-ttu-id="54c62-260">Архитектура</span><span class="sxs-lookup"><span data-stu-id="54c62-260">Architecture</span></span> |[<span data-ttu-id="54c62-261">Используете ли вы очереди для того, чтобы сделать все приложение более масштабируемым, не допуская длительных рабочих нагрузок на критическом пути и масштабируя их самостоятельно?</span><span class="sxs-lookup"><span data-stu-id="54c62-261">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="54c62-262"><a name="allservices"></a>Все службы</span><span class="sxs-lookup"><span data-stu-id="54c62-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="54c62-263">В этом разделе перечислены проверенные методики, применимые для использования любой из служб хранилища Azure (BLOB-объекты, таблицы, очереди или файлы).</span><span class="sxs-lookup"><span data-stu-id="54c62-263">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="54c62-264"><a name="subheading1"></a>Целевые показатели масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="54c62-265">Каждая служба хранилища Azure имеет целевые показатели масштабируемости по производительности (ГБ), скорости транзакции и пропускной способности.</span><span class="sxs-lookup"><span data-stu-id="54c62-265">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="54c62-266">Если приложение достигает одного из целевых показателей масштабируемости или превышает его, оно может столкнуться с увеличением задержки транзакций или запуском механизма регулировки количества запросов.</span><span class="sxs-lookup"><span data-stu-id="54c62-266">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="54c62-267">Когда служба хранилища включает механизм регулировки количества запросов приложения, для некоторых транзакций с хранилищем она начинает возвращать коды ошибки "503 Сервер занят" или "500 Время ожидания операции истекло".</span><span class="sxs-lookup"><span data-stu-id="54c62-267">When a Storage service throttles your application, the service begins to return "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="54c62-268">В этом разделе рассматривается как подход к целевым показателям масштабируемости в целом, так и к целевым показателям масштабируемости в отношении пропускной способности в частности.</span><span class="sxs-lookup"><span data-stu-id="54c62-268">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="54c62-269">В следующих разделах, которые касаются отдельных служб хранилища, обсуждаются целевые показатели масштабируемости в контексте конкретной службы:</span><span class="sxs-lookup"><span data-stu-id="54c62-269">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</span></span>  

* [<span data-ttu-id="54c62-270">Пропускная способность больших двоичных объектов и количество запросов в секунду</span><span class="sxs-lookup"><span data-stu-id="54c62-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="54c62-271">Сущности таблицы в секунду</span><span class="sxs-lookup"><span data-stu-id="54c62-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="54c62-272">Сообщения очереди в секунду</span><span class="sxs-lookup"><span data-stu-id="54c62-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="54c62-273"><a name="sub1bandwidth"></a>Целевой показатель масштабируемости пропускной способности для всех служб</span><span class="sxs-lookup"><span data-stu-id="54c62-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="54c62-274">На момент написания данной статьи целевыми показателями пропускной способности в США для учетной записи геоизбыточного хранилища (GRS) является скорость в 10 гигабит в секунду (Гбит/с) на входе (данные, отправленные в учетную запись хранения) и 20 Гбит/с на выходе (данные, отправленные из учетной записи хранения).</span><span class="sxs-lookup"><span data-stu-id="54c62-274">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</span></span> <span data-ttu-id="54c62-275">Для учетной записи локально избыточного хранилища (LRS) эти ограничения выше и составляют до 20 Гбит/с на входе и 30 Гбит/с на выходе.</span><span class="sxs-lookup"><span data-stu-id="54c62-275">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="54c62-276">Международные ограничения пропускной способности могут быть ниже. О них можно узнать на [странице целевых показателей масштабируемости](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span><span class="sxs-lookup"><span data-stu-id="54c62-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="54c62-277">Для получения дополнительной информации о параметрах избыточности хранилищ см. ссылки в разделе [Полезные ресурсы](#sub1useful) далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="54c62-277">For more information on the storage redundancy options, see the links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a><span data-ttu-id="54c62-278">Действия при достижении целевого показателя масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-278">What to do when approaching a scalability target</span></span>
<span data-ttu-id="54c62-279">Если приложение достигает целевых показателей масштабируемости, когда речь идет об одной учетной записи хранения, рассмотрите вопрос об использовании одного из следующих подходов:</span><span class="sxs-lookup"><span data-stu-id="54c62-279">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</span></span>  

* <span data-ttu-id="54c62-280">Пересмотрите рабочую нагрузку, которая приводит к достижению приложением целевого показателя масштабируемости или его превышению.</span><span class="sxs-lookup"><span data-stu-id="54c62-280">Reconsider the workload that causes your application to approach or exceed the scalability target.</span></span> <span data-ttu-id="54c62-281">Вы можете спроектировать его по-другому, чтобы использовать меньшую полосу пропускания или производительность, или меньшее количество транзакций?</span><span class="sxs-lookup"><span data-stu-id="54c62-281">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="54c62-282">Если приложение должно превышать один из целевых показателей масштабируемости, следует создать несколько учетных записей хранения и разделить по ним данные приложения.</span><span class="sxs-lookup"><span data-stu-id="54c62-282">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="54c62-283">При использовании этого подхода необходимо разработать приложение таким образом, чтобы в будущем для балансировки нагрузки в него можно было добавлять другие учетные записи хранения.</span><span class="sxs-lookup"><span data-stu-id="54c62-283">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</span></span> <span data-ttu-id="54c62-284">На момент написания данной статьи каждая подписка Azure может иметь до 100 учетных записей хранения.</span><span class="sxs-lookup"><span data-stu-id="54c62-284">At time of writing, each Azure subscription can have up to 100 storage accounts.</span></span>  <span data-ttu-id="54c62-285">Кроме случаев использования с целью хранения данных, совершения транзакций или передачи данных плата за учетные записи хранения не взимается.</span><span class="sxs-lookup"><span data-stu-id="54c62-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="54c62-286">Если приложение достигает целевых показателей пропускной способности, рассмотрите вопрос сжатия данных на стороне клиента, чтобы уменьшить полосу пропускания, необходимую для отправки данных в службу хранилища.</span><span class="sxs-lookup"><span data-stu-id="54c62-286">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</span></span>  <span data-ttu-id="54c62-287">Обратите внимание, этот способ может как сэкономить полосу пропускания и повысить производительность сети, так и иметь некоторые негативные последствия.</span><span class="sxs-lookup"><span data-stu-id="54c62-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="54c62-288">Вам следует оценить влияние на производительность этих дополнительных требований по сжатию и распаковке данных, выполняемых на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="54c62-288">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</span></span> <span data-ttu-id="54c62-289">Кроме того, хранение сжатых данных может усложнить устранение обнаруженных в них неполадок, так как в этом случае может возникнуть трудность с просмотром сохраненных данных с помощью стандартных инструментов.</span><span class="sxs-lookup"><span data-stu-id="54c62-289">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</span></span>
* <span data-ttu-id="54c62-290">Если приложение достигает целевых показателей масштабируемости, убедитесь в том, что используется экспоненциальная отсрочка для повторов (см. раздел [Повторы](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="54c62-290">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="54c62-291">Лучше всего сделать так, чтобы ваше приложение никогда не приближалось к целевым показателям масштабируемости (с помощью одного из вышеуказанных методов), но это приведет к тому, что приложение просто не будет продолжать выполнять быстрые повторения, еще более активируя механизм регулировки количества запросов.</span><span class="sxs-lookup"><span data-stu-id="54c62-291">It's better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won't just keep retrying rapidly, making the throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="54c62-292">Полезные ресурсы</span><span class="sxs-lookup"><span data-stu-id="54c62-292">Useful Resources</span></span>
<span data-ttu-id="54c62-293">Приведенные ниже ссылки предоставляют дополнительную информацию о целевых показателях масштабируемости:</span><span class="sxs-lookup"><span data-stu-id="54c62-293">The following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="54c62-294">Дополнительные сведения о целевых показателях масштабируемости см. в статье [Целевые показатели масштабируемости и производительности службы хранилища Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="54c62-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="54c62-295">Дополнительные сведения о параметрах избыточности хранилищ см. в статье [Репликация службы хранилища Azure](storage-redundancy.md) и записи блога [Microsoft Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) (Параметры избыточности службы хранилища Microsoft Azure и геоизбыточное хранилище с доступом на чтение).</span><span class="sxs-lookup"><span data-stu-id="54c62-295">See [Azure Storage replication](storage-redundancy.md) and the blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="54c62-296">Для получения актуальной информации о ценах за использование служб Azure см. страницу [Цены Azure](https://azure.microsoft.com/pricing/overview/).</span><span class="sxs-lookup"><span data-stu-id="54c62-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="54c62-297"><a name="subheading47"></a>Соглашение об именовании секций</span><span class="sxs-lookup"><span data-stu-id="54c62-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="54c62-298">Для масштабирования и распределения нагрузки в системы в хранилище Azure используется схема секционирования на основе диапазонов.</span><span class="sxs-lookup"><span data-stu-id="54c62-298">Azure Storage uses a range-based partitioning scheme to scale and load balance the system.</span></span> <span data-ttu-id="54c62-299">Данные распределяются по диапазонам с помощью ключа секции, а затем эти диапазоны распределяются по системе.</span><span class="sxs-lookup"><span data-stu-id="54c62-299">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="54c62-300">Это означает, что соглашения об именовании, такие как лексическое упорядочение (например, msftpayroll, msftperformance, msftemployees и т. д.) или использование отметок времени (log20160101, log20160102, log20160102 и т. д.), будут применяться для секций, которые могут размещаться на том же сервере секционирования, пока операция балансировки нагрузки разбивает их на более мелкие диапазоны.</span><span class="sxs-lookup"><span data-stu-id="54c62-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself to the partitions being potentially co-located on the same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="54c62-301">Например, все BLOB-объекты в контейнере могут обрабатываться одним и тем же сервером, пока нагрузка на эти BLOB-объекты не потребует дополнительного перераспределения диапазонов секций.</span><span class="sxs-lookup"><span data-stu-id="54c62-301">For example, all blobs within a container can be served by a single server until the load on these blobs requires further rebalancing of the partition ranges.</span></span> <span data-ttu-id="54c62-302">Точно так же группу незначительно нагруженных учетных записей с именами, упорядоченными в лексическом порядке, может обслуживать один и тот же сервер, пока нагрузка на одну или несколько из этих учетных записей не потребует разбить их между несколькими серверами секций.</span><span class="sxs-lookup"><span data-stu-id="54c62-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until the load on one or all of these accounts require them to be split across multiple partitions servers.</span></span> <span data-ttu-id="54c62-303">Каждая операция балансировки нагрузки может вызывать задержку вызовов хранилища во время ее выполнения.</span><span class="sxs-lookup"><span data-stu-id="54c62-303">Each load balancing operation may impact the latency of storage calls during the operation.</span></span> <span data-ttu-id="54c62-304">Способность системы справляться с внезапным всплеском трафика в секции ограничивается масштабированием единственного сервера секционирования, пока не будет запущена операция балансировки нагрузки, которая перераспределит диапазон ключей секций.</span><span class="sxs-lookup"><span data-stu-id="54c62-304">The system's ability to handle a sudden burst of traffic to a partition is limited by the scalability of a single partition server until the load balancing operation kicks-in and rebalances the partition key range.</span></span>  

<span data-ttu-id="54c62-305">Частоту выполнения таких операций можно уменьшить.</span><span class="sxs-lookup"><span data-stu-id="54c62-305">You can follow some best practices to reduce the frequency of such operations.</span></span>  

* <span data-ttu-id="54c62-306">Внимательно проверьте используемое соглашение об именовании учетных записей, контейнеров, BLOB-объектов, таблиц и очередей.</span><span class="sxs-lookup"><span data-stu-id="54c62-306">Examine the naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="54c62-307">К именам учетных записей можно добавить трехзначный хэш в виде префикса, используя функцию хэширования, наиболее соответствующую вашим задачам.</span><span class="sxs-lookup"><span data-stu-id="54c62-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="54c62-308">Если данные упорядочены по меткам времени или числовым идентификаторам, убедитесь в том, что вы используете инкрементируемые (или декрементируемые) шаблоны трафика.</span><span class="sxs-lookup"><span data-stu-id="54c62-308">If you organize your data using timestamps or numerical identifiers, you have to ensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="54c62-309">Эти шаблоны не подходят для системы секционирования на основе диапазонов и могут приводить к тому, что весь трафик будет направляться в одну и ту же секцию, препятствуя эффективной балансировке нагрузки.</span><span class="sxs-lookup"><span data-stu-id="54c62-309">These patterns are not suitable for a range -based partitioning system, and could lead to all the traffic going to a single partition and limiting the system from effectively load balancing.</span></span> <span data-ttu-id="54c62-310">Например, при наличии ежедневных операций с BLOB-объектом, имеющим метку времени вида ГГГГММДД, весь трафик этой ежедневной операции направляется в один объект, который обслуживается одним-единственным сервером секционирования.</span><span class="sxs-lookup"><span data-stu-id="54c62-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all the traffic for that daily operation is directed to a single object which is served by a single partition server.</span></span> <span data-ttu-id="54c62-311">Проверьте, соответствуют ли ограничения по BLOB-объектам и ограничения по секциям вашим потребностям и, если нужно, разбейте эту операцию на несколько BLOB-объектов.</span><span class="sxs-lookup"><span data-stu-id="54c62-311">Look at whether the per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="54c62-312">Точно так же, если в таблицах хранятся данные временных рядов, весь трафик может направляться в последнюю часть ключевого пространства имен.</span><span class="sxs-lookup"><span data-stu-id="54c62-312">Similarly, if you store time series data in your tables, all the traffic could be directed to the last part of the key namespace.</span></span> <span data-ttu-id="54c62-313">Если вам нужно использовать метки времени или числовые идентификаторы, добавляйте в идентификатор префикс в виде трехзначного хэша. Если нужны метки времени, добавляйте секунды в качестве префикса к значению времени: ссггггммдд.</span><span class="sxs-lookup"><span data-stu-id="54c62-313">If you must use timestamps or numerical IDs, prefix the id with a 3-digit hash, or in the case of timestamps prefix the seconds part of the time such as ssyyyymmdd.</span></span> <span data-ttu-id="54c62-314">Если операции перечисления и запросов выполняются регулярно, выберите функцию хэширования, ограничивающую число запросов.</span><span class="sxs-lookup"><span data-stu-id="54c62-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="54c62-315">В других случаях может быть достаточно случайного префикса.</span><span class="sxs-lookup"><span data-stu-id="54c62-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="54c62-316">Дополнительные сведения о схеме секционирования, которая используется в службе хранилища Azure, см. документ SOSP [здесь](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span><span class="sxs-lookup"><span data-stu-id="54c62-316">For additional information on the partitioning scheme used in Azure Storage, read the SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="54c62-317">Сеть</span><span class="sxs-lookup"><span data-stu-id="54c62-317">Networking</span></span>
<span data-ttu-id="54c62-318">Хотя API вызывается независимо, часто физические ограничения сети, в котором работает приложение, оказывают существенное влияние на производительность.</span><span class="sxs-lookup"><span data-stu-id="54c62-318">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</span></span> <span data-ttu-id="54c62-319">Ниже описаны некоторые ограничения, с которыми могут столкнуться пользователи.</span><span class="sxs-lookup"><span data-stu-id="54c62-319">The following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="54c62-320">Возможность клиентской сети</span><span class="sxs-lookup"><span data-stu-id="54c62-320">Client Network Capability</span></span>
##### <span data-ttu-id="54c62-321"><a name="subheading2"></a>Пропускная способность</span><span class="sxs-lookup"><span data-stu-id="54c62-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="54c62-322">Что касается полосы пропускания, частой проблемой являются возможности клиента.</span><span class="sxs-lookup"><span data-stu-id="54c62-322">For bandwidth, the problem is often the capabilities of the client.</span></span> <span data-ttu-id="54c62-323">Например, в то время как одна учетная запись хранения может обрабатывать данные со скоростью 10 Гбит/с или более на входе (см. [целевые показатели масштабируемости пропускной способности](#sub1bandwidth)), скорость работы сети в "небольшом" экземпляре рабочей роли Azure способна достигать только около 100 Мбит/с.</span><span class="sxs-lookup"><span data-stu-id="54c62-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), the network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="54c62-324">Очень крупные экземпляры Azure имеют сетевые карты, обладающие большими возможностями, поэтому если необходимы более высокие сетевые ограничения от одной машины, следует рассмотреть возможность использования более крупного экземпляра или большего количества виртуальных машин.</span><span class="sxs-lookup"><span data-stu-id="54c62-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="54c62-325">При обращении к службе хранилища из локального приложения применяется то же правило: понять сетевые возможности клиентского устройства и сетевого подключения к месту расположения хранилища Azure и либо улучшить их по мере необходимости, либо разработать приложение для работы в рамках их возможностей.</span><span class="sxs-lookup"><span data-stu-id="54c62-325">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</span></span>  

##### <span data-ttu-id="54c62-326"><a name="subheading3"></a>Качество связи</span><span class="sxs-lookup"><span data-stu-id="54c62-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="54c62-327">Как и при любом использовании сети, имейте в виду, что состояние сети, приводящее к ошибкам и потере пакетов, снижает эффективную пропускную способность.</span><span class="sxs-lookup"><span data-stu-id="54c62-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="54c62-328">Использование инструмента WireShark или NetMon может помочь в диагностике этой проблемы.</span><span class="sxs-lookup"><span data-stu-id="54c62-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="54c62-329">Полезные ресурсы</span><span class="sxs-lookup"><span data-stu-id="54c62-329">Useful Resources</span></span>
<span data-ttu-id="54c62-330">Дополнительные сведения о размерах виртуальной машины и выделенной пропускной способности см. в статье [Размеры виртуальных машин в Azure](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) (Windows) или [Размеры виртуальных машин в Azure](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) (Linux).</span><span class="sxs-lookup"><span data-stu-id="54c62-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="54c62-331"><a name="subheading4"></a>Расположение</span><span class="sxs-lookup"><span data-stu-id="54c62-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="54c62-332">В любой распределенной среде наилучшее быстродействие достигается при нахождении клиента рядом с сервером.</span><span class="sxs-lookup"><span data-stu-id="54c62-332">In any distributed environment, placing the client near to the server delivers in the best performance.</span></span> <span data-ttu-id="54c62-333">Для доступа к хранилищу Azure с наименьшей задержкой лучшим местом для клиента будет его нахождение в том же регионе Azure.</span><span class="sxs-lookup"><span data-stu-id="54c62-333">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</span></span> <span data-ttu-id="54c62-334">Например, при наличии веб-сайта Azure, который использует хранилище Azure, оба следует разместить внутри одного региона (например, на Западе США или в Юго-Восточной Азии).</span><span class="sxs-lookup"><span data-stu-id="54c62-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="54c62-335">Это уменьшает задержку и стоимость. На момент написания этой статьи использование полосы пропускания в пределах одного региона является бесплатным.</span><span class="sxs-lookup"><span data-stu-id="54c62-335">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="54c62-336">Опять же, если клиентские приложения не размещены в Azure (например, в приложениях для мобильных устройств или в локальных корпоративных службах), размещение учетной записи хранения в регионе рядом с устройствами, которые будут к нему обращаться, как правило, уменьшает задержку.</span><span class="sxs-lookup"><span data-stu-id="54c62-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="54c62-337">Если клиенты разбросаны по всему миру (например, одни находятся в Северной Америке, другие — в Европе), следует рассмотреть возможность использования нескольких учетных записей хранения: одна размещенная в североамериканском регионе и одна — в европейском.</span><span class="sxs-lookup"><span data-stu-id="54c62-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="54c62-338">Это поможет сократить задержку для пользователей в обоих регионах.</span><span class="sxs-lookup"><span data-stu-id="54c62-338">This will help to reduce latency for users in both regions.</span></span> <span data-ttu-id="54c62-339">Такой подход, как правило, легче реализовать, если данные, которые хранят приложения, предназначены для отдельных пользователей, и не требуют репликации между учетными записями хранения.</span><span class="sxs-lookup"><span data-stu-id="54c62-339">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="54c62-340">Для широкого распространения содержимого рекомендуется использовать сеть CDN. Для получения более подробной информации см. ​следующий раздел.</span><span class="sxs-lookup"><span data-stu-id="54c62-340">For broad content distribution, a CDN is recommended – see the next section for more details.</span></span>  

### <span data-ttu-id="54c62-341"><a name="subheading5"></a>Распространение содержимого</span><span class="sxs-lookup"><span data-stu-id="54c62-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="54c62-342">Иногда приложению необходимо предоставить одинаковое содержимое множеству пользователей (например, демо-видео продукта, используемое на домашней странице веб-сайта), которые находятся в одном или в нескольких регионах.</span><span class="sxs-lookup"><span data-stu-id="54c62-342">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</span></span> <span data-ttu-id="54c62-343">В этом случае следует использовать сеть доставки содержимого (CDN), такую как сеть Azure CDN, где CDN будет использовать хранилище Azure в качестве источника данных.</span><span class="sxs-lookup"><span data-stu-id="54c62-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</span></span> <span data-ttu-id="54c62-344">В отличие от учетной записи хранилища Azure, которая существует в одном регионе и которая не может распространять содержимое с минимальной задержкой в другие регионы, сеть Azure CDN использует серверы, расположенные в нескольких центрах обработки данных по всему миру.</span><span class="sxs-lookup"><span data-stu-id="54c62-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</span></span> <span data-ttu-id="54c62-345">Кроме того, сеть CDN обычно поддерживает гораздо более высокие ограничения на выходе, чем одна учетная запись хранения.</span><span class="sxs-lookup"><span data-stu-id="54c62-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="54c62-346">Для получения дополнительной информации о сети Azure CDN см. статью [Сеть кэширующих серверов](https://azure.microsoft.com/services/cdn/).</span><span class="sxs-lookup"><span data-stu-id="54c62-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="54c62-347"><a name="subheading6"></a>Использование SAS и CORS</span><span class="sxs-lookup"><span data-stu-id="54c62-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="54c62-348">Если для получения доступа к данным службы хранилища Azure в пользовательском браузере или приложении мобильного телефона необходимо авторизовать такой код, как JavaScript, то используйте в качестве прокси-сервера приложение с веб-ролью. Таким образом, пользовательское устройство проходит аутентификацию для веб-роли, которая в свою очередь проходит аутентификацию для службы хранилища.</span><span class="sxs-lookup"><span data-stu-id="54c62-348">When you need to authorize code such as JavaScript in a user's web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user's device authenticates with the web role, which in turn authenticates with the storage service.</span></span> <span data-ttu-id="54c62-349">Таким образом, на небезопасных устройствах можно не сообщать ключи своей учетной записи хранения.</span><span class="sxs-lookup"><span data-stu-id="54c62-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="54c62-350">Однако это приводит к большим затратам вычислительных ресурсов на обработку веб-роли, потому что все данные, передаваемые между пользовательским устройством и службой хранилища, должны пройти через эту веб-роль.</span><span class="sxs-lookup"><span data-stu-id="54c62-350">However, this places a big overhead on the web role because all the data transferred between the user's device and the storage service must pass through the web role.</span></span> <span data-ttu-id="54c62-351">Избежать использования веб-роли в качестве прокси-сервера для службы хранилища можно путем использования подписей совместного доступа (Shared Access Signatures, или SAS), иногда в сочетании с заголовками для общего доступа к ресурсам независимо от источника (Cross-Origin Resource Sharing, или CORS).</span><span class="sxs-lookup"><span data-stu-id="54c62-351">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="54c62-352">Используя технологию SAS, пользовательскому устройству можно позволить осуществлять запросы непосредственно к службе хранилища с помощью ограниченного маркера доступа.</span><span class="sxs-lookup"><span data-stu-id="54c62-352">Using SAS, you can allow your user's device to make requests directly to a storage service by means of a limited access token.</span></span> <span data-ttu-id="54c62-353">Например, если пользователь хочет загрузить фото в приложение, то веб-роль может создать и отправить на пользовательское устройство маркер SAS, который предоставляет разрешение на запись определенному большому двоичному объекту или контейнеру в течение ближайших 30 минут (после чего срок действия маркера SAS истекает).</span><span class="sxs-lookup"><span data-stu-id="54c62-353">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user's device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</span></span>

<span data-ttu-id="54c62-354">Обычно браузер не позволяет коду JavaScript, находящемуся на странице, размещенной на веб-сайте в одном домене, выполнять определенные операции, такие, как "PUT", направленные на другой домен.</span><span class="sxs-lookup"><span data-stu-id="54c62-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a "PUT" to another domain.</span></span> <span data-ttu-id="54c62-355">Например, если при размещении веб-роли в домене contosomarketing.cloudapp.net необходимо использовать код JavaScript, находящийся на стороне клиента, чтобы загрузить большой двоичный объект в учетную запись хранения, расположенную в домене contosoproducts.blob.core.windows.net, то "политика одинакового источника" браузера запретит эту операцию.</span><span class="sxs-lookup"><span data-stu-id="54c62-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want to use client side JavaScript to upload a blob to your storage account at "contosoproducts.blob.core.windows.net," the browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="54c62-356">Технология CORS является функцией браузера, которая позволяет целевому домену (в данном случае учетной записи хранения) связаться с браузером, которому она доверяет запросы, созданные в исходном домене (в данном случае веб-роли).</span><span class="sxs-lookup"><span data-stu-id="54c62-356">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</span></span>  

<span data-ttu-id="54c62-357">Обе эти технологии могут помочь избежать излишней нагрузки (и узких мест) веб-приложения.</span><span class="sxs-lookup"><span data-stu-id="54c62-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="54c62-358">Полезные ресурсы</span><span class="sxs-lookup"><span data-stu-id="54c62-358">Useful Resources</span></span>
<span data-ttu-id="54c62-359">Дополнительные сведения о подписанном URL-адресе см. в статье [Использование подписанных URL-адресов (SAS)](storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="54c62-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding the SAS Model](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="54c62-360">Дополнительные сведения о технологии CORS см. в статье [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx) (Поддержка общего доступа к ресурсам независимо от источника (CORS) для служб хранилища Azure).</span><span class="sxs-lookup"><span data-stu-id="54c62-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="54c62-361">Caching</span><span class="sxs-lookup"><span data-stu-id="54c62-361">Caching</span></span>
#### <span data-ttu-id="54c62-362"><a name="subheading7"></a>Получение данных</span><span class="sxs-lookup"><span data-stu-id="54c62-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="54c62-363">В большинстве случаев получение данных из службы с одной попытки лучше, чем с двух.</span><span class="sxs-lookup"><span data-stu-id="54c62-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="54c62-364">Рассмотрим пример веб-приложения MVC, выполняющегося в веб-роли, которая уже получила 50 МБ BLOB-объекта из службы хранилища для его предоставления пользователю в качестве содержимого.</span><span class="sxs-lookup"><span data-stu-id="54c62-364">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</span></span> <span data-ttu-id="54c62-365">Затем приложение может получать тот же самый BLOB-объект каждый раз, когда его запрашивает пользователь, или же оно может кэшировать его локально на диск и повторно использовать кэшированную версию для обработки последующих запросов пользователей.</span><span class="sxs-lookup"><span data-stu-id="54c62-365">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</span></span> <span data-ttu-id="54c62-366">Кроме того, каждый раз, когда пользователь запрашивает данные, приложение может вызывать команду GET с условным заголовком для времени изменения, благодаря чему можно не получать весь большой двоичный объект в том случае, если он не был изменен.</span><span class="sxs-lookup"><span data-stu-id="54c62-366">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn't been modified.</span></span> <span data-ttu-id="54c62-367">Такую же схему можно применить для работы с сущностями таблицы.</span><span class="sxs-lookup"><span data-stu-id="54c62-367">You can apply this same pattern to working with table entities.</span></span>  

<span data-ttu-id="54c62-368">В некоторых случаях можно решить, что приложение может считать BLOB-объект действующим в течение короткого периода времени после его получения и что в течение этого периода времени приложению не нужно проверять, был ли изменен этот BLOB-объект.</span><span class="sxs-lookup"><span data-stu-id="54c62-368">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</span></span>

<span data-ttu-id="54c62-369">Прекрасными кандидатами на кэширование являются данные конфигурации, поиска, а также другие данные, которые используются приложением всегда.</span><span class="sxs-lookup"><span data-stu-id="54c62-369">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</span></span>  

<span data-ttu-id="54c62-370">Пример того, как получить свойства большого двоичного объекта, необходимые для выяснения даты последнего изменения с помощью .NET, см. в статье [Задание и получение свойств и метаданных](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="54c62-370">For an example of how to get a blob's properties to discover the last modified date using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span> <span data-ttu-id="54c62-371">Дополнительные сведения об условных загрузках см. в статье [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) (Указание условных заголовков для операций службы BLOB-объектов).</span><span class="sxs-lookup"><span data-stu-id="54c62-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="54c62-372"><a name="subheading8"></a>Передача данных в пакетах</span><span class="sxs-lookup"><span data-stu-id="54c62-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="54c62-373">В некоторых случаях приложения могут объединять данные локально, а затем периодически отправлять их в пакете вместо немедленной отправки каждого фрагмента данных.</span><span class="sxs-lookup"><span data-stu-id="54c62-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="54c62-374">Например, веб-приложение может хранить файл журнала операций: приложение может или отправлять информацию о каждой операции по мере их появления в виде табличной сущности (что требует выполнения множества операций хранилища), или сохранять данные об операциях в локальный файл журнала, а затем периодически отправлять все эти данные в виде файла с разделителями в большой двоичный объект.</span><span class="sxs-lookup"><span data-stu-id="54c62-374">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</span></span> <span data-ttu-id="54c62-375">Если размер каждой записи журнала составляет 1 КБ, их можно отправлять тысячами в одной транзакции "Put Blob" (Вставка большого двоичного объекта) (в одной транзакции можно отправить большой двоичный объект размером до 64 МБ).</span><span class="sxs-lookup"><span data-stu-id="54c62-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up to 64MB in size in a single transaction).</span></span> <span data-ttu-id="54c62-376">Конечно, в том случае, если локальная машина выходит из строя до завершения отправки, некоторые данные журнала будут утеряны: разработчик приложения должен предусмотреть возможность ошибок клиентского устройства или ошибок передачи.</span><span class="sxs-lookup"><span data-stu-id="54c62-376">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</span></span>  <span data-ttu-id="54c62-377">Если необходимо загрузить данные о действиях, совершенных в определенные временные интервалы (а не только за одиночную операцию), рекомендуются использовать BLOB-объекты, а не таблицы.</span><span class="sxs-lookup"><span data-stu-id="54c62-377">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="54c62-378">Конфигурация .NET</span><span class="sxs-lookup"><span data-stu-id="54c62-378">.NET Configuration</span></span>
<span data-ttu-id="54c62-379">В данном разделе перечислены несколько быстрых параметров конфигурации, которые можно использовать для значительного повышения производительности при использовании платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="54c62-379">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</span></span>  <span data-ttu-id="54c62-380">При использовании других языков проверьте, применяются ли в выбранном языке подобные концепции.</span><span class="sxs-lookup"><span data-stu-id="54c62-380">If using other languages, check to see if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="54c62-381"><a name="subheading9"></a>Увеличение ограничения числа подключений по умолчанию</span><span class="sxs-lookup"><span data-stu-id="54c62-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="54c62-382">В языке .NET указанный ниже код увеличивает ограничение количества подключений по умолчанию (которое обычно соответствует 2 в клиентской среде или 10 в серверной среде) до 100.</span><span class="sxs-lookup"><span data-stu-id="54c62-382">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</span></span> <span data-ttu-id="54c62-383">В обычном случае следует установить значение, приблизительно соответствующее количеству потоков, используемых приложением.</span><span class="sxs-lookup"><span data-stu-id="54c62-383">Typically, you should set the value to approximately the number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="54c62-384">Ограничение числа подключений должно быть установлено до открытия каких-либо подключений.</span><span class="sxs-lookup"><span data-stu-id="54c62-384">You must set the connection limit before opening any connections.</span></span>  

<span data-ttu-id="54c62-385">Что касается других языков программирования, то для определения механизма установки ограничения числа подключений см. документацию по соответствующему языку.</span><span class="sxs-lookup"><span data-stu-id="54c62-385">For other programming languages, see that language's documentation to determine how to set the connection limit.</span></span>  

<span data-ttu-id="54c62-386">Дополнительные сведения см. в записи блога [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx) (Веб-службы: параллельные подключения).</span><span class="sxs-lookup"><span data-stu-id="54c62-386">For additional information, see the blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="54c62-387"><a name="subheading10"></a></span><span class="sxs-lookup"><span data-stu-id="54c62-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="54c62-388">Данный код позволяет увеличить минимальное количество потоков в пуле потоков:</span><span class="sxs-lookup"><span data-stu-id="54c62-388">This code will increase the thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

<span data-ttu-id="54c62-389">Дополнительные сведения см. в статье [ThreadPool.SetMinThreads Method (Int32, Int32)](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx) (Метод ThreadPool.SetMinThreads (Int32, Int32)).</span><span class="sxs-lookup"><span data-stu-id="54c62-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="54c62-390"><a name="subheading11"></a></span><span class="sxs-lookup"><span data-stu-id="54c62-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="54c62-391">Используйте для клиентского приложения .NET 4.5 или более поздней версии, чтобы воспользоваться новыми способами повышения производительности в технологии сборки серверного мусора.</span><span class="sxs-lookup"><span data-stu-id="54c62-391">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="54c62-392">Дополнительные сведения см. в статье [Обзор усовершенствований, направленных на повышение производительности](http://msdn.microsoft.com/magazine/hh882452.aspx).</span><span class="sxs-lookup"><span data-stu-id="54c62-392">For more information, see the article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="54c62-393"><a name="subheading12"></a>Неограниченный параллелизм</span><span class="sxs-lookup"><span data-stu-id="54c62-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="54c62-394">Хотя параллелизм может быть привлекательным с точки зрения производительности, будьте внимательны при использовании неограниченного параллелизма (отсутствие ограничения на количество потоков и (или) параллельных запросов) для отправки или загрузки данных, наличии нескольких работников с доступом к нескольким разделам (контейнерам, очередям или разделам таблиц) в одной учетной записи хранения или доступом к нескольким элементам в одном разделе.</span><span class="sxs-lookup"><span data-stu-id="54c62-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</span></span> <span data-ttu-id="54c62-395">Если параллелизм неограничен, то приложение может превышать возможности клиентского устройства или целевые показатели масштабируемости учетных записей хранения из-за более длинных задержек и регулирования количества запросов.</span><span class="sxs-lookup"><span data-stu-id="54c62-395">If the parallelism is unbounded, your application can exceed the client device's capabilities or the storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="54c62-396"><a name="subheading13"></a>Клиентские библиотеки и средства хранилища</span><span class="sxs-lookup"><span data-stu-id="54c62-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="54c62-397">Всегда используйте самые последние версии клиентских библиотек и инструментов, предоставляемых корпорацией Microsoft.</span><span class="sxs-lookup"><span data-stu-id="54c62-397">Always use the latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="54c62-398">На момент написания данной статьи существуют клиентские библиотеки, доступные для .NET, Windows Phone, Windows Runtime, Java и C++, а также библиотеки предварительного просмотра для других языков.</span><span class="sxs-lookup"><span data-stu-id="54c62-398">At the time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="54c62-399">Кроме того, корпорация Майкрософт выпустила командлеты PowerShell и команды CLI Azure для работы с хранилищем Azure.</span><span class="sxs-lookup"><span data-stu-id="54c62-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="54c62-400">Корпорация Microsoft активно разрабатывает эти инструменты с учетом производительности, поддерживает их в соответствии с последними версиями служб и обеспечивает в них поддержку проверенных и производительных методов работы.</span><span class="sxs-lookup"><span data-stu-id="54c62-400">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="54c62-401">Повторы</span><span class="sxs-lookup"><span data-stu-id="54c62-401">Retries</span></span>
#### <span data-ttu-id="54c62-402"><a name="subheading14"></a>Регулирование количества запросов и состояние "Сервер занят"</span><span class="sxs-lookup"><span data-stu-id="54c62-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="54c62-403">В некоторых случаях служба хранилища может регулировать количество запросов приложения или может просто быть не в состоянии обслуживать запрос из-за некоего переходного состояния и возвращает сообщение "503 Сервер занят" или "500 Время ожидания операции истекло".</span><span class="sxs-lookup"><span data-stu-id="54c62-403">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="54c62-404">Это может произойти в том случае, если приложение достигает одного из целевых показателей масштабируемости или если система занята повторной балансировкой секционированных данных для обеспечения более высокой пропускной способности.</span><span class="sxs-lookup"><span data-stu-id="54c62-404">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</span></span>  <span data-ttu-id="54c62-405">Клиентское приложение должно, как правило, повторить операцию, которая вызывает эту ошибку: попытка выполнить тот же самый запрос позже может быть успешной.</span><span class="sxs-lookup"><span data-stu-id="54c62-405">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</span></span> <span data-ttu-id="54c62-406">Однако если служба хранилища запускает механизм регулировки количества запросов из приложения из-за превышения целевых показателей масштабируемости или даже если служба была не в состоянии обслуживать данный запрос по какой-то другой причине, настойчивые повторы обычно только усугубляют проблему.</span><span class="sxs-lookup"><span data-stu-id="54c62-406">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</span></span> <span data-ttu-id="54c62-407">По этой причине следует использовать экспоненциальное откладывание (по умолчанию клиентские библиотеки настроены реагировать именно так).</span><span class="sxs-lookup"><span data-stu-id="54c62-407">For this reason, you should use an exponential back off (the client libraries default to this behavior).</span></span> <span data-ttu-id="54c62-408">Например, приложение может повторить действие через 2 секунды, затем через 4 секунды, затем через 10 секунд, затем через 30 секунд, а затем полностью отказаться от повторения.</span><span class="sxs-lookup"><span data-stu-id="54c62-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="54c62-409">Такое поведение приводит к тому, что приложение значительно снижает свою нагрузку на службу и не усугубляет проблем.</span><span class="sxs-lookup"><span data-stu-id="54c62-409">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="54c62-410">Обратите внимание: ошибки подключения могут вызывать немедленные повторы, так как они не являются результатом регулирования количества запросов и, как ожидается, будут временными.</span><span class="sxs-lookup"><span data-stu-id="54c62-410">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</span></span>  

#### <span data-ttu-id="54c62-411"><a name="subheading15"></a>Ошибки без повторов</span><span class="sxs-lookup"><span data-stu-id="54c62-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="54c62-412">Клиентским библиотекам известно, какие ошибки предполагают повторный запрос, а какие нет.</span><span class="sxs-lookup"><span data-stu-id="54c62-412">The client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="54c62-413">Тем не менее при написании своего собственного кода в отношении REST API для служб хранилища помните, что существуют такие ошибки, после которых запрос не следует повторять: например, ответ 400 (Неправильный запрос) указывает на то, что клиентское приложение направило запрос, который не может быть обработан из-за того, что он не был представлен в ожидаемой форме.</span><span class="sxs-lookup"><span data-stu-id="54c62-413">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="54c62-414">Повторная отправка этого запроса каждый раз будет приводить к такому же ответу, поэтому в его повторной попытке нет смысла.</span><span class="sxs-lookup"><span data-stu-id="54c62-414">Resending this request will result the same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="54c62-415">При написании своего собственного кода в отношении API-интерфейса REST для служб хранилища помните о значениях кодов ошибок и выбирайте правильный способ повторного запроса (или его отсутствия).</span><span class="sxs-lookup"><span data-stu-id="54c62-415">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="54c62-416">Полезные ресурсы</span><span class="sxs-lookup"><span data-stu-id="54c62-416">Useful Resources</span></span>
<span data-ttu-id="54c62-417">Для получения дополнительной информации о кодах ошибок хранилища см. статью [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) (Коды ошибок и состояний) на веб-сайте Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="54c62-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on the Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="54c62-418">BLOB-объекты</span><span class="sxs-lookup"><span data-stu-id="54c62-418">Blobs</span></span>
<span data-ttu-id="54c62-419">В дополнение к проверенным практическим подходам, ранее описанным в разделе [Все службы](#allservices) , следующие проверенные подходы применяются специально для службы BLOB-объектов.</span><span class="sxs-lookup"><span data-stu-id="54c62-419">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="54c62-420">Целевые показатели масштабируемости, характерные для BLOB-объекта</span><span class="sxs-lookup"><span data-stu-id="54c62-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="54c62-421"><a name="subheading46"></a>Несколько клиентов, одновременно обращающихся к одному объекту</span><span class="sxs-lookup"><span data-stu-id="54c62-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="54c62-422">При наличии большого количества клиентов, одновременно обращающихся к одному объекту, необходимо учитывать целевые показатели масштабируемости для объекта и учетной записи хранения.</span><span class="sxs-lookup"><span data-stu-id="54c62-422">If you have a large number of clients accessing a single object concurrently you will need to consider per object and storage account scalability targets.</span></span> <span data-ttu-id="54c62-423">Точное число клиентов, которые могут обратиться к одному объекту, будет зависеть от таких факторов, как количество клиентов, одновременно запрашивающих объект, размер объекта, состояние сети и т. д.</span><span class="sxs-lookup"><span data-stu-id="54c62-423">The exact number of clients that can access a single object will vary depending on factors such as the number of clients requesting the object simultaneously, the size of the object, network conditions etc.</span></span>

<span data-ttu-id="54c62-424">Если объект можно распространить по CDN (например, если это изображения или видео с веб-сайта), то следует использовать CDN.</span><span class="sxs-lookup"><span data-stu-id="54c62-424">If the object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="54c62-425">Дополнительные сведения см. [здесь](#subheading5).</span><span class="sxs-lookup"><span data-stu-id="54c62-425">See [here](#subheading5).</span></span>

<span data-ttu-id="54c62-426">В других сценариях, например в научном моделировании, где данные являются конфиденциальными, имеется две возможности.</span><span class="sxs-lookup"><span data-stu-id="54c62-426">In other scenarios such as scientific simulations where the data is confidential you have two options.</span></span> <span data-ttu-id="54c62-427">Первая — дифференцировать доступ рабочей нагрузки таким образом, чтобы доступ к объекту в одни периоды времени осуществлялся эксклюзивно, а в другие — одновременно.</span><span class="sxs-lookup"><span data-stu-id="54c62-427">The first is to stagger your workload's access such that the object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="54c62-428">Кроме того, можно временно скопировать объект в несколько учетных записей хранения, тем самым увеличивая общее число операций ввода-вывода для объекта и учетных записей хранения.</span><span class="sxs-lookup"><span data-stu-id="54c62-428">Alternatively, you can temporarily copy the object to multiple storage accounts thus increasing the total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="54c62-429">Проведя ограниченное тестирование, мы обнаружили, что примерно 25 виртуальных машин могут одновременно скачивать большой двоичный объект размером в 100 ГБ (каждая виртуальная машина распараллеливала скачивание на 32 потока).</span><span class="sxs-lookup"><span data-stu-id="54c62-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing the download using 32 threads).</span></span> <span data-ttu-id="54c62-430">Если у вас 100 клиентов, которым требуется доступ к объекту, сначала скопируйте его во вторую учетную запись хранения, а затем пусть первые 50 виртуальных машин обращаются к первому большому двоичному объекту, а вторые 50 — ко второму.</span><span class="sxs-lookup"><span data-stu-id="54c62-430">If you had 100 clients needing to access the object, first copy it to a second storage account and then have the first 50 VMs access the first blob and the second 50 VMs access the second blob.</span></span> <span data-ttu-id="54c62-431">Результаты будут зависеть от поведения приложений, поэтому это следует проверить во время разработки.</span><span class="sxs-lookup"><span data-stu-id="54c62-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="54c62-432"><a name="subheading16"></a>Пропускная способность и операции с BLOB-объектом</span><span class="sxs-lookup"><span data-stu-id="54c62-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="54c62-433">Данные одного BLOB-объекта можно считывать или записывать с максимальной скоростью до 60 МБ/с (это примерно 480 Мбит/с, что превышает возможности большинства клиентских сетей, в том числе физической сетевой карты на клиентском устройстве).</span><span class="sxs-lookup"><span data-stu-id="54c62-433">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</span></span> <span data-ttu-id="54c62-434">Кроме того, один BLOB-объект поддерживает до 500 запросов в секунду.</span><span class="sxs-lookup"><span data-stu-id="54c62-434">In addition, a single blob supports up to 500 requests per second.</span></span> <span data-ttu-id="54c62-435">При наличии нескольких клиентов, которым необходимо выполнить чтение одного BLOB-объекта, и высокой вероятности превысить эти ограничения следует рассмотреть возможность использования сети CDN для распределения BLOB-объекта.</span><span class="sxs-lookup"><span data-stu-id="54c62-435">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</span></span>  

<span data-ttu-id="54c62-436">Дополнительные сведения о целевой пропускной способности для больших двоичных объектов см. в статье [Целевые показатели масштабируемости и производительности службы хранилища Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="54c62-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="54c62-437">Копирование и перемещение BLOB-объектов</span><span class="sxs-lookup"><span data-stu-id="54c62-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="54c62-438"><a name="subheading17"></a>Копирование BLOB-объекта</span><span class="sxs-lookup"><span data-stu-id="54c62-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="54c62-439">В REST API для служб хранилища версии 02-12-2012 представлена полезная возможность копирования больших двоичных объектов между учетными записями: клиентское приложение может отдать команду службе хранилища скопировать большой двоичный объект из другого источника (возможно, в другой учетной записи хранения), а затем предоставить службе возможность выполнить асинхронное копирование.</span><span class="sxs-lookup"><span data-stu-id="54c62-439">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</span></span> <span data-ttu-id="54c62-440">Это может значительно снизить пропускную способность, необходимую приложению при миграции данных из других учетных записей хранения, потому что при этом не нужно загружать и отправлять данные.</span><span class="sxs-lookup"><span data-stu-id="54c62-440">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</span></span>  

<span data-ttu-id="54c62-441">Однако существует один важный момент: при копировании между учетными записями хранения отсутствует гарантия по сроку завершения процесса копирования.</span><span class="sxs-lookup"><span data-stu-id="54c62-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</span></span> <span data-ttu-id="54c62-442">Если приложение должно быстро и под контролем завершить копирование BLOB-объекта, лучшим вариантом для этого может быть его копирование путем загрузки BLOB-объекта на виртуальную машину с последующей его отправкой в место назначения.</span><span class="sxs-lookup"><span data-stu-id="54c62-442">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</span></span>  <span data-ttu-id="54c62-443">Для обеспечения полной предсказуемости в этой ситуации убедитесь в том, что копирование выполнено с помощью виртуальной машины, работающей в том же регионе Azure. В противном случае условия работы сети могут (и, вероятно, будут) влиять на скорость копирования.</span><span class="sxs-lookup"><span data-stu-id="54c62-443">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="54c62-444">Кроме того, можно следить за ходом асинхронного копирования программным способом.</span><span class="sxs-lookup"><span data-stu-id="54c62-444">In addition, you can monitor the progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="54c62-445">Обратите внимание на то, что копирование внутри одной учетной записи хранения, как правило, выполняется быстро.</span><span class="sxs-lookup"><span data-stu-id="54c62-445">Note that copies within the same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="54c62-446">Дополнительную информацию см. в статье [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx) (Копирование большого двоичного объекта).</span><span class="sxs-lookup"><span data-stu-id="54c62-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="54c62-447"><a name="subheading18"></a>Использование программы AzCopy</span><span class="sxs-lookup"><span data-stu-id="54c62-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="54c62-448">Разработчики службы хранилища Azure выпустили программу командной строки AzCopy, которая предназначена помочь с одновременной передачей большого количества больших двоичных объектов между учетными записями хранения.</span><span class="sxs-lookup"><span data-stu-id="54c62-448">The Azure Storage team has released a command-line tool "AzCopy" that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="54c62-449">Этот инструмент оптимизирован специально для такого случая и может достигать высоких скоростей передачи данных.</span><span class="sxs-lookup"><span data-stu-id="54c62-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="54c62-450">Его использование рекомендуется для случаев массовой отправки, загрузки и копирования данных.</span><span class="sxs-lookup"><span data-stu-id="54c62-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="54c62-451">Чтобы больше узнать об этом инструменте и скачать его, см. статью [Приступая к работе со служебной программой командной строки AzCopy](storage-use-azcopy.md).</span><span class="sxs-lookup"><span data-stu-id="54c62-451">To learn more about it and download it, see [Transfer data with the AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="54c62-452"><a name="subheading19"></a>Служба импорта и экспорта Azure</span><span class="sxs-lookup"><span data-stu-id="54c62-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="54c62-453">Для очень больших объемов данных (более 1 ТБ) хранилище Azure предлагает службу импорта и экспорта, которая позволяет размещать или загружать данные хранилищ BLOB-объектов путем доставки жестких дисков.</span><span class="sxs-lookup"><span data-stu-id="54c62-453">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="54c62-454">Можно поместить свои данные на жесткий диск и отправить его в корпорацию Microsoft для размещения в сети или отправить пустой жесткий диск в корпорацию Microsoft для загрузки данных из сети.</span><span class="sxs-lookup"><span data-stu-id="54c62-454">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</span></span>  <span data-ttu-id="54c62-455">Дополнительную информацию см. в статье [Использование службы импорта и экспорта Azure для передачи данных в хранилище BLOB-объектов](storage-import-export-service.md).</span><span class="sxs-lookup"><span data-stu-id="54c62-455">For more information, see [Use the Microsoft Azure Import/Export Service to Transfer Data to Blob Storage](storage-import-export-service.md).</span></span>  <span data-ttu-id="54c62-456">Это может быть гораздо более эффективным, чем отправка или загрузка такого объема данных по сети.</span><span class="sxs-lookup"><span data-stu-id="54c62-456">This can be much more efficient than uploading/downloading this volume of data over the network.</span></span>  

### <span data-ttu-id="54c62-457"><a name="subheading20"></a>Использование метаданных</span><span class="sxs-lookup"><span data-stu-id="54c62-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="54c62-458">Служба BLOB-объектов поддерживает запросы HEAD, которые могут включать метаданные о BLOB-объекте.</span><span class="sxs-lookup"><span data-stu-id="54c62-458">The blob service supports head requests, which can include metadata about the blob.</span></span> <span data-ttu-id="54c62-459">Например, если приложению необходимы EXIF-данные из фотографии, оно может получить фотографию и извлечь их из нее.</span><span class="sxs-lookup"><span data-stu-id="54c62-459">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</span></span> <span data-ttu-id="54c62-460">Для сохранения пропускной способности и повышения производительности приложение может сохранить данные EXIF в метаданных большого двоичного объекта при загрузке фотографии приложением: можно получить данные EXIF, находящиеся в метаданных, используя только запрос HEAD, тем самым экономя значительную пропускную способность и время обработки, необходимые для извлечения данных EXIF каждый раз при чтении большого двоичного объекта.</span><span class="sxs-lookup"><span data-stu-id="54c62-460">To save bandwidth and improve performance, your application could store the EXIF data in the blob's metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</span></span> <span data-ttu-id="54c62-461">Это было бы полезным в ситуациях, когда необходимы только метаданные, а не полное содержимое BLOB-объекта.</span><span class="sxs-lookup"><span data-stu-id="54c62-461">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</span></span>  <span data-ttu-id="54c62-462">Обратите внимание, что в большом двоичном объекте могут храниться только 8 КБ метаданных (служба не будет принимать запрос на хранение большего, чем этот, объема данных), поэтому если данные превышают этот размер, использование такого подхода становится невозможным.</span><span class="sxs-lookup"><span data-stu-id="54c62-462">Note that only 8 KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</span></span>  

<span data-ttu-id="54c62-463">Пример того, как получить метаданные большого двоичного объекта с помощью .NET, см. в статье [Задание и получение свойств и метаданных](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="54c62-463">For an example of how to get a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="54c62-464">Быстрая отправка</span><span class="sxs-lookup"><span data-stu-id="54c62-464">Uploading Fast</span></span>
<span data-ttu-id="54c62-465">Чтобы быстро отправить большие двоичные объекты, необходимо ответить на первый вопрос: вы отправляете один большой двоичный объект или много?</span><span class="sxs-lookup"><span data-stu-id="54c62-465">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="54c62-466">Чтобы правильно выбрать метод работы, используйте сведения из приведенного ниже руководства.</span><span class="sxs-lookup"><span data-stu-id="54c62-466">Use the below guidance to determine the correct method to use depending on your scenario.</span></span>  

#### <span data-ttu-id="54c62-467"><a name="subheading21"></a>Быстрая отправка одного BLOB-объекта</span><span class="sxs-lookup"><span data-stu-id="54c62-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="54c62-468">Чтобы быстро отправить один большой BLOB-объект, клиентское приложение должно отправить его блоки или страницы параллельно (помня о целевых показателях масштабируемости для отдельных BLOB-объектов и учетной записи хранения в целом).</span><span class="sxs-lookup"><span data-stu-id="54c62-468">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</span></span>  <span data-ttu-id="54c62-469">Обратите внимание на то, что этой способностью обладают клиентские библиотеки хранилища RTM, официально предоставляемые корпорацией Microsoft (.NET, Java).</span><span class="sxs-lookup"><span data-stu-id="54c62-469">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</span></span>  <span data-ttu-id="54c62-470">Для установки уровня параллелизма для каждой библиотеки используйте указанный ниже объект или свойство:</span><span class="sxs-lookup"><span data-stu-id="54c62-470">For each of the libraries, use the below specified object/property to set the level of concurrency:</span></span>  

* <span data-ttu-id="54c62-471">.NET: установите ParallelOperationThreadCount в объекте BlobRequestOptions, который будет использоваться.</span><span class="sxs-lookup"><span data-stu-id="54c62-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</span></span>
* <span data-ttu-id="54c62-472">Java/Android: используйте функцию BlobRequestOptions.setConcurrentRequestCount()</span><span class="sxs-lookup"><span data-stu-id="54c62-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="54c62-473">Node.js: используйте parallelOperationThreadCount в параметрах запроса или в службе BLOB-объектов.</span><span class="sxs-lookup"><span data-stu-id="54c62-473">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</span></span>
* <span data-ttu-id="54c62-474">C++: используйте метод blob_request_options::set_parallelism_factor.</span><span class="sxs-lookup"><span data-stu-id="54c62-474">C++: Use the blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="54c62-475"><a name="subheading22"></a>Быстрая отправка множества BLOB-объектов</span><span class="sxs-lookup"><span data-stu-id="54c62-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="54c62-476">Чтобы быстро отправить множество BLOB-объектов, отправьте их параллельно.</span><span class="sxs-lookup"><span data-stu-id="54c62-476">To upload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="54c62-477">Это быстрее по времени, чем отправка отдельных BLOB-объектов с параллельной отправкой блоков, потому что в данном случае отправка распределяется по нескольким разделам службы хранилища.</span><span class="sxs-lookup"><span data-stu-id="54c62-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</span></span> <span data-ttu-id="54c62-478">Один BLOB-объект поддерживает пропускную способность не более 60 МБ/с (около 480 Мбит/с).</span><span class="sxs-lookup"><span data-stu-id="54c62-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="54c62-479">На момент написания статьи базирующаяся в США учетная запись LRS поддерживает входящую скорость до 20 Гбит/с, что гораздо больше, чем пропускная способность, поддерживаемая отдельными BLOB-объектами.</span><span class="sxs-lookup"><span data-stu-id="54c62-479">At the time of writing, a US-based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</span></span>  <span data-ttu-id="54c62-480">[AzCopy](#subheading18) выполняет параллельную отправку по умолчанию, как и рекомендуется для данного случая.</span><span class="sxs-lookup"><span data-stu-id="54c62-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="54c62-481"><a name="subheading23"></a>Выбор правильного типа BLOB-объекта</span><span class="sxs-lookup"><span data-stu-id="54c62-481"><a name="subheading23"></a>Choosing the correct type of blob</span></span>
<span data-ttu-id="54c62-482">Служба хранилища Azure поддерживает два типа больших двоичных объектов: *страничные* BLOB-объекты и *блочные* BLOB-объекты.</span><span class="sxs-lookup"><span data-stu-id="54c62-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="54c62-483">В данном случае использования выбор типа BLOB-объекта будет влиять на производительность и масштабируемость решения.</span><span class="sxs-lookup"><span data-stu-id="54c62-483">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</span></span> <span data-ttu-id="54c62-484">Блочные большие двоичные объекты подходят тогда, когда необходимо эффективно отправить большие объемы данных: например, клиентскому приложению может понадобиться отправить в хранилище больших двоичных объектов фотографии или видео.</span><span class="sxs-lookup"><span data-stu-id="54c62-484">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</span></span> <span data-ttu-id="54c62-485">Станичные большие двоичные объекты подходят в том случае, если в данных необходимо выполнять случайные операции записи: например, виртуальные жесткие диски Azure хранятся в виде страничных больших двоичных объектов.</span><span class="sxs-lookup"><span data-stu-id="54c62-485">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="54c62-486">Дополнительные сведения см. в статье [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx) (Основные сведения о блочных, добавочных и страничных BLOB-объектах).</span><span class="sxs-lookup"><span data-stu-id="54c62-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="54c62-487">Таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-487">Tables</span></span>
<span data-ttu-id="54c62-488">В дополнение к проверенным практическим подходам, ранее описанным в разделе [Все службы](#allservices) , следующие проверенные подходы применяются специально для службы таблиц.</span><span class="sxs-lookup"><span data-stu-id="54c62-488">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the table service.</span></span>  

### <span data-ttu-id="54c62-489"><a name="subheading24"></a>Целевые показатели масштабирования для таблицы</span><span class="sxs-lookup"><span data-stu-id="54c62-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="54c62-490">В дополнение к ограничениям пропускной способности всей учетной записи хранения таблицы имеют следующее ограничение масштабируемости.</span><span class="sxs-lookup"><span data-stu-id="54c62-490">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</span></span>  <span data-ttu-id="54c62-491">Обратите внимание: система будет распределять нагрузку по мере увеличения трафика, но если трафик имеет внезапные вспышки, вы будете не в состоянии получить немедленно весь объем пропускной способности.</span><span class="sxs-lookup"><span data-stu-id="54c62-491">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</span></span>  <span data-ttu-id="54c62-492">Если метод работает скачками, следует ожидать применения технологии регулировки запросов и (или) тайм-ауты во время скачков по мере того, как служба хранилища автоматически распределяет нагрузку по таблице.</span><span class="sxs-lookup"><span data-stu-id="54c62-492">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</span></span>  <span data-ttu-id="54c62-493">Медленное повышение, как правило, дает лучшие результаты, поскольку предоставляет системное время для распределения нагрузки.</span><span class="sxs-lookup"><span data-stu-id="54c62-493">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="54c62-494">Сущностей в секунду (учетная запись)</span><span class="sxs-lookup"><span data-stu-id="54c62-494">Entities per Second (Account)</span></span>
<span data-ttu-id="54c62-495">Ограничение масштабируемости для доступа к таблицам составляет до 20 000 сущностей (каждая по 1 КВ) в секунду для одной учетной записи.</span><span class="sxs-lookup"><span data-stu-id="54c62-495">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="54c62-496">Обычно каждая сущность, которая вставляется, обновляется, удаляется или сканируется, идет в счет этой цели.</span><span class="sxs-lookup"><span data-stu-id="54c62-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="54c62-497">Так, пакетная вставка, которая содержит 100 сущностей, будет считаться за 100 сущностей.</span><span class="sxs-lookup"><span data-stu-id="54c62-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="54c62-498">Запрос, который сканирует 1000 сущностей и возвращает 5 из них, будет считаться за 1000 сущностей.</span><span class="sxs-lookup"><span data-stu-id="54c62-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="54c62-499">Сущностей в секунду (раздел)</span><span class="sxs-lookup"><span data-stu-id="54c62-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="54c62-500">В одном разделе целевой показатель масштабируемости для доступа к таблицам составляет 2 000 сущностей (каждая по 1 КБ) в секунду. Тут используется тот же принцип подсчета, что и описанный в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="54c62-500">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="54c62-501">Конфигурация</span><span class="sxs-lookup"><span data-stu-id="54c62-501">Configuration</span></span>
<span data-ttu-id="54c62-502">В данном разделе перечислены несколько параметров быстрой конфигурации, которые можно использовать для значительного увеличения производительности в службе таблиц:</span><span class="sxs-lookup"><span data-stu-id="54c62-502">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</span></span>  

#### <span data-ttu-id="54c62-503"><a name="subheading25"></a>Использование JSON</span><span class="sxs-lookup"><span data-stu-id="54c62-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="54c62-504">Начиная со службы хранилища версии 2013-08-15, для передачи данных таблицы служба таблиц вместо формата AtomPub на базе XML поддерживает формат JSON.</span><span class="sxs-lookup"><span data-stu-id="54c62-504">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="54c62-505">Это может уменьшить размеры полезной нагрузки не меньше, чем на 75 %, и может значительно увеличить производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="54c62-505">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</span></span>

<span data-ttu-id="54c62-506">Дополнительные сведения см. в статьях [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) (Таблицы Microsoft Azure: введение в JSON) и [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx) (Формат полезных данных для операций службы таблиц).</span><span class="sxs-lookup"><span data-stu-id="54c62-506">For more information, see the post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="54c62-507"><a name="subheading26"></a>Отключение алгоритма Nagle</span><span class="sxs-lookup"><span data-stu-id="54c62-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="54c62-508">Алгоритм Нейгла широко применяется во всех TCP/IP-сетях в качестве средства повышения производительности сети.</span><span class="sxs-lookup"><span data-stu-id="54c62-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</span></span> <span data-ttu-id="54c62-509">Тем не менее он не является оптимальным во всех случаях (включая высокоинтерактивные среды).</span><span class="sxs-lookup"><span data-stu-id="54c62-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="54c62-510">В службе хранилища Azure алгоритм Нейгла оказывает негативное влияние на производительность запросов к таблице и службам очереди, и при возможности его следует отключать.</span><span class="sxs-lookup"><span data-stu-id="54c62-510">For Azure Storage, Nagle's algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="54c62-511">Дополнительные сведения см. в нашей записи блога [Nagle’s Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx) (Алгоритм Нейгла не ориентирован на мелкие запросы), в которой объясняется, почему алгоритм Нейгла плохо взаимодействует с запросами к таблицам и очередям и как его отключить в клиентском приложении.</span><span class="sxs-lookup"><span data-stu-id="54c62-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="54c62-512">SCHEMA (Схема)</span><span class="sxs-lookup"><span data-stu-id="54c62-512">Schema</span></span>
<span data-ttu-id="54c62-513">То, каким образом вы представляете и запрашиваете данные, является одним из основных факторов, влияющих на производительность службы таблиц.</span><span class="sxs-lookup"><span data-stu-id="54c62-513">How you represent and query your data is the biggest single factor that affects the performance of the table service.</span></span> <span data-ttu-id="54c62-514">Поскольку приложения отличаются друг от друга, в данном разделе излагаются некоторые общие проверенные подходы, которые относятся к:</span><span class="sxs-lookup"><span data-stu-id="54c62-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="54c62-515">конструктору таблиц;</span><span class="sxs-lookup"><span data-stu-id="54c62-515">Table design</span></span>
* <span data-ttu-id="54c62-516">эффективным запросам;</span><span class="sxs-lookup"><span data-stu-id="54c62-516">Efficient queries</span></span>
* <span data-ttu-id="54c62-517">эффективным обновлениям данных.</span><span class="sxs-lookup"><span data-stu-id="54c62-517">Efficient data updates</span></span>  

#### <span data-ttu-id="54c62-518"><a name="subheading27"></a>Таблицы и секции</span><span class="sxs-lookup"><span data-stu-id="54c62-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="54c62-519">Таблицы разделены на разделы.</span><span class="sxs-lookup"><span data-stu-id="54c62-519">Tables are divided into partitions.</span></span> <span data-ttu-id="54c62-520">Каждая сущность, хранящаяся в разделе, совместно использует один ключ раздела и имеет уникальный ключ строки для своей идентификации внутри этого раздела.</span><span class="sxs-lookup"><span data-stu-id="54c62-520">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</span></span> <span data-ttu-id="54c62-521">Разделы предоставляют преимущества, но также вводят ограничения по масштабируемости.</span><span class="sxs-lookup"><span data-stu-id="54c62-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="54c62-522">Преимущества: можно обновить сущности в одной секции в рамках одной неделимой пакетной транзакции, содержащей до 100 отдельных операций хранения (общий размер ограничен 4 МБ).</span><span class="sxs-lookup"><span data-stu-id="54c62-522">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="54c62-523">Предполагая некоторое количество сущностей, которые будут получены, также можно более эффективно запросить данные, хранящиеся внутри одного раздела, чем данные, охватывающие несколько разделов (в то время как чтение по дальнейшим рекомендациям необходимо проводить по запрашиваемым табличным данным).</span><span class="sxs-lookup"><span data-stu-id="54c62-523">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="54c62-524">Ограничения масштабируемости: невозможно сбалансировать нагрузку доступа к сущностям, хранящимся в одной секции, поскольку секции поддерживают неделимые пакетные транзакции.</span><span class="sxs-lookup"><span data-stu-id="54c62-524">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="54c62-525">По этой причине целевой показатель масштабируемости для отдельного раздела таблицы ниже, чем для службы таблиц в целом.</span><span class="sxs-lookup"><span data-stu-id="54c62-525">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</span></span>  

<span data-ttu-id="54c62-526">Учитывая эти характеристики таблиц и разделов, следует принять следующие принципы проектирования:</span><span class="sxs-lookup"><span data-stu-id="54c62-526">Because of these characteristics of tables and partitions, you should adopt the following design principles:</span></span>  

* <span data-ttu-id="54c62-527">Данные, которые клиентское приложение часто обновляет или запрашивает в одном логическом блоке работы, должны быть расположены в одном разделе.</span><span class="sxs-lookup"><span data-stu-id="54c62-527">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</span></span>  <span data-ttu-id="54c62-528">Эта необходимость может возникнуть потому, что приложение создает сводку записей, или потому, что вы хотите воспользоваться атомарной пакетной операцией.</span><span class="sxs-lookup"><span data-stu-id="54c62-528">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</span></span>  <span data-ttu-id="54c62-529">Кроме того, данные, находящиеся в одном разделе, могут быть с большим успехом запрошены в одном обращении, чем данные, которые находятся в разных разделах.</span><span class="sxs-lookup"><span data-stu-id="54c62-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="54c62-530">Данные, которые клиентское приложение не вставляет, не обновляет и не запрашивает в одном логическом блоке работы (одном запросе или пакетном обновлении), должны быть расположены в отдельных разделах.</span><span class="sxs-lookup"><span data-stu-id="54c62-530">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="54c62-531">Важно отметить, что ограничения на количество ключей раздела в одной таблице не существует, так что наличие миллионов ключей раздела не является проблемой и не влияет на производительность.</span><span class="sxs-lookup"><span data-stu-id="54c62-531">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="54c62-532">Например, если приложение является популярным веб-сайтом с механизмом входа пользователя в систему, в качестве ключа раздела может хорошо подойти идентификатор пользователя.</span><span class="sxs-lookup"><span data-stu-id="54c62-532">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="54c62-533">Горячие разделы</span><span class="sxs-lookup"><span data-stu-id="54c62-533">Hot Partitions</span></span>
<span data-ttu-id="54c62-534">Горячий раздел — это раздел, который получает несоразмерный процент трафика на одну учетную запись и не может распределять нагрузку между разделами, так как является единственным разделом.</span><span class="sxs-lookup"><span data-stu-id="54c62-534">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="54c62-535">Обычно горячие разделы создаются одним из двух способов:</span><span class="sxs-lookup"><span data-stu-id="54c62-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="54c62-536"><a name="subheading28"></a>Инкрементируемые и декрементируемые шаблоны</span><span class="sxs-lookup"><span data-stu-id="54c62-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="54c62-537">"Инкрементируемый" шаблон — это шаблон, в котором весь (или почти весь) трафик для данного ключа секции увеличивается и уменьшается в зависимости от текущего времени.</span><span class="sxs-lookup"><span data-stu-id="54c62-537">The "Append Only" pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</span></span>  <span data-ttu-id="54c62-538">Примером может служить ситуация, при которой приложение использует текущую дату в качестве ключа раздела для данных журнала.</span><span class="sxs-lookup"><span data-stu-id="54c62-538">An example is if your application used the current date as a partition key for log data.</span></span>  <span data-ttu-id="54c62-539">Это приводит к тому, что все вставки попадают в самый последний раздел таблицы, и система не может распределять нагрузку, потому что все записи попадают в конец таблицы.</span><span class="sxs-lookup"><span data-stu-id="54c62-539">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</span></span>  <span data-ttu-id="54c62-540">Если объем трафика в этом разделе превышает целевой показатель масштабируемости на уровне раздела, это приведет к включению механизма регулировки количества запросов.</span><span class="sxs-lookup"><span data-stu-id="54c62-540">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="54c62-541">Обеспечение отправки трафика к нескольким секциям — более удачный вариант, чем включение механизма распределения нагрузки при запросах по всей таблице.</span><span class="sxs-lookup"><span data-stu-id="54c62-541">It's better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</span></span>  

##### <span data-ttu-id="54c62-542"><a name="subheading29"></a>Данные с интенсивным трафиком</span><span class="sxs-lookup"><span data-stu-id="54c62-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="54c62-543">Если схема создания разделов приводит к созданию одного раздела, в котором имеются только данные, которые используются значительно чаще, чем данные в других разделах, по мере достижения этим разделом целевого показателя масштабируемости для одного раздела можно также обнаружить, что включен механизм регулировки количества запросов.</span><span class="sxs-lookup"><span data-stu-id="54c62-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</span></span>  <span data-ttu-id="54c62-544">Лучше всего сделать так, чтобы в схеме секционирования не было отдельных секций, приближающихся к целевым показателям масштабируемости.</span><span class="sxs-lookup"><span data-stu-id="54c62-544">It's better to make sure that your partition scheme results in no single partition approaching the scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="54c62-545">Выполнение запроса</span><span class="sxs-lookup"><span data-stu-id="54c62-545">Querying</span></span>
<span data-ttu-id="54c62-546">В этом разделе описываются проверенные подходы, касающиеся выполнения запросов службы таблицы.</span><span class="sxs-lookup"><span data-stu-id="54c62-546">This section describes proven practices for querying the table service.</span></span>  

##### <span data-ttu-id="54c62-547"><a name="subheading30"></a>Область запроса</span><span class="sxs-lookup"><span data-stu-id="54c62-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="54c62-548">Существует несколько способов для определения диапазона сущностей для запросов.</span><span class="sxs-lookup"><span data-stu-id="54c62-548">There are several ways to specify the range of entities to query.</span></span>  <span data-ttu-id="54c62-549">Ниже обсуждается использование каждого из них.</span><span class="sxs-lookup"><span data-stu-id="54c62-549">The following is a discussion of the uses of each.</span></span>  

<span data-ttu-id="54c62-550">В целом, старайтесь избегать сканирования (запросы, превышающие одну сущность), но если это необходимо, попытайтесь организовать данные таким образом, чтобы сканирование извлекало необходимые данные без сканирования или возвращения значительного количества ненужных сущностей.</span><span class="sxs-lookup"><span data-stu-id="54c62-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="54c62-551">Точечные запросы</span><span class="sxs-lookup"><span data-stu-id="54c62-551">Point Queries</span></span>
<span data-ttu-id="54c62-552">Точечный запрос извлекает ровно одну сущность.</span><span class="sxs-lookup"><span data-stu-id="54c62-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="54c62-553">Он делает это, указав как ключ раздела, так и ключ строки сущности.</span><span class="sxs-lookup"><span data-stu-id="54c62-553">It does this by specifying both the partition key and row key of the entity to retrieve.</span></span> <span data-ttu-id="54c62-554">Эти запросы являются очень эффективными, и их следует использовать везде, где это возможно.</span><span class="sxs-lookup"><span data-stu-id="54c62-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="54c62-555">Запросы разделов</span><span class="sxs-lookup"><span data-stu-id="54c62-555">Partition Queries</span></span>
<span data-ttu-id="54c62-556">Запрос раздела — это запрос, который извлекает набор данных, совместно использующих общий ключ раздела.</span><span class="sxs-lookup"><span data-stu-id="54c62-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="54c62-557">Как правило, в запросе указывается диапазон значений ключа строки или — в дополнение к ключу раздела — диапазон значений для свойства некоторой сущности.</span><span class="sxs-lookup"><span data-stu-id="54c62-557">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</span></span> <span data-ttu-id="54c62-558">Они менее эффективны, чем точечные запросы, и их следует использовать с осторожностью.</span><span class="sxs-lookup"><span data-stu-id="54c62-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="54c62-559">Табличные запросы</span><span class="sxs-lookup"><span data-stu-id="54c62-559">Table Queries</span></span>
<span data-ttu-id="54c62-560">Табличный запрос — это запрос, который извлекает набор сущностей, не использующих совместно общий ключ раздела.</span><span class="sxs-lookup"><span data-stu-id="54c62-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="54c62-561">Эти запросы не являются эффективными, и, если это возможно, следует избегать их использования.</span><span class="sxs-lookup"><span data-stu-id="54c62-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="54c62-562"><a name="subheading31"></a>Плотность запроса</span><span class="sxs-lookup"><span data-stu-id="54c62-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="54c62-563">Еще одним важным фактором в эффективности запроса является соотношение между количеством возвращенных сущностей и количеством сканированных сущностей, использованных при поиске возвращаемого набора.</span><span class="sxs-lookup"><span data-stu-id="54c62-563">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</span></span> <span data-ttu-id="54c62-564">Если приложение выполняет табличный запрос с фильтром для значения свойства, которое соответствует только 1 % совместно используемых данных, запрос будет сканировать по 100 сущностей для каждой одной сущности, которую он возвращает.</span><span class="sxs-lookup"><span data-stu-id="54c62-564">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="54c62-565">Все рассмотренные ранее целевые показатели масштабируемости таблицы относятся к количеству сканированных сущностей, а не к количеству возвращенных сущностей: низкая плотность запроса может легко привести службу таблиц к регулированию количества запросов приложения, потому что для извлечения искомой сущности она должна сканировать слишком много других сущностей.</span><span class="sxs-lookup"><span data-stu-id="54c62-565">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</span></span>  <span data-ttu-id="54c62-566">Для получения дополнительной информации о том, как этого избежать, см. раздел [Денормализация](#subheading34) ниже.</span><span class="sxs-lookup"><span data-stu-id="54c62-566">See the section below on [denormalization](#subheading34) for more information on how to avoid this.</span></span>  

##### <a name="limiting-the-amount-of-data-returned"></a><span data-ttu-id="54c62-567">Ограничение объема возвращаемых данных</span><span class="sxs-lookup"><span data-stu-id="54c62-567">Limiting the Amount of Data Returned</span></span>
###### <span data-ttu-id="54c62-568"><a name="subheading32"></a>Фильтрация</span><span class="sxs-lookup"><span data-stu-id="54c62-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="54c62-569">Если известно, что запрос вернет ненужные в клиентском приложении сущности, рассмотрите вопрос об использовании фильтра, позволяющего уменьшить размер возвращаемого набора.</span><span class="sxs-lookup"><span data-stu-id="54c62-569">Where you know that a query will return entities that you don't need in the client application, consider using a filter to reduce the size of the returned set.</span></span> <span data-ttu-id="54c62-570">Несмотря на то, что не возвращаемые клиенту сущности учитываются в подсчете ограничений масштабируемости, производительность приложения увеличится из-за снижения полезной нагрузки на сеть и сокращения количества сущностей, которые должно обрабатывать клиентское приложение.</span><span class="sxs-lookup"><span data-stu-id="54c62-570">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="54c62-571">См. информацию в разделе о [плотности запроса](#subheading31) выше. Однако целевые показатели масштабируемости относятся к количеству сканируемых сущностей, поэтому выполнение запроса, фильтрующего множество сущностей, может привести к запуску механизма регулирования количества запросов даже в том случае, если возвращается небольшое число сущностей.</span><span class="sxs-lookup"><span data-stu-id="54c62-571">See above note on [Query Density](#subheading31), however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="54c62-572"><a name="subheading33"></a>Проекция</span><span class="sxs-lookup"><span data-stu-id="54c62-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="54c62-573">Если клиентскому приложению необходим лишь ограниченный набор свойств из сущностей таблицы, для ограничения размера возвращаемого набора данных можно использовать проекцию.</span><span class="sxs-lookup"><span data-stu-id="54c62-573">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</span></span> <span data-ttu-id="54c62-574">Как и в случае с фильтрацией, это помогает снизить нагрузку на сеть и обработку запросов клиента.</span><span class="sxs-lookup"><span data-stu-id="54c62-574">As with filtering, this helps to reduce network load and client processing.</span></span>  

##### <span data-ttu-id="54c62-575"><a name="subheading34"></a>Денормализация</span><span class="sxs-lookup"><span data-stu-id="54c62-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="54c62-576">В отличие от работы с реляционными базами данных, проверенные подходы для осуществления эффективного запроса данных таблицы ведут к денормализации данных.</span><span class="sxs-lookup"><span data-stu-id="54c62-576">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</span></span> <span data-ttu-id="54c62-577">То есть дублирование одних данных в нескольких сущностях (для поиска данных можно использовать по одной сущности для каждого ключа) с целью минимизации количества сущностей, которые должен сканировать запрос для поиска необходимых клиенту данных, вместо того чтобы сканировать большое количество сущностей для поиска данных, необходимых приложению.</span><span class="sxs-lookup"><span data-stu-id="54c62-577">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</span></span>  <span data-ttu-id="54c62-578">Например, на веб-сайте электронной коммерции может понадобиться найти заказ как по идентификатору клиента (найти заказы данного клиента), так и по дате (найти заказы на определенную дату).</span><span class="sxs-lookup"><span data-stu-id="54c62-578">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer's orders) and by the date (give me orders on a date).</span></span>  <span data-ttu-id="54c62-579">В табличном хранилище лучше всего хранить сущность (или ссылку на нее) в двух видах: один с именем таблицы, ключом раздела и ключом строки для облегчения поиска по идентификатору клиента, один для облегчения его поиска по дате.</span><span class="sxs-lookup"><span data-stu-id="54c62-579">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="54c62-580">Вставить, обновить, удалить</span><span class="sxs-lookup"><span data-stu-id="54c62-580">Insert/Update/Delete</span></span>
<span data-ttu-id="54c62-581">В этом разделе описываются проверенные методики для изменения сущностей, хранящихся в службе таблиц.</span><span class="sxs-lookup"><span data-stu-id="54c62-581">This section describes proven practices for modifying entities stored in the table service.</span></span>  

##### <span data-ttu-id="54c62-582"><a name="subheading35"></a>Пакетная обработка</span><span class="sxs-lookup"><span data-stu-id="54c62-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="54c62-583">Пакетные транзакции в хранилище Azure называются транзакциями группы сущностей (Entity Group Transactions, ETG). Все операции, выполняющиеся в ETG, должны производиться в одном разделе и в одной таблице.</span><span class="sxs-lookup"><span data-stu-id="54c62-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="54c62-584">Там, где это возможно, для выполнения пакетных команд вставки, обновления и удаления используйте транзакции группы сущностей.</span><span class="sxs-lookup"><span data-stu-id="54c62-584">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="54c62-585">Это сокращает количество циклов обработки между клиентским приложением и сервером, снижает количество подсчитываемых транзакций (при подсчете транзакция группы сущностей считается одной транзакцией и может содержать до 100 операций хранения) и позволяет выполнять атомарные обновления (в транзакции группы сущностей операции завершаются или все успешно, или все с ошибкой).</span><span class="sxs-lookup"><span data-stu-id="54c62-585">This reduces the number of round trips from your client application to the server, reduces the number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="54c62-586">Среды с большими задержками, такие как мобильные устройства, в результате использования транзакций групп сущностей получают большие преимущества.</span><span class="sxs-lookup"><span data-stu-id="54c62-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="54c62-587"><a name="subheading36"></a>Операция Upsert</span><span class="sxs-lookup"><span data-stu-id="54c62-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="54c62-588">Используйте табличные операции **Upsert** как можно чаще.</span><span class="sxs-lookup"><span data-stu-id="54c62-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="54c62-589">Существует два типа операций **Upsert**. Оба они могут быть более эффективными, чем обычные операции **Insert** и **Update**:</span><span class="sxs-lookup"><span data-stu-id="54c62-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="54c62-590">**InsertOrMerge**: используйте, если требуется передать подмножество свойств сущности, но неизвестно, существует ли она.</span><span class="sxs-lookup"><span data-stu-id="54c62-590">**InsertOrMerge**: Use this when you want to upload a subset of the entity's properties, but aren't sure whether the entity already exists.</span></span> <span data-ttu-id="54c62-591">Если сущность существует, она вызывает обновление свойств, включенных в операцию **Upsert** , и оставляет все имеющиеся свойства нетронутыми, если же сущность не существует, вставляется новая сущность.</span><span class="sxs-lookup"><span data-stu-id="54c62-591">If the entity exists, this call updates the properties included in the **Upsert** operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</span></span> <span data-ttu-id="54c62-592">Это похоже на использование проекции в запросе, в котором нужно отправить только изменяющиеся свойства.</span><span class="sxs-lookup"><span data-stu-id="54c62-592">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</span></span>
* <span data-ttu-id="54c62-593">**InsertOrReplace**: используйте, если требуется передать совершенно новую сущность, но неизвестно, существует ли она.</span><span class="sxs-lookup"><span data-stu-id="54c62-593">**InsertOrReplace**: Use this when you want to upload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="54c62-594">Команду следует использовать только тогда, когда известно, что недавно отправленная сущность является абсолютно правильной, потому что она полностью заменяет старую сущность.</span><span class="sxs-lookup"><span data-stu-id="54c62-594">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</span></span> <span data-ttu-id="54c62-595">Например, необходимо обновить сущность, в которой хранится текущее местоположение пользователя, независимо от того, сохраняло ли ранее приложение данные о местоположении пользователя. В данном случае создается сущность с новым местоположением пользователя, а потребность в какой-либо информации из любой предыдущей сущности отсутствует.</span><span class="sxs-lookup"><span data-stu-id="54c62-595">For example, you want to update the entity that stores a user's current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="54c62-596"><a name="subheading37"></a>Хранение ряда данных в одной сущности</span><span class="sxs-lookup"><span data-stu-id="54c62-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="54c62-597">Иногда приложение хранит ряд данных, которые часто бывают необходимыми для их единовременного получения: например, приложение может отслеживать загрузку ЦП в течение долгого времени для того, чтобы построить волнообразный график из данных за последние 24 часа.</span><span class="sxs-lookup"><span data-stu-id="54c62-597">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</span></span> <span data-ttu-id="54c62-598">Один подход заключается в том, чтобы для каждого часа иметь одну табличную сущность, при этом каждая сущность представляет определенный час и хранит значение загрузки ЦП для этого часа.</span><span class="sxs-lookup"><span data-stu-id="54c62-598">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</span></span> <span data-ttu-id="54c62-599">Для построения этих данных приложению необходимо извлечь сущности, в которых хранятся данные за последние 24 часа.</span><span class="sxs-lookup"><span data-stu-id="54c62-599">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</span></span>  

<span data-ttu-id="54c62-600">Кроме того, приложение может хранить данные о загрузке ЦП для каждого часа в виде отдельного свойства одной сущности: для ежечасного обновления приложение может использовать один вызов **InsertOrMerge Upsert**, чтобы обновить значение за последний час.</span><span class="sxs-lookup"><span data-stu-id="54c62-600">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single **InsertOrMerge Upsert** call to update the value for the most recent hour.</span></span> <span data-ttu-id="54c62-601">Для построения этих данных приложению необходимо получить только одну сущность, а не 24, выполняя при этом очень эффективный запрос (см. представленное выше обсуждение в разделе [Область запроса](#subheading30)).</span><span class="sxs-lookup"><span data-stu-id="54c62-601">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="54c62-602"><a name="subheading38"></a>Хранение структурированных данных в BLOB-объектах</span><span class="sxs-lookup"><span data-stu-id="54c62-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="54c62-603">Иногда кажется, что структурированные данные должны попадать в таблицы, но диапазоны сущностей всегда извлекаются вместе и могут быть вставлены пакетным образом.</span><span class="sxs-lookup"><span data-stu-id="54c62-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="54c62-604">Хорошим примером такой ситуации является файл журнала.</span><span class="sxs-lookup"><span data-stu-id="54c62-604">A good example of this is a log file.</span></span>  <span data-ttu-id="54c62-605">В этом случае несколько минут из журнала можно укомплектовать в пакет, затем произвести их вставку и потом, с тем же успехом, извлекать несколько минут журнала за раз.</span><span class="sxs-lookup"><span data-stu-id="54c62-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="54c62-606">В этом случае с точки зрения производительности вместо таблиц лучше использовать большие двоичные объекты, так как при этом можно значительно уменьшить количество записываемых или возвращаемых объектов, а также, как правило, количество необходимых для выполнения запросов.</span><span class="sxs-lookup"><span data-stu-id="54c62-606">In this case, for performance, it's better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="54c62-607">Очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-607">Queues</span></span>
<span data-ttu-id="54c62-608">В дополнение к проверенным практическим подходам, ранее описанным в разделе [Все службы](#allservices), следующие проверенные подходы применяются специально для службы очередей.</span><span class="sxs-lookup"><span data-stu-id="54c62-608">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the queue service.</span></span>  

### <span data-ttu-id="54c62-609"><a name="subheading39"></a>Ограничения масштабируемости</span><span class="sxs-lookup"><span data-stu-id="54c62-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="54c62-610">Одна очередь может обрабатывать около 2000 сообщений (размером 1 КБ каждое) в секунду (здесь каждая операция AddMessage, GetMessage и DeleteMessage считается сообщением).</span><span class="sxs-lookup"><span data-stu-id="54c62-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="54c62-611">Если для вашего приложения этого недостаточно, следует распределить сообщения по нескольким очередям.</span><span class="sxs-lookup"><span data-stu-id="54c62-611">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</span></span>  

<span data-ttu-id="54c62-612">Текущие целевые показатели масштабируемости можно посмотреть на странице [Цели масштабируемости хранилища и производительности Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="54c62-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="54c62-613"><a name="subheading40"></a>Отключение алгоритма Nagle</span><span class="sxs-lookup"><span data-stu-id="54c62-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="54c62-614">См. раздел по конфигурации таблицы, в котором обсуждается алгоритм Nagle. Алгоритм Nagle, как правило, плохо влияет на производительность запросов в очереди, поэтому его следует отключать.</span><span class="sxs-lookup"><span data-stu-id="54c62-614">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="54c62-615"><a name="subheading41"></a>Размер сообщения</span><span class="sxs-lookup"><span data-stu-id="54c62-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="54c62-616">Производительность и масштабируемость очередей уменьшается по мере увеличения размера сообщения.</span><span class="sxs-lookup"><span data-stu-id="54c62-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="54c62-617">В сообщении следует размещать только ту информацию, которая необходима получателю.</span><span class="sxs-lookup"><span data-stu-id="54c62-617">You should place only the information the receiver needs in a message.</span></span>  

### <span data-ttu-id="54c62-618"><a name="subheading42"></a>Пакетное извлечение</span><span class="sxs-lookup"><span data-stu-id="54c62-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="54c62-619">В одной операции из очереди можно извлечь до 32 сообщений.</span><span class="sxs-lookup"><span data-stu-id="54c62-619">You can retrieve up to 32 messages from a queue in a single operation.</span></span> <span data-ttu-id="54c62-620">Это может уменьшить количество циклов обработки клиентского приложения, что особенно полезно в таких средах с большой задержкой, как мобильные устройства.</span><span class="sxs-lookup"><span data-stu-id="54c62-620">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="54c62-621"><a name="subheading43"></a>Интервал опроса очереди</span><span class="sxs-lookup"><span data-stu-id="54c62-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="54c62-622">Большинство приложений опрашивают сообщения из такой очереди, которая может быть одним из самых крупных источников транзакций для этих приложений.</span><span class="sxs-lookup"><span data-stu-id="54c62-622">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</span></span> <span data-ttu-id="54c62-623">Выбирайте интервал опроса тщательно: слишком высокая частота опросов может привести к тому, что будет достигнуто целевое значений масштабируемости очереди.</span><span class="sxs-lookup"><span data-stu-id="54c62-623">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</span></span> <span data-ttu-id="54c62-624">Но при тарифе 0,01 долларов США за 200 000 транзакций (во время записи) опрос одного процессора с интервалом один раз в секунду будет стоить меньше 15 центов в месяц, поэтому стоимость обычно не влияет на выбор интервала опроса.</span><span class="sxs-lookup"><span data-stu-id="54c62-624">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="54c62-625">Актуальные сведения о стоимости см. на странице [Цены на хранилища Azure](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="54c62-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="54c62-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="54c62-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="54c62-627">Для увеличения невидимого времени ожидания или для обновления информации о состоянии сообщения можно использовать операцию **UpdateMessage** .</span><span class="sxs-lookup"><span data-stu-id="54c62-627">You can use **UpdateMessage** to increase the invisibility timeout or to update state information of a message.</span></span> <span data-ttu-id="54c62-628">Несмотря на ее эффективность, помните, что каждая операция **UpdateMessage** учитывается при подсчете целевого показателя масштабируемости.</span><span class="sxs-lookup"><span data-stu-id="54c62-628">While this is powerful, remember that each **UpdateMessage** operation counts towards the scalability target.</span></span> <span data-ttu-id="54c62-629">Тем не менее ее использование может быть гораздо более эффективным, чем наличие рабочего процесса, который передает работу из одной очереди в другую по мере завершения каждого этапа работы.</span><span class="sxs-lookup"><span data-stu-id="54c62-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</span></span> <span data-ttu-id="54c62-630">Использование операции **UpdateMessage** позволяет приложению сохранить состояние работы в сообщении, а затем продолжить работу, вместо того чтобы повторно запрашивать сообщение для выполнения следующего этапа работы по мере завершения каждого предыдущего.</span><span class="sxs-lookup"><span data-stu-id="54c62-630">Using the **UpdateMessage** operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</span></span>  

<span data-ttu-id="54c62-631">Дополнительные сведения см. в разделе [Изменение содержимого сообщения в очереди](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span><span class="sxs-lookup"><span data-stu-id="54c62-631">For more information, see the article [How to: Change the contents of a queued message](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="54c62-632"><a name="subheading45"></a>Архитектура приложения</span><span class="sxs-lookup"><span data-stu-id="54c62-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="54c62-633">Чтобы сделать архитектуру приложения масштабируемой, следует использовать очереди.</span><span class="sxs-lookup"><span data-stu-id="54c62-633">You should use queues to make your application architecture scalable.</span></span> <span data-ttu-id="54c62-634">Ниже перечислены некоторые способы использования очередей для того, чтобы сделать приложение более масштабируемым:</span><span class="sxs-lookup"><span data-stu-id="54c62-634">The following lists some ways you can use queues to make your application more scalable:</span></span>  

* <span data-ttu-id="54c62-635">Очереди можно использовать для инициации отставания от работы, необходимого для обработки и сглаживания рабочих нагрузок в приложении.</span><span class="sxs-lookup"><span data-stu-id="54c62-635">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="54c62-636">Например, запросы от пользователей можно поместить в очередь, чтобы позволить процессору выполнить трудоемкую работу, такую как изменение размера загружаемых изображений.</span><span class="sxs-lookup"><span data-stu-id="54c62-636">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="54c62-637">Очереди можно использовать, чтобы отделить части приложения для их независимого масштабирования.</span><span class="sxs-lookup"><span data-stu-id="54c62-637">You can use queues to decouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="54c62-638">Например, клиент веб-интерфейса может разместить результаты опроса пользователей в очередь для последующего анализа и хранения.</span><span class="sxs-lookup"><span data-stu-id="54c62-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="54c62-639">По мере необходимости для обработки данных очереди можно добавлять экземпляры роли worker.</span><span class="sxs-lookup"><span data-stu-id="54c62-639">You could add more worker role instances to process the queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="54c62-640">Заключение</span><span class="sxs-lookup"><span data-stu-id="54c62-640">Conclusion</span></span>
<span data-ttu-id="54c62-641">В этой статье обсуждаются некоторые из наиболее распространенных, проверенных подходов для оптимизации производительности при использовании службы хранилища Azure.</span><span class="sxs-lookup"><span data-stu-id="54c62-641">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="54c62-642">Мы призываем разработчиков оценить применимость описанных выше методик к их приложениям и рассмотреть, исходя из рекомендаций, возможность повышения производительности подобных приложений, использующих службу хранилища Azure.</span><span class="sxs-lookup"><span data-stu-id="54c62-642">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</span></span>