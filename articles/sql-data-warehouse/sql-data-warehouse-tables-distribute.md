---
title: "Распределение таблиц в хранилище данных SQL | Документация Майкрософт"
description: "Начало работы с распределением таблиц в хранилище данных SQL Azure."
services: sql-data-warehouse
documentationcenter: NA
author: shivaniguptamsft
manager: barbkess
editor: 
ms.assetid: 5ed4337f-7262-4ef6-8fd6-1809ce9634fc
ms.service: sql-data-warehouse
ms.devlang: NA
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: data-services
ms.custom: tables
ms.date: 10/31/2016
ms.author: shigu;barbkess
ms.openlocfilehash: d0e12bf821a81826a20b8db84e76c48fa60ad9b5
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2017
---
# <a name="distributing-tables-in-sql-data-warehouse"></a>Распределение таблиц в хранилище данных SQL
> [!div class="op_single_selector"]
> * [Обзор][Overview]
> * [Типы данных][Data Types]
> * [Распределение][Distribute]
> * [Индекс][Index]
> * [Секция][Partition]
> * [Статистика][Statistics]
> * [Временные таблицы][Temporary]
>
>

Хранилище данных SQL является распределенной системой баз данных с массовой параллельной обработкой (MPP).  Распределяя данные и возможности обработки между несколькими узлами, хранилище данных SQL может предложить огромную масштабируемость — намного больше любой единой системы.  Выбор метода распределения данных в хранилище данных SQL — один из наиболее важных факторов достижения оптимальной производительности.   Для достижения оптимальной производительности требуется минимизировать перемещение данных. В свою очередь, для последнего необходимо выбрать подходящий метод распределения.

## <a name="understanding-data-movement"></a>Основные сведения о перемещении данных
В системе MPP данные из каждой таблицы разделяются между несколькими основными базами данных.  Наиболее эффективно запросы в системе MPP выполняются в отдельных распределенных базах данных, которые не взаимодействуют с другими базами данных.  Например, предположим, что у вас есть база данных с данными о продажах, содержащая две таблицы: "Продажи" и "Клиенты".  Если необходимо выполнить запрос на соединение таблиц "Продажи" и "Клиенты", одновременно разделив их по номеру клиента и поместив каждого в отдельную базу данных, этот запрос будет выполняться отдельно в каждой базе данных. При этом в них не будет сведений о других базах данных.  В то же время, если разделить данные о продажах по номеру заказа, а данные о клиентах по номеру клиента, то любая база данных не будет содержать соответствующие данные о клиенте. Следовательно, чтобы объединить данные о продажах и данные о клиентах, необходимо получить данные о каждом клиенте из других баз данных.  Во втором примере для объединения данных о продажах и данных о клиентах, а в результате и самих таблиц, в которых они находятся, требуется выполнить перемещение данных.  

Перемещение данных — не всегда отрицательный момент. Иногда этот процесс требуется для выполнения запроса.  Но избежав его, запрос будет выполняться быстрее.  Перемещение данных в основном происходит при объединении или группировании таблиц.  Очень часто требуется выполнить и то, и другое. Вы можете избежать перемещения данных для оптимизации одного сценария (например, соединения), но оно может понадобиться для выполнения другого действия (например, группирования).  Нужно понять, какой процесс требует меньше ресурсов и времени.  В большинстве случаев один из самых эффективных методов минимизации перемещения данных заключается в распределении больших таблиц фактов по столбцу соединения.  Чаще всего распределение данных по столбцам соединения является более эффективным методом минимизации перемещения данных, чем распределение их по столбцам, задействованным в группировании.

## <a name="select-distribution-method"></a>Выбор метода распределения
Хранилище данных SQL по умолчанию разделяет данные по 60 базам данных.  Каждая отдельная база данных называется **распределением**.  После загрузки данных в каждую таблицу в хранилище данных SQL необходимо определить метод разделения данных по этим 60 распределениям.  

Метод распределения определяется на уровне таблицы. В настоящее время таких методов два:

1. **Метод циклического перебора** — данные распределяются равномерно, но случайным образом.
2. **Хэш-распределение** — данные распределяются на основе хэширования значений одного столбца.

Если метод распределения данных не выбран, по умолчанию для таблицы используется метод **циклического перебора** .  Однако когда вы усовершенствуете навыки работы с хранилищем данных, вы сможете минимизировать перемещение данных для оптимизации производительности запросов, используя **хэш-распределение** таблиц.

### <a name="round-robin-tables"></a>Таблицы, распределенные по методу циклического перебора
Таблицы, распределенные по методу циклического перебора, соответствуют своему названию.  После загрузки данных каждая строка отправляется в следующее распределение.  При применении циклического перебора данные всегда равномерно распределяются между всеми распределениями случайным образом.  Это значит, что данные, распределенные по этому методу, не сортируются.  По этой причине циклическое распределение иногда называют случайным хэшем.  При использовании таблицы с распределением по методу циклического перебора не нужно анализировать используемые данные.  По этой причине такие таблицы часто удобно использовать для загрузки.

Если метод распределения данных не выбран, по умолчанию используется метод циклического перебора.  Таблицы с распределением по методу циклического перебора удобно использовать, так как данные распределяются по системе случайным образом. Однако система не может гарантировать, в каком распределении будет находиться каждая строка.  Таким образом, чтобы упорядочить данные перед разрешением запроса, системе иногда требуется вызывать операции перемещения данных.  Это дополнительное действие может повлиять на производительность запросов.

Рассмотрите возможность использования циклического распределения для таблицы в следующих сценариях:

* если это простая отправная точка для начала работы;
* если отсутствует очевидный ключ соединения;
* если отсутствует подходящий для хэш-распределения таблицы столбец;
* если таблица не использует общий ключ соединения с другими таблицами;
* Если соединение менее важно, чем других соединения в запросе.
* если таблица является временной.

Ниже приведены два примера, которые позволяют создать таблицу с распределением по методу циклического перебора.

```SQL
-- Round Robin created by default
CREATE TABLE [dbo].[FactInternetSales]
(   [ProductKey]            int          NOT NULL
,   [OrderDateKey]          int          NOT NULL
,   [CustomerKey]           int          NOT NULL
,   [PromotionKey]          int          NOT NULL
,   [SalesOrderNumber]      nvarchar(20) NOT NULL
,   [OrderQuantity]         smallint     NOT NULL
,   [UnitPrice]             money        NOT NULL
,   [SalesAmount]           money        NOT NULL
)
;

-- Explicitly Created Round Robin Table
CREATE TABLE [dbo].[FactInternetSales]
(   [ProductKey]            int          NOT NULL
,   [OrderDateKey]          int          NOT NULL
,   [CustomerKey]           int          NOT NULL
,   [PromotionKey]          int          NOT NULL
,   [SalesOrderNumber]      nvarchar(20) NOT NULL
,   [OrderQuantity]         smallint     NOT NULL
,   [UnitPrice]             money        NOT NULL
,   [SalesAmount]           money        NOT NULL
)
WITH
(   CLUSTERED COLUMNSTORE INDEX
,   DISTRIBUTION = ROUND_ROBIN
)
;
```

> [!NOTE]
> Хотя циклический перебор используется по умолчанию, предпочтительно, чтобы тип таблицы был явно указан в DDL. Таким образом, все будут видеть предназначение макета таблицы.
>
>

### <a name="hash-distributed-tables"></a>Распределяемые по хэшу таблицы
Использование **хэш-алгоритма** для распределения данных в таблицах позволяет повысить производительность во многих сценариях благодаря снижению перемещения данных во время выполнения запроса.  Распределяемые по хэшу таблицы разделяются между распределенными базами данных с помощью хэш-алгоритма по одному выбранному столбцу.  Столбец распределения определят метод разделения данных по распределенным базам данных.  Этот столбец используется в хэш-функции для назначения строк распределениям.  Алгоритм хэширования и итоговое распределение являются детерминированными.  Это значит, что одинаковое значение с тем же типом данных всегда определяется в одно распределение.    

Ниже приведен пример создания таблицы, распределенной по идентификаторам.

```SQL
CREATE TABLE [dbo].[FactInternetSales]
(   [ProductKey]            int          NOT NULL
,   [OrderDateKey]          int          NOT NULL
,   [CustomerKey]           int          NOT NULL
,   [PromotionKey]          int          NOT NULL
,   [SalesOrderNumber]      nvarchar(20) NOT NULL
,   [OrderQuantity]         smallint     NOT NULL
,   [UnitPrice]             money        NOT NULL
,   [SalesAmount]           money        NOT NULL
)
WITH
(   CLUSTERED COLUMNSTORE INDEX
,  DISTRIBUTION = HASH([ProductKey])
)
;
```

## <a name="select-distribution-column"></a>Выбор столбца распределения
При выборе **хэш-распределения** таблицы также необходимо выбрать один столбец распределения.  При этом необходимо учитывать три основных фактора.  

Столбец должен соответствовать следующим критериям.

1. Он должен быть необновляемым.
2. Он должен распределять данные равномерно, предотвращая их смещение.
3. Минимизация перемещения данных

### <a name="select-distribution-column-which-will-not-be-updated"></a>Выбор необновляемого столбца распределения
Столбцы распределения являются необновляемыми. Поэтому для этой роли необходимо выбрать столбец со статическими значениями.  Если столбец требует обновления, он не подходит для этой роли.  Чтобы обновить столбец распределения, сначала необходимо удалить строку, а затем добавить новую.

### <a name="select-distribution-column-which-will-distribute-data-evenly"></a>Выбор столбца распределения, который распределяет данные равномерно
Распределенная система выполняет запросы так же быстро, как и самое медленное распределение, поэтому важно разделить работу между распределениями равномерно. Так вы сможете обеспечить сбалансированное выполнение запросов в системе.  Метод разделения работы в распределенной системе зависит от расположения данных каждого распределения.  Поэтому для распределения данных очень важно выбрать подходящий столбец распределения. Так работа будет равномерно разделяться между распределениями и выполняться за одинаковый промежуток времени.  Когда работа эффективно разделена по всей системе, то данные равномерно размещены в распределениях.  Если данные распределены неравномерно, это называется **неравномерным распределением данных**.  

Чтобы равномерно разделить данные и избежать их смещения, при выборе столбца распределения учтите следующие моменты.

1. Выберите столбец, содержащий значительное количество различных значений.
2. Избегайте распределения данных по столбцам, содержащим несколько различных значений.
3. Избегайте распределения данных по столбцам с высоким коэффициентом содержания значений NULL.
4. Не распределяйте данные по столбцам с датами.

Так как каждое значение хэшируется в 1 из 60 распределений, для равномерного распределения необходимо выбрать исключительно уникальный столбец, содержащий больше 60 уникальных значений.  В качестве примера рассмотрим случай, когда столбец содержит только 40 уникальных значений.  Если этот столбец выбран в качестве ключа распределения, то данные этой таблицы будут распределяться только по 40 распределениям. 20 распределений останутся без данных, а значит, не будут выполнять обработку.  И наоборот, 40 распределений будут обрабатывать большее количество данных, чем если бы данные были равномерно распределены по 60 распределениям.  Этот сценарий является примером неравномерного распределения данных.

В системе MPP каждый этап запроса ожидает, пока все распределения не выполнят свою часть работы.  Если одно распределение выполняет больше работы, чем остальные, то ресурсы остальных распределений фактически простаивают впустую, ожидая, пока занятое распределение завершит обработку.  Если работа неравномерно разделена между всеми распределениями, это называется **неравномерным распределением обработки**.  При неравномерном распределении обработки запросы выполняются медленнее, чем при равномерном разделении рабочей нагрузки между распределениями.  Неравномерное распределение данных приведет к неравномерному распределению обработки.

Избегайте распределения по столбцам с высоким коэффициентом содержания значений NULL, так как значения NULL попадут в одно и то же распределение. Распределение по столбцу даты также может привести к неравномерному распределению обработки, так как все данные для конкретной даты попадут в одно распределение. Если несколько пользователей будут выполнять запросы с фильтром по одной и той же дате, то всю работу будет выполнять только 1 распределение из 60, так как для этой даты будет доступно только одно распределение. Скорее всего, в этом случае запросы будут выполняться в 60 раз медленнее, чем если бы данные были равномерно разделены между всеми распределениями.

Если ни один столбец не подходит, рекомендуется использовать метод циклического перебора.

### <a name="select-distribution-column-which-will-minimize-data-movement"></a>Выбор столбца распределения, который минимизирует перемещение данных
Минимизация перемещения данных за счет выбора подходящего столбца распределения — одна из самых важных стратегий оптимизации производительности хранилища данных SQL.  Перемещение данных в основном происходит при объединении или группировании таблиц.  Все столбцы, используемые в предложениях `JOIN`, `GROUP BY`, `DISTINCT`, `OVER` и `HAVING`, **могут** становиться столбцами хэш-распределения.

С другой стороны, в качестве столбца хэш-распределения мы **не** рекомендуем применять столбцы, используемые в предложении `WHERE`, так как они ограничивают распределения, участвующие в запросе, что приводит к неравномерному распределению обработки.  Хорошим примером столбца, который может казаться удачным выбором для распределения, но часто может приводить к неравномерному распределению обработки, является столбец даты.

В общем, при наличии двух больших таблиц фактов, часто используемых в соединениях, оптимальная производительность достигается путем распределения обеих таблиц по одному из столбцов соединения.  При наличии таблицы, которая никогда не присоединялась к другой большой таблице фактов, рекомендуется использовать столбцы из предложения `GROUP BY` .

Существует несколько моментов, на которые следует обратить внимание, чтобы избежать перемещения данных во время операции соединения.

1. Таблицы, входящие в соединение, должны быть распределены по методу хэш-распределения по **одному** из столбцов соединения.
2. Типы данных столбцов соединения в обеих таблицах должны совпадать.
3. Объединение столбцов необходимо выполнять с помощью оператора equals.
4. Типом соединения не может быть `CROSS JOIN`.

## <a name="troubleshooting-data-skew"></a>Устранение смещения данных
Если данные таблицы распределяются путем хэш-распределения, существует вероятность, что распределение будет неравномерным, т. е. в некоторых местах будет непропорционально больше данных. Чрезмерное смещение данных может повлиять на производительность запроса, так как выполнение распределенного запроса завершится только после длительного процесса распределения. В таком случае необходимо предпринять меры по устранению проблемы.

### <a name="identifying-skew"></a>Определение смещения данных
Для выявления неравномерного распределения в таблице можно воспользоваться `DBCC PDW_SHOWSPACEUSED`.  Это позволяет легко и быстро увидеть, сколько строк таблицы хранится в каждом из 60 распределений базы данных.  Помните, что для максимально сбалансированной производительности строки в распределенной таблице должны размещаться равномерно по всем распределениям.

```sql
-- Find data skew for a distributed table
DBCC PDW_SHOWSPACEUSED('dbo.FactInternetSales');
```

Более глубокий анализ можно выполнить с помощью динамических административных представлений (DMV) хранилища данных SQL Azure.  Для начала создайте представление [dbo.vTableSizes][dbo.vTableSizes], используя хранилище данных SQL, описанное в статье [Общие сведения о таблицах в хранилище данных SQL][Overview].  После этого выполните этот запрос, чтобы определить таблицы со смещением данных с показателем более 10 %.

```sql
select *
from dbo.vTableSizes
where two_part_name in
    (
    select two_part_name
    from dbo.vTableSizes
    where row_count > 0
    group by two_part_name
    having min(row_count * 1.000)/max(row_count * 1.000) > .10
    )
order by two_part_name, row_count
;
```

### <a name="resolving-data-skew"></a>Устранение неравномерности данных
Не все смещения нужно исправлять.  В некоторых случаях производительность таблицы при выполнении некоторых запросов может компенсировать вред, нанесенный в результате смещения.  Чтобы решить, следует ли устранять смещение данных в таблице, нужно узнать как можно больше об объемах данных и запросах в рамках рабочей нагрузки.   Чтобы определить последствия неравномерного распределения, можно воспользоваться действиями, описанными в статье [Мониторинг рабочей нагрузки с помощью динамических административных представлений][Query Monitoring]. Они позволяют определить влияние неравномерного распределения на производительность запросов, а именно на время выполнения запросов в определенных распределениях.

В основе распределения данных лежит поиск баланса между уменьшением степени смещения и перемещения данных. Это могут быть противоположные цели, и иногда нужно сохранить смещение данных, чтобы уменьшить степень их перемещения. Например, если столбец распределения используется и для соединения, и для объединения, степень перемещения данных уменьшится. Преимущество минимального перемещения данных может компенсировать последствия смещения данных.

Стандартный способ устранения смещения данных — повторно создать таблицу с другим столбцом распределения. Столбец распределения в имеющейся таблице изменить невозможно. Поэтому для изменения распределения таблицы необходимо создать ее повторно с помощью инструкции [CTAS][].  Смещение данных можно устранить двумя способами.

### <a name="example-1-re-create-the-table-with-a-new-distribution-column"></a>Способ 1. Повторное создание таблицы с новым столбцом распределения
В примере ниже для повторного создания таблицы с другим столбцом хэш-распределения используется инструкция [CTAS][].

```sql
CREATE TABLE [dbo].[FactInternetSales_CustomerKey]
WITH (  CLUSTERED COLUMNSTORE INDEX
     ,  DISTRIBUTION =  HASH([CustomerKey])
     ,  PARTITION       ( [OrderDateKey] RANGE RIGHT FOR VALUES (   20000101, 20010101, 20020101, 20030101
                                                                ,   20040101, 20050101, 20060101, 20070101
                                                                ,   20080101, 20090101, 20100101, 20110101
                                                                ,   20120101, 20130101, 20140101, 20150101
                                                                ,   20160101, 20170101, 20180101, 20190101
                                                                ,   20200101, 20210101, 20220101, 20230101
                                                                ,   20240101, 20250101, 20260101, 20270101
                                                                ,   20280101, 20290101
                                                                )
                        )
    )
AS
SELECT  *
FROM    [dbo].[FactInternetSales]
OPTION  (LABEL  = 'CTAS : FactInternetSales_CustomerKey')
;

--Create statistics on new table
CREATE STATISTICS [ProductKey] ON [FactInternetSales_CustomerKey] ([ProductKey]);
CREATE STATISTICS [OrderDateKey] ON [FactInternetSales_CustomerKey] ([OrderDateKey]);
CREATE STATISTICS [CustomerKey] ON [FactInternetSales_CustomerKey] ([CustomerKey]);
CREATE STATISTICS [PromotionKey] ON [FactInternetSales_CustomerKey] ([PromotionKey]);
CREATE STATISTICS [SalesOrderNumber] ON [FactInternetSales_CustomerKey] ([SalesOrderNumber]);
CREATE STATISTICS [OrderQuantity] ON [FactInternetSales_CustomerKey] ([OrderQuantity]);
CREATE STATISTICS [UnitPrice] ON [FactInternetSales_CustomerKey] ([UnitPrice]);
CREATE STATISTICS [SalesAmount] ON [FactInternetSales_CustomerKey] ([SalesAmount]);

--Rename the tables
RENAME OBJECT [dbo].[FactInternetSales] TO [FactInternetSales_ProductKey];
RENAME OBJECT [dbo].[FactInternetSales_CustomerKey] TO [FactInternetSales];
```

### <a name="example-2-re-create-the-table-using-round-robin-distribution"></a>Способ 2. Повторное создание таблицы с распределением по принципу циклического перебора
В примере ниже для повторного создания таблицы, распределенной по методу циклического перебора, вместо хэш-распределения используется инструкция [CTAS][]. В результате применения такого сценария вы получите равномерное распределение данных. Однако это приводит к увеличению их перемещения.

```sql
CREATE TABLE [dbo].[FactInternetSales_ROUND_ROBIN]
WITH (  CLUSTERED COLUMNSTORE INDEX
     ,  DISTRIBUTION =  ROUND_ROBIN
     ,  PARTITION       ( [OrderDateKey] RANGE RIGHT FOR VALUES (   20000101, 20010101, 20020101, 20030101
                                                                ,   20040101, 20050101, 20060101, 20070101
                                                                ,   20080101, 20090101, 20100101, 20110101
                                                                ,   20120101, 20130101, 20140101, 20150101
                                                                ,   20160101, 20170101, 20180101, 20190101
                                                                ,   20200101, 20210101, 20220101, 20230101
                                                                ,   20240101, 20250101, 20260101, 20270101
                                                                ,   20280101, 20290101
                                                                )
                        )
    )
AS
SELECT  *
FROM    [dbo].[FactInternetSales]
OPTION  (LABEL  = 'CTAS : FactInternetSales_ROUND_ROBIN')
;

--Create statistics on new table
CREATE STATISTICS [ProductKey] ON [FactInternetSales_ROUND_ROBIN] ([ProductKey]);
CREATE STATISTICS [OrderDateKey] ON [FactInternetSales_ROUND_ROBIN] ([OrderDateKey]);
CREATE STATISTICS [CustomerKey] ON [FactInternetSales_ROUND_ROBIN] ([CustomerKey]);
CREATE STATISTICS [PromotionKey] ON [FactInternetSales_ROUND_ROBIN] ([PromotionKey]);
CREATE STATISTICS [SalesOrderNumber] ON [FactInternetSales_ROUND_ROBIN] ([SalesOrderNumber]);
CREATE STATISTICS [OrderQuantity] ON [FactInternetSales_ROUND_ROBIN] ([OrderQuantity]);
CREATE STATISTICS [UnitPrice] ON [FactInternetSales_ROUND_ROBIN] ([UnitPrice]);
CREATE STATISTICS [SalesAmount] ON [FactInternetSales_ROUND_ROBIN] ([SalesAmount]);

--Rename the tables
RENAME OBJECT [dbo].[FactInternetSales] TO [FactInternetSales_HASH];
RENAME OBJECT [dbo].[FactInternetSales_ROUND_ROBIN] TO [FactInternetSales];
```

## <a name="next-steps"></a>Дальнейшие действия
Дополнительные сведения о проектировании таблиц см. в статьях, посвященных [распределению][Distribute], [индексированию][Index], [секционированию таблиц][Partition], а также [типам данных][Data Types], [управлению статистикой][Statistics] и [временным таблицам][Temporary].

Обзор рекомендаций по использованию приведен в статье [Рекомендации по использованию хранилища данных SQL Azure][SQL Data Warehouse Best Practices].

<!--Image references-->

<!--Article references-->
[Overview]: ./sql-data-warehouse-tables-overview.md
[Data Types]: ./sql-data-warehouse-tables-data-types.md
[Distribute]: ./sql-data-warehouse-tables-distribute.md
[Index]: ./sql-data-warehouse-tables-index.md
[Partition]: ./sql-data-warehouse-tables-partition.md
[Statistics]: ./sql-data-warehouse-tables-statistics.md
[Temporary]: ./sql-data-warehouse-tables-temporary.md
[SQL Data Warehouse Best Practices]: ./sql-data-warehouse-best-practices.md
[Query Monitoring]: ./sql-data-warehouse-manage-monitor.md
[dbo.vTableSizes]: ./sql-data-warehouse-tables-overview.md#table-size-queries

<!--MSDN references-->
[DBCC PDW_SHOWSPACEUSED()]: https://msdn.microsoft.com/library/mt204028.aspx

<!--Other Web references-->
