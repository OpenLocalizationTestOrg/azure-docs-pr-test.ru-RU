---
title: "aaaHow tootroubleshoot кэша Redis для Azure | Документы Microsoft"
description: "Узнайте, как tooresolve распространенные проблемы с кэшем Redis Azure."
services: redis-cache
documentationcenter: 
author: steved0x
manager: douge
editor: 
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: sdanie
ms.openlocfilehash: 4e736fce2b6d5200a2a8d802f3f1384b63458cab
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2017
---
# <a name="how-tootroubleshoot-azure-redis-cache"></a>Как tootroubleshoot Redis для Azure кэша
В этой статье приводятся рекомендации по устранению hello следующие категории проблем кэша Redis для Azure.

* [Устранение неполадок стороны клиента](#client-side-troubleshooting) — в этом разделе приведены рекомендации по идентификации и устранения проблем причиной приложение hello, подключение tooAzure кэша Redis.
* [Устранение неполадок стороны сервера](#server-side-troubleshooting) — в этом разделе приведены рекомендации по идентификации и устранения проблем вызывала в hello серверный кэш Azure Redis.
* [Исключений таймаута StackExchange.Redis](#stackexchangeredis-timeout-exceptions) -этот раздел содержит сведения об устранении проблем при использовании клиента StackExchange.Redis hello.

> [!NOTE]
> Некоторые шаги данного руководства по устранению неполадок hello включать инструкции toorun команды Redis и отслеживать различные метрики производительности. Дополнительные сведения и инструкции см. в статьях hello в hello [дополнительной информацией](#additional-information) раздела.
> 
> 

## <a name="client-side-troubleshooting"></a>Устранение проблем на стороне клиента
В этом разделе описывается устранение неполадок, возникающих из-за состояния на клиентское приложение hello.

* [Нехватка памяти на приветствия клиента](#memory-pressure-on-the-client)
* [Увеличение трафика](#burst-of-traffic)
* [Высокий коэффициент загрузки ЦП клиента](#high-client-cpu-usage)
* [Превышение пропускной способности на стороне клиента](#client-side-bandwidth-exceeded)
* [Большой размер запроса или ответа](#large-requestresponse-size)
* [Какие данные ошибка toomy в Redis?](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-hello-client"></a>Нехватка памяти на приветствия клиента
#### <a name="problem"></a>Проблема
Дефицит памяти на клиентском компьютере hello приводит tooall видов проблемы производительности, которые могут замедлить обработку данных, который был отправлен в экземпляре Redis hello без задержки. Достигнув нехватки памяти, система hello обычно имеет toopage данные из памяти toovirtual физической памяти, который находится на диске. Это *подкачке страниц* причины hello системы tooslow вниз значительно.

#### <a name="measurement"></a>Измерения
1. Наблюдение за использованием памяти на машине toomake убедитесь, что он не превышает объем доступной памяти. 
2. Монитор hello `Page Faults/Sec` счетчика производительности. В большинстве систем ошибки страниц возникают даже во время обычной работы. Понаблюдайте за пиками счетчика производительности ошибок страниц, соответствующими времени ожидания.

#### <a name="resolution"></a>Способы устранения:
Обновите клиент tooa больший размер виртуальной Машины с большим объемом памяти клиента или детализировать вашей памяти tooreduce закономерности использования памяти consuption.

### <a name="burst-of-traffic"></a>Увеличение трафика
#### <a name="problem"></a>Проблема
Пики трафика в сочетании с низкой `ThreadPool` параметров может привести к задержкам в обработке данных, которые уже отправлены с сервера Redis hello, но еще не занятой hello на стороне клиента.

#### <a name="measurement"></a>Измерения
Проведите мониторинг того, как со временем изменяется статистика `ThreadPool` , используя [такой код](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs). Вы также можете изучить hello `TimeoutException` сообщение от StackExchange.Redis. Вот пример:

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

В hello выше сообщение существует несколько проблем, которые представляют интерес.

1. Обратите внимание, что в hello `IOCP` раздел и hello `WORKER` имеется раздел `Busy` значение, которое больше, чем hello `Min` значение. Это значит, что необходимо настроить параметры `ThreadPool` .
2. Кроме того, обратите внимание на `in: 64221`. Это означает, что 64211 байтов были получены на уровне сокетов ядра hello, но еще не были прочитал hello приложением (например StackExchange.Redis). Обычно это означает, приложение не сразу, как hello сервер отправляет его tooyou читает данные из сети hello.

#### <a name="resolution"></a>Способы устранения:
Настройка вашего [параметры пула потоков](https://gist.github.com/JonCole/e65411214030f0d823cb) toomake убедиться, что пул потоков будет масштабировать быстро в разделе прорыв сценариев.

### <a name="high-client-cpu-usage"></a>Высокий коэффициент загрузки ЦП клиента
#### <a name="problem"></a>Проблема
Высокая загрузка ЦП на приветствия клиента является означает, что система hello не справляются с рабочих hello, что она была поставлена задача tooperform. Это означает, что этот клиент hello может завершиться ошибкой tooprocess ответа от Redis в течение отведенного времени, несмотря на то, что Redis отправлен ответ hello очень быстро.

#### <a name="measurement"></a>Измерения
Монитор hello системы расширенных ЦП через портал Azure hello или hello связанный счетчик производительности. Будьте внимательны не toomonitor *процесс* ЦП, так как один процесс может иметь небольшую загрузку ЦП на hello же времени, что системы в целом ЦП может привести к увеличению. Понаблюдайте за пиками загрузки ЦП, которые соответствуют времени ожидания. Из-за высокой загрузки ЦП, также наблюдается высокий `in: XXX` значения в `TimeoutException` сообщения об ошибках, как описано в hello [большого количества трафика](#burst-of-traffic) раздела.

> [!NOTE]
> StackExchange.Redis 1.1.603 и более поздние версии включают hello `local-cpu` метрики в `TimeoutException` сообщения об ошибках. Убедитесь, что использование последней версии hello hello [пакета StackExchange.Redis NuGet](https://www.nuget.org/packages/StackExchange.Redis/). Имеются ошибки, которые постоянно в toomake кода hello ее устранения tootimeouts более надежной поэтому важно наличие последней версии hello.
> 
> 

#### <a name="resolution"></a>Способы устранения:
Обновите tooa ВМ большего размера большей емкости ЦП или исследовать причину пиков использования ЦП. 

### <a name="client-side-bandwidth-exceeded"></a>Превышение пропускной способности на стороне клиента
#### <a name="problem"></a>Проблема
В зависимости от размеров клиентских компьютеров на них применяются разные ограничения доступности пропускной способности сети. Если клиент hello превышает hello доступную пропускную способность, то данные не будут обрабатываться на стороне клиента hello быстро hello сервер отправляет его. Это может привести к tootimeouts.

#### <a name="measurement"></a>Измерения
Проведите мониторинг того, как изменяется использование пропускной способности со временем, используя [такой код](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs). Обратите внимание, что в некоторых средах с ограниченными разрешениями (таких как веб-сайты Azure) этот код, возможно, не удастся выполнить успешно.

#### <a name="resolution"></a>Способы устранения:
Увеличьте размер виртуальной машины или уменьшите использование пропускной способности сети.

### <a name="large-requestresponse-size"></a>Большой размер запроса или ответа
#### <a name="problem"></a>Проблема
Из-за большого размера запроса или ответа может истекать время ожидания. В качестве примера предположим, что значение времени ожидания на клиентском компьютере — 1 секунда. Приложение одновременно запросило два ключа (например, «A» и «B») в hello одновременно (с помощью hello же физическое подключение). Большинство клиентов поддерживают «Pipelining» запросов, таким образом, что оба «A» и «B» отправки запросов на сервере toohello передачи hello один после hello других не ожидая ответы hello. Hello сервер будет отправлять ответы hello обратно в hello же порядке. При больших размерах ответа «A» достаточно она заняла большую часть времени ожидания hello для последующих запросов. 

Привет, следующий пример демонстрирует этот сценарий. В этом сценарии «» и «B» отправляются быстро, запуске сервера hello быстро отправку ответов «A» и «B», но из-за время передачи данных, «B» возникли затруднения за запрос hello других запроса и времени ожидания, несмотря на то, что сервер hello оперативно.

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a>Измерения
Это сложно один toomeasure. По сути имеется tooinstrument клиентского кода tootrack больших запросов и ответов. 

#### <a name="resolution"></a>Способы устранения:
1. Redis оптимизирован для работы с большим количеством данных небольшого объема, а не с малым количеством данных большого объема. Hello предпочтительным решением является toobreak копирование данных в связанных значений меньше. В разделе hello [возможности hello идеально подходящий размер диапазона для redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) (Каков оптимальный размер данных для Redis? Является ли 100 КБ большим размером?).
2. Увеличьте размер hello вашей виртуальной машины (для клиента и сервера кэша Redis) tooget выше пропускной способности возможности, уменьшив объем данных передачи раз больше ответов. Обратите внимание, что начало больше пропускной способности только hello сервере или только на приветствия клиента может оказаться недостаточно. Измерения уровня использования пропускной способности и сравнивают его возможности toohello hello размер виртуальной Машины в настоящий момент.
3. Увеличьте число hello `ConnectionMultiplexer` объектов используйте и циклический перебор запросы через другие соединения.

### <a name="what-happened-toomy-data-in-redis"></a>Какие данные ошибка toomy в Redis?
#### <a name="problem"></a>Проблема
Ожидалось для определенных данных toobe в моем экземпляре кэша Redis для Azure, но не показаться toobe существует.

#### <a name="resolution"></a>Способы устранения:
В разделе [ошибка toomy данные в Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) возможные причины и способы их устранения.

## <a name="server-side-troubleshooting"></a>Устранение проблем на стороне сервера
В этом разделе описывается устранение неполадок, возникающих из-за состояния на сервере кэша hello.

* [Нехватка памяти на сервере hello](#memory-pressure-on-the-server)
* [Высокий коэффициент загрузки ЦП и сервера](#high-cpu-usage-server-load)
* [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-hello-server"></a>Нехватка памяти на сервере hello
#### <a name="problem"></a>Проблема
Дефицит памяти на стороне сервера hello приводит tooall виды проблем производительности, которые могут вызвать задержку обработки запросов. Достигнув нехватки памяти, система hello обычно имеет toopage данные из памяти toovirtual физической памяти, который находится на диске. Это *подкачке страниц* причины hello системы tooslow вниз значительно. Нехватка памяти может возникнуть по следующим причинам. 

1. Емкость toofull кэша hello заполнения данными. 
2. Redis наблюдает фрагментации памяти - чаще всего бывают вызваны хранения больших объектов (Redis оптимизировано для небольших объектов - hello см. в разделе [возможности hello идеально подходящий размер диапазона для redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) (Каков оптимальный размер данных для Redis? Является ли 100 КБ большим размером?). 

#### <a name="measurement"></a>Измерения
Redis предоставляет две метрики, с помощью которых можно определить проблемы: Hello первого — `used_memory` и hello других `used_memory_rss`. [Эти показатели](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) поддерживаются hello портала Azure или через hello [Redis сведения](http://redis.io/commands/info) команды.

#### <a name="resolution"></a>Способы устранения:
Существует несколько возможных изменений, которые можно сделать использование памяти toohelp поддержания работоспособности:

1. [Настройте политику памяти](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) и параметры времени завершения срока действия ключей. Учтите, что если используется фрагментация памяти, этого может быть недостаточно.
2. [Задано значение максимальной памяти зарезервировано](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) , достаточно большой toocompensate для фрагментации памяти.
3. Разбейте большие кэшированные объекты на меньшие связанные объекты.
4. [Масштаб](cache-how-to-scale.md) tooa размер кэш-памяти.
5. При использовании [кэша premium с использование кластера Redis](cache-how-to-premium-clustering.md) вы можете [увеличить количество сегментов в hello](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).

### <a name="high-cpu-usage--server-load"></a>Высокий коэффициент загрузки ЦП и сервера
#### <a name="problem"></a>Проблема
Высокая загрузка ЦП может означать, что hello на стороне клиента может завершиться ошибкой tooprocess ответа от Redis в течение отведенного времени, несмотря на то, что Redis отправлен ответ hello очень быстро.

#### <a name="measurement"></a>Измерения
Монитор hello системы расширенных ЦП через портал Azure hello или hello связанный счетчик производительности. Будьте внимательны не toomonitor *процесс* ЦП, так как один процесс может иметь небольшую загрузку ЦП на hello же времени, что системы в целом ЦП может привести к увеличению. Понаблюдайте за пиками загрузки ЦП, которые соответствуют времени ожидания.

#### <a name="resolution"></a>Способы устранения:
[Масштаб](cache-how-to-scale.md) tooa объемный кэш уровня большей емкости ЦП или исследовать причину пиков использования ЦП. 

### <a name="server-side-bandwidth-exceeded"></a>Превышение пропускной способности на стороне сервера
#### <a name="problem"></a>Проблема
В зависимости от размеров к экземплярам кэша применяются разные ограничения на доступную сетевую пропускную способность. Если сервер hello превышает доступную пропускную способность hello, затем данные будут не отправлены toohello клиента как можно быстрее. Это может привести к tootimeouts.

#### <a name="measurement"></a>Измерения
Вы можете отслеживать hello `Cache Read` метрики, которые являются hello объем данных, считанных из кэша в мегабайтах в секунду (МБИТ/с) для hello hello указанный период отчетности. Это значение соответствует toohello использование пропускной способности сети этот кэш. Если требуется tooset предупреждений для ограничения пропускной способности сети стороне сервера, можно создать их с помощью этого `Cache Read` счетчика. Сравнения со значениями hello в вашей показания [в этой таблице](cache-faq.md#cache-performance) для hello наблюдается ограничения пропускной способности для различных кэша цены уровни и размеры.

#### <a name="resolution"></a>Способы устранения:
Если постоянно рядом с наблюдаемыми максимальная пропускная способность для размер ценовую категорию и кэш hello, рассмотрите возможность [масштабирование](cache-how-to-scale.md) tooa ценовую категорию или размер, который имеет большую пропускную способность сети, используя значения hello в [в этой таблице](cache-faq.md#cache-performance) руководством.

## <a name="stackexchangeredis-timeout-exceptions"></a>Исключения времени ожидания StackExchange.Redis
Для синхронных операций со значением по умолчанию 1000 мс StackExchange.Redis использует параметр конфигурации `synctimeout`. Если синхронный вызов не завершилось в hello заданного времени, возникает исключение клиента StackExchange.Redis hello время ожидания ошибки аналогичные toohello, следующий пример.

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


Это сообщение об ошибке содержит показатели, которые помогают вам toohello причину и возможное решение проблемы hello. Hello Следующая таблица содержит сведения о метриках сообщение hello ошибки.

| Метрики сообщения об ошибке | Сведения |
| --- | --- |
| inst |В последней временной срез hello: 0 команды, выданные |
| mgr |Диспетчер сокета Hello выполняет `socket.select` это означает, что он запрашивает hello ОС tooindicate сокет, содержит какие-то toodo; по сути: hello чтения не считывает активно hello сети, так как не считает, что-то toodo |
| очередь |Указывает, что выполняется 73 операции. |
| qu |6 hello в процессе выполнения операций в очереди неотправленных hello и еще не сохранены исходящий сетевой toohello |
| qs |67 операций выполняющихся он был отправлен toohello сервера, но ответ еще не доступен. Hello отклик может быть `Not yet sent by hello server` или`sent by hello server but not yet processed by hello client.` |
| qc |0 в процессе выполнения операций hello увидели ответов, но не еще были помечены как завершенные из-за toowaiting на завершение цикла hello |
| wr |Нет активной записи (то есть hello 6 неотправленные запросы не игнорируются) байт/activewriters |
| больше |Нет нет активных модулей чтения и нулевых байтов, доступных toobe прочитано Сетевых байт/activereaders hello |

### <a name="steps-tooinvestigate"></a>Tooinvestigate действия
1. Рекомендуется убедитесь, что вы используете следующий шаблон tooconnect при использовании клиента StackExchange.Redis hello hello.

    ```c#
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
    });
    
    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ````

    Дополнительные сведения см. в разделе [подключиться с использованием StackExchange.Redis кэша toohello](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).

1. Убедитесь, что ваш кэш Redis для Azure и клиентское приложение hello в hello же регионе, в Azure. Например, вы может использоваться для получения значения времени ожидания кэша в регионе Восток США, но hello клиент находится на Западе США и при hello запроса не завершается в течение hello `synctimeout` интервал или может использоваться для получения значения времени ожидания при отладке с вашей локальной машины. 
   
    Он настоятельно рекомендуется использовать кэш toohave hello и в клиенте hello в hello же регионе Azure. Если у вас есть сценарий, включающий вызовы между регионами, необходимо задать hello `synctimeout` tooa интервал больше, чем интервал по умолчанию 1000 мс hello, включив `synctimeout` свойства в строке подключения hello. Hello примере показан фрагмент строки подключения кэша StackExchange.Redis с `synctimeout` 2000 мс.
   
        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
2. Убедитесь, что использование последней версии hello hello [пакета StackExchange.Redis NuGet](https://www.nuget.org/packages/StackExchange.Redis/). Имеются ошибки, которые постоянно в toomake кода hello ее устранения tootimeouts более надежной поэтому важно наличие последней версии hello.
3. Если имеются запросы, получение привязанных ограничения пропускной способности на приветствия сервера или клиента, он займет больше времени для них toocomplete, что может вызвать тайм-ауты. toosee, если на время ожидания из-за toonetwork пропускной способности на сервере hello см [Превышение пропускной способности стороны сервера](#server-side-bandwidth-exceeded). toosee, если на время ожидания из-за tooclient пропускной способности сети, в разделе [Превышение пропускной способности стороны клиента](#client-side-bandwidth-exceeded).
4. Привязаны к ЦП на сервере hello или на приветствия клиента?
   
   * В рамках hello обрабатываться проверки вы начало связаны с ЦП на клиентском компьютере, что может привести к toonot запрос hello `synctimeout` интервал, тем самым вызывая истечения времени ожидания. Перемещение tooa большего размера клиента или распределения нагрузки hello может помочь toocontrol это. 
   * Флажок, если вы получаете ЦП ограничивается на сервере hello мониторинга hello `CPU` [кэшировать метрики производительности](cache-how-to-monitor.md#available-metrics-and-reporting-intervals). Запросы, поступающие во время ЦП может привести к их Redis запрашивает tootimeout. tooaddress это можно распространять hello нагрузки на несколько сегментов в кэше premium или обновление tooa большего размера или ценовой категории. Дополнительные сведения см. в разделе [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded).
5. Существуют занимает много времени tooprocess на сервере hello команды? Долго выполняющихся команд, выполнение которых занимает много времени tooprocess на сервер redis hello может привести к задержке. К этим командам относятся `mget` с большим количеством ключей, `keys *` или плохо написанные сценарии LUА. Можно подключиться tooyour экземпляра кэша Redis для Azure, используя клиент redis cli hello или использовать hello [Redis консоли](cache-configure.md#redis-console) и выполнения hello [SlowLog](http://redis.io/commands/slowlog) toosee команду, если имеются запросы, занимает больше времени, чем ожидалось. Сервер Redis и StackExchange.Redis оптимизированы для обработки большого количества небольших запросов, а не нескольких больших запросов. Чтобы повысить их производительность, рекомендуется разбить данные на небольшие фрагменты. 
   
    Сведения о подключении toohello конечной точки SSL кэша Redis Azure с помощью redis cli и stunnel см. в разделе hello [объявление поставщика состояний сеансов ASP.NET для Redis предварительной версии](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) записи блога. Дополнительные сведения о команде SlowLog см. [здесь](http://redis.io/commands/slowlog).
6. Высокая загрузка сервера Redis может влечь истечение времени ожидания. Вы можете отслеживать hello нагрузку на сервер, мониторинг hello `Redis Server Load` [кэшировать метрики производительности](cache-how-to-monitor.md#available-metrics-and-reporting-intervals). Загрузка сервера 100 (максимальное значение) означает, что этот сервер redis hello был занят без простоя времени обработки запросов. toosee, если определенные запросы, занимающих все возможности сервера hello, выполните команду SlowLog hello, как описано в предыдущем абзаце hello. Дополнительные сведения см. в разделе [Высокий коэффициент загрузки ЦП и сервера](#high-cpu-usage-server-load).
7. Была ли любое другое событие на стороне клиента hello, возможно, использовать сети? Проверьте на приветствия клиента (web, рабочей роли или ВМ Iaas), если было событие как масштабирование hello количеством экземпляров клиента или развертывание новой версии клиента hello или включено автоматическое масштабирование? В нашем тестировании, который мы знаем, что автомасштабирования или масштабирование вверх/вниз может привести к исходящего сетевого подключения могут быть потеряны на несколько секунд. Код StackExchange.Redis устойчивым toosuch событий и выполнит повторное подключение. В это время повторное подключение все запросы в очереди hello истечь время ожидания.
8. Была ли больших предыдущего toohello несколько небольших запросов кэша Redis, истекло время ожидания запроса? Здравствуйте, параметр `qs` по ошибке hello сообщения о том, сколько запросов были отправлены с сервера toohello hello клиента, но еще не обработаны ответа. Это количество может увеличиваться, так как StackExchange.Redis использует одно подключение TCP, которое позволяет обрабатывать только один ответ за раз. Несмотря на то, что первая операция hello истекло время ожидания, не останавливает hello данных, отправляемых с сервера hello и другие запросы блокируются до завершения этой операции, вызывая истечения времени ожидания. Одним из решений является toominimize hello вероятность возникновения тайм-ауты за счет того, что ваш кэш достаточен для рабочей нагрузки и разбиения на более мелкие фрагменты данных больших значений. Другим возможным решением является toouse пул `ConnectionMultiplexer` объектов в клиентском приложении, а затем выберите hello бы загрузить `ConnectionMultiplexer` при отправке запроса на новый. Это должны быть запрещены более одного тайм-аута из-за времени ожидания tooalso других запросов.
9. Если вы используете `RedisSessionStateprovider`, проверить время ожидания попытки повтора hello настроены правильно. Значение `retrytimeoutInMilliseconds` должно быть выше, чем `operationTimeoutinMilliseonds`, иначе попытки не будут повторяться. В следующий пример hello `retrytimeoutInMilliseconds` имеет значение too3000. Дополнительные сведения см. в разделе [поставщика состояний сеансов ASP.NET для кэша Azure Redis](cache-aspnet-session-state-provider.md) и [как toouse hello параметры конфигурации поставщика состояния сеанса и поставщик кэша вывода](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).

    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


1. Проверка использования памяти на сервере hello кэш Azure Redis [мониторинг](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` и `Used Memory`. Если политика вытеснения, в месте Redis запускает исключения ключей при `Used_Memory` достигает hello размер кэша. В идеале значение `Used Memory RSS` должно быть немного больше, чем значение `Used memory`. Большая разница между значениями означает фрагментацию памяти (внутренней или внешней). Когда `Used Memory RSS` — меньше, чем `Used Memory`, это означает, что часть памяти кэша hello были заменены hello операционной системы. В этом случае может возникать значительная задержка. Поскольку Redis не имеет контроля над как соответствующие ему выделения сопоставляются toomemory страниц высокой `Used Memory RSS` часто является результатом hello пик в использовании памяти. При Redis освобождает память, память hello возвращается распределителя toohello и hello распределителя может или не может привести к задней toohello система hello памяти. Возможно несоответствие между hello `Used Memory` значение и потребления памяти по данным hello операционной системы. Возможно, из-за toohello фактов используется память и выпуска по Redis, но не данный toohello серверной системы. toohelp избежать проблем с памятью можно выполнить следующие шаги hello.
   
   * Обновите hello кэша tooa большего размера, чтобы проводить сопоставление ограничения памяти в системе hello не будет запущена.
   * Задать время истечения срока действия ключей hello, чтобы заранее вытесняются старые значения.
   * Монитор hello hello `used_memory_rss` кэшировать метрику. Это значение достигает размера hello их кэша, вы, скорее всего, toostart Просмотр проблем с производительностью. Распределение данных hello в нескольких сегментах, если вы используете кэша premium, или обновить tooa размер кэш-памяти.
   
   Дополнительные сведения см. в разделе [нехватки памяти на сервере hello](#memory-pressure-on-the-server).

## <a name="additional-information"></a>Дополнительная информация
* [Какое предложение и размер кэша Redis мне следует использовать?](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
* [Как сравнить и протестировать hello производительность моих кэша?](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
* [Как выполнять команды Redis?](cache-faq.md#how-can-i-run-redis-commands)
* [Как toomonitor Redis для Azure кэша](cache-how-to-monitor.md)

