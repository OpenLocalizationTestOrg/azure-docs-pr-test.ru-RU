---
title: "Как устранять неполадки кэша Redis для Azure | Документация Майкрософт"
description: "Узнайте, как устранить самые распространенные проблемы с кэшем Redis для Azure"
services: redis-cache
documentationcenter: 
author: steved0x
manager: douge
editor: 
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: sdanie
ms.openlocfilehash: 2e9d1b644f1e80c7d916a261a6c47fcc11a1ffe0
ms.sourcegitcommit: 6699c77dcbd5f8a1a2f21fba3d0a0005ac9ed6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2017
---
# <a name="how-to-troubleshoot-azure-redis-cache"></a>Способы устранения проблем с кэшем Redis для Azure
Эта статья содержит сведения об устранении следующих категорий проблем с кэшем Redis для Azure.

* [Устранение проблем на стороне клиента](#client-side-troubleshooting). В этом разделе представлены рекомендации по выявлению и устранению проблем, вызванных подключением приложения к серверу кэша Redis для Azure.
* [Устранение проблем на стороне сервера](#server-side-troubleshooting). В этом разделе представлены рекомендации по обнаружению и устранению проблем на сервере кэша Redis для Azure.
* [Исключения времени ожидания StackExchange.Redis](#stackexchangeredis-timeout-exceptions). В этом разделе содержатся сведения об устранении проблем при использовании клиента StackExchange.Redis.

> [!NOTE]
> Шаги по устранению проблем в этой статье также включают в себя указания по выполнению команд Redis и мониторингу различных метрик производительности. Дополнительные сведения и указания см. в разделе [Дополнительные сведения](#additional-information).
> 
> 

## <a name="client-side-troubleshooting"></a>Устранение проблем на стороне клиента
В этом разделе рассматриваются способы устранения проблем, вызванных определенным условием в клиентском приложении.

* [Нехватка памяти на клиенте](#memory-pressure-on-the-client)
* [Увеличение трафика](#burst-of-traffic)
* [Высокий коэффициент загрузки ЦП клиента](#high-client-cpu-usage)
* [Превышение пропускной способности на стороне клиента](#client-side-bandwidth-exceeded)
* [Большой размер запроса или ответа](#large-requestresponse-size)
* [Что произошло с моими данными в Redis?](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-the-client"></a>Нехватка памяти на клиенте
#### <a name="problem"></a>Проблема
Нехватка памяти на клиентском компьютере служит причиной всевозможных проблем с производительностью, которые вызывают задержку обработки данных, отправленных с помощью экземпляра Redis без задержки. Как правило, в результате нехватки памяти система перемещает данные со страниц физической на страницы виртуальной памяти, которая расположена на диске. Именно *ошибки страниц* существенно замедляют работу системы.

#### <a name="measurement"></a>Измерения
1. Проведите мониторинг использования памяти на компьютере, чтобы убедиться в том, что объем доступной памяти не превышен. 
2. Выполните мониторинг счетчика производительности `Page Faults/Sec`. В большинстве систем ошибки страниц возникают даже во время обычной работы. Понаблюдайте за пиками счетчика производительности ошибок страниц, соответствующими времени ожидания.

#### <a name="resolution"></a>Способы устранения:
Увеличьте размер клиентской виртуальной машины или измените шаблоны использования памяти, снизив потребление памяти.

### <a name="burst-of-traffic"></a>Увеличение трафика
#### <a name="problem"></a>Проблема
Увеличение трафика в сочетании с недостаточными параметрами `ThreadPool` может привести к возникновению задержек обработки данных, отправленных сервером Redis, но еще не использованных на стороне клиента.

#### <a name="measurement"></a>Измерения
Проведите мониторинг того, как со временем изменяется статистика `ThreadPool` , используя [такой код](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs). Кроме того, можно просмотреть сообщение `TimeoutException` от StackExchange.Redis. Вот пример:

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

В примере сообщения выше следует обратить внимание на следующее.

1. Обратите внимание, что в разделах `IOCP` и `WORKER` значение `Busy` больше, чем значение `Min`. Это значит, что необходимо настроить параметры `ThreadPool` .
2. Кроме того, обратите внимание на `in: 64221`. Число 64211 — это количество байт, отправленных на уровень сокета ядра, но еще не считанных приложением (например, StackExchange.Redis). Как правило, это значит, что приложение не успевает считывать весь объем данных, отправленных с сервера.

#### <a name="resolution"></a>Способы устранения:
Настройте [параметры пула потоков](https://gist.github.com/JonCole/e65411214030f0d823cb) , чтобы обеспечить быстрое увеличение масштаба пула потоков при увеличении трафика.

### <a name="high-client-cpu-usage"></a>Высокий коэффициент загрузки ЦП клиента
#### <a name="problem"></a>Проблема
Высокий коэффициент загрузки ЦП клиента служит причиной того, что системе не удается справиться со всеми поставленными заданиями. Это означает, что, возможно, клиенту не удастся своевременно обработать ответ от Redis (даже если ответ отправлен очень быстро).

#### <a name="measurement"></a>Измерения
Выполните мониторинг загрузки ЦП для всей системы, используя портал Azure или связанный счетчик производительности. Не путайте ее с загрузкой ЦП *процесса* , так как коэффициент загрузки ЦП одного процесса может быть низким, а всей системы — высоким. Понаблюдайте за пиками загрузки ЦП, которые соответствуют времени ожидания. Результатом высокой загрузки ЦП могут быть высокие значения `in: XXX` в сообщениях об ошибке `TimeoutException`, как описано в разделе [Увеличение трафика](#burst-of-traffic).

> [!NOTE]
> В StackExchange.Redis 1.1.603 и более поздней версии в сообщениях об ошибках `TimeoutException` содержится метрика `local-cpu`. Убедитесь, что вы используете последнюю версию [пакета NuGet для StackExchange.Redis](https://www.nuget.org/packages/StackExchange.Redis/). Это важно, так как ошибки в коде постоянно исправляют, что позволяет обеспечить надежность в отношении времени ожидания.
> 
> 

#### <a name="resolution"></a>Способы устранения:
Увеличьте емкость ЦП виртуальной машины или выясните, что создает пики загрузки ЦП. 

### <a name="client-side-bandwidth-exceeded"></a>Превышение пропускной способности на стороне клиента
#### <a name="problem"></a>Проблема
В зависимости от размеров клиентских компьютеров на них применяются разные ограничения доступности пропускной способности сети. При превышении доступной пропускной способности клиент не сможет обрабатывать весь объем данных, отправляемых с сервера. Это может повлечь истечение времени ожидания.

#### <a name="measurement"></a>Измерения
Проведите мониторинг того, как изменяется использование пропускной способности со временем, используя [такой код](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs). Обратите внимание, что в некоторых средах с ограниченными разрешениями (таких как веб-сайты Azure) этот код, возможно, не удастся выполнить успешно.

#### <a name="resolution"></a>Способы устранения:
Увеличьте размер виртуальной машины или уменьшите использование пропускной способности сети.

### <a name="large-requestresponse-size"></a>Большой размер запроса или ответа
#### <a name="problem"></a>Проблема
Из-за большого размера запроса или ответа может истекать время ожидания. В качестве примера предположим, что значение времени ожидания на клиентском компьютере — 1 секунда. Приложение одновременно запросило два ключа (например, A и Б), используя одно и то же подключение к физической сети. Большинство клиентов поддерживают конвейерный режим отправки запросов. Это означает, что запросы А и Б последовательно отправляются на сервер через физическое подключение, не ожидая получения ответов. Ответы с сервера отправляются в том же порядке. Если ответ А достаточно большого размера, его обработка может занять преимущественную часть времени ожидания, необходимого для выполнения следующих запросов. 

Этот сценарий показан в следующем примере. В этом сценарии запросы А и Б отправлены быстро, сервер быстро начал отправку ответов, но из-за длительного времени передачи данных ответ Б задержался после другого запроса и срок его ожидания истек, несмотря на то, что сервер быстро ответил.

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a>Измерения
Трудно выполнить соответствующие измерения. По сути, вам нужно добавить в клиентский код инструменты для отслеживания запросов и ответов большого размера. 

#### <a name="resolution"></a>Способы устранения:
1. Redis оптимизирован для работы с большим количеством данных небольшого объема, а не с малым количеством данных большого объема. Поэтому рекомендуется разбить данные на небольшие связанные части. Дополнительные сведения о том, почему лучше использовать данные небольшого объема, см. в записи на форуме [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) (Каков оптимальный размер данных для Redis? Является ли 100 КБ большим размером?).
2. Увеличьте размер виртуальной машины (для клиента и сервера кэша Redis), чтобы увеличить пропускную способность и уменьшить время передачи данных для больших ответов. Обратите внимание, что увеличение пропускной способности только на сервере или только на клиенте не решит проблему. Измерьте использование пропускной способности и сравните его с возможностями, которые обеспечивает текущий размер вашей виртуальной машины.
3. Увеличьте количество используемых объектов `ConnectionMultiplexer` и запросов циклического перебора между подключениями.

### <a name="what-happened-to-my-data-in-redis"></a>Что произошло с моими данными в Redis?
#### <a name="problem"></a>Проблема
В экземпляре кэша Redis для Azure отсутствуют некоторые данные.

#### <a name="resolution"></a>Способы устранения:
Дополнительные сведения о возможных причинах и способах устранения проблемы см. в статье [What happened to my data in Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) (Что произошло с моими данными в Redis?).

## <a name="server-side-troubleshooting"></a>Устранение проблем на стороне сервера
В этом разделе рассматриваются способы устранения проблем, вызванных определенным условием на сервере кэширования.

* [Нехватка памяти на сервере](#memory-pressure-on-the-server)
* [Высокий коэффициент загрузки ЦП и сервера](#high-cpu-usage-server-load)
* [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-the-server"></a>Нехватка памяти на сервере
#### <a name="problem"></a>Проблема
Нехватка памяти на сервере кэширования служит причиной всевозможных проблем с производительностью, которые вызывают задержку обработки запросов. Как правило, в результате нехватки памяти система перемещает данные со страниц физической на страницы виртуальной памяти, которая расположена на диске. Именно *ошибки страниц* существенно замедляют работу системы. Нехватка памяти может возникнуть по следующим причинам. 

1. Весь кэш заполнен данными. 
2. Чаще всего причиной высокой степени фрагментации памяти Redis является хранение больших объектов. (Redis оптимизирован для работы с небольшими объектами. Дополнительные сведения см. в записи форума [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) (Каков оптимальный размер данных для Redis? Является ли 100 КБ большим размером?). 

#### <a name="measurement"></a>Измерения
Redis предоставляет две метрики, с помощью которых можно определить проблемы: `used_memory` и `used_memory_rss`. [Эти метрики](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) доступны на портале Azure. Или запустите команду [Redis INFO](http://redis.io/commands/info), чтобы получить их.

#### <a name="resolution"></a>Способы устранения:
Настроить оптимальное использование памяти можно несколькими способами.

1. [Настройте политику памяти](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) и параметры времени завершения срока действия ключей. Учтите, что если используется фрагментация памяти, этого может быть недостаточно.
2. [Настройте значение maxmemory-reserved](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) , которого будет достаточно, чтобы компенсировать фрагментацию памяти.
3. Разбейте большие кэшированные объекты на меньшие связанные объекты.
4. [Увеличьте](cache-how-to-scale.md) размер кэша.
5. Если используется [кэш Redis (цен. категории "Премиум") со включенной кластеризацией](cache-how-to-premium-clustering.md), [увеличьте количество сегментов](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).

### <a name="high-cpu-usage--server-load"></a>Высокий коэффициент загрузки ЦП и сервера
#### <a name="problem"></a>Проблема
Высокий коэффициент загрузки ЦП служит причиной того, что клиенту может не удаться своевременно обработать ответ от Redis (даже если ответ отправлен очень быстро).

#### <a name="measurement"></a>Измерения
Выполните мониторинг загрузки ЦП для всей системы, используя портал Azure или связанный счетчик производительности. Не путайте ее с загрузкой ЦП *процесса* , так как коэффициент загрузки ЦП одного процесса может быть низким, а всей системы — высоким. Понаблюдайте за пиками загрузки ЦП, которые соответствуют времени ожидания.

#### <a name="resolution"></a>Способы устранения:
[Увеличьте](cache-how-to-scale.md) размер кэша или определите причину пиков загрузки ЦП. 

### <a name="server-side-bandwidth-exceeded"></a>Превышение пропускной способности на стороне сервера
#### <a name="problem"></a>Проблема
В зависимости от размеров к экземплярам кэша применяются разные ограничения на доступную сетевую пропускную способность. Если сервер превысит пропускную способность, уменьшится скорость передачи данных с сервера на клиентский компьютер. Это может повлечь истечение времени ожидания.

#### <a name="measurement"></a>Измерения
Вы можете провести мониторинг значения метрики `Cache Read` , которая равна объему данных (в МБ/с), считанных из кэша за указанный интервал отчетности. Это значение соответствует пропускной способности сети для этого кэша. Если вы хотите настроить оповещения об ограничениях пропускной способности сети на стороне сервера, их можно создать с использованием счетчика `Cache Read` . Сравните полученные показатели со значениями в [этой таблице](cache-faq.md#cache-performance) , где приводятся наблюдаемые ограничения пропускной способности для различных ценовых категорий и размеров кэша.

#### <a name="resolution"></a>Способы устранения:
Если для вашей ценовой категории и размера кэша почти достигнуто максимальное ограничение пропускной способности, [измените](cache-how-to-scale.md) ценовую категорию или размер, чтобы увеличить пропускную способность, используя значения [этой таблицы](cache-faq.md#cache-performance) для справки.

## <a name="stackexchangeredis-timeout-exceptions"></a>Исключения времени ожидания StackExchange.Redis
Для синхронных операций со значением по умолчанию 1000 мс StackExchange.Redis использует параметр конфигурации `synctimeout`. Если синхронный вызов не завершается за установленное время, клиент StackExchange.Redis выводит ошибку времени ожидания, которая выглядит примерно так:

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


В этом сообщении об ошибке содержатся метрики, которые помогут вам определить причину и возможное решение проблемы. В следующей таблице содержатся сведения о метриках сообщения об ошибке.

| Метрики сообщения об ошибке | Сведения |
| --- | --- |
| inst |Указывает, что за последний интервал времени инициировано 0 команд. |
| mgr |Диспетчер сокетов выполняет `socket.select`, а это значит, что он отправляет в ОС запрос на определение сокета, который должен выполнять какое-то действие. Как правило, модуль чтения не выполняет активное чтение с сети, так как он предполагает, что нет действий, которые необходимо выполнить. |
| очередь |Указывает, что выполняется 73 операции. |
| qu |Указывает, что 6 выполняемых операций находится в очереди неотправленных, и они еще не записаны в исходящую сеть. |
| qs |Указывает, что 67 выполняемых операций отправлено на сервер, но ответ еще не доступен. Ответ может быть таким: `Not yet sent by the server` или `sent by the server but not yet processed by the client.` |
| qc |Указывает, что для 0 выполняемых операций отправлены ответы, но операции не отмечены в качестве завершенных ожидания в цикле выполнения. |
| wr |Указывает, что есть bytes/activewriters активных модулей записи (6 неотправленных запросов не игнорируются). |
| больше |Указывает, что отсутствуют активные модули чтения и нет байтов для чтения для bytes/activereaders сетевой карты. |

### <a name="steps-to-investigate"></a>Действия для обнаружения проблем
1. Убедитесь, что для подключения к кэшу с помощью клиента StackExchange.Redis используется следующий шаблон.

    ```c#
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
    });
    
    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ````

    Дополнительные сведения см. в разделе о [подключении к кэшу с использованием StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).

1. Убедитесь, что кэш Redis для Azure и клиентское приложение расположены в одном регионе Azure. Например, если кэш расположен в восточной части США, а клиент — в западной части США, то может истекать время ожидания выполнения запроса и для выполнения может быть недостаточно интервала `synctimeout`. Кроме того, время ожидания может истекать при отладке на локальном компьютере разработки. 
   
    Кэш и клиент настоятельно рекомендуется размещать в одном и том же регионе Azure. Если используются межрегиональные вызовы, необходимо увеличить значение интервала `synctimeout` по умолчанию (1000 мс), добавив в строку подключения свойство `synctimeout`. В следующем примере показан фрагмент строки подключения кэша StackExchange.Redis со значением 2000 мс для `synctimeout` .
   
        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
2. Убедитесь, что вы используете последнюю версию [пакета NuGet для StackExchange.Redis](https://www.nuget.org/packages/StackExchange.Redis/). Это важно, так как ошибки в коде постоянно исправляют, что позволяет обеспечить надежность в отношении времени ожидания.
3. Выполнение запросов, связанных с ограничением пропускной способности на сервере или клиенте, будет занимать больше времени и во время этого может истекать время ожидания. Дополнительные сведения об истечении времени ожидания, связанном с сетевой пропускной способностью на сервере, см. в разделе [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded). Дополнительные сведения об истечении времени ожидания, связанном с сетевой пропускной способностью клиента, см. в разделе [Превышение пропускной способности на стороне клиента](#client-side-bandwidth-exceeded).
4. Используются ли ресурсы ЦП на сервере или клиенте?
   
   * Проверьте, не вызвана ли нехватка времени на обработку запроса в разрешенный интервал времени `synctimeout` (что вызывает истечение времени ожидания) высоким коэффициентом загрузки ЦП на стороне клиента. Чтобы решить эту проблему, увеличьте размер клиента или распределите загрузку. 
   * Проверьте коэффициент загрузки ЦП на сервере, выполнив мониторинг [метрики производительности кэша](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `CPU`. Запросы, поступающие во время выполнения Redis операций, связанных с ЦП, могут вызывать возникновение времени ожидания. Чтобы устранить эту проблему, распределите нагрузку между несколькими сегментами в кэше (цен. категории "Премиум") или используйте кэш большего размера или другой ценовой уровень. Дополнительные сведения см. в разделе [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded).
5. Занимает ли выполнение команд на сервере слишком много времени? Выполнение длительных команд на сервере Redis может вызывать истечение времени ожидания. К этим командам относятся `mget` с большим количеством ключей, `keys *` или плохо написанные сценарии LUА. Чтобы проверить, выполняются ли некоторые запросы дольше чем необходимо, подключитесь к экземпляру кэша Redis для Azure с помощью клиента redis-cli или откройте [консоль Redis](cache-configure.md#redis-console) и выполните команду [SlowLog](http://redis.io/commands/slowlog). Сервер Redis и StackExchange.Redis оптимизированы для обработки большого количества небольших запросов, а не нескольких больших запросов. Чтобы повысить их производительность, рекомендуется разбить данные на небольшие фрагменты. 
   
    Дополнительные сведения о подключении к конечной точке SSL кэша Redis для Azure с помощью redis-cli и stunnel см. в записи блога [Announcing ASP.NET Session State Provider for Redis Preview Release](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) (Объявление поставщика состояний сеансов ASP.NET для предварительной версии Redis). Дополнительные сведения о команде SlowLog см. [здесь](http://redis.io/commands/slowlog).
6. Высокая загрузка сервера Redis может влечь истечение времени ожидания. Вы можете выполнить мониторинг значения загрузки сервера, измеряя [метрику производительности кэша](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Redis Server Load`. Максимальное значение загрузки (100) указывает на то, что сервер слишком загружен обработкой запросов и не простаивает. Чтобы узнать, не использует ли сервер все свои ресурсы на определенные запросы, выполните команду SlowLog, как описано в предыдущем абзаце. Дополнительные сведения см. в разделе [Высокий коэффициент загрузки ЦП и сервера](#high-cpu-usage-server-load).
7. Происходили ли на клиенте другие события, для которых требовалось сетевое кэширование? Проверьте, не выполнялись ли на клиенте (в веб-, рабочей роли или на виртуальной машине IaaS) такие операции, как изменение количества экземпляров, развертывание новых версий клиента или включение автомасштабирования. Наше тестирование показало, что автомасштабирование или изменение масштаба может влечь утрату связи с сетью на несколько секунд. Код StackExchange.Redis устойчив к таким событиям и будет переподключен. Во время переподключения некоторые запросы в очереди могут простаивать.
8. Истекло ли время ожидания при выполнении большого запроса к кэшу Redis перед несколькими небольшими? Параметр `qs` в сообщении об ошибке указывает, сколько необработанных запросов отправлено с клиента на сервер. Это количество может увеличиваться, так как StackExchange.Redis использует одно подключение TCP, которое позволяет обрабатывать только один ответ за раз. Несмотря на то, что время ожидания первой операции истекло, данные все равно будут поступать на сервер или с него, а другие запросы будут заблокированы, что повлечет истечение времени ожидания. Чтобы решить эту проблему, рекомендуется снизить вероятность возникновения времени ожидания, увеличив размер кэша для рабочей нагрузки и разбив данные большого объема на небольшие фрагменты. Другое решение — использовать в клиенте пул объектов `ConnectionMultiplexer` и для отправки новых запросов применять наименее загруженный объект `ConnectionMultiplexer`. Это позволяет снизить вероятность того, что истечение времени ожидания одного запроса повлечет истечение времени ожидания других запросов.
9. Если вы используете `RedisSessionStateprovider`, не забудьте правильно установить время ожидания перед повтором попытки. Значение `retrytimeoutInMilliseconds` должно быть выше, чем `operationTimeoutinMilliseonds`, иначе попытки не будут повторяться. В следующем примере для `retrytimeoutInMilliseconds` задано значение 3000. Дополнительные сведения см. в статьях [Поставщик состояний сеансов ASP.NET для кэша Redis для Azure](cache-aspnet-session-state-provider.md) и [How to use configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration) (Использование параметров конфигурации поставщика состояний сеанса и поставщика кэша вывода).

    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


1. Проверяйте использование памяти на сервере кэша Redis для Azure, [отслеживая](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) значения `Used Memory RSS` и `Used Memory`. Если используется политика вытеснения, Redis начнет вытеснять ключи, когда значение `Used_Memory` достигнет размера кэша. В идеале значение `Used Memory RSS` должно быть немного больше, чем значение `Used memory`. Большая разница между значениями означает фрагментацию памяти (внутренней или внешней). Если значение `Used Memory RSS` меньше значения `Used Memory`, это значит, что часть кэш-памяти используется операционной системой для подкачки. В этом случае может возникать значительная задержка. Так как Redis не контролирует сопоставление распределений со станицами памяти, высокое значение `Used Memory RSS` зачастую является результатом увеличения использования памяти. Когда Redis освобождает память, она возвращается распределителю, который может вернуть или не вернуть память в систему. При этом операционная система может сообщать о расхождении между `Used Memory` и использованием памяти. Это связано с тем, что использованная и освобожденная Redis память не возвращена обратно в систему. Чтобы устранить риски возникновения проблем с памятью, выполните следующие шаги.
   
   * Увеличьте размер кэша, чтобы предотвратить превышение ограничения объема используемой памяти в системе.
   * Задайте время истечения срока действия ключей, чтобы они вытеснялись заранее.
   * Отслеживайте метрику кэша `used_memory_rss`. Если это значение близко к значению размера кэша, скорее всего, появятся проблемы с производительностью. Если используется кэш (цен. категории "Премиум"), распределите данные по нескольким сегментам или увеличьте размер кэша.
   
   Дополнительные сведения см. в разделе [Нехватка памяти на сервере](#memory-pressure-on-the-server).

## <a name="additional-information"></a>Дополнительная информация
* [Какое предложение и размер кэша Redis мне следует использовать?](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
* [Как измерить и протестировать производительность моего кэша?](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
* [Как выполнять команды Redis?](cache-faq.md#how-can-i-run-redis-commands)
* [Как отслеживать кэш Redis для Azure](cache-how-to-monitor.md)

