---
title: "Поиск данных по журналам в Azure Log Analytics | Документация Майкрософт"
description: "Поиск по журналам позволяет объединять и сопоставлять любые данные о компьютерах из нескольких источников в вашей среде."
services: log-analytics
documentationcenter: 
author: bwren
manager: carmonm
editor: 
ms.assetid: 0d7b6712-1722-423b-a60f-05389cde3625
ms.service: log-analytics
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 07/26/2017
ms.author: bwren
ms.openlocfilehash: bf237a837297cb8f1ab3a3340139133adcd2b244
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/03/2017
---
# <a name="find-data-using-log-searches-in-log-analytics"></a>Поиск данных по журналам в Log Analytics

>[!NOTE]
> В этой статье описывается поиск по журналам с использованием текущего языка запросов в Log Analytics.  Если ваша рабочая область переведена на [новый язык запросов Log Analytics](log-analytics-log-search-upgrade.md), ознакомьтесь с описанием [функции поиска по журналам в Log Analytics (новая версия)](log-analytics-log-search-new.md).


Основой Log Analytics является функция поиска по журналам, которая позволяет объединять и сопоставлять данные компьютеров из нескольких источников в существующей среде. Функция поиска журналов также дополняет решения, позволяя получать сводные показатели по определенной проблемной области.

На странице Поиск можно создать запрос, а затем во время поиска отфильтровать результаты с помощью элементов управления аспектами. Можно создать сложные запросы для преобразования и фильтрации результатов, а также для формирования соответствующих отчетов.

Общие запросы поиска журналов отображаются на большинстве страниц решений. В консоли OMS можно щелкнуть плитки или открыть вложенные элементы, чтобы просмотреть сведения о них с помощью функции поиска по журналам.

В этом учебнике мы рассмотрим примеры, охватывающие все основные аспекты использования поиска журналов.

Мы начнем с простых практических примеров, а затем разовьем их, чтобы получить представление о реальных вариантах использования синтаксиса для извлечения нужных ценных сведений из данных.

После ознакомления с методиками поиска рекомендуем изучить [справочник по поиску в журналах Log Analytics](log-analytics-search-reference.md).

## <a name="use-basic-filters"></a>использование базовых фильтров;
Прежде всего, необходимо знать, что первой частью поискового запроса, расположенной перед символом вертикальной черты "|", всегда является *фильтр*. Его можно рассматривать как предложение WHERE в TSQL: он определяет, *какое* подмножество данных следует извлекать из хранилища данных OMS. Поиск в хранилище данных заключается главным образом в указании характеристик данных, которые нужно извлечь, поэтому логично, что запрос будет начинаться с предложения WHERE.

Самыми простыми из доступных фильтров являются *ключевые слова*, такие как "ошибка", "время ожидания" или имя компьютера. Эти типы простых запросов обычно возвращают различные формы данных в рамках одного результирующего набора. Это происходит потому, что Log Analytics использует в системе различные *типы* данных.

### <a name="to-conduct-a-simple-search"></a>Выполнение простого поиска
1. На портале OMS щелкните **Поиск по журналам**.  
    ![плитка поиска](./media/log-analytics-log-searches/oms-overview-log-search.png)
2. В поле запроса введите `error` и нажмите кнопку **Поиск**.  
    ![ошибка поиска](./media/log-analytics-log-searches/oms-search-error.png)  
    Например, запрос для `error` на следующем рисунке вернул 100 000 записей **Event** (собранных функцией управления журналами), 18 записей **ConfigurationAlert** (созданных в ходе оценки конфигурации) и 12 записей **ConfigurationChange** (полученных функцией отслеживания изменений).   
    ![результаты поиска](./media/log-analytics-log-searches/oms-search-results01.png)  

Эти фильтры на самом деле не являются классами и типами объектов. *Type* — это просто тег, свойство, строка, имя или категория, присоединяемые к фрагменту данных. Некоторые документы в системе помечены как **Type:ConfigurationAlert**, другие — как **Type:Perf** или **Type:Event** и т. д. Каждый результат поиска, документ или запись отображает все общие свойства и их значения для каждого из этих фрагментов данных, и вы можете использовать эти имена полей в фильтре, когда необходимо получить только те записи, где поле имеет заданное значение.

*Type* — это просто поле, которое имеет все записи, оно ничем не отличается от любого другого поля. Это было установлено на основе значения поля "Тип". Эта запись будет иметь другую форму. Кстати, синтаксис вида **Type=Perf** или **Type=Event** понадобится вам еще и для запроса событий или данных о производительности.

Между именем поля и значением можно использовать двоеточие (:) или знак равенства (=). **Type:Event** и **Type=Event** имеют одинаковое значение, и вы можете выбрать любой из этих стилей.

Например, если записи с Type=Perf имеют поле с именем CounterName, вы можете написать запрос такого вида: `Type=Perf CounterName="% Processor Time"`.

Это позволит получить только те данные о производительности, где счетчик производительности имеет имя "% Processor Time" (% загруженности процессора).

### <a name="to-search-for-processor-time-performance-data"></a>Поиск данных о производительности по загруженности процессора
* В поле поискового запроса введите `Type=Perf CounterName="% Processor Time"`

Можно указать значение более точно и использовать в запросе элемент **InstanceName=_'Total'**, который представляет собой счетчик производительности Windows. Можно также выбрать другой аспект и другую пару **поле:значение**. Фильтр автоматически добавляется в фильтр в строке запроса. Вы увидите это на следующем рисунке. Там показано, как добавить **InstanceName:’_Total’** в запрос, не вводя никакого текста.

![аспект поиска](./media/log-analytics-log-searches/oms-search-facet.png)

Ваш запрос превращается в `Type=Perf CounterName="% Processor Time" InstanceName="_Total"`

В этом примере нет необходимости указывать **Type=Perf** для получения этого результата. Так как поля CounterName и InstanceName существуют только для записей Type=Perf, запрос является достаточно точным и вернет точно такие же результаты, как и предыдущий, более длинный запрос.

```
CounterName="% Processor Time" InstanceName="_Total"
```

Это происходит потому, что все фильтры в запросе вычисляются так, как если бы они были связаны оператором *И (AND)* . Фактически, чем больше поле вы добавляете в условия, тем менее точные и детальные результаты вы получаете.

Например, запрос `Type=Event EventLog="Windows PowerShell"` идентичен запросу `Type=Event AND EventLog="Windows PowerShell"`. Он возвращает все события, которые были зарегистрированы и собраны из журнала событий Windows PowerShell. Если вы добавляете фильтр несколько раз, выбирая один и тот же аспект, проблема является совершенно формальной — он может загромождать панель поиска, но по-прежнему возвращает те же результаты, так как неявный оператор И всегда присутствует.

Вы можете легко обратить неявный оператор И с помощью явного оператора НЕ (NOT). Например:

Запрос `Type:Event NOT(EventLog:"Windows PowerShell")` или его эквивалент `Type=Event EventLog!="Windows PowerShell"` возвращают все события из всех журналов, которые НЕ являются журналом Windows PowerShell.

Либо можно использовать другой логический оператор, такой как ИЛИ (OR). Следующий запрос возвращает записи, для которых EventLog имеет значение Application ИЛИ System.

```
EventLog=Application OR EventLog=System
```

Используя приведенный выше запрос, вы получаете записи для обоих журналов в одном результирующем наборе.

Однако если удалить оператор ИЛИ, оставив неявный оператор И на месте, то следующий запрос не даст никаких результатов, так как запись журнала событий, относящаяся к обоим журналам, не существует. Каждая запись журнала была записана только в один из двух журналов.

```
EventLog=Application EventLog=System
```


## <a name="use-additional-filters"></a>использование дополнительных фильтров;
Следующий запрос возвращает записи для 2 журналов событий для всех компьютеров, которые отправляли данные.

```
EventLog=Application OR EventLog=System
```

![результаты поиска](./media/log-analytics-log-searches/oms-search-results03.png)

Выбрав одно из полей и один из фильтров, можно будут сузить запрос до конкретного компьютера, исключив при этом все остальные. Результирующий запрос будет выглядеть следующим образом.

```
EventLog=Application OR EventLog=System Computer=SERVER1.contoso.com
```

Это эквивалентно следующему запросу из-за неявного оператора И.

```
EventLog=Application OR EventLog=System AND Computer=SERVER1.contoso.com
```

Каждый запрос вычисляется в следующем явном порядке. Обратите внимание на скобки.

```
(EventLog=Application OR EventLog=System) AND Computer=SERVER1.contoso.com
```

Как и в случае с полем журнала событий, вы можете извлечь данные только для набора определенных компьютеров путем добавления оператора ИЛИ. Например:

```
(EventLog=Application OR EventLog=System) AND (Computer=SERVER1.contoso.com OR Computer=SERVER2.contoso.com OR Computer=SERVER3.contoso.com)
```

Аналогичным образом, этот следующий запрос возвращает значение **% времени ЦП** только для двух выбранных компьютеров.

```
CounterName="% Processor Time"  AND InstanceName="_Total" AND (Computer=SERVER1.contoso.com OR Computer=SERVER2.contoso.com)
```

### <a name="field-types"></a>Типы полей
При создании фильтров следует учитывать особенности работы с разными типами полей, возвращаемых в результатах поиска по журналам.

**Поля, доступные для поиска,** выделены синим цветом в результатах.  Эти поля можно включить в условия поиска по конкретному полю, как показано ниже.

```
Type: Event EventLevelName: "Error"
Type: SecurityEvent Computer:Contains("contoso.com")
Type: Event EventLevelName IN {"Error","Warning"}
```

**Поля с возможностью поиска произвольного текста** выделены серым цветом в результатах поиска.  В отличие от полей, доступных для поиска, их нельзя включить в условия поиска по определенному полю.  Они включаются в поиск только при выполнении запроса по всем полям, как показано ниже.

```
"Error"
Type: Event "Exception"
```


### <a name="boolean-operators"></a>Логические операторы
С помощью полей даты и времени и числовых полей можно выполнить поиск значений с помощью операторов *больше*, *меньше* и *меньше или равно*. На панели поисковых запросов можно использовать простые операторы, такие как >, < , >=, <= , !=.

Можно запросить журнал событий за конкретный период времени. Например, последние 24 часа обозначает следующее мнемоническое выражение.

```
EventLog=System TimeGenerated>NOW-24HOURS
```


#### <a name="to-search-using-a-boolean-operator"></a>Поиск с помощью логического оператора
* В поле поискового запроса введите `EventLog=System TimeGenerated>NOW-24HOURS`  
    ![поиск с логическими операторами](./media/log-analytics-log-searches/oms-search-boolean.png)

Хотя интервалом времени можно управлять графически и в большинстве случаев так и следует поступать, включение фильтра времени непосредственно в запрос дает определенные преимущества. Например, это прекрасно работает с панелями мониторинга, где можно переопределить время для каждой плитки независимо от *глобального* селектора времени на странице панели мониторинга. Дополнительные сведения см. в статье [Time Matters in Dashboard](http://cloudadministrator.wordpress.com/2014/10/19/system-center-advisor-restarted-time-matters-in-dashboard-part-6/) (Аспекты использования времени на панели мониторинга).

При фильтрации по времени помните о том, что вы получите результаты, соответствующие *пересечению* двух периодов: заданного на портале OMS (S1) и в запросе (S2).

![пересечению](./media/log-analytics-log-searches/oms-search-intersection.png)

Это означает, что, если периоды не пересекаются (например, на портале OMS выбрана **текущая неделя**, а в запросе указана **прошлая неделя**), вы не получите никаких результатов.

Операторы сравнения, используемые для поля TimeGenerated, также могут пригодиться и в других ситуациях. Например, для числовых полей.

Предположим, что оповещения оценки конфигурации имеют следующие уровни серьезности:

* 0 = информационный
* 1 = предупреждение
* 2 = критический

С помощью следующего запроса можно запросить предупреждения и критические оповещения, а также исключить информационные оповещения:

```
Type=ConfigurationAlert  Severity>=1
```


Можно также использовать запросы в диапазоне. Это означает, что вы можете задать начало и конец диапазона значений в последовательности. Например, если требуются события из журнала событий Operations Manager, где EventID больше или равен 2100, но не больше 2199, следующий запрос позволит получить их.

```
Type=Event EventLog="Operations Manager" EventID:[2100..2199]
```


> [!NOTE]
> Необходимо использовать синтаксис диапазона, подразумевающий использование в качестве разделителя пары поле:значение двоеточия (:), а *не* знака равенства (=). Заключите нижнюю и верхнюю границу диапазона в квадратные скобки, разделив их двумя точками (..).
>
>

## <a name="manipulate-search-results"></a>работа с результатами поиска;
При поиске данных может потребоваться уточнение поискового запроса и наличие высокого уровня контроля над результатами. При извлечении результатов можно применять команды для их преобразования.

Команды в поиске Log Analytics *обязательно* указываются после символа вертикальной черты (|). Фильтр должен всегда быть первой частью строки запроса. Он определяет набор данных, с которым вы работаете, а затем направляет эти результаты в команду. После этого можно использовать символ черты, чтобы добавить дополнительные команды. Это приблизительно соответствует конвейеру Windows PowerShell.

В целом язык поиска Log Analytics использует стиль и правила PowerShell, чтобы ИТ-специалистам было проще его изучать.

Команды имеют форму глаголов, чтобы можно было легко понять, что именно они делают.  

### <a name="sort"></a>Сортировать
Команда sort позволяет задать порядок сортировки по одному или нескольким полям. Даже если вы не используете ее, по умолчанию применяется сортировка по времени в порядке убывания. Недавние результаты всегда находятся в верхней части результатов поиска. Это означает, что при выполнении поиска с учетом `Type=Event EventID=1234` реально выполняется следующее:

```
Type=Event EventID=1234 **| Sort TimeGenerated desc**
```

Это происходит так, поскольку данная процедура знакома вам по работе с журналами. Например, в средстве просмотра событий Windows.

С помощью команды sort можно изменить способ возврата результатов. Ниже приведены примеры того, как именно это работает.

```
Type=Event EventID=1234 | Sort TimeGenerated asc
```

```
Type=Event EventID=1234 | Sort Computer asc
```

```
Type=Event EventID=1234 | Sort Computer asc,TimeGenerated desc
```


Простые примеры выше показывают работу команды: они изменяют форму результатов, возвращаемых фильтром.

### <a name="limit-and-top"></a>Limit и top
Другой менее известной командой является LIMIT. Эта команда похожа на команды PowerShell. По функциональности Limit аналогична команде TOP. Следующие запросы возвращают одинаковые результаты.

```
Type=Event EventID=600 | Limit 1
```

```
Type=Event EventID=600 | Top 1
```


#### <a name="to-search-using-top"></a>Поиск с использованием команды top
* В поле поискового запроса введите `Type=Event EventID=600 | Top 1`   
    ![поиск лучших результатов](./media/log-analytics-log-searches/oms-search-top.png)

На приведенном выше рисунке показано 358 тыс. записей с EventID=600. Поля, аспекты и фильтры в левой части всегда отображают сведения о результатах, возвращаемых *фильтром* запроса, то есть частью запроса до первой вертикальной черты. Область **Результаты** панели возвращает только 1 последний результат, так как команда в примере изменила форму результатов и преобразовала их.

### <a name="select"></a>Выберите пункт
Команда SELECT похожа на команду Select-Object в PowerShell. Она возвращает отфильтрованные результаты, имеющие не все свои первоначальные свойства. Вместо этого она выбирает только заданные вами свойства.

#### <a name="to-run-a-search-using-the-select-command"></a>Выполнение поиска с помощью команды select
1. В поле поиска введите `Type=Event` и нажмите кнопку **Поиск**.
2. Щелкните **+ Дополнительно** в одном из результатов, чтобы просмотреть все свойства, которые имеют результаты.
3. Выберите некоторые из них явным образом, и запрос изменяется на `Type=Event | Select Computer,EventID,RenderedDescription`.  
    ![поиск с помощью select](./media/log-analytics-log-searches/oms-search-select.png)

Это команда особенно полезна, когда требуется управлять выходными данными поиска и отбирать из всего набора записей только те блоки данных, которые важны для анализа. Это также полезно, когда записи различных типов имеют *несколько* общих свойств, но не *все* их свойства являются общими. Вы можете формировать выходные данные, которые имеют более привычный вид таблицы или более удобны для экспорта в CSV-файл и последующей обработки в Excel.

## <a name="use-the-measure-command"></a>использование команды measure;
MEASURE является одной из наиболее универсальных команд в поиске Log Analytics. Она позволяет применять статистические *функции* к данным и статистически обрабатывать данные, сгруппированные по заданному полю. Существует несколько статистических функций, поддерживаемых командой Measure.

### <a name="measure-count"></a>Measure count()
Первой и наиболее простой в использовании статистической функцией является функция *count()* .

В левой части результатов любого поискового запроса, например `Type=Event`, отображаются фильтры, которые также называются аспектами. Эти фильтры показывают распределение значений по заданному полю для результатов выполненного поиска.

![поиск с помощью measure count](./media/log-analytics-log-searches/oms-search-measure-count01.png)

Например, на приведенном выше рисунке видно поле **Computer**, показывающее, что в рамках почти 739 тыс. событий в результатах присутствует 68 уникальных и не совпадающих значений для поля **Computer**. На плитке отображаются только 5 лучших значений, которые наиболее часто записываются в поля **Computer**, с сортировкой по количеству документов, содержащих именно это значение в данном поле. На рисунке видно, что среди почти 369 тыс. событий 90 тыс. поступают с компьютера OpsInsights04.contoso.com, 83 тыс. — с компьютера DB03.contoso.com и т. д.

Что делать, если вы хотите просмотреть все значения, а не только 5 лучших значений на плитке?

Для этого вместе с командой measure можно применить функцию count(). Эта функция не использует никаких параметров. Просто укажите поле, по которому требуется выполнить группировку, в данном случае это поле **Computer** :

`Type=Event | Measure count() by Computer`

![поиск с помощью measure count](./media/log-analytics-log-searches/oms-search-measure-count-computer.png)

Однако **Computer** — это просто поле, используемое *в* каждом фрагменте данных. Нет никаких реляционных баз данных и никакого отдельного объекта **Computer**. Только значения *в* данных могут описывать, какая сущность создала их, а также ряд других характеристик и аспектов данных, — отсюда мы и получаем термин *аспект*. Однако вы точно так же можете выполнять группировку по другим полям. Так как исходные результаты почти 739 тыс. событий, переданных в команду measure, также имеют поле с именем **EventID**, можно применить ту же методику для группировки по этому полю и получить количество событий по EventID:

```
Type=Event | Measure count() by EventID
```

Если вас не интересует реальное число записей, содержащих определенное значение, а требуется только список самих значений, можно добавить в конец команду *Select* и просто выбрать первый столбец:

```
Type=Event | Measure count() by EventID | Select EventID
```

После этого можно усложнить запрос и предварительно отсортировать результаты в нем или просто щелкнуть столбцы в сетке.

```
Type=Event | Measure count() by EventID | Select EventID | Sort EventID asc
```

#### <a name="to-search-using-measure-count"></a>Поиск с использованием measure count
* В поле поискового запроса введите `Type=Event | Measure count() by EventID`
* Добавьте `| Select EventID` в конец запроса.
* Затем добавьте `| Sort EventID asc` в конец запроса.

Существует несколько важных моментов, на которые следует обратите внимание.

Во-первых, отображаемые результаты больше не являются исходными необработанными результатами. Вместо этого они являются агрегированными результатами, то есть группами результатов. Это не представляет проблемы, однако следует понимать, что взаимодействие осуществляется совершенно с иной формой данных, которая отличается от исходной необработанной формы, создаваемой в режиме реального времени в результате статистической обработки или применения статистической функции.

Во-вторых, в настоящее время **Measure count** возвращает только 100 лучших несовпадающих результатов. Это ограничение не применяется к другим статистическим функциям. Поэтому обычно перед применением measure count() сначала требуется использовать более точный фильтр для поиска определенных элементов.

## <a name="use-the-max-and-min-functions-with-the-measure-command"></a>использование функций max и min с командой measure;
Существуют различные сценарии, где использование **Measure Max()** и **Measure Min()** имеет смысл. Однако поскольку каждая функция является противоположностью другой, мы опишем Max(), а с Min() вы сможете поэкспериментировать самостоятельно.

При запросе событий системы безопасности они имеют свойство **Level**, которое может изменяться. Например:

```
Type=SecurityEvent
```

![начало поиска с помощью measure count](./media/log-analytics-log-searches/oms-search-measure-max01.png)

Если вы хотите просмотреть наибольшее значение для всех событий системы безопасности, которым назначено общее поле Computer, с группировкой по полю, можно использовать следующий код:

```
Type=ConfigurationAlert | Measure Max(Level) by Computer
```

![поиск с помощью measure max по computer](./media/log-analytics-log-searches/oms-search-measure-max02.png)

Он покажет, что большинство компьютеров, имевших записи **Level**, имеют по крайней мере уровень 8, а многие из них — уровень 16.

```
Type=ConfigurationAlert | Measure Max(Severity) by Computer
```

![поиск с помощью measure max для времени создания по computer](./media/log-analytics-log-searches/oms-search-measure-max03.png)

Эта функция хорошо работает с числами, однако она также работает с полями типа DateTime. Это полезно, когда требуется проверить самую последнюю или недавнюю метку времени для любого фрагмента данных, индексируемых для каждого компьютера. Например, когда поступило сообщение о последнем событии системы безопасности для каждого компьютера?

```
Type=ConfigurationChange | Measure Max(TimeGenerated) by Computer
```

## <a name="use-the-avg-function-with-the-measure-command"></a>использование функции avg с командой measure;
Статистическая функция Avg(), используемая с командой measure, позволяет вычислить среднее значение для некоторого поля, группируя результаты по тому же или другому полю. Это оказывается полезным в самых различных случаях, например в случае с данными о производительности.

Мы начнем с данных о производительности. Обратите внимание, что OMS в настоящее время собирает счетчики производительности для машин Windows и Linux.

Самый простой запрос для поиска *всех* данных о производительности имеет следующий вид:

```
Type=Perf
```

![начало поиска с помощью avg](./media/log-analytics-log-searches/oms-search-avg01.png)

Первое, что вы заметите, — это то, что в Log Analytics отображаются три представления: список, который содержит фактические записи, лежащие в основе диаграмм, таблица, которая показывает табличное представление данных счетчика производительности, и метрики, которые отображают графики для счетчиков производительности.

На рисунке выше помечено два набора полей, которые обозначают следующее.

* Первый набор определяет имя счетчика производительности Windows, имя объекта и имя экземпляра в фильтре запроса. Это поля, которые вы, вероятно, будете использовать в качестве аспектов и фильтров чаще всего.
* **CounterValue** — это фактическое значение счетчика. В этом примере используется значение *75*.
* **TimeGenerated** имеет значение 12:51 в 24-часовом формате.

Ниже приводится представление метрик на графике.

![начало поиска с помощью avg](./media/log-analytics-log-searches/oms-search-avg02.png)

После ознакомления с формой записи Perf и другими методиками поиска вы сможете использовать функцию measure Avg() для статистической обработки числовых данных этого типа.

Ниже приведен простой пример.

```
Type=Perf  ObjectName:Processor  InstanceName:_Total  CounterName:"% Processor Time" | Measure Avg(CounterValue) by Computer
```

![поиска с помощью avg по samplevalue](./media/log-analytics-log-searches/oms-search-avg03.png)

В этом примере вы выбираете счетчик производительности CPU Total Time (Общее время ЦП) и получаете среднее значение по полю Computer. Если требуется ограничить результаты, например отображать данные только за последние 6 часов, можно использовать элемент управления фильтра времени или включить это условие в запрос следующим образом:

```
Type=Perf  ObjectName:Processor  InstanceName:_Total  CounterName:"% Processor Time" TimeGenerated>NOW-6HOURS | Measure Avg(CounterValue) by Computer
```

### <a name="to-search-using-the-avg-function-with-the-measure-command"></a>Поиска с использованием функции avg с командой measure
* В поле поиска введите `Type=Perf  ObjectName:Processor  InstanceName:_Total  CounterName:"% Processor Time" TimeGenerated>NOW-6HOURS | Measure Avg(CounterValue) by Computer`.

Можно объединять и сопоставлять данные *по* разным компьютерам. Например, предположим, что имеется набор узлов в некоторой ферме, где каждый узел совпадает с любым другим узлом и они выполняют одинаковую работу, а также требуется грубая балансировка нагрузки. Вы можете собрать все счетчики за один проход с помощью следующего запроса и получить средние значения для всей фермы. Для начала можно выбрать компьютеры, используя следующий пример:

```
Type=Perf AND (Computer="AzureMktg01" OR Computer="AzureMktg02" OR Computer="AzureMktg03")
```

Теперь, когда вы получили компьютеры, вам требуется выбрать всего два ключевых показателя эффективности (KPI): "% CPU Usage" (% загрузки ЦП) и "% Free Disk Space" (% свободного места на диске). Таким образом, запрос принимает следующий вид:

```
Type=Perf InstanceName:_Total  ((ObjectName:Processor AND CounterName:"% Processor Time") OR (ObjectName="LogicalDisk" AND CounterName="% Free Space")) AND TimeGenerated>NOW-4HOURS
```

Теперь можно добавить компьютеры и счетчики, как показано в следующем примере:

```
Type=Perf InstanceName:_Total  ((ObjectName:Processor AND CounterName:"% Processor Time") OR (ObjectName="LogicalDisk" AND CounterName="% Free Space")) AND TimeGenerated>NOW-4HOURS AND (Computer="AzureMktg01" OR Computer="AzureMktg02" OR Computer="AzureMktg03")
```

Благодаря выбору конкретных элементов команда **measure Avg()** позволяет возвратить среднее значение не для компьютера, а для всей фермы путем группирования по CounterName. Например:

```
Type=Perf  InstanceName:_Total  ((ObjectName:Processor AND CounterName:"% Processor Time") OR (ObjectName="LogicalDisk" AND CounterName="% Free Space")) AND TimeGenerated>NOW-4HOURS AND (Computer="AzureMktg01" OR Computer="AzureMktg02" OR Computer="AzureMktg03") | Measure Avg(CounterValue) by CounterName
```

Это позволяет получить удобное компактное представление с парой ключевых показателей эффективности вашей среды.

![группировка поиска с помощью avg](./media/log-analytics-log-searches/oms-search-avg04.png)

На панели мониторинга можно использовать поисковый запрос. Например, можно сохранить поисковый запрос и создать на его основе панель мониторинга *Web Farm KPIs* (Ключевые показатели эффективности веб-фермы). Дополнительные сведения об использовании панелей мониторинга см. в статье [Создание пользовательской панели мониторинга в Log Analytics](log-analytics-dashboards.md).

![панель мониторинга поиска с помощью avg](./media/log-analytics-log-searches/oms-search-avg05.png)

### <a name="use-the-sum-function-with-the-measure-command"></a>Использование функции sum с командой measure
Функция sum аналогична другим функциям команды measure. Пример использования функции sum см. в разделе [W3C IIS Logs Search in Microsoft Azure Operational Insights](http://blogs.msdn.com/b/dmuscett/archive/2014/09/20/w3c-iis-logs-search-in-system-center-advisor-limited-preview.aspx) (Поиск в журналах W3C IIS в компоненте оперативной аналитики Microsoft Azure).

Функции Max() и Min() можно использовать с числами, датой и временем, а также с текстовыми строками. Текстовые строки сортируются в алфавитном порядке, и вы получаете первую и последнюю сроку.

Однако функцию Sum() можно использовать только с числовыми полями. Это также касается и функции Avg().

### <a name="use-the-percentile-function-with-the-measure-command"></a>Использование функции percentile с командой measure
Функция вычисления процентиля используется так же, как Avg() и Sum(), то есть только для числовых полей. Для числового поля можно применить любой процентиль в диапазоне от 1 до 99. Можно использовать оба варианта команды: **percentile** и **pct**. Рассмотрим несколько примеров.  

```
Type:Perf CounterName:"DiskTransers/sec" |measure percentile95(CurrentValue) by Computer
```
```
Type:Perf ObjectName=LogicalDisk CounterName="Current Disk Queue Length" Computer="MyComputerName" | measure pct65(CurrentValue) by InstanceName
```

## <a name="use-the-where-command"></a>использование команды where.
Команда where работает как фильтр, но ее можно применить в конвейере для дальнейшей фильтрации сводных результатов, полученных с помощью команды Measure, в отличие от необработанных результатов, которые фильтруются в начале запроса.

Например:

```
Type=Perf  CounterName="% Processor Time"  InstanceName="_Total" | Measure Avg(CounterValue) as AVGCPU by Computer
```

Можно добавить еще один символ вертикальной черты "|" и команду WHERE, чтобы выбрать только те компьютеры, на которых средняя загрузка ЦП превышает 80 %, как показано в следующем примере:

```
Type=Perf  CounterName="% Processor Time"  InstanceName="_Total" | Measure Avg(CounterValue) as AVGCPU by Computer | Where AVGCPU>80
```

Если вы знакомы с Microsoft System Center Operations Manager, команду where можно определить в терминах пакета управления. Если бы данный пример являлся правилом, первая часть запроса была бы источником данных, а команда where была бы определением условия.

Этот запрос можно использовать в качестве плитки в окне **Моя панель мониторинга**, позволяющей отслеживать чрезмерную загрузку ЦП компьютера. Дополнительные сведения о панелях мониторинга см. в статье [Создание пользовательской панели мониторинга в Log Analytics](log-analytics-dashboards.md). Вы также можете создавать и использовать панели мониторинга с помощью мобильного приложения. Дополнительные сведения вы найдете в описании [мобильного приложения OMS](http://www.windowsphone.com/en-us/store/app/operational-insights/4823b935-83ce-466c-82bb-bd0a3f58d865). На двух нижних плитках на следующем изображении представлен монитор, отображающий список и число. В большинстве случаев желательно, чтобы это число было равным нулю, а список был пуст. Иное состояние указывает на наличие условия предупреждения. При необходимости его можно использовать для просмотра компьютеров с высокой загрузкой.

![панель мониторинга на мобильном устройстве](./media/log-analytics-log-searches/oms-search-mobile.png)

## <a name="use-the-in-operator"></a>Использование оператора IN
Оператор *IN* и противоположный ему оператор *NOT IN* позволяют использовать вложенный поиск, то есть передавать результаты поиска в качестве аргумента в другой поисковый запрос. Такой поисковый запрос заключается в фигурные скобки {} внутри другого поискового запроса, который называется *основным* или *внешним*. Результат вложенного поискового запроса, обычно представленный в виде списка значений, используется как аргумент в основном поисковом запросе.

Вложенный поисковый запрос удобно использовать для сопоставления подмножества данных, которое невозможно описать непосредственно в выражении поиска, но можно получить с помощью поискового запроса. Например, если вы хотите найти все события, поступившие от *компьютеров, на которых не установлены обновления безопасности*, то сначала нужно составить вложенный поисковый запрос, который определит все *компьютеры, на которых не установлены обновления безопасности*, а затем выполнить поиск событий на этих узлах.

Составить список всех *компьютеров, на которых не установлены обновления безопасности* , можно с помощью такого запроса:

```
Type:Update UpdateState=Needed Optional=false Classification="Security Updates" TimeGenerated>NOW-24HOURS | measure count() by Computer
```    

![пример поиска с оператором IN](./media/log-analytics-log-searches/oms-search-in01-revised.png)

Теперь вы получили нужный список и можете использовать созданный запрос как внутренний поиск для передачи этого списка компьютеров во внешний (основной) поисковый запрос, который будет искать события для этих компьютеров. Для этого внутренний поиск заключается в фигурные скобки, а его результаты передаются во внешний поиск в качестве допустимых значений определенного фильтра (поля) с помощью оператора IN. Запрос будет выглядеть примерно так:

```
Type=Event Computer IN {Type:Update UpdateState=Needed Optional=false Classification="Security Updates" TimeGenerated>NOW-24HOURS | measure count() by Computer}
```
![пример поиска с оператором IN](./media/log-analytics-log-searches/oms-search-in02-revised.png)

Обратите особое внимание на фильтр времени во внутреннем поисковом запросе. Он нужен потому, что компонент оценки системных обновлений создает моментальный снимок всех компьютеров каждые 24 часа. Внутренний запрос будет более легким и точным, если выполнять поиск только за один день. Во внешнем же поиске используется параметр выбора времени, установленный в пользовательском интерфейсе, то есть события отбираются за последние 7 дней. Подробные сведения об операторах времени см. в разделе [Логические операторы](#boolean-operators).

Результаты внутреннего поиска используются только в качестве фильтра для внешнего поиска, поэтому сохраняется возможность использовать для внешнего поиска дополнительные команды. Например, полученные выше события можно сгруппировать с помощью другой команды measure:

```
Type=Event Computer IN {Type:Update UpdateState=Needed Optional=false Classification="Security Updates" TimeGenerated>NOW-24HOURS | measure count() by Computer} | measure count() by Source
```

![пример поиска с оператором IN](./media/log-analytics-log-searches/oms-search-in03-revised.png)

Обычно требуется, чтобы внутренний запрос выполнялся быстро, так как Log Analytics устанавливает на стороне службы ограничения на время ожидания. Также важно, чтобы количество возвращаемых результатов было небольшим. Если внутренний запрос возвращает много результатов, этот список будет обрезан и в итоге результаты внешнего поиска могут быть неправильными.

Еще одно правило, которое действует в отношении внутреннего поиска: он должен возвращать *агрегированные* результаты. Другими словами, в нем должна содержаться команда *measure*. Необработанные результаты пока нельзя передавать во внешний поиск.

Кроме того, в нем может существовать только один оператор IN, и он должен быть последним фильтром в запросе. Не допускается объединение нескольких операторов IN с помощью OR. Таким образом, невозможно создать цепочку внутренних поисков — для каждого внешнего поиска возможен только один внутренний поиск.

Но даже с учетом этих ограничений оператор IN позволяет выполнять множество видов связанных поисков, а также создавать своего рода группы (компьютеров, пользователей, файлов и т. п., в зависимости от содержимого ваших данных). Ниже приведены некоторые примеры.

**Все обновления, отсутствующие на компьютерах, где отключен параметр автоматического обновления.**

```
Type=Update UpdateState=Needed Optional=false Computer IN {Type=UpdateSummary WindowsUpdateSetting=Manual | measure count() by Computer} | measure count() by KBID
```

**Все события ошибок для компьютеров, на которых работает SQL Server (то есть тех, где выполнялась оценка SQL).**

```
Type=Event EventLevelName=error Computer IN {Type=SQLAssessmentRecommendation | measure count() by Computer}
```

**Все события безопасности для компьютеров, являющихся контроллерами домена (то есть тех, где выполнялась оценка AD).**

```
Type=SecurityEvent Computer IN { Type=ADAssessmentRecommendation | measure count() by Computer }
```

**С какими еще учетными записями выполнялся вход на те компьютеры, на которых использовалась учетная запись BACONLAND\jochan?**

```
Type=SecurityEvent EventID=4624   Account!="BACONLAND\\jochan" Computer IN { Type=SecurityEvent EventID=4624   Account="BACONLAND\\jochan" | measure count() by Computer } | measure count() by Account
```

## <a name="use-the-distinct-command"></a>Использование команды distinct
Эта команда позволяет получить список уникальных значений для поля. Несмотря на простоту команды, она весьма полезна. Аналогичные результаты можно получить с помощью команды measure count(), как показано ниже.

```
Type=Event | Measure count() by Computer
```

![пример команды поиска DISTINCT](./media/log-analytics-log-searches/oms-search-distinct01-revised.png)

Но если вам нужен только список уникальных значений, а не число документов с каждым из этих значений, команда DISTINCT будет более правильным выбором. Она предоставляет более простой и понятный формат вывода, а также использует более короткий синтаксис, как показано ниже.

```
Type=Event | Distinct Computer
```
![пример команды поиска DISTINCT](./media/log-analytics-log-searches/oms-search-distinct02-revised.png)

## <a name="use-the-countdistinct-function-with-the-measure-command"></a>Использование функции countdistinct с командой measure
Функция countdistinct подсчитывает количество уникальных значений в каждой группе. Например, так можно подсчитать число уникальных компьютеров, создающих отчеты каждого типа.

```
* | measure countdistinct(Computer) by Type
```

![OMS-countdistinct](./media/log-analytics-log-searches/oms-countdistinct.png)

## <a name="use-the-measure-interval-command"></a>Использование команды measure interval
Log Analytics собирает данные практически в режиме реального времени, что позволяет собирать и наглядно отображать почти любой счетчик производительности. Просто введите запрос **Type: Perf** , и вы получите тысячи диаграмм для метрик в зависимости от числа счетчиков и серверов в вашей среде Log Analytics. Агрегирование метрик по требованию позволяет получить высокоуровневую оценку метрик в вашей среде или более подробно изучить наиболее интересные данные.

Предположим, вы хотите узнать среднюю загрузку ЦП на всех компьютерах. Изучение средних значений загрузки ЦП для каждого компьютера не всегда будет полезным, так как эти результаты сглаживаются. Чтобы изучить вопрос более подробно, вы можете объединить информацию за более короткие отрезки времени, а затем изучить эту последовательность в различных представлениях. Например, так вы можете получить почасовую оценку средней загрузки ЦП по всем компьютерам:

```
Type:Perf CounterName="% Processor Time" InstanceName="_Total" | measure avg(CounterValue) by Computer Interval 1HOUR
```

![measure average interval](./media/log-analytics-log-searches/oms-measure-avg-interval.png)

По умолчанию эти результаты будут отображаться в виде интерактивного графика с несколькими рядами данных.  Этот график поддерживает переключение рядов (с масштабированием по оси y), масштабирование и подсказки при наведении указателя мыши.  При необходимости вы всегда можете отобразить необработанные данные в табличном виде.

Также можно сгруппировать результаты по другим полям. В этом примере мы получаем все процентные счетчики для одного конкретного компьютера и отбираем почасовые 70-е процентили по каждому счетчику.

```
Type:Perf Computer=beefpatty4 CounterName=%* InstanceName=_Total | measure percentile70(CounterValue) by CounterName Interval 1HOUR
```
Следует заметить, что такие запросы возможны не только для счетчиков производительности. Их можно применить к любой метрике. В этом примере выполняется просмотр журналов W3C IIS. Мы хотим узнать максимальное время, затрачиваемое на обработку каждого запроса за 5-минутные интервалы.

```
Type:W3CIISLog | measure max(TimeTaken) by csMethod Interval 5MINUTES
```

### <a name="use-multiple-aggregates-in-one-query"></a>Использование нескольких статистических выражений в одном запросе
Для команды measure можно указать несколько статистических выражений.  Каждому из них можно присвоить отдельный псевдоним.  Если вы не укажете псевдоним, в качестве имени итогового столбца будет использоваться имя соответствующей статистической функции (например, avg(CounterValue) для функции avg(CounterValue)).

 ```
Type=WireData | measure avg(ReceivedBytes), avg(SentBytes) by Direction interval 1hour
```
![OMS-multiaggregates1](./media/log-analytics-log-searches/oms-multiaggregates1.png)

Вот еще один пример:

 ```
* | measure countdistinct(Computer) as Computers, count() as TotalRecords by Type
```


## <a name="next-steps"></a>Дальнейшие действия
Дополнительные сведения о поиске по журналам можно получить в следующих статьях.

* Чтобы расширить возможности поиска по журналам, см. статью [Настраиваемые поля в службе Log Analytics](log-analytics-custom-fields.md).
* Полный список полей и аспектов для поиска, доступных в Log Analytics, см. в [справочнике по поиску в журналах Log Analytics](log-analytics-search-reference.md).
