---
title: "Общие сведения о неявном потоке предоставления OAuth2 в Azure AD | Документация Майкрософт"
description: "Узнайте о процессе неявного потока предоставления OAuth2 в Azure Active Directory и его совместимости с вашим приложением."
services: active-directory
documentationcenter: dev-center-name
author: jmprieur
manager: mbaldwin
editor: 
ms.assetid: 90e42ff9-43b0-4b4f-a222-51df847b2a8d
ms.service: active-directory
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: identity
ms.date: 11/15/2016
ms.author: jmprieur
ms.custom: aaddev
ms.openlocfilehash: 241c744737515ee0c8d5d833a51121808877e559
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2017
---
# <a name="understanding-the-oauth2-implicit-grant-flow-in-azure-active-directory-ad"></a><span data-ttu-id="863aa-103">Общие сведения о неявном потоке предоставления OAuth2 в Azure Active Directory (AD)</span><span class="sxs-lookup"><span data-stu-id="863aa-103">Understanding the OAuth2 implicit grant flow in Azure Active Directory (AD)</span></span>
<span data-ttu-id="863aa-104">В спецификации OAuth2 неявное предоставление OAuth2 известно по наибольшему количеству проблем, связанных с безопасностью.</span><span class="sxs-lookup"><span data-stu-id="863aa-104">The OAuth2 implicit grant is notorious for being the grant with the longest list of security concerns in the OAuth2 specification.</span></span> <span data-ttu-id="863aa-105">Но именно этот подход, реализуемый с использованием библиотеки аутентификации Active Directory для JavaScript, рекомендуется использовать при написании одностраничных приложений.</span><span class="sxs-lookup"><span data-stu-id="863aa-105">And yet, that is the approach implemented by ADAL JS and the one we recommend when writing SPA applications.</span></span> <span data-ttu-id="863aa-106">Что это дает?</span><span class="sxs-lookup"><span data-stu-id="863aa-106">What gives?</span></span> <span data-ttu-id="863aa-107">Все зависит от преимуществ: неявное предоставление лучше всего подходит для приложений, которые используют веб-API через JavaScript в браузере.</span><span class="sxs-lookup"><span data-stu-id="863aa-107">It’s all a matter of tradeoffs: and as it turns out, the implicit grant is the best approach you can pursue for applications that consume a Web API via JavaScript from a browser.</span></span>

## <a name="what-is-the-oauth2-implicit-grant"></a><span data-ttu-id="863aa-108">Что такое неявное предоставление OAuth2</span><span class="sxs-lookup"><span data-stu-id="863aa-108">What is the OAuth2 implicit grant?</span></span>
<span data-ttu-id="863aa-109">По своей сути [предоставление кода авторизации OAuth2](https://tools.ietf.org/html/rfc6749#section-1.3.1) предусматривает использование двух отдельных конечных точек.</span><span class="sxs-lookup"><span data-stu-id="863aa-109">The quintessential [OAuth2 authorization code grant](https://tools.ietf.org/html/rfc6749#section-1.3.1) is the authorization grant which uses two separate endpoints.</span></span> <span data-ttu-id="863aa-110">Конечная точка авторизации используется на этапе взаимодействия с пользователем для получения кода авторизации.</span><span class="sxs-lookup"><span data-stu-id="863aa-110">The authorization endpoint is used for the user interaction phase, which results in an authorization code.</span></span> <span data-ttu-id="863aa-111">Затем клиент использует конечную точку маркера для обмена этого кода на маркер доступа, а часто еще и маркер обновления.</span><span class="sxs-lookup"><span data-stu-id="863aa-111">The token endpoint is then used by the client for exchanging the code for an access token, and often a refresh token as well.</span></span> <span data-ttu-id="863aa-112">Чтобы подключится к конечной точке маркера, для веб-приложений требуются собственные учетные данные. Они позволяют клиенту пройти проверку подлинности на сервере авторизации.</span><span class="sxs-lookup"><span data-stu-id="863aa-112">Web applications are required to present their own application credentials to the token endpoint, so that the authorization server can authenticate the client.</span></span>

<span data-ttu-id="863aa-113">[Неявное предоставление OAuth2](https://tools.ietf.org/html/rfc6749#section-1.3.2) — это один из типов предоставления авторизации.</span><span class="sxs-lookup"><span data-stu-id="863aa-113">The [OAuth2 implicit grant](https://tools.ietf.org/html/rfc6749#section-1.3.2) is a variant of other authorization grants.</span></span> <span data-ttu-id="863aa-114">Он позволяет клиенту получить маркер доступа (а при использовании [OpenId Connect](http://openid.net/specs/openid-connect-core-1_0.html) — маркер id_token) напрямую из конечной точки авторизации без взаимодействия с конечной точкой маркера и без проверки подлинности для клиента.</span><span class="sxs-lookup"><span data-stu-id="863aa-114">It allows a client to obtain an access token (and id_token, when using [OpenId Connect](http://openid.net/specs/openid-connect-core-1_0.html)) directly from the authorization endpoint, without contacting the token endpoint nor authenticating the client.</span></span> <span data-ttu-id="863aa-115">Этот вариант разработан специально для приложений на основе JavaScript, работающих в веб-браузере. По стандартной спецификации OAuth2 маркеры возвращаются в виде фрагмента универсального кода ресурса (URI).</span><span class="sxs-lookup"><span data-stu-id="863aa-115">This variant was specifically designed for JavaScript based applications running in a Web browser: in the original OAuth2 specification, tokens are returned in a URI fragment.</span></span> <span data-ttu-id="863aa-116">Это обеспечивает доступность маркеров для кода JavaScript в клиенте, но гарантирует, что они не будут перенаправляться на сервер.</span><span class="sxs-lookup"><span data-stu-id="863aa-116">That makes the token bits available to the JavaScript code in the client, but it guarantees they won’t be included in redirects toward the server.</span></span> <span data-ttu-id="863aa-117">Возврат маркеров через браузер позволяет перенаправлять пользователя сразу из конечной точки авторизации.</span><span class="sxs-lookup"><span data-stu-id="863aa-117">Returning tokens via browser redirects directly from the authorization endpoint.</span></span> <span data-ttu-id="863aa-118">Также этот вариант удобен тем, что избавляет от любых междоменных вызовов, которые необходимы при обращении приложения JavaScript к конечной точке маркера.</span><span class="sxs-lookup"><span data-stu-id="863aa-118">It also has the advantage of eliminating any requirements for cross origin calls, which are necessary if the JavaScript application is required to contact the token endpoint.</span></span>

<span data-ttu-id="863aa-119">Важной характеристикой неявного предоставления OAuth2 является то, что такие потоки никогда не возвращают маркеры обновления в клиент.</span><span class="sxs-lookup"><span data-stu-id="863aa-119">An important characteristic of the OAuth2 implicit grant is the fact that such flows never return refresh tokens to the client.</span></span> <span data-ttu-id="863aa-120">Как мы увидим в следующем разделе, для этого нет необходимости. Кроме того, это может служить причиной проблем с безопасностью.</span><span class="sxs-lookup"><span data-stu-id="863aa-120">As we will see in the next section, that isn’t really necessary and would in fact be a security issue.</span></span>

## <a name="suitable-scenarios-for-the-oauth2-implicit-grant"></a><span data-ttu-id="863aa-121">Подходящие сценарии для неявного предоставления OAuth2</span><span class="sxs-lookup"><span data-stu-id="863aa-121">Suitable scenarios for the OAuth2 implicit grant</span></span>
<span data-ttu-id="863aa-122">Как указано в самой спецификации OAuth2, неявное предоставление разработано для поддержки приложений агента пользователя, то есть выполняемых в браузере приложений JavaScript.</span><span class="sxs-lookup"><span data-stu-id="863aa-122">As the OAuth2 specification itself declares, the implicit grant has been devised to enable user-agent applications – that is to say, JavaScript applications executing within a browser.</span></span> <span data-ttu-id="863aa-123">Определяющей характеристикой таких приложений является использование кода JavaScript для доступа к ресурсам сервера (обычно к веб-API) и для обновления интерфейса приложения.</span><span class="sxs-lookup"><span data-stu-id="863aa-123">The defining characteristic of such applications is that JavaScript code is used for accessing server resources (typically a Web API) and for updating the application UX accordingly.</span></span> <span data-ttu-id="863aa-124">Рассмотрим такие приложения, как Gmail или Outlook Web Access. При выборе входящего сообщения, чтобы отобразить новое выделение, изменяется только область визуализации, в то время как остальная часть страницы остается неизменной.</span><span class="sxs-lookup"><span data-stu-id="863aa-124">Think of applications like Gmail or Outlook Web Access: when you select a message from your inbox, only the message visualization panel changes to display the new selection, while the rest of the page remains unmodified.</span></span> <span data-ttu-id="863aa-125">В этом заключается их отличие от традиционных веб-приложений на основе перенаправления, в которых при каждом действии пользователя выполняется обратная передача всей страницы и полная отрисовка нового ответа сервера.</span><span class="sxs-lookup"><span data-stu-id="863aa-125">This is in contrast with traditional redirect-based Web apps, where every user interaction results in a full page postback and a full page rendering of the new server response.</span></span>

<span data-ttu-id="863aa-126">Приложения, в которых концепция JavaScript используется наиболее полно, называются одностраничными. Такие приложения передают только начальную HTML-страницу и связанный с ней объект JavaScript, а все последующие операции выполняются в виде вызовов веб-API через JavaScript.</span><span class="sxs-lookup"><span data-stu-id="863aa-126">Applications that take the JavaScript based approach to its extreme are called Single Page Applications, or SPAs: the idea is that those applications only serve an initial HTML page and associated JavaScript, with all subsequent interactions being driven by Web API calls performed via JavaScript.</span></span> <span data-ttu-id="863aa-127">Но нередко используются и гибридные методы, когда приложение в основном выполняет обратную передачу, а иногда — отдельные вызовы через JavaScript. Информация об использовании неявного потока применима и для таких приложений.</span><span class="sxs-lookup"><span data-stu-id="863aa-127">However, hybrid approaches, where the application is mostly postback-driven but performs occasional JS calls, are not uncommon – the discussion about implicit flow usage is relevant for those as well.</span></span>

<span data-ttu-id="863aa-128">Приложения на основе перенаправления традиционно защищают свои запросы с помощью файлов cookie, но этот метод не очень хорошо подходит для приложений JavaScript.</span><span class="sxs-lookup"><span data-stu-id="863aa-128">Redirect-based applications typically secure their requests via cookies, however, that approach does not work as well for JavaScript applications.</span></span> <span data-ttu-id="863aa-129">Файлы cookie действуют только для того домена, в котором они были созданы, тогда как вызовы JavaScript могут направляться и в другие домены.</span><span class="sxs-lookup"><span data-stu-id="863aa-129">Cookies only work against the domain they have been generated for, while JavaScript calls might be directed toward other domains.</span></span> <span data-ttu-id="863aa-130">И такая ситуация возникает довольно часто, например, для любых приложений, которые вызывают API-интерфейсы Microsoft Graph, Office или Azure. Все эти службы интерфейсов расположены за пределами домена, из которого получено приложение.</span><span class="sxs-lookup"><span data-stu-id="863aa-130">In fact, that will frequently be the case: think of applications invoking Microsoft Graph API, Office API, Azure API – all residing outside the domain from where the application is served.</span></span> <span data-ttu-id="863aa-131">Все чаще в приложениях JavaScript не бывает интерфейса, а для реализации бизнес-функций полностью используются сторонние веб-API.</span><span class="sxs-lookup"><span data-stu-id="863aa-131">A growing trend for JavaScript applications is to have no backend at all, relying 100% on 3rd party Web APIs to implement their business function.</span></span>

<span data-ttu-id="863aa-132">В настоящее время для защиты вызовов к веб-API рекомендуется использовать токены носителя OAuth2, которые прилагаются к каждому вызову интерфейса.</span><span class="sxs-lookup"><span data-stu-id="863aa-132">Currently, the preferred method of protecting calls to a Web API is to use the OAuth2 bearer token approach, where every call is accompanied by an OAuth2 access token.</span></span> <span data-ttu-id="863aa-133">Веб-API проверяет входящий маркер доступа и предоставляет доступ к запрошенной операции, если соблюдены все необходимые условия.</span><span class="sxs-lookup"><span data-stu-id="863aa-133">The Web API examines the incoming access token and, if it finds in it the necessary scopes, it grants access to the requested operation.</span></span> <span data-ttu-id="863aa-134">Неявный поток предоставляет приложениям JavaScript удобный механизм получения маркеров доступа для веб-API, а также множество преимуществ по сравнению с использованием файлов cookie.</span><span class="sxs-lookup"><span data-stu-id="863aa-134">The implicit flow provides a convenient mechanism for JavaScript applications to obtain access tokens for a Web API, offering numerous advantages in respect to cookies:</span></span>

* <span data-ttu-id="863aa-135">Маркеры можно получать безопасно, не выполняя междоменные вызовы. Обязательная регистрация URI перенаправления, на который возвращаются маркеры, гарантирует, что они не будут направлены в неправильное расположение.</span><span class="sxs-lookup"><span data-stu-id="863aa-135">Tokens can be reliably obtained without any need for cross origin calls – mandatory registration of the redirect URI to which tokens are return guarantees that tokens are not displaced</span></span>
* <span data-ttu-id="863aa-136">Приложения JavaScript могут получать любое необходимое количество маркеров доступа для обращения к любому количеству веб-API без ограничений по доменам.</span><span class="sxs-lookup"><span data-stu-id="863aa-136">JavaScript applications can obtain as many access tokens as they need, for as many Web APIs they target – with no restriction on domains</span></span>
* <span data-ttu-id="863aa-137">Возможности HTML5, например управления сеансом или локальным хранилищем, предоставляют полный контроль над кэшированием и управлением временем существования маркеров, тогда как управление файлами cookie является непрозрачным для приложения.</span><span class="sxs-lookup"><span data-stu-id="863aa-137">HTML5 features like session or local storage grant full control over token caching and lifetime management, whereas cookies management is opaque to the app</span></span>
* <span data-ttu-id="863aa-138">Маркеры доступа неуязвимы к атакам с подделкой межсайтовых запросов (CSRF).</span><span class="sxs-lookup"><span data-stu-id="863aa-138">Access tokens aren’t susceptible to Cross-site request forgery (CSRF) attacks</span></span>

<span data-ttu-id="863aa-139">Неявный поток предоставления не выдает маркеры обновления, преимущественно в целях безопасности.</span><span class="sxs-lookup"><span data-stu-id="863aa-139">The implicit grant flow does not issue refresh tokens, mostly for security reasons.</span></span> <span data-ttu-id="863aa-140">В отличие от маркеров доступа, маркеры обновления не используются в узкой области. Они предоставляют больше возможностей, и поэтому их раскрытие причиняет больше вреда.</span><span class="sxs-lookup"><span data-stu-id="863aa-140">A refresh token isn’t as narrowly scoped as access tokens, granting far more power hence inflicting far more damage in case it is leaked out.</span></span> <span data-ttu-id="863aa-141">В неявном потоке маркеры предоставляются в URL-адресе, поэтому риск их перехвата больше, чем при предоставлении кода авторизации.</span><span class="sxs-lookup"><span data-stu-id="863aa-141">In the implicit flow, tokens are delivered in the URL, hence the risk of interception is higher than in the authorization code grant.</span></span>

<span data-ttu-id="863aa-142">Тем не менее учтите, что приложения JavaScript используют другой механизм обновления маркеров доступа, который не предусматривает многократное запрашивание учетных данных пользователя.</span><span class="sxs-lookup"><span data-stu-id="863aa-142">However, note that a JavaScript application has another mechanism at its disposal for renewing access tokens without repeatedly prompting the user for credentials.</span></span> <span data-ttu-id="863aa-143">Для выполнения новых запросов маркеров к конечной точке авторизации Azure AD приложение может использовать скрытый элемент iframe. Пока в браузере открыт сеанс в домене Azure AD (т. е. сохраняется файл cookie сеанса), при запросе проверки подлинности не нужно взаимодействие с пользователем.</span><span class="sxs-lookup"><span data-stu-id="863aa-143">The application can use a hidden iframe to perform new token requests against the authorization endpoint of Azure AD: as long as the browser still has an active session (read: has a session cookie) against the Azure AD domain, the authentication request can successfully occur without any need for user interaction.</span></span>

<span data-ttu-id="863aa-144">Эта модель дает приложению JavaScript возможность независимо обновлять маркеры доступа и даже получать новые для новых API (при условии, что пользователь ранее согласился на это).</span><span class="sxs-lookup"><span data-stu-id="863aa-144">This model grants the JavaScript application the ability to independently renew access tokens and even acquire new ones for a new API (provided that the user previously consented for them.</span></span> <span data-ttu-id="863aa-145">Это избавляет от накладных расходов на получение, обслуживание и защиту такого ценного артефакта, как маркер обновления.</span><span class="sxs-lookup"><span data-stu-id="863aa-145">This avoids the added burden of acquiring, maintaining, and protecting a high value artifact such as a refresh token.</span></span> <span data-ttu-id="863aa-146">Управление файлом cookie сеанса, т. е. артефактом, который позволяет выполнять автоматическое обновление маркера доступа, происходит вне приложения.</span><span class="sxs-lookup"><span data-stu-id="863aa-146">The artifact which makes the silent renewal possible, the Azure AD session cookie, is managed outside of the application.</span></span> <span data-ttu-id="863aa-147">У этого подхода есть и другое преимущество: пользователь может выйти из Azure AD, используя любое из приложений, с помощью которого был выполнен вход в Azure AD, запущенного в любой из вкладок браузера.</span><span class="sxs-lookup"><span data-stu-id="863aa-147">Another advantage of this approach is a user can sign out from Azure AD, using any of the applications signed into Azure AD, running in any of the browser tabs.</span></span> <span data-ttu-id="863aa-148">При этом удаляется файл cookie сеанса Azure AD, и приложение JavaScript автоматически теряет возможность обновлять маркеры для пользователя, выполнившего выход.</span><span class="sxs-lookup"><span data-stu-id="863aa-148">This results in the deletion of the Azure AD session cookie, and the JavaScript application will automatically lose the ability to renew tokens for the signed out user.</span></span>

## <a name="is-the-implicit-grant-suitable-for-my-app"></a><span data-ttu-id="863aa-149">Совместимость неявного предоставления с приложением</span><span class="sxs-lookup"><span data-stu-id="863aa-149">Is the implicit grant suitable for my app?</span></span>
<span data-ttu-id="863aa-150">Неявное предоставление сопровождается большим числом рисков, чем предоставления других типов. Аспекты, на которые следует обратить внимание, описаны во многих документах.</span><span class="sxs-lookup"><span data-stu-id="863aa-150">The implicit grant presents more risks than other grants, and the areas you need to pay attention to are well documented.</span></span> <span data-ttu-id="863aa-151">Например, см. сведения в разделе [Misuse of Access Token to Impersonate Resource Owner in Implicit Flow][OAuth2-Spec-Implicit-Misuse] (Неправильное использование маркера доступа для выполнения роли владельца ресурсов в неявном потоке) и [OAuth 2.0 Threat Model and Security Considerations][OAuth2-Threat-Model-And-Security-Implications] (Модель рисков и рекомендации по безопасности OAuth 2.0).</span><span class="sxs-lookup"><span data-stu-id="863aa-151">For example, [Misuse of Access Token to Impersonate Resource Owner in Implicit Flow][OAuth2-Spec-Implicit-Misuse] and [OAuth 2.0 Threat Model and Security Considerations][OAuth2-Threat-Model-And-Security-Implications]).</span></span> <span data-ttu-id="863aa-152">Но высокий риск связан преимущественно с тем, что предоставление позволяет использовать приложения с активным кодом, который отправляется из удаленного ресурса в браузер.</span><span class="sxs-lookup"><span data-stu-id="863aa-152">However, the higher risk profile is largely due to the fact that it is meant to enable applications that execute active code, served by a remote resource to a browser.</span></span> <span data-ttu-id="863aa-153">Если у вас нет серверных компонентов приложения, если вы намерены использовать архитектуру безопасной проверки пароля или вызывать веб-API через JavaScript, мы рекомендуем использовать неявный поток получения маркеров.</span><span class="sxs-lookup"><span data-stu-id="863aa-153">If you are planning an SPA architecture, have no backend components or intend to invoke a Web API via JavaScript, use of the implicit flow for token acquisition is recommended.</span></span>

<span data-ttu-id="863aa-154">Если ваше приложение является собственным клиентом, неявный поток подходит в меньшей степени.</span><span class="sxs-lookup"><span data-stu-id="863aa-154">If your application is a native client, the implicit flow isn’t a great fit.</span></span> <span data-ttu-id="863aa-155">Отсутствие файла cookie для сеанса Azure AD в контексте собственного клиента не позволит вашему приложению поддерживать длительные сеансы.</span><span class="sxs-lookup"><span data-stu-id="863aa-155">The absence of the Azure AD session cookie in the context of a native client deprives your application from the means of maintaining a long lived session.</span></span> <span data-ttu-id="863aa-156">Это означает, что приложение будет регулярно запрашивать разрешение пользователя при получении маркеров доступа для новых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="863aa-156">Which means your application will repeatedly prompt the user when obtaining access tokens for new resources.</span></span>

<span data-ttu-id="863aa-157">При разработке веб-приложения с серверным компонентом, который будет использовать API из серверного кода, также не рекомендуется использовать неявный поток.</span><span class="sxs-lookup"><span data-stu-id="863aa-157">If you are developing a Web application which includes a backend, and consuming an API from its backend code, the implicit flow is also not a good fit.</span></span> <span data-ttu-id="863aa-158">Другие варианты предоставления маркера дают намного больше возможностей.</span><span class="sxs-lookup"><span data-stu-id="863aa-158">Other grants give you far more power.</span></span> <span data-ttu-id="863aa-159">Например, предоставление учетных данных клиента OAuth2 позволяет получать маркеры с указанием разрешений для конкретного приложения, а не для пользователя.</span><span class="sxs-lookup"><span data-stu-id="863aa-159">For example, the OAuth2 client credentials grant provides the ability to obtain tokens that reflect the permissions assigned to the application itself, as opposed to user delegations.</span></span> <span data-ttu-id="863aa-160">Это означает, что клиент сможет программно поддерживать доступ к ресурсам, даже когда пользователь не участвует в сеансе, и т. д.</span><span class="sxs-lookup"><span data-stu-id="863aa-160">This means the client has the ability to maintain programmatic access to resources even when a user is not actively engaged in a session, and so on.</span></span> <span data-ttu-id="863aa-161">Кроме того, такое предоставление обеспечивает более высокий уровень безопасности.</span><span class="sxs-lookup"><span data-stu-id="863aa-161">Not only that, but such grants give higher security guarantees.</span></span> <span data-ttu-id="863aa-162">Например, маркеры доступа никогда не проходят через браузер пользователя, не могут сохраниться в журнале браузера и т. д.</span><span class="sxs-lookup"><span data-stu-id="863aa-162">For instance, access tokens never transit through the user browser, they don’t risk being saved in the browser history, and so on.</span></span> <span data-ttu-id="863aa-163">Клиентское приложение может выполнять при запросе маркера строгую проверку подлинности.</span><span class="sxs-lookup"><span data-stu-id="863aa-163">The client application can also perform strong authentication when requesting a token.</span></span>

## <a name="next-steps"></a><span data-ttu-id="863aa-164">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="863aa-164">Next steps</span></span>
* <span data-ttu-id="863aa-165">Полный список ресурсов для разработчиков, в том числе информацию о поддержке в Azure AD протоколов и потоков предоставления авторизации OAuth2, см. в статье [Руководство разработчика по Azure Active Directory][AAD-Developers-Guide].</span><span class="sxs-lookup"><span data-stu-id="863aa-165">For a complete list of developer resources, including reference information for the protocols and OAuth2 authorization grant flows support by Azure AD, refer to the [Azure AD Developer's Guide][AAD-Developers-Guide]</span></span>
* <span data-ttu-id="863aa-166">Дополнительные сведения об интеграции приложений см. в статье [Интеграция с Azure Active Directory][ACOM-How-To-Integrate].</span><span class="sxs-lookup"><span data-stu-id="863aa-166">See [How to integrate an application with Azure AD][ACOM-How-To-Integrate] for additional depth on the application integration process.</span></span>

<!--Image references-->

<!--Reference style links in use-->
[AAD-Developers-Guide]: active-directory-developers-guide.md
[ACOM-How-And-Why-Apps-Added-To-AAD]: active-directory-how-applications-are-added.md
[ACOM-How-To-Integrate]: active-directory-how-to-integrate.md
[OAuth2-Spec-Implicit-Misuse]: https://tools.ietf.org/html/rfc6749#section-10.16
[OAuth2-Threat-Model-And-Security-Implications]: https://tools.ietf.org/html/rfc6819
