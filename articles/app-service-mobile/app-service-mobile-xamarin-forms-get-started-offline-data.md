---
title: "Включение автономной синхронизации мобильного приложения Azure в Xamarin.Forms | Документация Майкрософт"
description: "Узнайте, как использовать мобильное приложение службы приложений для кэширования и синхронизации автономных данных в приложении Xamarin.Forms"
documentationcenter: xamarin
author: conceptdev
manager: yochayk
editor: 
services: app-service\mobile
ms.assetid: acf0f874-3ea5-4410-bd22-b0e72140f3b5
ms.service: app-service-mobile
ms.workload: mobile
ms.tgt_pltfrm: mobile-xamarin-ios
ms.devlang: dotnet
ms.topic: article
ms.date: 10/04/2016
ms.author: crdun
ms.openlocfilehash: f88e6a4037bcca54982359742cdc6021f020882d
ms.sourcegitcommit: df4ddc55b42b593f165d56531f591fdb1e689686
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/04/2018
---
# <a name="enable-offline-sync-for-your-xamarinforms-mobile-app"></a>Включение автономной синхронизации мобильного приложения Xamarin.Forms
[!INCLUDE [app-service-mobile-selector-offline](../../includes/app-service-mobile-selector-offline.md)]

## <a name="overview"></a>Обзор
В этом руководстве представлена функция автономной синхронизации мобильных приложений Azure для Xamarin.Forms. Автономная синхронизация позволяет конечным пользователям взаимодействовать с мобильным приложением — просматривать, добавлять или изменять данные — даже при отсутствии подключения к сети. Изменения сохраняются в локальной базе данных. Как только устройство возвращается в режим подключения к сети, эти изменения синхронизируются с удаленной службой.

В этом руководстве используется решение быстрого запуска Xamarin.Forms для мобильных приложений, которые вы создадите, завершив изучение руководства по [созданию приложения Xamarin iOS]. В решении быстрого запуска Xamarin.Forms содержится код для поддержки автономной синхронизации, которую просто нужно включить. При работе с этим руководством вы обновите решение быстрого запуска для включения автономных функций мобильных приложений Azure. Мы также рассмотрим автономный код, применяемый в приложении. Если вы не используете скачанное решение быстрого запуска, в проект необходимо добавить пакеты расширений доступа к данным. Дополнительные сведения о пакетах расширений для сервера см. в статье [Работа с пакетом SDK для внутреннего сервера .NET для мобильных приложений Azure][1].

Дополнительные сведения о функции автономной синхронизации см. в статье [Синхронизация автономных данных в мобильных приложениях Azure][2].

## <a name="enable-offline-sync-functionality-in-the-quickstart-solution"></a>Включение функции автономной синхронизации в решении быстрого запуска
Код автономной синхронизации включается в проект с помощью директив препроцессора C#. Когда символ **OFFLINE\_SYNC\_ENABLED** определен, в сборку включаются указанные ниже пути к коду. Для приложений Windows нужно также установить платформу SQLite.

1. В Visual Studio щелкните правой кнопкой мыши решение, выберите пункт **Управление пакетами NuGet для решения…**, а затем найдите и установите пакет NuGet **Microsoft.Azure.Mobile.Client.SQLiteStore** для всех проектов в решении.
2. В обозревателе решений откройте файл TodoItemManager.cs из проекта, в имени которого содержится слово **Переносимый** , а именно проект переносимой библиотеки классов, а затем раскомментируйте следующую директиву препроцессора:

        #define OFFLINE_SYNC_ENABLED
3. (Необязательный шаг.) Чтобы обеспечить поддержку устройств Windows, установите один из следующих пакетов среды выполнения SQLite:

   * **Среда выполнения Windows 8.1**: установите [SQLite для Windows 8.1][3].
   * **Windows Phone 8.1**: установите [SQLite для Windows Phone 8.1][4].
   * **Универсальная платформа Windows**: установите [SQLite для универсальной платформы Windows][5].

     Хотя это краткое руководство не содержит проект универсальной платформы Windows, платформа поддерживается Xamarin Forms.
4. (Необязательный шаг.) Для устройств с Windows щелкните правой кнопкой мыши **Ссылки** > **Добавить ссылку…**, разверните папку **Windows** > **Расширения**.
    Включите соответствующий пакет SDK **SQLite для Windows** и пакет SDK **среды выполнения Visual C++ 2013 для Windows**.
    Имена пакетов SDK для SQLite немного отличаются в зависимости от версии платформы Windows.

## <a name="review-the-client-sync-code"></a>Просмотр кода синхронизации клиента
В этом разделе приводится краткий обзор компонентов, которые уже включены в приведенный в руководстве код внутри директив `#if OFFLINE_SYNC_ENABLED`. Функция автономной синхронизации указана в файле проекта TodoItemManager.cs в проекте переносимой библиотеки классов. Общие сведения об этой функции см. в статье [Синхронизация автономных данных в мобильных приложениях Azure][2].

* Прежде чем можно будет выполнить операции с таблицами, необходимо инициализировать локальное хранилище. База данных локального хранилища инициализируется в конструкторе класса **TodoItemManager** , используя следующий код:

        var store = new MobileServiceSQLiteStore(OfflineDbPath);
        store.DefineTable<TodoItem>();

        //Initializes the SyncContext using the default IMobileServiceSyncHandler.
        this.client.SyncContext.InitializeAsync(store);

        this.todoTable = client.GetSyncTable<TodoItem>();

    С помощью кода создается локальная база данных SQLite, использующая класс **MobileServiceSQLiteStore**.

    Метод **DefineTable** создает в локальном хранилище таблицу, соответствующую полям в указанном типе.  Тип необязательно должен включать в себя все столбцы, которые находятся в удаленной базе данных. Можно хранить и подмножество столбцов.
* Для поля **todoTable** в **TodoItemManager** указывается тип **IMobileServiceSyncTable** вместо **IMobileServiceTable**. Этот класс использует локальную базу данных для всех операций создания, чтения, обновления и удаления (CRUD), выполняемых с таблицей. Можно решить, когда эти изменения будут передаваться в серверную часть мобильного приложения, вызвав **PushAsync** в **IMobileServiceSyncContext**. Этот контекст синхронизации помогает сохранить связи между таблицами, отслеживая и отправляя изменения во всех таблицах, измененных клиентским приложением при вызове **PushAsync** .

    Для синхронизации с серверной частью мобильного приложения вызывается указанный ниже метод **SyncAsync** .

        public async Task SyncAsync()
        {
            ReadOnlyCollection<MobileServiceTableOperationError> syncErrors = null;

            try
            {
                await this.client.SyncContext.PushAsync();

                await this.todoTable.PullAsync(
                    "allTodoItems",
                    this.todoTable.CreateQuery());
            }
            catch (MobileServicePushFailedException exc)
            {
                if (exc.PushResult != null)
                {
                    syncErrors = exc.PushResult.Errors;
                }
            }

            // Simple error/conflict handling.
            if (syncErrors != null)
            {
                foreach (var error in syncErrors)
                {
                    if (error.OperationKind == MobileServiceTableOperationKind.Update && error.Result != null)
                    {
                        //Update failed, reverting to server's copy.
                        await error.CancelAndUpdateItemAsync(error.Result);
                    }
                    else
                    {
                        // Discard local change.
                        await error.CancelAndDiscardItemAsync();
                    }

                    Debug.WriteLine(@"Error executing sync operation. Item: {0} ({1}). Operation discarded.",
                        error.TableName, error.Item["id"]);
                }
            }
        }

    В этом примере используется простая обработка ошибок с применением обработчика синхронизации по умолчанию. Реальное приложение будет обрабатывать различные ошибки, например ошибки состояния сети, конфликты серверов, с помощью пользовательской реализации **IMobileServiceSyncHandler**.

## <a name="offline-sync-considerations"></a>Рекомендации по автономной синхронизации
В приведенном примере метод **SyncAsync** вызывается только при запуске и при запросе синхронизации.  Чтобы запустить синхронизацию в приложении Android или iOS, разверните список элементов (для Windows используйте кнопку **Синхронизировать**). В реальном приложении функцию синхронизации также можно активировать при изменении состояния сети.

При извлечении из таблицы, для которой есть ожидающие локальные обновления, отслеживаемые по контексту, операция извлечения автоматически активирует отправку предыдущего контекста. При обновлении, добавлении и завершении элементов в данном примере можно опустить явный вызов **PushAsync**.

В представленном коде запрашиваются все записи из удаленной таблицы TodoItem, однако их можно также отфильтровать путем передачи идентификатора запроса и запроса в **PushAsync**. Дополнительные сведения см. в разделе *Добавочная синхронизация* статьи [Синхронизация автономных данных в мобильных приложениях Azure][2].

## <a name="run-the-client-app"></a>Запуск клиентского приложения
Теперь, когда автономная синхронизация включена, можно запустить клиентское приложение по крайней мере по одному разу на каждой платформе, чтобы заполнить базу данных локального хранилища. Далее вы сымитируете сценарий автономного режима и измените данные в локальном хранилище, пока приложение будет находиться в автономном режиме.

## <a name="update-the-sync-behavior-of-the-client-app"></a>Обновление режима синхронизации клиентского приложения
В этом разделе вы измените клиентский проект, чтобы смоделировать сценарий автономного режима, используя недействительный URL-адрес приложения для серверной части. Кроме того, можно отключить сетевые подключения путем переключения устройства в режим "В самолете".  При добавлении или изменении элементов данных эти изменения будут сохраняться в локальном хранилище, но не будут синхронизироваться с серверным хранилищем данных, пока не будет восстановлено подключение.

1. В обозревателе решений откройте файл проекта Constants.cs из проекта **переносимой библиотеки классов** и измените значение `ApplicationURL` таким образом, чтобы оно указывало на недопустимый URL-адрес:

        public static string ApplicationURL = @"https://your-service.azurewebsites.net/";
2. Откройте файл TodoItemManager.cs из проекта **переносимой библиотеки классов** и добавьте еще элемент **catch** для базового класса **Exception** к блоку **try...catch** в **SyncAsync**. Этот блок **catch** записывает сообщение об исключении в консоль следующим образом:

            catch (Exception ex)
            {
                Console.Error.WriteLine(@"Exception: {0}", ex.Message);
            }
3. Выполните сборку и запустите клиентское приложение.  Добавьте несколько новых элементов. Обратите внимание, что исключение регистрируется в журнале консоли при каждой попытке синхронизации с серверной частью. Эти новые элементы существуют только в локальном хранилище, пока не будут принудительно переданы на мобильный внутренний сервер. Клиентское приложение ведет себя так, как если бы оно было подключено к внутреннему серверу, поддерживающему все операции создания, чтения, обновления и удаления (CRUD).
4. Закройте приложение и перезапустите его, чтобы убедиться, что новые элементы сохранены в локальном хранилище.
5. (Необязательно.) С помощью Visual Studio просмотрите таблицу базы данных SQL Azure, чтобы увидеть, что данные в серверной базе данных не изменились.

    В Visual Studio в откройте **обозреватель сервера**. Перейдите к своей базе данных в **Azure**->**Базы данных SQL**. Щелкните правой кнопкой мыши базу данных и выберите пункт **Открыть в обозревателе объектов SQL Server**. Теперь можно перейти к таблице базы данных SQL и ее содержимому.

## <a name="update-the-client-app-to-reconnect-your-mobile-backend"></a>Обновление клиентского приложения для повторного подключения мобильной серверной части
В этом разделе вы повторно подключите приложение к мобильному внутреннему серверу, имитирующему приложение, подключающееся к сети. При выполнении жеста обновления данные будут синхронизированы с мобильным внутренним сервером.

1. Снова откройте Constants.cs. Укажите в `applicationURL` правильный URL-адрес.
2. Повторно выполните сборку и запустите клиентское приложение. После запуска приложение пытается выполнить синхронизацию с серверной частью мобильного приложения. Убедитесь, что в журнале консоли отладки нет исключений.
3. Просмотрите обновленные данные, используя обозреватель объектов SQL Server или средство REST, например Fiddler или [Postman][6] (необязательно). Обратите внимание, что данные синхронизированы между базой данных в серверной части и локальным хранилищем.

    Обратите внимание, данные синхронизированы между базой данных и локальным хранилищем, и они содержат элементы, которые вы добавили, пока ваше приложение было вне сети.

## <a name="additional-resources"></a>Дополнительные ресурсы
* [Синхронизация автономных данных в мобильных приложениях Azure][2]
* [Использование пакета SDK .NET для мобильных приложений Azure][8]

<!-- URLs. -->
[1]: app-service-mobile-dotnet-backend-how-to-use-server-sdk.md
[2]: app-service-mobile-offline-data-sync.md
[3]: http://go.microsoft.com/fwlink/p/?LinkID=716919
[4]: http://go.microsoft.com/fwlink/p/?LinkID=716920
[5]: http://sqlite.org/2016/sqlite-uwp-3120200.vsix
[6]: https://www.getpostman.com/
[7]: http://www.telerik.com/fiddler
[8]: app-service-mobile-dotnet-how-to-use-client-library.md
